# time { #starsim.time }

`time`

Functions and classes for handling time

## Classes

| Name | Description |
| --- | --- |
| [Time](#starsim.time.Time) | Handle time vectors for both simulations and modules. |
| [TimePar](#starsim.time.TimePar) | Base class for time-aware parameters, durations and rates |
| [beta](#starsim.time.beta) | A container for beta (i.e. the disease transmission rate) |
| [date](#starsim.time.date) | Define a single date; based on ``pd.Timestamp`` |
| [dur](#starsim.time.dur) | Any number that acts like a duration |
| [rate](#starsim.time.rate) | Any number that acts like a rate; can be greater than 1 |
| [rate_prob](#starsim.time.rate_prob) | An instantaneous rate converted to a probability; must be >=0. |
| [time_prob](#starsim.time.time_prob) | A probability over time (a.k.a. a cumulative hazard rate); must be >=0 and <=1. |

### Time { #starsim.time.Time }

```python
time.Time(
    self,
    start=None,
    stop=None,
    dt=None,
    unit=None,
    pars=None,
    parent=None,
    name=None,
    init=True,
    sim=None,
)
```

Handle time vectors for both simulations and modules.

Args:
    start (float/str/date): the start date for the simulation/module
    stop (float/str/date): the end date for the simulation/module
    dt (float): the step size, in units of "unit"
    unit (str): the time unit; choices are "day", "week", "month", "year", or "unitless"
    pars (dict): if provided, populate parameter values from this dictionary
    parent (obj): if provided, populate missing parameter values from a 'parent" ``Time`` instance
    name (str): if provided, name the ``Time`` object
    init (bool): whether or not to immediately initialize the Time object
    sim (bool/Sim): if True, initializes as a sim-specific ``Time`` instance; if a Sim instance, initialize the absolute time vector

The ``Time`` object, after initialization, has the following attributes:

- ``ti`` (int): the current timestep
-  ``dt_year`` (float): the timestep in units of years
- ``npts`` (int): the number of timesteps
- ``tvec`` (array): time starting at 0, in self units (e.g. ``[0, 0.1, 0.2, ... 10.0]`` if start=0, stop=10, dt=0.1)
- ``absvec`` (array): time relative to sim start, in units of sim units (e.g. ``[366, 373, 380, ...]`` if sim-start=2001, start=2002, sim-unit='day', unit='week')
- ``yearvec`` (array): time represented as floating-point years (e.g. ``[2000, 2000.1, 2000.2, ... 2010.0]`` if start=2000, stop=2010, dt=0.1)
- ``datevec`` (array): time represented as an array of ``ss.date`` objects (e.g. ``[<2000.01.01>, <2000.02.07>, ... <2010.01.01>]`` if start=2000, stop=2010, dt=0.1)
- ``timevec`` (array): the "native" time vector, which always matches one of ``tvec``, ``yearvec``, or ``datevec``

**Examples**::

    t1 = ss.Time(start=2000, stop=2020, dt=1.0, unit='year') # Years, numeric units
    t2 = ss.Time(start='2021-01-01', stop='2021-04-04', dt=2.0, unit='day') # Days, date units

#### Attributes

| Name | Description |
| --- | --- |
| [is_numeric](#starsim.time.Time.is_numeric) | Check whether the fundamental simulation unit is numeric (as opposed to date-based) |
| [ready](#starsim.time.Time.ready) | Check if all parameters are in place to be initialized |

#### Methods

| Name | Description |
| --- | --- |
| [equiv](#starsim.time.Time.equiv) | Determine if two Time objects have identical parameters |
| [init](#starsim.time.Time.init) | Initialize all vectors |
| [make_abstvec](#starsim.time.Time.make_abstvec) | Convert the current time vector into sim units |
| [now](#starsim.time.Time.now) | Get the current simulation time |
| [update](#starsim.time.Time.update) | Reconcile different ways of supplying inputs |

##### equiv { #starsim.time.Time.equiv }

```python
time.Time.equiv(other)
```

Determine if two Time objects have identical parameters

##### init { #starsim.time.Time.init }

```python
time.Time.init(sim=None)
```

Initialize all vectors

##### make_abstvec { #starsim.time.Time.make_abstvec }

```python
time.Time.make_abstvec(sim)
```

Convert the current time vector into sim units

##### now { #starsim.time.Time.now }

```python
time.Time.now(key=None)
```

Get the current simulation time

Args:
    which (str): which type of time to get: default (None), "year", "date", "tvec", or "str"

**Examples**::

    t = ss.Time(start='2021-01-01', stop='2022-02-02', dt=1, unit='week')
    t.ti = 25
    t.now() # Returns <2021-06-25>
    t.now('date') # Returns <2021-06-25>
    t.now('year') # Returns 2021.479
    t.now('str') # Returns '2021-06-25'

##### update { #starsim.time.Time.update }

```python
time.Time.update(pars=None, parent=None, reset=True, force=None, **kwargs)
```

Reconcile different ways of supplying inputs

### TimePar { #starsim.time.TimePar }

```python
time.TimePar(self, v, unit=None, parent_unit=None, parent_dt=None, self_dt=1.0)
```

Base class for time-aware parameters, durations and rates

NB, because the factor needs to be recalculated, do not set values directly.

#### Attributes

| Name | Description |
| --- | --- |
| [isarray](#starsim.time.TimePar.isarray) | Check if the value is an array |

#### Methods

| Name | Description |
| --- | --- |
| [init](#starsim.time.TimePar.init) | Link to the sim and/or module units |
| [set](#starsim.time.TimePar.set) | Set the specified parameter values (ignoring None values) and update stored values |
| [to](#starsim.time.TimePar.to) | Create a new timepar based on the current one but with a different unit and/or dt |
| [to_json](#starsim.time.TimePar.to_json) | Export to JSON |
| [to_parent](#starsim.time.TimePar.to_parent) | Create a new timepar with the same units as the parent |
| [update_cached](#starsim.time.TimePar.update_cached) | Update the cached factor and values |
| [update_factor](#starsim.time.TimePar.update_factor) | Set factor used to multiply the value to get the output |
| [update_values](#starsim.time.TimePar.update_values) | Convert from self.v to self.values based on self.factor -- must be implemented by derived classes |
| [validate_units](#starsim.time.TimePar.validate_units) | Check that the units entered are valid |

##### init { #starsim.time.TimePar.init }

```python
time.TimePar.init(
    parent=None,
    parent_unit=None,
    parent_dt=None,
    update_values=True,
    die=True,
)
```

Link to the sim and/or module units

##### set { #starsim.time.TimePar.set }

```python
time.TimePar.set(
    v=None,
    unit=None,
    parent_unit=None,
    parent_dt=None,
    self_dt=None,
    force=False,
)
```

Set the specified parameter values (ignoring None values) and update stored values

##### to { #starsim.time.TimePar.to }

```python
time.TimePar.to(unit=None, dt=None)
```

Create a new timepar based on the current one but with a different unit and/or dt

##### to_json { #starsim.time.TimePar.to_json }

```python
time.TimePar.to_json()
```

Export to JSON

##### to_parent { #starsim.time.TimePar.to_parent }

```python
time.TimePar.to_parent()
```

Create a new timepar with the same units as the parent

##### update_cached { #starsim.time.TimePar.update_cached }

```python
time.TimePar.update_cached(update_values=True, die=True)
```

Update the cached factor and values

##### update_factor { #starsim.time.TimePar.update_factor }

```python
time.TimePar.update_factor()
```

Set factor used to multiply the value to get the output

##### update_values { #starsim.time.TimePar.update_values }

```python
time.TimePar.update_values()
```

Convert from self.v to self.values based on self.factor -- must be implemented by derived classes

##### validate_units { #starsim.time.TimePar.validate_units }

```python
time.TimePar.validate_units()
```

Check that the units entered are valid

### beta { #starsim.time.beta }

```python
time.beta(self, v, unit=None, parent_unit=None, parent_dt=None, self_dt=1.0)
```

A container for beta (i.e. the disease transmission rate)

### date { #starsim.time.date }

```python
time.date()
```

Define a single date; based on ``pd.Timestamp``

Args:
    date (int/float/str/datetime): Any type of date input (ints and floats will be interpreted as years)
    kwargs (dict): passed to pd.Timestamp()

**Examples**::

    ss.date(2020) # Returns <2020-01-01>
    ss.date(year=2020) # Returns <2020-01-01>
    ss.date(year=2024.75) # Returns <2024-10-01>
    ss.date('2024-04-04') # Returns <2024-04-04>
    ss.date(year=2024, month=4, day=4) # Returns <2024-04-04>

#### Methods

| Name | Description |
| --- | --- |
| [disp](#starsim.time.date.disp) | Show the full object |
| [from_year](#starsim.time.date.from_year) | Convert an int or float year to a date. |
| [replace](#starsim.time.date.replace) | Returns a new ss.date(); pd.Timestamp is immutable |
| [to_pandas](#starsim.time.date.to_pandas) | Convert to a standard pd.Timestamp instance |
| [to_year](#starsim.time.date.to_year) | Convert a date to a floating-point year |

##### disp { #starsim.time.date.disp }

```python
time.date.disp(**kwargs)
```

Show the full object

##### from_year { #starsim.time.date.from_year }

```python
time.date.from_year(year)
```

Convert an int or float year to a date.

**Examples**::

    ss.date.from_year(2020) # Returns <2020-01-01>
    ss.date.from_year(2024.75) # Returns <2024-10-01>

##### replace { #starsim.time.date.replace }

```python
time.date.replace(*args, **kwargs)
```

Returns a new ss.date(); pd.Timestamp is immutable

##### to_pandas { #starsim.time.date.to_pandas }

```python
time.date.to_pandas()
```

Convert to a standard pd.Timestamp instance

##### to_year { #starsim.time.date.to_year }

```python
time.date.to_year()
```

Convert a date to a floating-point year

**Examples**::

    ss.date('2020-01-01').to_year() # Returns 2020.0
    ss.date('2024-10-01').to_year() # Returns 2024.7486

### dur { #starsim.time.dur }

```python
time.dur(self, v, unit=None, parent_unit=None, parent_dt=None, self_dt=1.0)
```

Any number that acts like a duration

### rate { #starsim.time.rate }

```python
time.rate(self, v, unit=None, parent_unit=None, parent_dt=None, self_dt=1.0)
```

Any number that acts like a rate; can be greater than 1

### rate_prob { #starsim.time.rate_prob }

```python
time.rate_prob(
    self,
    v,
    unit=None,
    parent_unit=None,
    parent_dt=None,
    self_dt=1.0,
)
```

An instantaneous rate converted to a probability; must be >=0.

Note: ``ss.time_prob()`` converts one cumulative hazard rate to another with a
different time unit. ``ss.rate_prob()`` converts an exponential rate to a cumulative
hazard rate.

### time_prob { #starsim.time.time_prob }

```python
time.time_prob(
    self,
    v,
    unit=None,
    parent_unit=None,
    parent_dt=None,
    self_dt=1.0,
)
```

A probability over time (a.k.a. a cumulative hazard rate); must be >=0 and <=1.

Note: ``ss.time_prob()`` converts one cumulative hazard rate to another with a
different time unit. ``ss.rate_prob()`` converts an exponential rate to a cumulative
hazard rate.

## Functions

| Name | Description |
| --- | --- |
| [date_add](#starsim.time.date_add) | Add two dates (or integers) together |
| [date_diff](#starsim.time.date_diff) | Find the difference between two dates (or integers) |
| [days](#starsim.time.days) | Shortcut to ss.dur(value, units='day') |
| [perday](#starsim.time.perday) | Shortcut to ss.rate(value, units='day') |
| [peryear](#starsim.time.peryear) | Shortcut to ss.rate(value, units='year') |
| [time_ratio](#starsim.time.time_ratio) | Calculate the relationship between two sets of time factors |
| [years](#starsim.time.years) | Shortcut to ss.dur(value, units='year') |

### date_add { #starsim.time.date_add }

```python
time.date_add(start, dur, unit)
```

Add two dates (or integers) together

### date_diff { #starsim.time.date_diff }

```python
time.date_diff(start, stop, unit)
```

Find the difference between two dates (or integers)

### days { #starsim.time.days }

```python
time.days(v, parent_unit=None, parent_dt=None)
```

Shortcut to ss.dur(value, units='day')

### perday { #starsim.time.perday }

```python
time.perday(v, parent_unit=None, parent_dt=None)
```

Shortcut to ss.rate(value, units='day')

### peryear { #starsim.time.peryear }

```python
time.peryear(v, parent_unit=None, parent_dt=None)
```

Shortcut to ss.rate(value, units='year')

### time_ratio { #starsim.time.time_ratio }

```python
time.time_ratio(unit1='day', dt1=1.0, unit2='day', dt2=1.0, as_int=False)
```

Calculate the relationship between two sets of time factors

Args:
    unit1 (str): units for the numerator
    dt1 (float): timestep for the numerator
    unit2 (str): units for the denominator
    dt2 (float): timestep for the denominator
    as_int (bool): round and convert to an integer

**Example**::
    ss.time_ratio(unit1='week', dt1=2, unit2='day', dt2=1, as_int=True) # Returns 14

### years { #starsim.time.years }

```python
time.years(v, parent_unit=None, parent_dt=None)
```

Shortcut to ss.dur(value, units='year')