# networks { #starsim.networks }

`networks`

Networks that connect people within a population

## Classes

| Name | Description |
| --- | --- |
| [AgeGroup](#starsim.networks.AgeGroup) | A simple age-based filter that returns uids of agents that match the criteria |
| [DiskNet](#starsim.networks.DiskNet) | Disk graph in which edges are made between agents located within a user-defined radius. |
| [DynamicNetwork](#starsim.networks.DynamicNetwork) | A network where partnerships update dynamically |
| [EmbeddingNet](#starsim.networks.EmbeddingNet) | Heterosexual age-assortative network based on a one-dimensional embedding. Could be made more generic. |
| [ErdosRenyiNet](#starsim.networks.ErdosRenyiNet) | In the Erdos-Renyi network, every possible edge has a probability, p, of |
| [MFNet](#starsim.networks.MFNet) | This network is built by **randomly pairing** males and female with variable |
| [MSMNet](#starsim.networks.MSMNet) | A network that randomly pairs males |
| [MaternalNet](#starsim.networks.MaternalNet) | Base class for maternal transmission |
| [MixingPool](#starsim.networks.MixingPool) | Define a single mixing pool; can be used as a drop-in replacement for a network. |
| [MixingPools](#starsim.networks.MixingPools) | A container for creating a rectangular array of MixingPool instances |
| [Network](#starsim.networks.Network) | A class holding a single network of contact edges (connections) between people |
| [NullNet](#starsim.networks.NullNet) | A convenience class for a network of size n that only has self-connections with a weight of 0. |
| [PostnatalNet](#starsim.networks.PostnatalNet) | Postnatal transmission network |
| [PrenatalNet](#starsim.networks.PrenatalNet) | Prenatal transmission network |
| [RandomNet](#starsim.networks.RandomNet) | Random connectivity between agents |
| [Route](#starsim.networks.Route) | A transmission route -- e.g., a network, mixing pool, environmental transmission, etc. |
| [SexualNetwork](#starsim.networks.SexualNetwork) | Base class for all sexual networks |
| [StaticNet](#starsim.networks.StaticNet) | A network class of static partnerships converted from a networkx graph. There's no formation of new partnerships |

### AgeGroup { #starsim.networks.AgeGroup }

```python
networks.AgeGroup(self, low, high, do_cache=True)
```

A simple age-based filter that returns uids of agents that match the criteria

### DiskNet { #starsim.networks.DiskNet }

```python
networks.DiskNet(self, pars=None, key_dict=None, **kwargs)
```

Disk graph in which edges are made between agents located within a user-defined radius.

Interactions take place within a square with edge length of 1. Agents are
initialized to have a random position and orientation within this square. On
each time step, agents advance v*dt in the direction they are pointed. When
encountering a wall, agents are reflected.

Edges are formed between two agents if they are within r distance of each other.

#### Methods

| Name | Description |
| --- | --- |
| [add_pairs](#starsim.networks.DiskNet.add_pairs) | Generate contacts |

##### add_pairs { #starsim.networks.DiskNet.add_pairs }

```python
networks.DiskNet.add_pairs()
```

Generate contacts

### DynamicNetwork { #starsim.networks.DynamicNetwork }

```python
networks.DynamicNetwork(self, key_dict=None, **kwargs)
```

A network where partnerships update dynamically

### EmbeddingNet { #starsim.networks.EmbeddingNet }

```python
networks.EmbeddingNet(self, pars=None, **kwargs)
```

Heterosexual age-assortative network based on a one-dimensional embedding. Could be made more generic.

### ErdosRenyiNet { #starsim.networks.ErdosRenyiNet }

```python
networks.ErdosRenyiNet(self, pars=None, key_dict=None, **kwargs)
```

In the Erdos-Renyi network, every possible edge has a probability, p, of
being created on each time step.

The degree of each node will have a binomial distribution, considering each
of the N-1 possible edges connection this node to the others will be created
with probability p.

Please be careful with the `dur` parameter. When set to 0, new edges will be
created on each time step. If positive, edges will persist for `dur` years.
Note that the existence of edges from previous time steps will not prevent
or otherwise alter the creation of new edges on each time step, edges will
accumulate over time.

#### Methods

| Name | Description |
| --- | --- |
| [add_pairs](#starsim.networks.ErdosRenyiNet.add_pairs) | Generate contacts |

##### add_pairs { #starsim.networks.ErdosRenyiNet.add_pairs }

```python
networks.ErdosRenyiNet.add_pairs()
```

Generate contacts

### MFNet { #starsim.networks.MFNet }

```python
networks.MFNet(self, pars=None, key_dict=None, **kwargs)
```

This network is built by **randomly pairing** males and female with variable
relationship durations.

#### Methods

| Name | Description |
| --- | --- |
| [set_debut](#starsim.networks.MFNet.set_debut) | Set debut age |
| [set_network_states](#starsim.networks.MFNet.set_network_states) | Set network states including age of entry into network and participation rates |
| [set_participation](#starsim.networks.MFNet.set_participation) | Set people who will participate in the network at some point |

##### set_debut { #starsim.networks.MFNet.set_debut }

```python
networks.MFNet.set_debut(upper_age=None)
```

Set debut age

##### set_network_states { #starsim.networks.MFNet.set_network_states }

```python
networks.MFNet.set_network_states(upper_age=None)
```

Set network states including age of entry into network and participation rates

##### set_participation { #starsim.networks.MFNet.set_participation }

```python
networks.MFNet.set_participation(upper_age=None)
```

Set people who will participate in the network at some point

### MSMNet { #starsim.networks.MSMNet }

```python
networks.MSMNet(self, pars=None, key_dict=None, **kwargs)
```

A network that randomly pairs males

#### Methods

| Name | Description |
| --- | --- |
| [add_pairs](#starsim.networks.MSMNet.add_pairs) | Pair all unpartnered MSM |
| [set_network_states](#starsim.networks.MSMNet.set_network_states) | Set network states including age of entry into network and participation rates |

##### add_pairs { #starsim.networks.MSMNet.add_pairs }

```python
networks.MSMNet.add_pairs()
```

Pair all unpartnered MSM

##### set_network_states { #starsim.networks.MSMNet.set_network_states }

```python
networks.MSMNet.set_network_states(upper_age=None)
```

Set network states including age of entry into network and participation rates

### MaternalNet { #starsim.networks.MaternalNet }

```python
networks.MaternalNet(
    self,
    key_dict=None,
    prenatal=True,
    postnatal=False,
    **kwargs,
)
```

Base class for maternal transmission
Use PrenatalNet and PostnatalNet to capture transmission in different phases

#### Methods

| Name | Description |
| --- | --- |
| [add_pairs](#starsim.networks.MaternalNet.add_pairs) | Add connections between pregnant women and their as-yet-unborn babies |
| [step](#starsim.networks.MaternalNet.step) | Set beta to 0 for women who complete duration of transmission |

##### add_pairs { #starsim.networks.MaternalNet.add_pairs }

```python
networks.MaternalNet.add_pairs(
    mother_inds=None,
    unborn_inds=None,
    dur=None,
    start=None,
)
```

Add connections between pregnant women and their as-yet-unborn babies

##### step { #starsim.networks.MaternalNet.step }

```python
networks.MaternalNet.step()
```

Set beta to 0 for women who complete duration of transmission
Keep connections for now, might want to consider removing

NB: add_pairs() and end_pairs() are NOT called here; this is done separately
in ss.Pregnancy.update_states().

### MixingPool { #starsim.networks.MixingPool }

```python
networks.MixingPool(self, pars=None, **kwargs)
```

Define a single mixing pool; can be used as a drop-in replacement for a network.

Args:
    diseases (str): the diseases that transmit via this mixing pool
    src (inds): source agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents
    dst (inds): destination agents; as above
    beta (float): overall transmission (note: use a float, not a TimePar; the time component is usually handled by the disease beta)
    contacts (Dist): the number of effective contacts of the destination agents

**Example**::

    import starsim as ss

    # Set the parameters
    mp_pars = dict(
        src = lambda sim: sim.people.male, # only males are infectious
        dst = None, # all agents are susceptible
        beta = 0.2,
        contacts = ss.poisson(lam=4),
    )

    # Seed 5% of the male population
    def p_init(self, sim, uids):
        return 0.05*sim.people.male

    # Create and run the sim
    sis = ss.SIS(init_prev=p_init)
    mp = ss.MixingPool(mp_pars)
    sim = ss.Sim(diseases=sis, networks=mp)
    sim.run()
    sim.plot()

#### Methods

| Name | Description |
| --- | --- |
| [compute_transmission](#starsim.networks.MixingPool.compute_transmission) | Calculate transmission |
| [remove_uids](#starsim.networks.MixingPool.remove_uids) | If UIDs are supplied explicitly, remove them if people die |

##### compute_transmission { #starsim.networks.MixingPool.compute_transmission }

```python
networks.MixingPool.compute_transmission(rel_sus, rel_trans, disease_beta)
```

Calculate transmission

This is called from Infection.infect() together with network transmission.

Args:
    rel_sus (float): Relative susceptibility
    rel_trans (float): Relative infectiousness
    disease_beta (float): The beta value for the disease. This is typically calculated as a
        pair of values as networks are bidirectional, however, only the first value
        is used because mixing pools are unidirectional.
Returns:
    UIDs of agents who acquired the disease at this step

##### remove_uids { #starsim.networks.MixingPool.remove_uids }

```python
networks.MixingPool.remove_uids(uids)
```

If UIDs are supplied explicitly, remove them if people die

### MixingPools { #starsim.networks.MixingPools }

```python
networks.MixingPools(self, pars=None, **kwargs)
```

A container for creating a rectangular array of MixingPool instances

By default, separates the population into <15 and >15 age groups.

Args:
    diseases (str): the diseases that transmit via these mixing pools
    src (inds): source agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents
    dst (inds): destination agents; as above
    beta (float): overall transmission via these mixing pools
    contacts (array): the relative connectivity between different mixing pools (can be float or Dist)

**Example**::

    import starsim as ss
    mps = ss.MixingPools(
        diseases = 'sis',
        beta = 0.1,
        src = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},
        dst = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},
        contacts = [[2.4, 0.49], [0.91, 0.16]],
    )
    sim = ss.Sim(diseases='sis', networks=mps).run()
    sim.plot()

#### Methods

| Name | Description |
| --- | --- |
| [init_post](#starsim.networks.MixingPools.init_post) | Initialize each mixing pool |
| [remove_uids](#starsim.networks.MixingPools.remove_uids) | Remove UIDs from each mixing pool |
| [validate_pars](#starsim.networks.MixingPools.validate_pars) | Check that src and dst have correct types, and contacts is the correct shape |

##### init_post { #starsim.networks.MixingPools.init_post }

```python
networks.MixingPools.init_post()
```

Initialize each mixing pool

##### remove_uids { #starsim.networks.MixingPools.remove_uids }

```python
networks.MixingPools.remove_uids(uids)
```

Remove UIDs from each mixing pool

##### validate_pars { #starsim.networks.MixingPools.validate_pars }

```python
networks.MixingPools.validate_pars()
```

Check that src and dst have correct types, and contacts is the correct shape

### Network { #starsim.networks.Network }

```python
networks.Network(
    self,
    key_dict=None,
    prenatal=False,
    postnatal=False,
    name=None,
    label=None,
    **kwargs,
)
```

A class holding a single network of contact edges (connections) between people
as well as methods for updating these.

The input is typically arrays including: person 1 of the connection, person 2 of
the connection, the weight of the connection, the duration and start/end times of
the connection.

Args:
    p1 (array): an array of length N, the number of connections in the network, with the indices of people on one side of the connection.
    p2 (array): an array of length N, the number of connections in the network, with the indices of people on the other side of the connection.
    beta (array): an array representing relative transmissibility of each connection for this network - TODO, do we need this?
    label (str): the name of the network (optional)
    kwargs (dict): other keys copied directly into the network

Note that all arguments (except for label) must be arrays of the same length,
although not all have to be supplied at the time of creation (they must all
be the same at the time of initialization, though, or else validation will fail).

**Examples**::

    # Generate an average of 10 contacts for 1000 people
    n_contacts_pp = 10
    n_people = 1000
    n = n_contacts_pp * n_people
    p1 = np.random.randint(n_people, size=n)
    p2 = np.random.randint(n_people, size=n)
    beta = np.ones(n)
    network = ss.Network(p1=p1, p2=p2, beta=beta, label='rand')
    network = ss.Network(dict(p1=p1, p2=p2, beta=beta), label='rand') # Alternate method

    # Convert one network to another with extra columns
    index = np.arange(n)
    self_conn = p1 == p2
    network2 = ss.Network(**network, index=index, self_conn=self_conn, label=network.label)

#### Attributes

| Name | Description |
| --- | --- |
| [beta](#starsim.networks.Network.beta) | Relative transmission on each network edge |
| [members](#starsim.networks.Network.members) | Return sorted array of all members |
| [p1](#starsim.networks.Network.p1) | The first half of a network edge (person 1) |
| [p2](#starsim.networks.Network.p2) | The second half of a network edge (person 2) |

#### Methods

| Name | Description |
| --- | --- |
| [add_pairs](#starsim.networks.Network.add_pairs) | Define how pairs of people are formed |
| [append](#starsim.networks.Network.append) | Append edges to the current network. |
| [find_contacts](#starsim.networks.Network.find_contacts) | Find all contacts of the specified people |
| [from_df](#starsim.networks.Network.from_df) | Convert from a dataframe |
| [get_inds](#starsim.networks.Network.get_inds) | Get the specified indices from the edgelist and return them as a dict. |
| [init_results](#starsim.networks.Network.init_results) | Store network length by default |
| [meta_keys](#starsim.networks.Network.meta_keys) | Return the keys for the network's meta information |
| [net_beta](#starsim.networks.Network.net_beta) | Calculate the beta for the given disease and network |
| [pop_inds](#starsim.networks.Network.pop_inds) | "Pop" the specified indices from the edgelist and return them as a dict. |
| [remove_uids](#starsim.networks.Network.remove_uids) | Remove interactions involving specified UIDs |
| [set_network_states](#starsim.networks.Network.set_network_states) | Many network states depend on properties of people -- e.g. MSM depends on being male, |
| [to_df](#starsim.networks.Network.to_df) | Convert to dataframe |
| [to_dict](#starsim.networks.Network.to_dict) | Convert to dictionary |
| [to_graph](#starsim.networks.Network.to_graph) | Convert to a networkx DiGraph |
| [update_results](#starsim.networks.Network.update_results) | Store the number of edges in the network |
| [validate](#starsim.networks.Network.validate) | Check the integrity of the network: right types, right lengths. |
| [validate_uids](#starsim.networks.Network.validate_uids) | Ensure that p1, p2 are both UID arrays |

##### add_pairs { #starsim.networks.Network.add_pairs }

```python
networks.Network.add_pairs()
```

Define how pairs of people are formed

##### append { #starsim.networks.Network.append }

```python
networks.Network.append(edges=None, **kwargs)
```

Append edges to the current network.

Args:
    edges (dict): a dictionary of arrays with keys p1,p2,beta, as returned from network.pop_inds()

##### find_contacts { #starsim.networks.Network.find_contacts }

```python
networks.Network.find_contacts(inds, as_array=True)
```

Find all contacts of the specified people

For some purposes (e.g. contact tracing) it's necessary to find all the edges
associated with a subset of the people in this network. Since edges are bidirectional
it's necessary to check both p1 and p2 for the target indices. The return type is a Set
so that there is no duplication of indices (otherwise if the Network has explicit
symmetric interactions, they could appear multiple times). This is also for performance so
that the calling code doesn't need to perform its own unique() operation. Note that
this cannot be used for cases where multiple connections count differently than a single
infection, e.g. exposure risk.

Args:
    inds (array): indices of people whose edges to return
    as_array (bool): if true, return as sorted array (otherwise, return as unsorted set)

Returns:
    contact_inds (array): a set of indices for pairing partners

Example: If there were a network with
- p1 = [1,2,3,4]
- p2 = [2,3,1,4]
Then find_edges([1,3]) would return {1,2,3}

##### from_df { #starsim.networks.Network.from_df }

```python
networks.Network.from_df(df, keys=None)
```

Convert from a dataframe

##### get_inds { #starsim.networks.Network.get_inds }

```python
networks.Network.get_inds(inds, remove=False)
```

Get the specified indices from the edgelist and return them as a dict.

Args:
    inds (int, array, slice): the indices to find
    remove (bool): whether to remove the indices

##### init_results { #starsim.networks.Network.init_results }

```python
networks.Network.init_results()
```

Store network length by default

##### meta_keys { #starsim.networks.Network.meta_keys }

```python
networks.Network.meta_keys()
```

Return the keys for the network's meta information

##### net_beta { #starsim.networks.Network.net_beta }

```python
networks.Network.net_beta(disease_beta=None, inds=None, disease=None)
```

Calculate the beta for the given disease and network

##### pop_inds { #starsim.networks.Network.pop_inds }

```python
networks.Network.pop_inds(inds)
```

"Pop" the specified indices from the edgelist and return them as a dict.
Returns arguments in the right format to be used with network.append().

Args:
    inds (int, array, slice): the indices to be removed

##### remove_uids { #starsim.networks.Network.remove_uids }

```python
networks.Network.remove_uids(uids)
```

Remove interactions involving specified UIDs
This method is typically called via `People.remove()` and
is specifically used when removing agents from the simulation.

##### set_network_states { #starsim.networks.Network.set_network_states }

```python
networks.Network.set_network_states(people)
```

Many network states depend on properties of people -- e.g. MSM depends on being male,
age of debut varies by sex and over time, and participation rates vary by age.
Each time states are dynamically grown, this function should be called to set the network
states that depend on other states.

##### to_df { #starsim.networks.Network.to_df }

```python
networks.Network.to_df()
```

Convert to dataframe

##### to_dict { #starsim.networks.Network.to_dict }

```python
networks.Network.to_dict()
```

Convert to dictionary

##### to_graph { #starsim.networks.Network.to_graph }

```python
networks.Network.to_graph()
```

Convert to a networkx DiGraph

**Example**::

    import networkx as nx
    sim = ss.Sim(n_agents=100, networks='mf').init()
    G = sim.networks.randomnet.to_graph()
    nx.draw(G)

##### update_results { #starsim.networks.Network.update_results }

```python
networks.Network.update_results()
```

Store the number of edges in the network

##### validate { #starsim.networks.Network.validate }

```python
networks.Network.validate(force=True)
```

Check the integrity of the network: right types, right lengths.

If dtype is incorrect, try to convert automatically; if length is incorrect,
do not.

##### validate_uids { #starsim.networks.Network.validate_uids }

```python
networks.Network.validate_uids()
```

Ensure that p1, p2 are both UID arrays

### NullNet { #starsim.networks.NullNet }

```python
networks.NullNet(self, n_people=None, **kwargs)
```

A convenience class for a network of size n that only has self-connections with a weight of 0.
This network can be useful for debugging purposes or as a placeholder network during development
for conditions that require more complex network mechanisms.

Guarantees there's one (1) contact per agent (themselves), and that their connection weight is zero.

For an empty network (ie, no edges) use
>> import starsim as ss
>> import networkx as nx
>> empty_net_static = ss.StaticNet(nx.empty_graph)
>> empty_net_rand = ss.RandomNet(n_contacts=0)

#### Methods

| Name | Description |
| --- | --- |
| [step](#starsim.networks.NullNet.step) | Not used for NullNet |

##### step { #starsim.networks.NullNet.step }

```python
networks.NullNet.step()
```

Not used for NullNet

### PostnatalNet { #starsim.networks.PostnatalNet }

```python
networks.PostnatalNet(
    self,
    key_dict=None,
    prenatal=False,
    postnatal=True,
    **kwargs,
)
```

Postnatal transmission network

### PrenatalNet { #starsim.networks.PrenatalNet }

```python
networks.PrenatalNet(
    self,
    key_dict=None,
    prenatal=True,
    postnatal=False,
    **kwargs,
)
```

Prenatal transmission network

### RandomNet { #starsim.networks.RandomNet }

```python
networks.RandomNet(self, pars=None, key_dict=None, **kwargs)
```

Random connectivity between agents

#### Methods

| Name | Description |
| --- | --- |
| [add_pairs](#starsim.networks.RandomNet.add_pairs) | Generate edges |
| [get_edges](#starsim.networks.RandomNet.get_edges) | Efficiently find edges |
| [get_source](#starsim.networks.RandomNet.get_source) | Optimized helper function for getting contacts |

##### add_pairs { #starsim.networks.RandomNet.add_pairs }

```python
networks.RandomNet.add_pairs()
```

Generate edges

##### get_edges { #starsim.networks.RandomNet.get_edges }

```python
networks.RandomNet.get_edges(inds, n_contacts)
```

Efficiently find edges

Note that because of the shuffling operation, each person is assigned 2N contacts
(i.e. if a person has 5 contacts, they appear 5 times in the 'source' array and 5
times in the 'target' array). Therefore, the `number_of_contacts` argument to this
function should be HALF of the total contacts a person is expected to have, if both
the source and target array outputs are used (e.g. for social contacts)

adjusted_number_of_contacts = np.round(number_of_contacts / 2).astype(ss.dtype.int)

Whereas for asymmetric contacts (e.g. staff-public interactions) it might not be necessary

Args:
    inds: List/array of person indices
    number_of_contacts: List/array the same length as `inds` with the number of unidirectional
    contacts to assign to each person. Therefore, a person will have on average TWICE this number
    of random contacts.

Returns: Two arrays, for source and target

##### get_source { #starsim.networks.RandomNet.get_source }

```python
networks.RandomNet.get_source(inds, n_contacts)
```

Optimized helper function for getting contacts

### Route { #starsim.networks.Route }

```python
networks.Route(self, name=None, label=None, **kwargs)
```

A transmission route -- e.g., a network, mixing pool, environmental transmission, etc.

### SexualNetwork { #starsim.networks.SexualNetwork }

```python
networks.SexualNetwork(self, key_dict=None, **kwargs)
```

Base class for all sexual networks

### StaticNet { #starsim.networks.StaticNet }

```python
networks.StaticNet(self, graph=None, pars=None, **kwargs)
```

A network class of static partnerships converted from a networkx graph. There's no formation of new partnerships
and initialized partnerships only end when one of the partners dies. The networkx graph can be created outside Starsim
if population size is known. Or the graph can be created by passing a networkx generator function to Starsim.

If "seed=True" is passed as a keyword argument or a parameter in pars, it is replaced with the built-in RNG.
The parameter "n" is supplied automatically to be equal to n_agents.

**Examples**::
    # Generate a networkx graph and pass to Starsim
    import networkx as nx
    import starsim as ss
    g = nx.scale_free_graph(n=10000)
    ss.StaticNet(graph=g)

    # Pass a networkx graph generator to Starsim
    ss.StaticNet(graph=nx.erdos_renyi_graph, p=0.0001, seed=True)

    # Just create a default graph