[
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "Contributing",
    "section": "",
    "text": "Contributing\nWelcome! We are thrilled you are interested in contributing to Starsim. This document will help you get started.\n\nWe are serious about inclusion and believe the open-source software community still has a long way to go. The Starsim community follows a code of conduct. By participating in this project, you agree to abide by its terms.\nTake a look at our house style guide. Starsim more or less follows Google’s Python style guide, but with some exceptions.\nFeel free to open an issue on more or less anything! This project is small enough that we don’t need a formal triage system.\nPull requests should be made against main. In addition to following the style guide, please make sure the tests pass (run_tests in the tests folder; they also run via GitHub actions).\n\nIf you have any other questions, please reach out to us: info@starsim.org. Thank you!",
    "crumbs": [
      "Home",
      "**Contributing**"
    ]
  },
  {
    "objectID": "api/utils.html",
    "href": "api/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\nNumerical utilities\n\n\n\n\n\nName\nDescription\n\n\n\n\nProfile\nClass to profile the performance of a simulation\n\n\nndict\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nutils.Profile(self, sim, do_run=True, plot=True, verbose=False, **kwargs)\nClass to profile the performance of a simulation\n\n\n\n\n\nName\nDescription\n\n\n\n\ndisp\nSame as sc.profile.disp(), but skip the run function by default\n\n\ninit_and_run\nProfile the performance of the simulation\n\n\nplot_cpu\nShortcut to sim.loop.plot_cpu()\n\n\n\n\n\nutils.Profile.disp(bytime=1, maxentries=10, skiprun=True)\nSame as sc.profile.disp(), but skip the run function by default\n\n\n\nutils.Profile.init_and_run()\nProfile the performance of the simulation\n\n\n\nutils.Profile.plot_cpu()\nShortcut to sim.loop.plot_cpu()\n\n\n\n\n\nutils.ndict(\n    self,\n    *args,\n    nameattr='name',\n    type=None,\n    strict=True,\n    overwrite=False,\n    **kwargs,\n)\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe attribute of the item to use as the dict key (i.e., all items should have this attribute defined)\nrequired\n\n\ntype\ntype\nThe expected type of items.\nNone\n\n\nstrict\nbool\nIf True, only items with the specified attribute will be accepted.\nTrue\n\n\noverwrite\nbool\nwhether to allow adding a key when one has already been added\nFalse\n\n\n\nExamples:\nnetworks = ss.ndict(ss.MFNet(), ss.MaternalNet())\nnetworks = ss.ndict([ss.MFNet(), ss.MaternalNet()])\nnetworks = ss.ndict({'mf':ss.MFNet(), 'maternal':ss.MaternalNet()})\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nShallow copy\n\n\nextend\nAdd new items to the ndict, by item, list, or dict\n\n\nmerge\nMerge another dictionary with this one\n\n\n\n\n\nutils.ndict.copy()\nShallow copy\n\n\n\nutils.ndict.extend(*args, **kwargs)\nAdd new items to the ndict, by item, list, or dict\n\n\n\nutils.ndict.merge(other)\nMerge another dictionary with this one\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_requires\nCheck that the module’s requirements (of other modules) are met\n\n\nfind_contacts\nVariation on Network.find_contacts() that avoids sorting.\n\n\nload\nAlias to Sciris sc.loadany()\n\n\nreturn_fig\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead\n\n\nsave\nAlias to Sciris sc.save()\n\n\nset_seed\nReset the random seed – complicated because of Numba, which requires special\n\n\nshow\nShortcut for matplotlib.pyplot.show()\n\n\nstandardize_data\nStandardize formats of input data\n\n\nstandardize_netkey\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\nvalidate_sim_data\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\nwarn\nHelper function to handle warnings – shortcut to warnings.warn\n\n\n\n\n\nutils.check_requires(sim, requires, *args)\nCheck that the module’s requirements (of other modules) are met\n\n\n\nutils.find_contacts(p1, p2, inds)\nVariation on Network.find_contacts() that avoids sorting.\nA set is returned here rather than a sorted array so that custom tracing interventions can efficiently add extra people. For a version with sorting by default, see Network.find_contacts(). Indices must be an int64 array since this is what’s returned by true() etc. functions by default.\n\n\n\nutils.load(filename, **kwargs)\nAlias to Sciris sc.loadany()\nSince Starsim uses Sciris for saving objects, they can be loaded back using this function. This can also be used to load other objects of known type (e.g. JSON), although this usage is discouraged.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to load\nrequired\n\n\nkwargs\ndict\npassed to sc.loadany()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe loaded object\n\n\n\n\n\n\n\nutils.return_fig(fig, **kwargs)\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead\n\n\n\nutils.save(filename, obj, **kwargs)\nAlias to Sciris sc.save()\nWhile some Starsim objects have their own save methods, this function can be used to save any arbitrary object. It can then be loaded with ss.load().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to save\nrequired\n\n\nobj\nany\nthe object to save\nrequired\n\n\nkwargs\ndict\npassed to sc.save()\n{}\n\n\n\n\n\n\n\nutils.set_seed(seed=None)\nReset the random seed – complicated because of Numba, which requires special syntax to reset the seed. This function also resets Python’s built-in random number generated.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nseed\nint\nthe random seed\nNone\n\n\n\n\n\n\n\nutils.show(**kwargs)\nShortcut for matplotlib.pyplot.show()\n\n\n\nutils.standardize_data(\n    data=None,\n    metadata=None,\n    min_year=1800,\n    out_of_range=0,\n    default_age=0,\n    default_year=2024,\n)\nStandardize formats of input data\nInput data can arrive in many different forms. This function accepts a variety of data structures, and converts them into a Pandas Series containing one variable, based on specified metadata, or an ss.Dist if the data is already an ss.Dist object.\nThe metadata is a dictionary that defines columns of the dataframe or keys of the dictionary to use as indices in the output Series. It should contain:\n\nmetadata['data_cols']['value'] specifying the name of the column/key to draw values from\nmetadata['data_cols']['year'] optionally specifying the column containing year values; otherwise the default year will be used\nmetadata['data_cols']['age'] optionally specifying the column containing age values; otherwise the default age will be used\nmetadata['data_cols'][&lt;arbitrary&gt;] optionally specifying any other columns to use as indices. These will form part of the multi-index for the standardized Series output.\n\nIf a sex column is part of the index, the metadata can also optionally specify a string mapping to convert the sex labels in the input data into the ‘m’/‘f’ labels used by Starsim. In that case, the metadata can contain an additional key like metadata['sex_keys'] = {'Female':'f','Male':'m'} which in this case would map the strings ‘Female’ and ‘Male’ in the original data into ‘m’/‘f’ for Starsim.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(pandas.DataFrame, pandas.Series, dict, int, float)\nAn associative array or a number, with the input data to be standardized.\nNone\n\n\nmetadata\ndict\nDictionary specifiying index columns, the value column, and optionally mapping for sex labels\nNone\n\n\nmin_year\nfloat\nOptionally specify a minimum year allowed in the data. Default is 1800.\n1800\n\n\nout_of_range\nfloat\nValue to use for negative ages - typically 0 is a reasonable choice but other values (e.g., np.inf or np.nan) may be useful depending on the calculation. This will automatically be added to the dataframe with an age of -np.inf\n0\n\n\n\nReturns:\n- A `pd.Series` for all supported formats of `data` *except* an `ss.Dist`. This series will contain index columns for 'year'\n  and 'age' (in that order) and then subsequent index columns for any other variables specified in the metadata, in the order\n  they appeared in the metadata (except for year and age appearing first).\n- An `ss.Dist` instance - if the `data` input is an `ss.Dist`, that same object will be returned by this function\n\n\n\n\nutils.standardize_netkey(key)\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\n\nutils.validate_sim_data(data=None, die=None)\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndf / dict\na dataframe (or dict) of data, with a column “time” plus data columns of the form “module.result”, e.g. “hiv.new_infections”\nNone\n\n\ndie\nbool\nwhether to raise an exception if the data cannot be converted (default: die if data is not None but cannot be converted)\nNone\n\n\n\n\n\n\n\nutils.warn(msg, category=None, verbose=None, die=None)\nHelper function to handle warnings – shortcut to warnings.warn",
    "crumbs": [
      "**Utilities**",
      "utils"
    ]
  },
  {
    "objectID": "api/utils.html#classes",
    "href": "api/utils.html#classes",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nProfile\nClass to profile the performance of a simulation\n\n\nndict\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nutils.Profile(self, sim, do_run=True, plot=True, verbose=False, **kwargs)\nClass to profile the performance of a simulation\n\n\n\n\n\nName\nDescription\n\n\n\n\ndisp\nSame as sc.profile.disp(), but skip the run function by default\n\n\ninit_and_run\nProfile the performance of the simulation\n\n\nplot_cpu\nShortcut to sim.loop.plot_cpu()\n\n\n\n\n\nutils.Profile.disp(bytime=1, maxentries=10, skiprun=True)\nSame as sc.profile.disp(), but skip the run function by default\n\n\n\nutils.Profile.init_and_run()\nProfile the performance of the simulation\n\n\n\nutils.Profile.plot_cpu()\nShortcut to sim.loop.plot_cpu()\n\n\n\n\n\nutils.ndict(\n    self,\n    *args,\n    nameattr='name',\n    type=None,\n    strict=True,\n    overwrite=False,\n    **kwargs,\n)\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe attribute of the item to use as the dict key (i.e., all items should have this attribute defined)\nrequired\n\n\ntype\ntype\nThe expected type of items.\nNone\n\n\nstrict\nbool\nIf True, only items with the specified attribute will be accepted.\nTrue\n\n\noverwrite\nbool\nwhether to allow adding a key when one has already been added\nFalse\n\n\n\nExamples:\nnetworks = ss.ndict(ss.MFNet(), ss.MaternalNet())\nnetworks = ss.ndict([ss.MFNet(), ss.MaternalNet()])\nnetworks = ss.ndict({'mf':ss.MFNet(), 'maternal':ss.MaternalNet()})\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nShallow copy\n\n\nextend\nAdd new items to the ndict, by item, list, or dict\n\n\nmerge\nMerge another dictionary with this one\n\n\n\n\n\nutils.ndict.copy()\nShallow copy\n\n\n\nutils.ndict.extend(*args, **kwargs)\nAdd new items to the ndict, by item, list, or dict\n\n\n\nutils.ndict.merge(other)\nMerge another dictionary with this one",
    "crumbs": [
      "**Utilities**",
      "utils"
    ]
  },
  {
    "objectID": "api/utils.html#functions",
    "href": "api/utils.html#functions",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_requires\nCheck that the module’s requirements (of other modules) are met\n\n\nfind_contacts\nVariation on Network.find_contacts() that avoids sorting.\n\n\nload\nAlias to Sciris sc.loadany()\n\n\nreturn_fig\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead\n\n\nsave\nAlias to Sciris sc.save()\n\n\nset_seed\nReset the random seed – complicated because of Numba, which requires special\n\n\nshow\nShortcut for matplotlib.pyplot.show()\n\n\nstandardize_data\nStandardize formats of input data\n\n\nstandardize_netkey\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\nvalidate_sim_data\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\nwarn\nHelper function to handle warnings – shortcut to warnings.warn\n\n\n\n\n\nutils.check_requires(sim, requires, *args)\nCheck that the module’s requirements (of other modules) are met\n\n\n\nutils.find_contacts(p1, p2, inds)\nVariation on Network.find_contacts() that avoids sorting.\nA set is returned here rather than a sorted array so that custom tracing interventions can efficiently add extra people. For a version with sorting by default, see Network.find_contacts(). Indices must be an int64 array since this is what’s returned by true() etc. functions by default.\n\n\n\nutils.load(filename, **kwargs)\nAlias to Sciris sc.loadany()\nSince Starsim uses Sciris for saving objects, they can be loaded back using this function. This can also be used to load other objects of known type (e.g. JSON), although this usage is discouraged.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to load\nrequired\n\n\nkwargs\ndict\npassed to sc.loadany()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe loaded object\n\n\n\n\n\n\n\nutils.return_fig(fig, **kwargs)\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead\n\n\n\nutils.save(filename, obj, **kwargs)\nAlias to Sciris sc.save()\nWhile some Starsim objects have their own save methods, this function can be used to save any arbitrary object. It can then be loaded with ss.load().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to save\nrequired\n\n\nobj\nany\nthe object to save\nrequired\n\n\nkwargs\ndict\npassed to sc.save()\n{}\n\n\n\n\n\n\n\nutils.set_seed(seed=None)\nReset the random seed – complicated because of Numba, which requires special syntax to reset the seed. This function also resets Python’s built-in random number generated.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nseed\nint\nthe random seed\nNone\n\n\n\n\n\n\n\nutils.show(**kwargs)\nShortcut for matplotlib.pyplot.show()\n\n\n\nutils.standardize_data(\n    data=None,\n    metadata=None,\n    min_year=1800,\n    out_of_range=0,\n    default_age=0,\n    default_year=2024,\n)\nStandardize formats of input data\nInput data can arrive in many different forms. This function accepts a variety of data structures, and converts them into a Pandas Series containing one variable, based on specified metadata, or an ss.Dist if the data is already an ss.Dist object.\nThe metadata is a dictionary that defines columns of the dataframe or keys of the dictionary to use as indices in the output Series. It should contain:\n\nmetadata['data_cols']['value'] specifying the name of the column/key to draw values from\nmetadata['data_cols']['year'] optionally specifying the column containing year values; otherwise the default year will be used\nmetadata['data_cols']['age'] optionally specifying the column containing age values; otherwise the default age will be used\nmetadata['data_cols'][&lt;arbitrary&gt;] optionally specifying any other columns to use as indices. These will form part of the multi-index for the standardized Series output.\n\nIf a sex column is part of the index, the metadata can also optionally specify a string mapping to convert the sex labels in the input data into the ‘m’/‘f’ labels used by Starsim. In that case, the metadata can contain an additional key like metadata['sex_keys'] = {'Female':'f','Male':'m'} which in this case would map the strings ‘Female’ and ‘Male’ in the original data into ‘m’/‘f’ for Starsim.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(pandas.DataFrame, pandas.Series, dict, int, float)\nAn associative array or a number, with the input data to be standardized.\nNone\n\n\nmetadata\ndict\nDictionary specifiying index columns, the value column, and optionally mapping for sex labels\nNone\n\n\nmin_year\nfloat\nOptionally specify a minimum year allowed in the data. Default is 1800.\n1800\n\n\nout_of_range\nfloat\nValue to use for negative ages - typically 0 is a reasonable choice but other values (e.g., np.inf or np.nan) may be useful depending on the calculation. This will automatically be added to the dataframe with an age of -np.inf\n0\n\n\n\nReturns:\n- A `pd.Series` for all supported formats of `data` *except* an `ss.Dist`. This series will contain index columns for 'year'\n  and 'age' (in that order) and then subsequent index columns for any other variables specified in the metadata, in the order\n  they appeared in the metadata (except for year and age appearing first).\n- An `ss.Dist` instance - if the `data` input is an `ss.Dist`, that same object will be returned by this function\n\n\n\n\nutils.standardize_netkey(key)\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\n\nutils.validate_sim_data(data=None, die=None)\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndf / dict\na dataframe (or dict) of data, with a column “time” plus data columns of the form “module.result”, e.g. “hiv.new_infections”\nNone\n\n\ndie\nbool\nwhether to raise an exception if the data cannot be converted (default: die if data is not None but cannot be converted)\nNone\n\n\n\n\n\n\n\nutils.warn(msg, category=None, verbose=None, die=None)\nHelper function to handle warnings – shortcut to warnings.warn",
    "crumbs": [
      "**Utilities**",
      "utils"
    ]
  },
  {
    "objectID": "api/networks.html",
    "href": "api/networks.html",
    "title": "networks",
    "section": "",
    "text": "networks\nNetworks that connect people within a population\n\n\n\n\n\nName\nDescription\n\n\n\n\nAgeGroup\nA simple age-based filter that returns uids of agents that match the criteria\n\n\nDiskNet\nDisk graph in which edges are made between agents located within a user-defined radius.\n\n\nDynamicNetwork\nA network where partnerships update dynamically\n\n\nEmbeddingNet\nHeterosexual age-assortative network based on a one-dimensional embedding.\n\n\nErdosRenyiNet\nIn the Erdos-Renyi network, every possible edge has a probability, p, of\n\n\nMFNet\nThis network is built by randomly pairing males and female with variable\n\n\nMSMNet\nA network that randomly pairs males\n\n\nMaternalNet\nBase class for maternal transmission\n\n\nMixingPool\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\nMixingPools\nA container for creating a rectangular array of MixingPool instances\n\n\nNetwork\nA class holding a single network of contact edges (connections) between people\n\n\nNullNet\nA convenience class for a network of size n that only has self-connections with a weight of 0.\n\n\nPostnatalNet\nPostnatal transmission network\n\n\nPrenatalNet\nPrenatal transmission network\n\n\nRandomNet\nRandom connectivity between agents\n\n\nRoute\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\nSexualNetwork\nBase class for all sexual networks\n\n\nStaticNet\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships\n\n\n\n\n\nnetworks.AgeGroup(self, low, high, do_cache=True)\nA simple age-based filter that returns uids of agents that match the criteria\n\n\n\nnetworks.DiskNet(self, key_dict=None, **kwargs)\nDisk graph in which edges are made between agents located within a user-defined radius.\nInteractions take place within a square with edge length of 1. Agents are initialized to have a random position and orientation within this square. On each time step, agents advance v*dt in the direction they are pointed. When encountering a wall, agents are reflected.\nEdges are formed between two agents if they are within r distance of each other.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate contacts\n\n\n\n\n\nnetworks.DiskNet.add_pairs()\nGenerate contacts\n\n\n\n\n\nnetworks.DynamicNetwork(self, key_dict=None, **kwargs)\nA network where partnerships update dynamically\n\n\n\nnetworks.EmbeddingNet(self, **kwargs)\nHeterosexual age-assortative network based on a one-dimensional embedding.\nWarning: this network is random-number safe, but is very slow compared to RandomNet.\n\n\n\nnetworks.ErdosRenyiNet(self, key_dict=None, **kwargs)\nIn the Erdos-Renyi network, every possible edge has a probability, p, of being created on each time step.\nThe degree of each node will have a binomial distribution, considering each of the N-1 possible edges connection this node to the others will be created with probability p.\nPlease be careful with the dur parameter. When set to 0, new edges will be created on each time step. If positive, edges will persist for dur years. Note that the existence of edges from previous time steps will not prevent or otherwise alter the creation of new edges on each time step, edges will accumulate over time.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate contacts\n\n\n\n\n\nnetworks.ErdosRenyiNet.add_pairs()\nGenerate contacts\n\n\n\n\n\nnetworks.MFNet(self, **kwargs)\nThis network is built by randomly pairing males and female with variable relationship durations.\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_debut\nSet debut age\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\nset_participation\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MFNet.set_debut(upper_age=None)\nSet debut age\n\n\n\nnetworks.MFNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\nnetworks.MFNet.set_participation(upper_age=None)\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MSMNet(self, key_dict=None, **kwargs)\nA network that randomly pairs males\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nPair all unpartnered MSM\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MSMNet.add_pairs()\nPair all unpartnered MSM\n\n\n\nnetworks.MSMNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MaternalNet(\n    self,\n    key_dict=None,\n    prenatal=True,\n    postnatal=False,\n    **kwargs,\n)\nBase class for maternal transmission Use PrenatalNet and PostnatalNet to capture transmission in different phases\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nAdd connections between pregnant women and their as-yet-unborn babies\n\n\nstep\nSet beta to 0 for women who complete duration of transmission\n\n\n\n\n\nnetworks.MaternalNet.add_pairs(\n    mother_inds=None,\n    unborn_inds=None,\n    dur=None,\n    start=None,\n)\nAdd connections between pregnant women and their as-yet-unborn babies\n\n\n\nnetworks.MaternalNet.step()\nSet beta to 0 for women who complete duration of transmission Keep connections for now, might want to consider removing\nNB: add_pairs() and end_pairs() are NOT called here; this is done separately in ss.Pregnancy.update_states().\n\n\n\n\n\nnetworks.MixingPool(self, **kwargs)\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via this mixing pool\nrequired\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\nrequired\n\n\ndst\ninds\ndestination agents; as above\nrequired\n\n\nbeta\nfloat\noverall transmission (note: use a float, not a TimePar; the time component is usually handled by the disease beta)\nrequired\n\n\ncontacts\nDist\nthe number of effective contacts of the destination agents\nrequired\n\n\n\nExample:\nimport starsim as ss\n\n# Set the parameters\nmp_pars = dict(\n    src = lambda sim: sim.people.male, # only males are infectious\n    dst = None, # all agents are susceptible\n    beta = ss.Rate(0.2),\n    contacts = ss.poisson(lam=4),\n)\n\n# Seed 5% of the male population\ndef p_init(self, sim, uids):\n    return 0.05*sim.people.male\n\n# Create and run the sim\nsis = ss.SIS(init_prev=p_init)\nmp = ss.MixingPool(mp_pars)\nsim = ss.Sim(diseases=sis, networks=mp)\nsim.run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCalculate transmission\n\n\nremove_uids\nIf UIDs are supplied explicitly, remove them if people die\n\n\nstep\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPool.compute_transmission(rel_sus, rel_trans, disease_beta)\nCalculate transmission\nThis is called from Infection.infect() together with network transmission.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrel_sus\nfloat\nRelative susceptibility\nrequired\n\n\nrel_trans\nfloat\nRelative infectiousness\nrequired\n\n\ndisease_beta\nfloat\nThe beta value for the disease\nrequired\n\n\n\nReturns: UIDs of agents who acquired the disease at this step\n\n\n\n\nnetworks.MixingPool.remove_uids(uids)\nIf UIDs are supplied explicitly, remove them if people die\n\n\n\nnetworks.MixingPool.step()\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPools(self, **kwargs)\nA container for creating a rectangular array of MixingPool instances\nBy default, separates the population into &lt;15 and &gt;15 age groups.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via these mixing pools\nrequired\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\nrequired\n\n\ndst\ninds\ndestination agents; as above\nrequired\n\n\nbeta\nfloat\noverall transmission via these mixing pools\nrequired\n\n\ncontacts\narray\nthe relative connectivity between different mixing pools (can be float or Dist)\nrequired\n\n\n\nExample:\nimport starsim as ss\nmps = ss.MixingPools(\n    diseases = 'sis',\n    beta = 0.1,\n    src = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    dst = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    contacts = [[2.4, 0.49], [0.91, 0.16]],\n)\nsim = ss.Sim(diseases='sis', networks=mps).run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_post\nInitialize each mixing pool\n\n\nremove_uids\nRemove UIDs from each mixing pool\n\n\nvalidate_pars\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.MixingPools.init_post()\nInitialize each mixing pool\n\n\n\nnetworks.MixingPools.remove_uids(uids)\nRemove UIDs from each mixing pool\n\n\n\nnetworks.MixingPools.validate_pars()\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.Network(\n    self,\n    key_dict=None,\n    prenatal=False,\n    postnatal=False,\n    name=None,\n    label=None,\n    **kwargs,\n)\nA class holding a single network of contact edges (connections) between people as well as methods for updating these.\nThe input is typically arrays including: person 1 of the connection, person 2 of the connection, the weight of the connection, the duration and start/end times of the connection.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np1\narray\nan array of length N, the number of connections in the network, with the indices of people on one side of the connection.\nrequired\n\n\np2\narray\nan array of length N, the number of connections in the network, with the indices of people on the other side of the connection.\nrequired\n\n\nbeta\narray\nan array representing relative transmissibility of each connection for this network - TODO, do we need this?\nrequired\n\n\nlabel\nstr\nthe name of the network (optional)\nNone\n\n\nkwargs\ndict\nother keys copied directly into the network\n{}\n\n\n\nNote that all arguments (except for label) must be arrays of the same length, although not all have to be supplied at the time of creation (they must all be the same at the time of initialization, though, or else validation will fail).\nExamples:\n# Generate an average of 10 contacts for 1000 people\nn_contacts_pp = 10\nn_people = 1000\nn = n_contacts_pp * n_people\np1 = np.random.randint(n_people, size=n)\np2 = np.random.randint(n_people, size=n)\nbeta = np.ones(n)\nnetwork = ss.Network(p1=p1, p2=p2, beta=beta, label='rand')\nnetwork = ss.Network(dict(p1=p1, p2=p2, beta=beta), label='rand') # Alternate method\n\n# Convert one network to another with extra columns\nindex = np.arange(n)\nself_conn = p1 == p2\nnetwork2 = ss.Network(**network, index=index, self_conn=self_conn, label=network.label)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbeta\nRelative transmission on each network edge\n\n\nmembers\nReturn sorted array of all members\n\n\np1\nThe first half of a network edge (person 1)\n\n\np2\nThe second half of a network edge (person 2)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nDefine how pairs of people are formed\n\n\nappend\nAppend edges to the current network.\n\n\nfind_contacts\nFind all contacts of the specified people\n\n\nfrom_df\nConvert from a dataframe\n\n\nget_inds\nGet the specified indices from the edgelist and return them as a dict.\n\n\ninit_results\nStore network length by default\n\n\nmeta_keys\nReturn the keys for the network’s meta information\n\n\nnet_beta\nCalculate the beta for the given disease and network\n\n\nplot\nPlot the network using NetworkX.\n\n\npop_inds\n“Pop” the specified indices from the edgelist and return them as a dict.\n\n\nremove_uids\nRemove interactions involving specified UIDs\n\n\nset_network_states\nMany network states depend on properties of people – e.g. MSM depends on being male,\n\n\nto_df\nConvert to dataframe\n\n\nto_dict\nConvert to dictionary\n\n\nto_graph\nConvert to a networkx DiGraph\n\n\nupdate_results\nStore the number of edges in the network\n\n\nvalidate\nCheck the integrity of the network: right types, right lengths.\n\n\nvalidate_uids\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.Network.add_pairs()\nDefine how pairs of people are formed\n\n\n\nnetworks.Network.append(edges=None, **kwargs)\nAppend edges to the current network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nedges\ndict\na dictionary of arrays with keys p1,p2,beta, as returned from network.pop_inds()\nNone\n\n\n\n\n\n\n\nnetworks.Network.find_contacts(inds, as_array=True)\nFind all contacts of the specified people\nFor some purposes (e.g. contact tracing) it’s necessary to find all the edges associated with a subset of the people in this network. Since edges are bidirectional it’s necessary to check both p1 and p2 for the target indices. The return type is a Set so that there is no duplication of indices (otherwise if the Network has explicit symmetric interactions, they could appear multiple times). This is also for performance so that the calling code doesn’t need to perform its own unique() operation. Note that this cannot be used for cases where multiple connections count differently than a single infection, e.g. exposure risk.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\narray\nindices of people whose edges to return\nrequired\n\n\nas_array\nbool\nif true, return as sorted array (otherwise, return as unsorted set)\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncontact_inds\narray\na set of indices for pairing partners\n\n\n\nExample: If there were a network with - p1 = [1,2,3,4] - p2 = [2,3,1,4] Then find_edges([1,3]) would return {1,2,3}\n\n\n\n\nnetworks.Network.from_df(df, keys=None)\nConvert from a dataframe\n\n\n\nnetworks.Network.get_inds(inds, remove=False)\nGet the specified indices from the edgelist and return them as a dict.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to find\nrequired\n\n\nremove\nbool\nwhether to remove the indices\nFalse\n\n\n\n\n\n\n\nnetworks.Network.init_results()\nStore network length by default\n\n\n\nnetworks.Network.meta_keys()\nReturn the keys for the network’s meta information\n\n\n\nnetworks.Network.net_beta(disease_beta=None, inds=None, disease=None)\nCalculate the beta for the given disease and network\n\n\n\nnetworks.Network.plot(max_edges=500, random=False, alpha=0.2, **kwargs)\nPlot the network using NetworkX.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\n500\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\nalpha\nfloat\nthe alpha value of the edges\n0.2\n\n\nkwargs\ndict\npassed to nx.draw_networkx()\n{}\n\n\n\n\n\n\n\nnetworks.Network.pop_inds(inds)\n“Pop” the specified indices from the edgelist and return them as a dict. Returns arguments in the right format to be used with network.append().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to be removed\nrequired\n\n\n\n\n\n\n\nnetworks.Network.remove_uids(uids)\nRemove interactions involving specified UIDs This method is typically called via People.remove() and is specifically used when removing agents from the simulation.\n\n\n\nnetworks.Network.set_network_states(people)\nMany network states depend on properties of people – e.g. MSM depends on being male, age of debut varies by sex and over time, and participation rates vary by age. Each time states are dynamically grown, this function should be called to set the network states that depend on other states.\n\n\n\nnetworks.Network.to_df()\nConvert to dataframe\n\n\n\nnetworks.Network.to_dict()\nConvert to dictionary\n\n\n\nnetworks.Network.to_graph(max_edges=None, random=False)\nConvert to a networkx DiGraph\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\nNone\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\n\nExample:\nimport networkx as nx\nsim = ss.Sim(n_agents=100, networks='mf').init()\nG = sim.networks.randomnet.to_graph()\nnx.draw(G)\n\n\n\n\nnetworks.Network.update_results()\nStore the number of edges in the network\n\n\n\nnetworks.Network.validate(force=True)\nCheck the integrity of the network: right types, right lengths.\nIf dtype is incorrect, try to convert automatically; if length is incorrect, do not.\n\n\n\nnetworks.Network.validate_uids()\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.NullNet(self, n_people=None, **kwargs)\nA convenience class for a network of size n that only has self-connections with a weight of 0. This network can be useful for debugging purposes or as a placeholder network during development for conditions that require more complex network mechanisms.\nGuarantees there’s one (1) contact per agent (themselves), and that their connection weight is zero.\nFor an empty network (ie, no edges) use &gt;&gt; import starsim as ss &gt;&gt; import networkx as nx &gt;&gt; empty_net_static = ss.StaticNet(nx.empty_graph) &gt;&gt; empty_net_rand = ss.RandomNet(n_contacts=0)\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nNot used for NullNet\n\n\n\n\n\nnetworks.NullNet.step()\nNot used for NullNet\n\n\n\n\n\nnetworks.PostnatalNet(\n    self,\n    key_dict=None,\n    prenatal=False,\n    postnatal=True,\n    **kwargs,\n)\nPostnatal transmission network\n\n\n\nnetworks.PrenatalNet(\n    self,\n    key_dict=None,\n    prenatal=True,\n    postnatal=False,\n    **kwargs,\n)\nPrenatal transmission network\n\n\n\nnetworks.RandomNet(self, key_dict=None, **kwargs)\nRandom connectivity between agents\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate edges\n\n\nget_edges\nEfficiently find edges\n\n\nget_source\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.RandomNet.add_pairs()\nGenerate edges\n\n\n\nnetworks.RandomNet.get_edges(inds, n_contacts)\nEfficiently find edges\nNote that because of the shuffling operation, each person is assigned 2N contacts (i.e. if a person has 5 contacts, they appear 5 times in the ‘source’ array and 5 times in the ‘target’ array). Therefore, the number_of_contacts argument to this function should be HALF of the total contacts a person is expected to have, if both the source and target array outputs are used (e.g. for social contacts)\nadjusted_number_of_contacts = np.round(number_of_contacts / 2).astype(ss.dtype.int)\nWhereas for asymmetric contacts (e.g. staff-public interactions) it might not be necessary\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n\nList/array of person indices\nrequired\n\n\nnumber_of_contacts\n\nList/array the same length as inds with the number of unidirectional\nrequired\n\n\n\nReturns: Two arrays, for source and target\n\n\n\n\nnetworks.RandomNet.get_source(inds, n_contacts)\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.Route(self, name=None, label=None, **kwargs)\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\n\nnetworks.SexualNetwork(self, key_dict=None, **kwargs)\nBase class for all sexual networks\n\n\n\nnetworks.StaticNet(self, graph=None, pars=None, **kwargs)\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships and initialized partnerships only end when one of the partners dies. The networkx graph can be created outside Starsim if population size is known. Or the graph can be created by passing a networkx generator function to Starsim.\nIf “seed=True” is passed as a keyword argument or a parameter in pars, it is replaced with the built-in RNG. The parameter “n” is supplied automatically to be equal to n_agents.\nExamples:\n# Generate a networkx graph and pass to Starsim\nimport networkx as nx\nimport starsim as ss\ng = nx.scale_free_graph(n=10000)\nss.StaticNet(graph=g)\n\n# Pass a networkx graph generator to Starsim\nss.StaticNet(graph=nx.erdos_renyi_graph, p=0.0001, seed=True)",
    "crumbs": [
      "**Modules**",
      "networks"
    ]
  },
  {
    "objectID": "api/networks.html#classes",
    "href": "api/networks.html#classes",
    "title": "networks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAgeGroup\nA simple age-based filter that returns uids of agents that match the criteria\n\n\nDiskNet\nDisk graph in which edges are made between agents located within a user-defined radius.\n\n\nDynamicNetwork\nA network where partnerships update dynamically\n\n\nEmbeddingNet\nHeterosexual age-assortative network based on a one-dimensional embedding.\n\n\nErdosRenyiNet\nIn the Erdos-Renyi network, every possible edge has a probability, p, of\n\n\nMFNet\nThis network is built by randomly pairing males and female with variable\n\n\nMSMNet\nA network that randomly pairs males\n\n\nMaternalNet\nBase class for maternal transmission\n\n\nMixingPool\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\nMixingPools\nA container for creating a rectangular array of MixingPool instances\n\n\nNetwork\nA class holding a single network of contact edges (connections) between people\n\n\nNullNet\nA convenience class for a network of size n that only has self-connections with a weight of 0.\n\n\nPostnatalNet\nPostnatal transmission network\n\n\nPrenatalNet\nPrenatal transmission network\n\n\nRandomNet\nRandom connectivity between agents\n\n\nRoute\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\nSexualNetwork\nBase class for all sexual networks\n\n\nStaticNet\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships\n\n\n\n\n\nnetworks.AgeGroup(self, low, high, do_cache=True)\nA simple age-based filter that returns uids of agents that match the criteria\n\n\n\nnetworks.DiskNet(self, key_dict=None, **kwargs)\nDisk graph in which edges are made between agents located within a user-defined radius.\nInteractions take place within a square with edge length of 1. Agents are initialized to have a random position and orientation within this square. On each time step, agents advance v*dt in the direction they are pointed. When encountering a wall, agents are reflected.\nEdges are formed between two agents if they are within r distance of each other.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate contacts\n\n\n\n\n\nnetworks.DiskNet.add_pairs()\nGenerate contacts\n\n\n\n\n\nnetworks.DynamicNetwork(self, key_dict=None, **kwargs)\nA network where partnerships update dynamically\n\n\n\nnetworks.EmbeddingNet(self, **kwargs)\nHeterosexual age-assortative network based on a one-dimensional embedding.\nWarning: this network is random-number safe, but is very slow compared to RandomNet.\n\n\n\nnetworks.ErdosRenyiNet(self, key_dict=None, **kwargs)\nIn the Erdos-Renyi network, every possible edge has a probability, p, of being created on each time step.\nThe degree of each node will have a binomial distribution, considering each of the N-1 possible edges connection this node to the others will be created with probability p.\nPlease be careful with the dur parameter. When set to 0, new edges will be created on each time step. If positive, edges will persist for dur years. Note that the existence of edges from previous time steps will not prevent or otherwise alter the creation of new edges on each time step, edges will accumulate over time.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate contacts\n\n\n\n\n\nnetworks.ErdosRenyiNet.add_pairs()\nGenerate contacts\n\n\n\n\n\nnetworks.MFNet(self, **kwargs)\nThis network is built by randomly pairing males and female with variable relationship durations.\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_debut\nSet debut age\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\nset_participation\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MFNet.set_debut(upper_age=None)\nSet debut age\n\n\n\nnetworks.MFNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\nnetworks.MFNet.set_participation(upper_age=None)\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MSMNet(self, key_dict=None, **kwargs)\nA network that randomly pairs males\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nPair all unpartnered MSM\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MSMNet.add_pairs()\nPair all unpartnered MSM\n\n\n\nnetworks.MSMNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MaternalNet(\n    self,\n    key_dict=None,\n    prenatal=True,\n    postnatal=False,\n    **kwargs,\n)\nBase class for maternal transmission Use PrenatalNet and PostnatalNet to capture transmission in different phases\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nAdd connections between pregnant women and their as-yet-unborn babies\n\n\nstep\nSet beta to 0 for women who complete duration of transmission\n\n\n\n\n\nnetworks.MaternalNet.add_pairs(\n    mother_inds=None,\n    unborn_inds=None,\n    dur=None,\n    start=None,\n)\nAdd connections between pregnant women and their as-yet-unborn babies\n\n\n\nnetworks.MaternalNet.step()\nSet beta to 0 for women who complete duration of transmission Keep connections for now, might want to consider removing\nNB: add_pairs() and end_pairs() are NOT called here; this is done separately in ss.Pregnancy.update_states().\n\n\n\n\n\nnetworks.MixingPool(self, **kwargs)\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via this mixing pool\nrequired\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\nrequired\n\n\ndst\ninds\ndestination agents; as above\nrequired\n\n\nbeta\nfloat\noverall transmission (note: use a float, not a TimePar; the time component is usually handled by the disease beta)\nrequired\n\n\ncontacts\nDist\nthe number of effective contacts of the destination agents\nrequired\n\n\n\nExample:\nimport starsim as ss\n\n# Set the parameters\nmp_pars = dict(\n    src = lambda sim: sim.people.male, # only males are infectious\n    dst = None, # all agents are susceptible\n    beta = ss.Rate(0.2),\n    contacts = ss.poisson(lam=4),\n)\n\n# Seed 5% of the male population\ndef p_init(self, sim, uids):\n    return 0.05*sim.people.male\n\n# Create and run the sim\nsis = ss.SIS(init_prev=p_init)\nmp = ss.MixingPool(mp_pars)\nsim = ss.Sim(diseases=sis, networks=mp)\nsim.run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCalculate transmission\n\n\nremove_uids\nIf UIDs are supplied explicitly, remove them if people die\n\n\nstep\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPool.compute_transmission(rel_sus, rel_trans, disease_beta)\nCalculate transmission\nThis is called from Infection.infect() together with network transmission.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrel_sus\nfloat\nRelative susceptibility\nrequired\n\n\nrel_trans\nfloat\nRelative infectiousness\nrequired\n\n\ndisease_beta\nfloat\nThe beta value for the disease\nrequired\n\n\n\nReturns: UIDs of agents who acquired the disease at this step\n\n\n\n\nnetworks.MixingPool.remove_uids(uids)\nIf UIDs are supplied explicitly, remove them if people die\n\n\n\nnetworks.MixingPool.step()\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPools(self, **kwargs)\nA container for creating a rectangular array of MixingPool instances\nBy default, separates the population into &lt;15 and &gt;15 age groups.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via these mixing pools\nrequired\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\nrequired\n\n\ndst\ninds\ndestination agents; as above\nrequired\n\n\nbeta\nfloat\noverall transmission via these mixing pools\nrequired\n\n\ncontacts\narray\nthe relative connectivity between different mixing pools (can be float or Dist)\nrequired\n\n\n\nExample:\nimport starsim as ss\nmps = ss.MixingPools(\n    diseases = 'sis',\n    beta = 0.1,\n    src = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    dst = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    contacts = [[2.4, 0.49], [0.91, 0.16]],\n)\nsim = ss.Sim(diseases='sis', networks=mps).run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_post\nInitialize each mixing pool\n\n\nremove_uids\nRemove UIDs from each mixing pool\n\n\nvalidate_pars\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.MixingPools.init_post()\nInitialize each mixing pool\n\n\n\nnetworks.MixingPools.remove_uids(uids)\nRemove UIDs from each mixing pool\n\n\n\nnetworks.MixingPools.validate_pars()\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.Network(\n    self,\n    key_dict=None,\n    prenatal=False,\n    postnatal=False,\n    name=None,\n    label=None,\n    **kwargs,\n)\nA class holding a single network of contact edges (connections) between people as well as methods for updating these.\nThe input is typically arrays including: person 1 of the connection, person 2 of the connection, the weight of the connection, the duration and start/end times of the connection.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np1\narray\nan array of length N, the number of connections in the network, with the indices of people on one side of the connection.\nrequired\n\n\np2\narray\nan array of length N, the number of connections in the network, with the indices of people on the other side of the connection.\nrequired\n\n\nbeta\narray\nan array representing relative transmissibility of each connection for this network - TODO, do we need this?\nrequired\n\n\nlabel\nstr\nthe name of the network (optional)\nNone\n\n\nkwargs\ndict\nother keys copied directly into the network\n{}\n\n\n\nNote that all arguments (except for label) must be arrays of the same length, although not all have to be supplied at the time of creation (they must all be the same at the time of initialization, though, or else validation will fail).\nExamples:\n# Generate an average of 10 contacts for 1000 people\nn_contacts_pp = 10\nn_people = 1000\nn = n_contacts_pp * n_people\np1 = np.random.randint(n_people, size=n)\np2 = np.random.randint(n_people, size=n)\nbeta = np.ones(n)\nnetwork = ss.Network(p1=p1, p2=p2, beta=beta, label='rand')\nnetwork = ss.Network(dict(p1=p1, p2=p2, beta=beta), label='rand') # Alternate method\n\n# Convert one network to another with extra columns\nindex = np.arange(n)\nself_conn = p1 == p2\nnetwork2 = ss.Network(**network, index=index, self_conn=self_conn, label=network.label)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbeta\nRelative transmission on each network edge\n\n\nmembers\nReturn sorted array of all members\n\n\np1\nThe first half of a network edge (person 1)\n\n\np2\nThe second half of a network edge (person 2)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nDefine how pairs of people are formed\n\n\nappend\nAppend edges to the current network.\n\n\nfind_contacts\nFind all contacts of the specified people\n\n\nfrom_df\nConvert from a dataframe\n\n\nget_inds\nGet the specified indices from the edgelist and return them as a dict.\n\n\ninit_results\nStore network length by default\n\n\nmeta_keys\nReturn the keys for the network’s meta information\n\n\nnet_beta\nCalculate the beta for the given disease and network\n\n\nplot\nPlot the network using NetworkX.\n\n\npop_inds\n“Pop” the specified indices from the edgelist and return them as a dict.\n\n\nremove_uids\nRemove interactions involving specified UIDs\n\n\nset_network_states\nMany network states depend on properties of people – e.g. MSM depends on being male,\n\n\nto_df\nConvert to dataframe\n\n\nto_dict\nConvert to dictionary\n\n\nto_graph\nConvert to a networkx DiGraph\n\n\nupdate_results\nStore the number of edges in the network\n\n\nvalidate\nCheck the integrity of the network: right types, right lengths.\n\n\nvalidate_uids\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.Network.add_pairs()\nDefine how pairs of people are formed\n\n\n\nnetworks.Network.append(edges=None, **kwargs)\nAppend edges to the current network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nedges\ndict\na dictionary of arrays with keys p1,p2,beta, as returned from network.pop_inds()\nNone\n\n\n\n\n\n\n\nnetworks.Network.find_contacts(inds, as_array=True)\nFind all contacts of the specified people\nFor some purposes (e.g. contact tracing) it’s necessary to find all the edges associated with a subset of the people in this network. Since edges are bidirectional it’s necessary to check both p1 and p2 for the target indices. The return type is a Set so that there is no duplication of indices (otherwise if the Network has explicit symmetric interactions, they could appear multiple times). This is also for performance so that the calling code doesn’t need to perform its own unique() operation. Note that this cannot be used for cases where multiple connections count differently than a single infection, e.g. exposure risk.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\narray\nindices of people whose edges to return\nrequired\n\n\nas_array\nbool\nif true, return as sorted array (otherwise, return as unsorted set)\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncontact_inds\narray\na set of indices for pairing partners\n\n\n\nExample: If there were a network with - p1 = [1,2,3,4] - p2 = [2,3,1,4] Then find_edges([1,3]) would return {1,2,3}\n\n\n\n\nnetworks.Network.from_df(df, keys=None)\nConvert from a dataframe\n\n\n\nnetworks.Network.get_inds(inds, remove=False)\nGet the specified indices from the edgelist and return them as a dict.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to find\nrequired\n\n\nremove\nbool\nwhether to remove the indices\nFalse\n\n\n\n\n\n\n\nnetworks.Network.init_results()\nStore network length by default\n\n\n\nnetworks.Network.meta_keys()\nReturn the keys for the network’s meta information\n\n\n\nnetworks.Network.net_beta(disease_beta=None, inds=None, disease=None)\nCalculate the beta for the given disease and network\n\n\n\nnetworks.Network.plot(max_edges=500, random=False, alpha=0.2, **kwargs)\nPlot the network using NetworkX.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\n500\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\nalpha\nfloat\nthe alpha value of the edges\n0.2\n\n\nkwargs\ndict\npassed to nx.draw_networkx()\n{}\n\n\n\n\n\n\n\nnetworks.Network.pop_inds(inds)\n“Pop” the specified indices from the edgelist and return them as a dict. Returns arguments in the right format to be used with network.append().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to be removed\nrequired\n\n\n\n\n\n\n\nnetworks.Network.remove_uids(uids)\nRemove interactions involving specified UIDs This method is typically called via People.remove() and is specifically used when removing agents from the simulation.\n\n\n\nnetworks.Network.set_network_states(people)\nMany network states depend on properties of people – e.g. MSM depends on being male, age of debut varies by sex and over time, and participation rates vary by age. Each time states are dynamically grown, this function should be called to set the network states that depend on other states.\n\n\n\nnetworks.Network.to_df()\nConvert to dataframe\n\n\n\nnetworks.Network.to_dict()\nConvert to dictionary\n\n\n\nnetworks.Network.to_graph(max_edges=None, random=False)\nConvert to a networkx DiGraph\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\nNone\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\n\nExample:\nimport networkx as nx\nsim = ss.Sim(n_agents=100, networks='mf').init()\nG = sim.networks.randomnet.to_graph()\nnx.draw(G)\n\n\n\n\nnetworks.Network.update_results()\nStore the number of edges in the network\n\n\n\nnetworks.Network.validate(force=True)\nCheck the integrity of the network: right types, right lengths.\nIf dtype is incorrect, try to convert automatically; if length is incorrect, do not.\n\n\n\nnetworks.Network.validate_uids()\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.NullNet(self, n_people=None, **kwargs)\nA convenience class for a network of size n that only has self-connections with a weight of 0. This network can be useful for debugging purposes or as a placeholder network during development for conditions that require more complex network mechanisms.\nGuarantees there’s one (1) contact per agent (themselves), and that their connection weight is zero.\nFor an empty network (ie, no edges) use &gt;&gt; import starsim as ss &gt;&gt; import networkx as nx &gt;&gt; empty_net_static = ss.StaticNet(nx.empty_graph) &gt;&gt; empty_net_rand = ss.RandomNet(n_contacts=0)\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nNot used for NullNet\n\n\n\n\n\nnetworks.NullNet.step()\nNot used for NullNet\n\n\n\n\n\nnetworks.PostnatalNet(\n    self,\n    key_dict=None,\n    prenatal=False,\n    postnatal=True,\n    **kwargs,\n)\nPostnatal transmission network\n\n\n\nnetworks.PrenatalNet(\n    self,\n    key_dict=None,\n    prenatal=True,\n    postnatal=False,\n    **kwargs,\n)\nPrenatal transmission network\n\n\n\nnetworks.RandomNet(self, key_dict=None, **kwargs)\nRandom connectivity between agents\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate edges\n\n\nget_edges\nEfficiently find edges\n\n\nget_source\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.RandomNet.add_pairs()\nGenerate edges\n\n\n\nnetworks.RandomNet.get_edges(inds, n_contacts)\nEfficiently find edges\nNote that because of the shuffling operation, each person is assigned 2N contacts (i.e. if a person has 5 contacts, they appear 5 times in the ‘source’ array and 5 times in the ‘target’ array). Therefore, the number_of_contacts argument to this function should be HALF of the total contacts a person is expected to have, if both the source and target array outputs are used (e.g. for social contacts)\nadjusted_number_of_contacts = np.round(number_of_contacts / 2).astype(ss.dtype.int)\nWhereas for asymmetric contacts (e.g. staff-public interactions) it might not be necessary\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n\nList/array of person indices\nrequired\n\n\nnumber_of_contacts\n\nList/array the same length as inds with the number of unidirectional\nrequired\n\n\n\nReturns: Two arrays, for source and target\n\n\n\n\nnetworks.RandomNet.get_source(inds, n_contacts)\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.Route(self, name=None, label=None, **kwargs)\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\n\nnetworks.SexualNetwork(self, key_dict=None, **kwargs)\nBase class for all sexual networks\n\n\n\nnetworks.StaticNet(self, graph=None, pars=None, **kwargs)\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships and initialized partnerships only end when one of the partners dies. The networkx graph can be created outside Starsim if population size is known. Or the graph can be created by passing a networkx generator function to Starsim.\nIf “seed=True” is passed as a keyword argument or a parameter in pars, it is replaced with the built-in RNG. The parameter “n” is supplied automatically to be equal to n_agents.\nExamples:\n# Generate a networkx graph and pass to Starsim\nimport networkx as nx\nimport starsim as ss\ng = nx.scale_free_graph(n=10000)\nss.StaticNet(graph=g)\n\n# Pass a networkx graph generator to Starsim\nss.StaticNet(graph=nx.erdos_renyi_graph, p=0.0001, seed=True)",
    "crumbs": [
      "**Modules**",
      "networks"
    ]
  },
  {
    "objectID": "api/calibration.html",
    "href": "api/calibration.html",
    "title": "calibration",
    "section": "",
    "text": "calibration\nDefine the calibration class\n\n\n\n\n\nName\nDescription\n\n\n\n\nCalibration\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter\n\n\n\n\n\ncalibration.Calibration(\n    self,\n    sim,\n    calib_pars,\n    n_workers=None,\n    total_trials=None,\n    reseed=True,\n    build_fn=None,\n    build_kw=None,\n    eval_fn=None,\n    eval_kw=None,\n    components=None,\n    prune_fn=None,\n    label=None,\n    study_name=None,\n    db_name=None,\n    keep_db=None,\n    continue_db=None,\n    storage=None,\n    sampler=None,\n    die=False,\n    debug=False,\n    verbose=True,\n)\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter optimization library (optuna.org).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\n(Sim)\nthe base simulation to calibrate\nrequired\n\n\ncalib_pars\n(dict)\na dictionary of the parameters to calibrate of the format dict(key1=dict(low=1, high=2, guess=1.5, **kwargs), key2=...), where kwargs can include “suggest_type” to choose the suggest method of the trial (e.g. suggest_float) and args passed to the trial suggest function like “log” and “step”\nrequired\n\n\nn_workers\n(int)\nthe number of parallel workers (if None, will use all available CPUs)\nNone\n\n\ntotal_trials\nint)\nthe total number of trials to run, each worker will run approximately n_trials = total_trial / n_workers\nNone\n\n\nreseed\n(bool)\nwhether to generate new random seeds for each trial\nTrue\n\n\nbuild_fn\n(callable)\nfunction that takes a sim object and calib_pars dictionary and returns a modified sim\nNone\n\n\nbuild_kw\n(dict)\na dictionary of options that are passed to build_fn to aid in modifying the base simulation. The API is self.build_fn(sim, calib_pars=calib_pars, **self.build_kw), where sim is a copy of the base simulation to be modified with calib_pars\nNone\n\n\ncomponents\n(list)\nCalibComponents independently assess pseudo-likelihood as part of evaluating the quality of input parameters\nNone\n\n\nprune_fn\n(callable)\nFunction that takes a dictionary of parameters and returns True if the trial should be pruned\nNone\n\n\neval_fn\n(callable)\nFunction mapping a sim to a float (e.g. negative log likelihood) to be maximized. If None, the default will use CalibComponents.\nNone\n\n\neval_kw\n(dict)\nAdditional keyword arguments to pass to the eval_fn\nNone\n\n\nlabel\n(str)\na label for this calibration object\nNone\n\n\nstudy_name\n(str)\nname of the optuna study\nNone\n\n\ndb_name\n(str)\nthe name of the database file (default: ‘starsim_calibration.db’)\nNone\n\n\ncontinue_db\n(bool)\nwhether to continue if the database already exists, removes the database if false (default: false, any existing database will be deleted)\nNone\n\n\nkeep_db\n(bool)\nwhether to keep the database after calibration (default: false, the database will be deleted)\nNone\n\n\nstorage\n(str)\nthe location of the database (default: sqlite)\nNone\n\n\nsampler\nBaseSampler\nthe sampler used by optuna, like optuna.samplers.TPESampler\nNone\n\n\ndie\n(bool)\nwhether to stop if an exception is encountered (default: false)\nFalse\n\n\ndebug\n(bool)\nif True, do not run in parallel\nFalse\n\n\nverbose\n(bool)\nwhether to print details of the calibration\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalibrate\nPerform calibration.\n\n\ncheck_fit\nRun before and after simulations to validate the fit\n\n\nmake_study\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\nparse_study\nParse the study into a data frame – called automatically\n\n\nplot\n”\n\n\nplot_final\nPlot sims after calibration\n\n\nplot_optuna\nPlot Optuna’s visualizations\n\n\nremove_db\nRemove the database file if keep_db is false and the path exists\n\n\nrun_sim\nCreate and run a simulation\n\n\nrun_trial\nDefine the objective for Optuna\n\n\nrun_workers\nRun multiple workers in parallel\n\n\nto_df\nReturn the top K results as a dataframe, sorted by value\n\n\nto_json\nConvert the results to JSON\n\n\nworker\nRun a single worker\n\n\n\n\n\ncalibration.Calibration.calibrate(calib_pars=None, **kwargs)\nPerform calibration.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncalib_pars\ndict\nif supplied, overwrite stored calib_pars\nNone\n\n\nkwargs\ndict\nif supplied, overwrite stored run_args (n_trials, n_workers, etc.)\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.check_fit(do_plot=True)\nRun before and after simulations to validate the fit\n\n\n\ncalibration.Calibration.make_study()\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\n\ncalibration.Calibration.parse_study(study)\nParse the study into a data frame – called automatically\n\n\n\ncalibration.Calibration.plot(**kwargs)\n” Plot the calibration results. For a component-based likelihood, it only makes sense to directly call plot after calling eval_fn.\n\n\n\ncalibration.Calibration.plot_final(**kwargs)\nPlot sims after calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to MultiSim.plot()\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.plot_optuna(methods=None)\nPlot Optuna’s visualizations\n\n\n\ncalibration.Calibration.remove_db()\nRemove the database file if keep_db is false and the path exists\n\n\n\ncalibration.Calibration.run_sim(calib_pars=None, label=None)\nCreate and run a simulation\n\n\n\ncalibration.Calibration.run_trial(trial)\nDefine the objective for Optuna\n\n\n\ncalibration.Calibration.run_workers()\nRun multiple workers in parallel\n\n\n\ncalibration.Calibration.to_df(top_k=None)\nReturn the top K results as a dataframe, sorted by value\n\n\n\ncalibration.Calibration.to_json(filename=None, indent=2, **kwargs)\nConvert the results to JSON\n\n\n\ncalibration.Calibration.worker()\nRun a single worker",
    "crumbs": [
      "**Workflows**",
      "calibration"
    ]
  },
  {
    "objectID": "api/calibration.html#classes",
    "href": "api/calibration.html#classes",
    "title": "calibration",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nCalibration\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter\n\n\n\n\n\ncalibration.Calibration(\n    self,\n    sim,\n    calib_pars,\n    n_workers=None,\n    total_trials=None,\n    reseed=True,\n    build_fn=None,\n    build_kw=None,\n    eval_fn=None,\n    eval_kw=None,\n    components=None,\n    prune_fn=None,\n    label=None,\n    study_name=None,\n    db_name=None,\n    keep_db=None,\n    continue_db=None,\n    storage=None,\n    sampler=None,\n    die=False,\n    debug=False,\n    verbose=True,\n)\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter optimization library (optuna.org).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\n(Sim)\nthe base simulation to calibrate\nrequired\n\n\ncalib_pars\n(dict)\na dictionary of the parameters to calibrate of the format dict(key1=dict(low=1, high=2, guess=1.5, **kwargs), key2=...), where kwargs can include “suggest_type” to choose the suggest method of the trial (e.g. suggest_float) and args passed to the trial suggest function like “log” and “step”\nrequired\n\n\nn_workers\n(int)\nthe number of parallel workers (if None, will use all available CPUs)\nNone\n\n\ntotal_trials\nint)\nthe total number of trials to run, each worker will run approximately n_trials = total_trial / n_workers\nNone\n\n\nreseed\n(bool)\nwhether to generate new random seeds for each trial\nTrue\n\n\nbuild_fn\n(callable)\nfunction that takes a sim object and calib_pars dictionary and returns a modified sim\nNone\n\n\nbuild_kw\n(dict)\na dictionary of options that are passed to build_fn to aid in modifying the base simulation. The API is self.build_fn(sim, calib_pars=calib_pars, **self.build_kw), where sim is a copy of the base simulation to be modified with calib_pars\nNone\n\n\ncomponents\n(list)\nCalibComponents independently assess pseudo-likelihood as part of evaluating the quality of input parameters\nNone\n\n\nprune_fn\n(callable)\nFunction that takes a dictionary of parameters and returns True if the trial should be pruned\nNone\n\n\neval_fn\n(callable)\nFunction mapping a sim to a float (e.g. negative log likelihood) to be maximized. If None, the default will use CalibComponents.\nNone\n\n\neval_kw\n(dict)\nAdditional keyword arguments to pass to the eval_fn\nNone\n\n\nlabel\n(str)\na label for this calibration object\nNone\n\n\nstudy_name\n(str)\nname of the optuna study\nNone\n\n\ndb_name\n(str)\nthe name of the database file (default: ‘starsim_calibration.db’)\nNone\n\n\ncontinue_db\n(bool)\nwhether to continue if the database already exists, removes the database if false (default: false, any existing database will be deleted)\nNone\n\n\nkeep_db\n(bool)\nwhether to keep the database after calibration (default: false, the database will be deleted)\nNone\n\n\nstorage\n(str)\nthe location of the database (default: sqlite)\nNone\n\n\nsampler\nBaseSampler\nthe sampler used by optuna, like optuna.samplers.TPESampler\nNone\n\n\ndie\n(bool)\nwhether to stop if an exception is encountered (default: false)\nFalse\n\n\ndebug\n(bool)\nif True, do not run in parallel\nFalse\n\n\nverbose\n(bool)\nwhether to print details of the calibration\nTrue\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalibrate\nPerform calibration.\n\n\ncheck_fit\nRun before and after simulations to validate the fit\n\n\nmake_study\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\nparse_study\nParse the study into a data frame – called automatically\n\n\nplot\n”\n\n\nplot_final\nPlot sims after calibration\n\n\nplot_optuna\nPlot Optuna’s visualizations\n\n\nremove_db\nRemove the database file if keep_db is false and the path exists\n\n\nrun_sim\nCreate and run a simulation\n\n\nrun_trial\nDefine the objective for Optuna\n\n\nrun_workers\nRun multiple workers in parallel\n\n\nto_df\nReturn the top K results as a dataframe, sorted by value\n\n\nto_json\nConvert the results to JSON\n\n\nworker\nRun a single worker\n\n\n\n\n\ncalibration.Calibration.calibrate(calib_pars=None, **kwargs)\nPerform calibration.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncalib_pars\ndict\nif supplied, overwrite stored calib_pars\nNone\n\n\nkwargs\ndict\nif supplied, overwrite stored run_args (n_trials, n_workers, etc.)\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.check_fit(do_plot=True)\nRun before and after simulations to validate the fit\n\n\n\ncalibration.Calibration.make_study()\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\n\ncalibration.Calibration.parse_study(study)\nParse the study into a data frame – called automatically\n\n\n\ncalibration.Calibration.plot(**kwargs)\n” Plot the calibration results. For a component-based likelihood, it only makes sense to directly call plot after calling eval_fn.\n\n\n\ncalibration.Calibration.plot_final(**kwargs)\nPlot sims after calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to MultiSim.plot()\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.plot_optuna(methods=None)\nPlot Optuna’s visualizations\n\n\n\ncalibration.Calibration.remove_db()\nRemove the database file if keep_db is false and the path exists\n\n\n\ncalibration.Calibration.run_sim(calib_pars=None, label=None)\nCreate and run a simulation\n\n\n\ncalibration.Calibration.run_trial(trial)\nDefine the objective for Optuna\n\n\n\ncalibration.Calibration.run_workers()\nRun multiple workers in parallel\n\n\n\ncalibration.Calibration.to_df(top_k=None)\nReturn the top K results as a dataframe, sorted by value\n\n\n\ncalibration.Calibration.to_json(filename=None, indent=2, **kwargs)\nConvert the results to JSON\n\n\n\ncalibration.Calibration.worker()\nRun a single worker",
    "crumbs": [
      "**Workflows**",
      "calibration"
    ]
  },
  {
    "objectID": "api/arrays.html",
    "href": "api/arrays.html",
    "title": "arrays",
    "section": "",
    "text": "arrays\nDefine array-handling classes, including agent states\n\n\n\n\n\nName\nDescription\n\n\n\n\nArr\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\n\n\nBaseArr\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\nBoolArr\nSubclass of Arr with defaults for booleans\n\n\nFloatArr\nSubclass of Arr with defaults for floats and ints.\n\n\nIndexArr\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\nState\nA boolean array being used as a state.\n\n\nuids\nClass to specify that integers should be interpreted as UIDs.\n\n\n\n\n\narrays.Arr(\n    self,\n    name=None,\n    dtype=None,\n    default=None,\n    nan=None,\n    label=None,\n    skip_init=False,\n    people=None,\n)\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\nIn practice, Arr objects can be used interchangeably with NumPy arrays. They have two main data interfaces: Arr.raw contains the “raw”, underlying NumPy array of the data. Arr.values contains the “active” values, which usually corresponds to agents who are alive.\nBy default, operations are performed on active agents only (specified by Arr.auids, which is a pointer to sim.people.auids). For example, sim.people.age.mean() will only use the ages of active agents. Thus, sim.people.age.mean() is equal to sim.people.age.values.mean(), not sim.people.age.raw.mean().\nIf indexing by an int or slice, Arr.values is used. If indexing by an ss.uids object, Arr.raw is used. Arr objects can’t be directly indexed by a list or array of ints, as this would be ambiguous about whether values or raw is intended. For example, if there are 1000 people in a simulation and 100 of them have died, sim.people.age[999] will return an IndexError (since sim.people.age[899] is the last active agent), whereas sim.people.age[ss.uids(999)] is valid.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name for the state (also used as the dictionary key, so should not have spaces etc.)\nNone\n\n\ndtype\nclass\nThe dtype to use for this instance (if None, infer from value)\nNone\n\n\ndefault\nany\nSpecify default value for new agents. This can be: * A scalar with the same dtype (or castable to the same dtype) as the State; * A callable, with a single argument for the number of values to produce; * A ss.Dist instance.\nNone\n\n\nnan\nany\nthe value to use to represent NaN (not a number); also used as the default value if not supplied\nNone\n\n\nlabel\nstr\nThe human-readable name for the state\nNone\n\n\nskip_init\nbool\nWhether to skip initialization with the People object (used for uid and slot states)\nFalse\n\n\npeople\n[ss.People](starsim.people.People\nOptionally specify an initialized People object, used to construct temporary Arr instances\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauids\nLink to the indices of active agents – sim.people.auids\n\n\nvalues\nReturn the values of the active agents\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\nfalse\nReverse of true(); return UIDs of falsy values\n\n\ngrow\nAdd new agents to an Arr\n\n\ninit_vals\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\nlink_people\nLink a People object to this state, for access auids\n\n\nset\nSet the values for the specified UIDs\n\n\nset_nan\nShortcut function to set values to NaN\n\n\nto_json\nExport to JSON\n\n\ntrue\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.Arr.asnew(arr=None, cls=None, name=None)\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\n\narrays.Arr.false()\nReverse of true(); return UIDs of falsy values\n\n\n\narrays.Arr.grow(new_uids=None, new_vals=None)\nAdd new agents to an Arr\nThis method is normally only called via People.grow().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_uids\narray\nNumpy array of UIDs for the new agents being added\nNone\n\n\nnew_vals\narray\nIf provided, assign these state values to the new UIDs\nNone\n\n\n\n\n\n\n\narrays.Arr.init_vals()\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\n\narrays.Arr.link_people(people)\nLink a People object to this state, for access auids\n\n\n\narrays.Arr.set(uids, new_vals=None)\nSet the values for the specified UIDs\n\n\n\narrays.Arr.set_nan(uids)\nShortcut function to set values to NaN\n\n\n\narrays.Arr.to_json()\nExport to JSON\n\n\n\narrays.Arr.true()\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.BaseArr(self, values, *args, **kwargs)\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data\n\n\nconvert\nCheck if an object is an array, and convert if so\n\n\ndisp\nFull display of object\n\n\nto_json\nReturn a dictionary representation of the Arr\n\n\nupdate\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BaseArr.asnew(values=None, cls=None, **kwargs)\nDuplicate and copy (rather than link) data\n\n\n\narrays.BaseArr.convert(obj)\nCheck if an object is an array, and convert if so\n\n\n\narrays.BaseArr.disp()\nFull display of object\n\n\n\narrays.BaseArr.to_json()\nReturn a dictionary representation of the Arr\n\n\n\narrays.BaseArr.update(skip_none=True, overwrite=True, force=False, **kwargs)\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BoolArr(self, name=None, nan=False, **kwargs)\nSubclass of Arr with defaults for booleans\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to Arr.true\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nsplit\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.BoolArr.split()\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.FloatArr(self, name=None, nan=np.nan, **kwargs)\nSubclass of Arr with defaults for floats and ints.\nNote: Starsim does not support integer arrays by default since they introduce ambiguity in dealing with NaNs, and float arrays are suitable for most purposes. If you really want an integer array, you can use the default Arr class instead.\n\n\n\n\n\nName\nDescription\n\n\n\n\nisnan\nReturn BoolArr for NaN values\n\n\nnotnan\nReturn BoolArr for non-NaN values\n\n\nnotnanvals\nReturn values that are not-NaN\n\n\n\n\n\n\n\narrays.IndexArr(self, name=None, label=None)\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to self.values, to allow Arr.uids like BoolArr\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ngrow\nChange the size of the array\n\n\n\n\n\narrays.IndexArr.grow(new_uids=None, new_vals=None)\nChange the size of the array\n\n\n\n\n\narrays.State(self, name=None, nan=False, **kwargs)\nA boolean array being used as a state.\nAlthough functionally identical to BoolArr, a State is handled differently in terms of automation: specifically, results are automatically generated from a State (but not a BoolArr).\nStates are typically used to keep track of externally-facing variables (e.g. disease.susceptible), while BoolArrs can be used to keep track of internal ones (e.g. disease.has_immunity).\n\n\n\narrays.uids()\nClass to specify that integers should be interpreted as UIDs.\nFor all practical purposes, behaves like a NumPy integer array. However, has additional methods uids.concat() (instance method), ss.uids.cat() (class method), uids.remove(), and uids.intersect() to simplify common UID operations.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncat\nEquivalent to np.concatenate(), but return correct type\n\n\nconcat\nEquivalent to np.concatenate(), but return correct type\n\n\nintersect\nKeep only UIDs that are also present in the other array\n\n\nremove\nRemove provided UIDs from current array\n\n\nto_numpy\nReturn a view as a standard NumPy array\n\n\nunion\nReturn all UIDs present in both arrays\n\n\nunique\nReturn unique UIDs; equivalent to np.unique()\n\n\nxor\nReturn UIDs present in only one of the arrays\n\n\n\n\n\narrays.uids.cat(*args, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.concat(other, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.intersect(other, **kw)\nKeep only UIDs that are also present in the other array\n\n\n\narrays.uids.remove(other, **kw)\nRemove provided UIDs from current array\n\n\n\narrays.uids.to_numpy()\nReturn a view as a standard NumPy array\n\n\n\narrays.uids.union(other, **kw)\nReturn all UIDs present in both arrays\n\n\n\narrays.uids.unique(return_index=False)\nReturn unique UIDs; equivalent to np.unique()\n\n\n\narrays.uids.xor(other, **kw)\nReturn UIDs present in only one of the arrays",
    "crumbs": [
      "**Utilities**",
      "arrays"
    ]
  },
  {
    "objectID": "api/arrays.html#classes",
    "href": "api/arrays.html#classes",
    "title": "arrays",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nArr\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\n\n\nBaseArr\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\nBoolArr\nSubclass of Arr with defaults for booleans\n\n\nFloatArr\nSubclass of Arr with defaults for floats and ints.\n\n\nIndexArr\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\nState\nA boolean array being used as a state.\n\n\nuids\nClass to specify that integers should be interpreted as UIDs.\n\n\n\n\n\narrays.Arr(\n    self,\n    name=None,\n    dtype=None,\n    default=None,\n    nan=None,\n    label=None,\n    skip_init=False,\n    people=None,\n)\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\nIn practice, Arr objects can be used interchangeably with NumPy arrays. They have two main data interfaces: Arr.raw contains the “raw”, underlying NumPy array of the data. Arr.values contains the “active” values, which usually corresponds to agents who are alive.\nBy default, operations are performed on active agents only (specified by Arr.auids, which is a pointer to sim.people.auids). For example, sim.people.age.mean() will only use the ages of active agents. Thus, sim.people.age.mean() is equal to sim.people.age.values.mean(), not sim.people.age.raw.mean().\nIf indexing by an int or slice, Arr.values is used. If indexing by an ss.uids object, Arr.raw is used. Arr objects can’t be directly indexed by a list or array of ints, as this would be ambiguous about whether values or raw is intended. For example, if there are 1000 people in a simulation and 100 of them have died, sim.people.age[999] will return an IndexError (since sim.people.age[899] is the last active agent), whereas sim.people.age[ss.uids(999)] is valid.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name for the state (also used as the dictionary key, so should not have spaces etc.)\nNone\n\n\ndtype\nclass\nThe dtype to use for this instance (if None, infer from value)\nNone\n\n\ndefault\nany\nSpecify default value for new agents. This can be: * A scalar with the same dtype (or castable to the same dtype) as the State; * A callable, with a single argument for the number of values to produce; * A ss.Dist instance.\nNone\n\n\nnan\nany\nthe value to use to represent NaN (not a number); also used as the default value if not supplied\nNone\n\n\nlabel\nstr\nThe human-readable name for the state\nNone\n\n\nskip_init\nbool\nWhether to skip initialization with the People object (used for uid and slot states)\nFalse\n\n\npeople\n[ss.People](starsim.people.People\nOptionally specify an initialized People object, used to construct temporary Arr instances\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauids\nLink to the indices of active agents – sim.people.auids\n\n\nvalues\nReturn the values of the active agents\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\nfalse\nReverse of true(); return UIDs of falsy values\n\n\ngrow\nAdd new agents to an Arr\n\n\ninit_vals\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\nlink_people\nLink a People object to this state, for access auids\n\n\nset\nSet the values for the specified UIDs\n\n\nset_nan\nShortcut function to set values to NaN\n\n\nto_json\nExport to JSON\n\n\ntrue\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.Arr.asnew(arr=None, cls=None, name=None)\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\n\narrays.Arr.false()\nReverse of true(); return UIDs of falsy values\n\n\n\narrays.Arr.grow(new_uids=None, new_vals=None)\nAdd new agents to an Arr\nThis method is normally only called via People.grow().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_uids\narray\nNumpy array of UIDs for the new agents being added\nNone\n\n\nnew_vals\narray\nIf provided, assign these state values to the new UIDs\nNone\n\n\n\n\n\n\n\narrays.Arr.init_vals()\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\n\narrays.Arr.link_people(people)\nLink a People object to this state, for access auids\n\n\n\narrays.Arr.set(uids, new_vals=None)\nSet the values for the specified UIDs\n\n\n\narrays.Arr.set_nan(uids)\nShortcut function to set values to NaN\n\n\n\narrays.Arr.to_json()\nExport to JSON\n\n\n\narrays.Arr.true()\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.BaseArr(self, values, *args, **kwargs)\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data\n\n\nconvert\nCheck if an object is an array, and convert if so\n\n\ndisp\nFull display of object\n\n\nto_json\nReturn a dictionary representation of the Arr\n\n\nupdate\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BaseArr.asnew(values=None, cls=None, **kwargs)\nDuplicate and copy (rather than link) data\n\n\n\narrays.BaseArr.convert(obj)\nCheck if an object is an array, and convert if so\n\n\n\narrays.BaseArr.disp()\nFull display of object\n\n\n\narrays.BaseArr.to_json()\nReturn a dictionary representation of the Arr\n\n\n\narrays.BaseArr.update(skip_none=True, overwrite=True, force=False, **kwargs)\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BoolArr(self, name=None, nan=False, **kwargs)\nSubclass of Arr with defaults for booleans\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to Arr.true\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nsplit\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.BoolArr.split()\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.FloatArr(self, name=None, nan=np.nan, **kwargs)\nSubclass of Arr with defaults for floats and ints.\nNote: Starsim does not support integer arrays by default since they introduce ambiguity in dealing with NaNs, and float arrays are suitable for most purposes. If you really want an integer array, you can use the default Arr class instead.\n\n\n\n\n\nName\nDescription\n\n\n\n\nisnan\nReturn BoolArr for NaN values\n\n\nnotnan\nReturn BoolArr for non-NaN values\n\n\nnotnanvals\nReturn values that are not-NaN\n\n\n\n\n\n\n\narrays.IndexArr(self, name=None, label=None)\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to self.values, to allow Arr.uids like BoolArr\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ngrow\nChange the size of the array\n\n\n\n\n\narrays.IndexArr.grow(new_uids=None, new_vals=None)\nChange the size of the array\n\n\n\n\n\narrays.State(self, name=None, nan=False, **kwargs)\nA boolean array being used as a state.\nAlthough functionally identical to BoolArr, a State is handled differently in terms of automation: specifically, results are automatically generated from a State (but not a BoolArr).\nStates are typically used to keep track of externally-facing variables (e.g. disease.susceptible), while BoolArrs can be used to keep track of internal ones (e.g. disease.has_immunity).\n\n\n\narrays.uids()\nClass to specify that integers should be interpreted as UIDs.\nFor all practical purposes, behaves like a NumPy integer array. However, has additional methods uids.concat() (instance method), ss.uids.cat() (class method), uids.remove(), and uids.intersect() to simplify common UID operations.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncat\nEquivalent to np.concatenate(), but return correct type\n\n\nconcat\nEquivalent to np.concatenate(), but return correct type\n\n\nintersect\nKeep only UIDs that are also present in the other array\n\n\nremove\nRemove provided UIDs from current array\n\n\nto_numpy\nReturn a view as a standard NumPy array\n\n\nunion\nReturn all UIDs present in both arrays\n\n\nunique\nReturn unique UIDs; equivalent to np.unique()\n\n\nxor\nReturn UIDs present in only one of the arrays\n\n\n\n\n\narrays.uids.cat(*args, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.concat(other, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.intersect(other, **kw)\nKeep only UIDs that are also present in the other array\n\n\n\narrays.uids.remove(other, **kw)\nRemove provided UIDs from current array\n\n\n\narrays.uids.to_numpy()\nReturn a view as a standard NumPy array\n\n\n\narrays.uids.union(other, **kw)\nReturn all UIDs present in both arrays\n\n\n\narrays.uids.unique(return_index=False)\nReturn unique UIDs; equivalent to np.unique()\n\n\n\narrays.uids.xor(other, **kw)\nReturn UIDs present in only one of the arrays",
    "crumbs": [
      "**Utilities**",
      "arrays"
    ]
  },
  {
    "objectID": "api/time.html",
    "href": "api/time.html",
    "title": "time",
    "section": "",
    "text": "time\nFunctions and classes for handling time\n\n\n\n\n\nName\nDescription\n\n\n\n\nRate\nStore a value per unit time e.g., 2 per day\n\n\nTime\nHandle time vectors for both simulations and modules.\n\n\ndate\nDefine a point in time, based on pd.Timestamp\n\n\nrateprob\nA rateprob represents an instantaneous rate of an event occurring. Rates\n\n\ntimeprob\ntimeprob represents the probability of an event occurring during a\n\n\n\n\n\ntime.Rate(self, value, unit=None)\nStore a value per unit time e.g., 2 per day - self.value - the numerator (e.g., 2) - a scalar float - self.unit - the denominator (e.g., 1 day) - a Dur object\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_prob\nCalculate a time-specific probability value\n\n\n\n\n\ntime.Rate.to_prob(dur, v=1)\nCalculate a time-specific probability value\nThis function is mainly useful for subclasses where the multiplication by a duration is non-linear (e.g., timeprob) and therefore it is important to apply the factor prior to multiplication by duration. This function avoids creating an intermediate array of rates, and is therefore much higher performance.\ne.g.\n\n\n\np = ss.timeprob(0.05)self.cd4self.t.dt\n\n\n\nand\n\n\n\np = ss.timeprob(0.05).scale(self.cd4,self.t.dt)\n\n\n\nare equivalent, except that the second one is (much) faster.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv\n\nThe factor to scale the rate by. This factor is applied before multiplication by the duration\n1\n\n\ndur\n\nAn ss.Dur instance to scale the rate by (often this is dt)\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA numpy float array of values\n\n\n\n\n\n\n\n\n\ntime.Time(self, start=None, stop=None, dt=None, dur=None, name=None)\nHandle time vectors for both simulations and modules.\nEach module can have its own time instance, in the case where the time vector is defined by absolute dates, these time vectors are by definition aligned. Otherwise they can be specified using Dur objects which express relative times (they can be added to a date to get an absolute time)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\n\nss.date or ss.Dur\nNone\n\n\nstop\n\nss.date if start is an ss.date, or an ss.Dur if start is an ss.Dur\nNone\n\n\ndt\nss.Dur\nSimulation step size\nNone\n\n\npars\ndict\nif provided, populate parameter values from this dictionary\nrequired\n\n\nparent\nobj\nif provided, populate missing parameter values from a ’parent” Time instance\nrequired\n\n\nname\nstr\nif provided, name the Time object\nNone\n\n\ninit\nbool\nwhether or not to immediately initialize the Time object\nrequired\n\n\nsim\nbool / Sim\nif True, initializes as a sim-specific Time instance; if a Sim instance, initialize the absolute time vector\nrequired\n\n\n\nThe Time object, after initialization, has the following attributes:\n\nti (int): the current timestep\nnpts (int): the number of timesteps\ntvec (array): time either as absolute ss.date instances, or relative ss.Dur instances\nyearvec (array): time represented as floating-point years\n\nExamples:\nt1 = ss.Time(start=2000, stop=2020, dt=1.0)\nt2 = ss.Time(start='2021-01-01', stop='2021-04-04', dt=ss.days(2))\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nis_absolute\nCheck whether the fundamental simulation unit is absolute\n\n\nready\nCheck if all parameters are in place to be initialized\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit\nInitialize all vectors\n\n\nnow\nGet the current simulation time\n\n\nupdate\nReconcile different ways of supplying inputs\n\n\n\n\n\ntime.Time.init(sim=None)\nInitialize all vectors\n\n\n\ntime.Time.now(key=None)\nGet the current simulation time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhich\nstr\nwhich type of time to get: default (None), “year”, “date”, “tvec”, or “str”\nrequired\n\n\n\nExamples:\nt = ss.Time(start='2021-01-01', stop='2022-02-02', dt=1, unit='week')\nt.ti = 25\nt.now() # Returns &lt;2021-06-25&gt;\nt.now('date') # Returns &lt;2021-06-25&gt;\nt.now('year') # Returns 2021.479\nt.now('str') # Returns '2021-06-25'\n\n\n\n\ntime.Time.update(pars=None, parent=None, reset=True, force=None, **kwargs)\nReconcile different ways of supplying inputs\n\n\n\n\n\ntime.date()\nDefine a point in time, based on pd.Timestamp\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndate\nint / float / str / datetime\nAny type of date input (ints and floats will be interpreted as years)\nrequired\n\n\nkwargs\ndict\npassed to pd.Timestamp()\nrequired\n\n\n\nExamples:\nss.date(2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2024.75) # Returns &lt;2024-10-01&gt;\nss.date('2024-04-04') # Returns &lt;2024-04-04&gt;\nss.date(year=2024, month=4, day=4) # Returns &lt;2024-04-04&gt;\n\n\n\n\n\n\nName\nDescription\n\n\n\n\narange\nConstruct an array of dates\n\n\ndisp\nShow the full object\n\n\nfrom_array\nConvert an array of float years into an array of date instances\n\n\nfrom_year\nConvert an int or float year to a date.\n\n\nreplace\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\nto_pandas\nConvert to a standard pd.Timestamp instance\n\n\nto_year\nConvert a date to a floating-point year\n\n\n\n\n\ntime.date.arange(low, high, step=1)\nConstruct an array of dates\nFunctions similarly to np.arange, but returns date objects\nExample usage:\n\n\n\ndate.arange(2020, 2025) array([&lt;2020.01.01&gt;, &lt;2021.01.01&gt;, &lt;2022.01.01&gt;, &lt;2023.01.01&gt;, &lt;2024.01.01&gt;], dtype=object)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlow\n\nLower bound - can be a date or a numerical year\nrequired\n\n\nhigh\n\nUpper bound - can be a date or a numerical year\nrequired\n\n\nstep\n\nAssumes 1 calendar year steps by default\n1\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.disp(**kwargs)\nShow the full object\n\n\n\ntime.date.from_array(array)\nConvert an array of float years into an array of date instances\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narray\n\nAn array of float years\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.from_year(year)\nConvert an int or float year to a date.\nExamples:\nss.date.from_year(2020) # Returns &lt;2020-01-01&gt;\nss.date.from_year(2024.75) # Returns &lt;2024-10-01&gt;\n\n\n\ntime.date.replace(*args, **kwargs)\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\n\ntime.date.to_pandas()\nConvert to a standard pd.Timestamp instance\n\n\n\ntime.date.to_year()\nConvert a date to a floating-point year\nExamples:\nss.date('2020-01-01').to_year() # Returns 2020.0\nss.date('2024-10-01').to_year() # Returns 2024.7486\n\n\n\n\n\ntime.rateprob(self, value, unit=None)\nA rateprob represents an instantaneous rate of an event occurring. Rates must be non-negative, but need not be less than 1.\nThrough multiplication, rate can be modified or converted to a probability, depending on the data type of the object being multiplied.\nWhen a rateprob is multiplied by a scalar or array, the rate is simply scaled. Such multiplication occurs frequently in epidemiological models, where the base rate is multiplied by “rate ratio” or “relative rate” to represent agents experiencing higher (multiplier &gt; 1) or lower (multiplier &lt; 1) event rates.\nAlternatively, when a rateprob is multiplied by a duration (type ss.Dur), a probability is calculated. The conversion from rate to probability on multiplication by a duration is 1 - np.exp(-rate/factor), where factor is the ratio of the multiplied duration to the original period (denominator).\nFor example, consider &gt;&gt;&gt; p = ss.rateprob(0.8, ss.years(1)) When multiplied by a duration of 1 year, the calculated probability is 1 - np.exp(-0.8), which is approximately 55%. &gt;&gt;&gt; p*ss.years(1)\nWhen multiplied by a scalar, the rate is simply scaled. &gt;&gt;&gt; p*2\nThe difference between timeprob and rateprob is subtle, but important. rateprob works directly with the instantaneous rate of an event occurring. In contrast, timeprob starts with a probability and a duration, and the underlying rate is calculated. On multiplication by a duration, * rateprob: rate -&gt; probability * timeprob: probability -&gt; rate -&gt; probability\nThe behavior of both classes is depending on the data type of the object being multiplied.\n\n\n\ntime.timeprob(self, value, unit=None)\ntimeprob represents the probability of an event occurring during a specified period of time.\nThe class is designed to allow conversion of a probability from one duration to another through multiplication. However, the behavior of this conversion depends on the data type of the the object being multiplied.\nWhen multiplied by a duration (type ss.Dur), the underlying constant rate is calculated as rate = -np.log(1 - self.value). Then, the probability over the new duration is p = 1 - np.exp(-rate/factor), where factor is the ratio of the new duration to the original duration.\nFor example, &gt;&gt;&gt; p = ss.timeprob(0.8, ss.years(1)) indicates a 80% chance of an event occurring in one year.\n\n\n\np*ss.years(1) When multiplied by the original denominator, 1 year in this case, the probability remains unchanged, 80%.\n\n\n\n\n\n\np * ss.years(2) Multiplying p by ss.years(2) does not simply double the probability to 160% (which is not possible), but rather returns a new probability of 96% representing the chance of the event occurring at least once over the new duration of two years.\n\n\n\nHowever, the behavior is different when a timeprob object is multiplied by a scalar or array. In this case, the probability is simply scaled. This scaling may result in a value greater than 1, which is not valid. For example, &gt;&gt;&gt; p * 2 raises an AssertionError because the resulting probability (160%) exceeds 100%.\nUse rateprob instead if timeprob if you would prefer to directly specify the instantaneous rate.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nperday\nShortcut to specify rate per calendar day\n\n\npermonth\nShortcut to specify rate per calendar month\n\n\nperweek\nShortcut to specify rate per calendar week\n\n\nperyear\nShortcut to specify rate per numeric year\n\n\n\n\n\ntime.perday(v)\nShortcut to specify rate per calendar day\n\n\n\ntime.permonth(v)\nShortcut to specify rate per calendar month\n\n\n\ntime.perweek(v)\nShortcut to specify rate per calendar week\n\n\n\ntime.peryear(v)\nShortcut to specify rate per numeric year",
    "crumbs": [
      "**Utilities**",
      "time"
    ]
  },
  {
    "objectID": "api/time.html#classes",
    "href": "api/time.html#classes",
    "title": "time",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nRate\nStore a value per unit time e.g., 2 per day\n\n\nTime\nHandle time vectors for both simulations and modules.\n\n\ndate\nDefine a point in time, based on pd.Timestamp\n\n\nrateprob\nA rateprob represents an instantaneous rate of an event occurring. Rates\n\n\ntimeprob\ntimeprob represents the probability of an event occurring during a\n\n\n\n\n\ntime.Rate(self, value, unit=None)\nStore a value per unit time e.g., 2 per day - self.value - the numerator (e.g., 2) - a scalar float - self.unit - the denominator (e.g., 1 day) - a Dur object\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_prob\nCalculate a time-specific probability value\n\n\n\n\n\ntime.Rate.to_prob(dur, v=1)\nCalculate a time-specific probability value\nThis function is mainly useful for subclasses where the multiplication by a duration is non-linear (e.g., timeprob) and therefore it is important to apply the factor prior to multiplication by duration. This function avoids creating an intermediate array of rates, and is therefore much higher performance.\ne.g.\n\n\n\np = ss.timeprob(0.05)self.cd4self.t.dt\n\n\n\nand\n\n\n\np = ss.timeprob(0.05).scale(self.cd4,self.t.dt)\n\n\n\nare equivalent, except that the second one is (much) faster.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv\n\nThe factor to scale the rate by. This factor is applied before multiplication by the duration\n1\n\n\ndur\n\nAn ss.Dur instance to scale the rate by (often this is dt)\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA numpy float array of values\n\n\n\n\n\n\n\n\n\ntime.Time(self, start=None, stop=None, dt=None, dur=None, name=None)\nHandle time vectors for both simulations and modules.\nEach module can have its own time instance, in the case where the time vector is defined by absolute dates, these time vectors are by definition aligned. Otherwise they can be specified using Dur objects which express relative times (they can be added to a date to get an absolute time)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\n\nss.date or ss.Dur\nNone\n\n\nstop\n\nss.date if start is an ss.date, or an ss.Dur if start is an ss.Dur\nNone\n\n\ndt\nss.Dur\nSimulation step size\nNone\n\n\npars\ndict\nif provided, populate parameter values from this dictionary\nrequired\n\n\nparent\nobj\nif provided, populate missing parameter values from a ’parent” Time instance\nrequired\n\n\nname\nstr\nif provided, name the Time object\nNone\n\n\ninit\nbool\nwhether or not to immediately initialize the Time object\nrequired\n\n\nsim\nbool / Sim\nif True, initializes as a sim-specific Time instance; if a Sim instance, initialize the absolute time vector\nrequired\n\n\n\nThe Time object, after initialization, has the following attributes:\n\nti (int): the current timestep\nnpts (int): the number of timesteps\ntvec (array): time either as absolute ss.date instances, or relative ss.Dur instances\nyearvec (array): time represented as floating-point years\n\nExamples:\nt1 = ss.Time(start=2000, stop=2020, dt=1.0)\nt2 = ss.Time(start='2021-01-01', stop='2021-04-04', dt=ss.days(2))\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nis_absolute\nCheck whether the fundamental simulation unit is absolute\n\n\nready\nCheck if all parameters are in place to be initialized\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit\nInitialize all vectors\n\n\nnow\nGet the current simulation time\n\n\nupdate\nReconcile different ways of supplying inputs\n\n\n\n\n\ntime.Time.init(sim=None)\nInitialize all vectors\n\n\n\ntime.Time.now(key=None)\nGet the current simulation time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhich\nstr\nwhich type of time to get: default (None), “year”, “date”, “tvec”, or “str”\nrequired\n\n\n\nExamples:\nt = ss.Time(start='2021-01-01', stop='2022-02-02', dt=1, unit='week')\nt.ti = 25\nt.now() # Returns &lt;2021-06-25&gt;\nt.now('date') # Returns &lt;2021-06-25&gt;\nt.now('year') # Returns 2021.479\nt.now('str') # Returns '2021-06-25'\n\n\n\n\ntime.Time.update(pars=None, parent=None, reset=True, force=None, **kwargs)\nReconcile different ways of supplying inputs\n\n\n\n\n\ntime.date()\nDefine a point in time, based on pd.Timestamp\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndate\nint / float / str / datetime\nAny type of date input (ints and floats will be interpreted as years)\nrequired\n\n\nkwargs\ndict\npassed to pd.Timestamp()\nrequired\n\n\n\nExamples:\nss.date(2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2024.75) # Returns &lt;2024-10-01&gt;\nss.date('2024-04-04') # Returns &lt;2024-04-04&gt;\nss.date(year=2024, month=4, day=4) # Returns &lt;2024-04-04&gt;\n\n\n\n\n\n\nName\nDescription\n\n\n\n\narange\nConstruct an array of dates\n\n\ndisp\nShow the full object\n\n\nfrom_array\nConvert an array of float years into an array of date instances\n\n\nfrom_year\nConvert an int or float year to a date.\n\n\nreplace\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\nto_pandas\nConvert to a standard pd.Timestamp instance\n\n\nto_year\nConvert a date to a floating-point year\n\n\n\n\n\ntime.date.arange(low, high, step=1)\nConstruct an array of dates\nFunctions similarly to np.arange, but returns date objects\nExample usage:\n\n\n\ndate.arange(2020, 2025) array([&lt;2020.01.01&gt;, &lt;2021.01.01&gt;, &lt;2022.01.01&gt;, &lt;2023.01.01&gt;, &lt;2024.01.01&gt;], dtype=object)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlow\n\nLower bound - can be a date or a numerical year\nrequired\n\n\nhigh\n\nUpper bound - can be a date or a numerical year\nrequired\n\n\nstep\n\nAssumes 1 calendar year steps by default\n1\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.disp(**kwargs)\nShow the full object\n\n\n\ntime.date.from_array(array)\nConvert an array of float years into an array of date instances\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narray\n\nAn array of float years\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.from_year(year)\nConvert an int or float year to a date.\nExamples:\nss.date.from_year(2020) # Returns &lt;2020-01-01&gt;\nss.date.from_year(2024.75) # Returns &lt;2024-10-01&gt;\n\n\n\ntime.date.replace(*args, **kwargs)\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\n\ntime.date.to_pandas()\nConvert to a standard pd.Timestamp instance\n\n\n\ntime.date.to_year()\nConvert a date to a floating-point year\nExamples:\nss.date('2020-01-01').to_year() # Returns 2020.0\nss.date('2024-10-01').to_year() # Returns 2024.7486\n\n\n\n\n\ntime.rateprob(self, value, unit=None)\nA rateprob represents an instantaneous rate of an event occurring. Rates must be non-negative, but need not be less than 1.\nThrough multiplication, rate can be modified or converted to a probability, depending on the data type of the object being multiplied.\nWhen a rateprob is multiplied by a scalar or array, the rate is simply scaled. Such multiplication occurs frequently in epidemiological models, where the base rate is multiplied by “rate ratio” or “relative rate” to represent agents experiencing higher (multiplier &gt; 1) or lower (multiplier &lt; 1) event rates.\nAlternatively, when a rateprob is multiplied by a duration (type ss.Dur), a probability is calculated. The conversion from rate to probability on multiplication by a duration is 1 - np.exp(-rate/factor), where factor is the ratio of the multiplied duration to the original period (denominator).\nFor example, consider &gt;&gt;&gt; p = ss.rateprob(0.8, ss.years(1)) When multiplied by a duration of 1 year, the calculated probability is 1 - np.exp(-0.8), which is approximately 55%. &gt;&gt;&gt; p*ss.years(1)\nWhen multiplied by a scalar, the rate is simply scaled. &gt;&gt;&gt; p*2\nThe difference between timeprob and rateprob is subtle, but important. rateprob works directly with the instantaneous rate of an event occurring. In contrast, timeprob starts with a probability and a duration, and the underlying rate is calculated. On multiplication by a duration, * rateprob: rate -&gt; probability * timeprob: probability -&gt; rate -&gt; probability\nThe behavior of both classes is depending on the data type of the object being multiplied.\n\n\n\ntime.timeprob(self, value, unit=None)\ntimeprob represents the probability of an event occurring during a specified period of time.\nThe class is designed to allow conversion of a probability from one duration to another through multiplication. However, the behavior of this conversion depends on the data type of the the object being multiplied.\nWhen multiplied by a duration (type ss.Dur), the underlying constant rate is calculated as rate = -np.log(1 - self.value). Then, the probability over the new duration is p = 1 - np.exp(-rate/factor), where factor is the ratio of the new duration to the original duration.\nFor example, &gt;&gt;&gt; p = ss.timeprob(0.8, ss.years(1)) indicates a 80% chance of an event occurring in one year.\n\n\n\np*ss.years(1) When multiplied by the original denominator, 1 year in this case, the probability remains unchanged, 80%.\n\n\n\n\n\n\np * ss.years(2) Multiplying p by ss.years(2) does not simply double the probability to 160% (which is not possible), but rather returns a new probability of 96% representing the chance of the event occurring at least once over the new duration of two years.\n\n\n\nHowever, the behavior is different when a timeprob object is multiplied by a scalar or array. In this case, the probability is simply scaled. This scaling may result in a value greater than 1, which is not valid. For example, &gt;&gt;&gt; p * 2 raises an AssertionError because the resulting probability (160%) exceeds 100%.\nUse rateprob instead if timeprob if you would prefer to directly specify the instantaneous rate.",
    "crumbs": [
      "**Utilities**",
      "time"
    ]
  },
  {
    "objectID": "api/time.html#functions",
    "href": "api/time.html#functions",
    "title": "time",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nperday\nShortcut to specify rate per calendar day\n\n\npermonth\nShortcut to specify rate per calendar month\n\n\nperweek\nShortcut to specify rate per calendar week\n\n\nperyear\nShortcut to specify rate per numeric year\n\n\n\n\n\ntime.perday(v)\nShortcut to specify rate per calendar day\n\n\n\ntime.permonth(v)\nShortcut to specify rate per calendar month\n\n\n\ntime.perweek(v)\nShortcut to specify rate per calendar week\n\n\n\ntime.peryear(v)\nShortcut to specify rate per numeric year",
    "crumbs": [
      "**Utilities**",
      "time"
    ]
  },
  {
    "objectID": "api/settings.html",
    "href": "api/settings.html",
    "title": "settings",
    "section": "",
    "text": "settings\nsettings\nDefine options for Starsim. All options should be set using set() or directly, e.g.:\nss.options(verbose=False)",
    "crumbs": [
      "**Utilities**",
      "settings"
    ]
  },
  {
    "objectID": "api/results.html",
    "href": "api/results.html",
    "title": "results",
    "section": "",
    "text": "results\nResult structures.\n\n\n\n\n\nName\nDescription\n\n\n\n\nResult\nArray-like container for holding sim results.\n\n\nResults\nContainer for storing results\n\n\n\n\n\nresults.Result(\n    self,\n    name=None,\n    label=None,\n    dtype=float,\n    shape=None,\n    scale=True,\n    auto_plot=True,\n    module=None,\n    values=None,\n    timevec=None,\n    low=None,\n    high=None,\n    summarize_by=None,\n    **kwargs,\n)\nArray-like container for holding sim results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodule\nstr\nthe name of the parent module, e.g. ‘hiv’\nNone\n\n\nname\nstr\nthe name of this result, e.g. ‘new_infections’\nNone\n\n\nshape\nint / tuple\nthe shape of the result array (usually module.npts)\nNone\n\n\nscale\nbool\nwhether or not the result scales by population size (e.g. a count does, a prevalence does not)\nTrue\n\n\nauto_plot\nbool\nwhether to include automatically in sim.plot() results\nTrue\n\n\nlabel\nstr\na human-readable label for the result\nNone\n\n\nvalues\narray\nprepopulate the Result with these values\nNone\n\n\ntimevec\narray\nan array of time points\nNone\n\n\nlow\narray\nvalues for the lower bound\nNone\n\n\nhigh\narray\nvalues for the upper bound\nNone\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\n\nIn most cases, ss.Result behaves exactly like np.array(), except with the additional fields listed above. To see everything contained in a result, you can use result.disp().\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfull_label\nReturn the full label of the result: : , e.g. “HIV: New infections”\n\n\nhas_dates\nCheck whether the time vector uses dates (rather than numbers)\n\n\nkey\nReturn the unique key of the result: ., e.g. “hiv.new_infections”\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_df\nMake a copy of the result with new values from a dataframe\n\n\ninit_values\nHandle values\n\n\nplot\nPlot a single result; kwargs are interpreted as plot_kw\n\n\nresample\nResample the result, e.g. from days to years. Leverages the pandas resample method.\n\n\nto_df\nConvert to a dataframe with timevec, value, low, and high columns\n\n\nto_series\nConvert to a series with timevec as the index and value as the data\n\n\nupdate\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Result.from_df(df)\nMake a copy of the result with new values from a dataframe\n\n\n\nresults.Result.init_values(values=None, dtype=None, shape=None, force=False)\nHandle values\n\n\n\nresults.Result.plot(\n    fig=None,\n    ax=None,\n    fig_kw=None,\n    plot_kw=None,\n    fill_kw=None,\n    **kwargs,\n)\nPlot a single result; kwargs are interpreted as plot_kw\n\n\n\nresults.Result.resample(\n    new_unit='year',\n    summarize_by=None,\n    col_names='vlh',\n    die=False,\n    output_form='series',\n    use_years=False,\n    sep='_',\n)\nResample the result, e.g. from days to years. Leverages the pandas resample method. Accepts all the Starsim units, plus the Pandas ones documented here: https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_unit\nstr\nthe new unit to resample to, e.g. ‘year’, ‘month’, ‘week’, ‘day’, ‘1W’, ‘2M’, etc.\n'year'\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\ncol_names\nstr\nwhether to rename the columns with the name of the result\n'vlh'\n\n\ndie\nbool\nwhether to raise an error if the summarization method cannot be determined\nFalse\n\n\noutput_form\nstr\n‘series’, ‘dataframe’, or ‘result’\n'series'\n\n\nuse_years\nbool\nwhether to use years as the unit of time\nFalse\n\n\n\n\n\n\n\nresults.Result.to_df(\n    sep='_',\n    col_names='vlh',\n    resample=None,\n    set_date_index=False,\n    **kwargs,\n)\nConvert to a dataframe with timevec, value, low, and high columns\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsep\nstr\nseparator for the column names\n'_'\n\n\ncol_names\nstr or None\nif None, uses the name of the result. Default is ‘vlh’ which uses value, low, high\n'vlh'\n\n\nset_date_index\nbool\nif True, use the timevec as the index\nFalse\n\n\nresample\nstr\nif provided, resample the data to this frequency\nNone\n\n\nkwargs\n\npassed to the resample method\n{}\n\n\n\n\n\n\n\nresults.Result.to_series(set_name=False, resample=None, sep='_', **kwargs)\nConvert to a series with timevec as the index and value as the data Args: set_name (bool): whether to set the name of the series to the name of the result resample (str): if provided, resample the data to this frequency kwargs: passed to the resample method\n\n\n\nresults.Result.update(*args, **kwargs)\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Results(self, module, *args, strict=True, **kwargs)\nContainer for storing results\n\n\n\n\n\nName\nDescription\n\n\n\n\nall_results\nIterator over all results, skipping any nested values\n\n\nall_results_dict\nDictionary of all results, skipping any nested values\n\n\nequal_len\nCheck if all results are equal length\n\n\nis_msim\nCheck if this is a MultiSim\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nappend\nThis is activated by adding as well, e.g. results += result\n\n\nflatten\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\nplot\nPlot all the results\n\n\nto_df\nMerge all results dataframes into one\n\n\n\n\n\nresults.Results.append(arg, key=None)\nThis is activated by adding as well, e.g. results += result\n\n\n\nresults.Results.flatten(sep='_', only_results=True, keep_case=False, **kwargs)\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\n\nresults.Results.plot(style='fancy', fig_kw=None, plot_kw=None)\nPlot all the results\n\n\n\nresults.Results.to_df(sep='_', descend=False, **kwargs)\nMerge all results dataframes into one Args: sep (str): separator for the column names descend (bool): whether to descend into nested results kwargs: passed to the to_df method, can include instructions for summarizing results by time",
    "crumbs": [
      "**Utilities**",
      "results"
    ]
  },
  {
    "objectID": "api/results.html#classes",
    "href": "api/results.html#classes",
    "title": "results",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nResult\nArray-like container for holding sim results.\n\n\nResults\nContainer for storing results\n\n\n\n\n\nresults.Result(\n    self,\n    name=None,\n    label=None,\n    dtype=float,\n    shape=None,\n    scale=True,\n    auto_plot=True,\n    module=None,\n    values=None,\n    timevec=None,\n    low=None,\n    high=None,\n    summarize_by=None,\n    **kwargs,\n)\nArray-like container for holding sim results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodule\nstr\nthe name of the parent module, e.g. ‘hiv’\nNone\n\n\nname\nstr\nthe name of this result, e.g. ‘new_infections’\nNone\n\n\nshape\nint / tuple\nthe shape of the result array (usually module.npts)\nNone\n\n\nscale\nbool\nwhether or not the result scales by population size (e.g. a count does, a prevalence does not)\nTrue\n\n\nauto_plot\nbool\nwhether to include automatically in sim.plot() results\nTrue\n\n\nlabel\nstr\na human-readable label for the result\nNone\n\n\nvalues\narray\nprepopulate the Result with these values\nNone\n\n\ntimevec\narray\nan array of time points\nNone\n\n\nlow\narray\nvalues for the lower bound\nNone\n\n\nhigh\narray\nvalues for the upper bound\nNone\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\n\nIn most cases, ss.Result behaves exactly like np.array(), except with the additional fields listed above. To see everything contained in a result, you can use result.disp().\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfull_label\nReturn the full label of the result: : , e.g. “HIV: New infections”\n\n\nhas_dates\nCheck whether the time vector uses dates (rather than numbers)\n\n\nkey\nReturn the unique key of the result: ., e.g. “hiv.new_infections”\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_df\nMake a copy of the result with new values from a dataframe\n\n\ninit_values\nHandle values\n\n\nplot\nPlot a single result; kwargs are interpreted as plot_kw\n\n\nresample\nResample the result, e.g. from days to years. Leverages the pandas resample method.\n\n\nto_df\nConvert to a dataframe with timevec, value, low, and high columns\n\n\nto_series\nConvert to a series with timevec as the index and value as the data\n\n\nupdate\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Result.from_df(df)\nMake a copy of the result with new values from a dataframe\n\n\n\nresults.Result.init_values(values=None, dtype=None, shape=None, force=False)\nHandle values\n\n\n\nresults.Result.plot(\n    fig=None,\n    ax=None,\n    fig_kw=None,\n    plot_kw=None,\n    fill_kw=None,\n    **kwargs,\n)\nPlot a single result; kwargs are interpreted as plot_kw\n\n\n\nresults.Result.resample(\n    new_unit='year',\n    summarize_by=None,\n    col_names='vlh',\n    die=False,\n    output_form='series',\n    use_years=False,\n    sep='_',\n)\nResample the result, e.g. from days to years. Leverages the pandas resample method. Accepts all the Starsim units, plus the Pandas ones documented here: https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_unit\nstr\nthe new unit to resample to, e.g. ‘year’, ‘month’, ‘week’, ‘day’, ‘1W’, ‘2M’, etc.\n'year'\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\ncol_names\nstr\nwhether to rename the columns with the name of the result\n'vlh'\n\n\ndie\nbool\nwhether to raise an error if the summarization method cannot be determined\nFalse\n\n\noutput_form\nstr\n‘series’, ‘dataframe’, or ‘result’\n'series'\n\n\nuse_years\nbool\nwhether to use years as the unit of time\nFalse\n\n\n\n\n\n\n\nresults.Result.to_df(\n    sep='_',\n    col_names='vlh',\n    resample=None,\n    set_date_index=False,\n    **kwargs,\n)\nConvert to a dataframe with timevec, value, low, and high columns\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsep\nstr\nseparator for the column names\n'_'\n\n\ncol_names\nstr or None\nif None, uses the name of the result. Default is ‘vlh’ which uses value, low, high\n'vlh'\n\n\nset_date_index\nbool\nif True, use the timevec as the index\nFalse\n\n\nresample\nstr\nif provided, resample the data to this frequency\nNone\n\n\nkwargs\n\npassed to the resample method\n{}\n\n\n\n\n\n\n\nresults.Result.to_series(set_name=False, resample=None, sep='_', **kwargs)\nConvert to a series with timevec as the index and value as the data Args: set_name (bool): whether to set the name of the series to the name of the result resample (str): if provided, resample the data to this frequency kwargs: passed to the resample method\n\n\n\nresults.Result.update(*args, **kwargs)\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Results(self, module, *args, strict=True, **kwargs)\nContainer for storing results\n\n\n\n\n\nName\nDescription\n\n\n\n\nall_results\nIterator over all results, skipping any nested values\n\n\nall_results_dict\nDictionary of all results, skipping any nested values\n\n\nequal_len\nCheck if all results are equal length\n\n\nis_msim\nCheck if this is a MultiSim\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nappend\nThis is activated by adding as well, e.g. results += result\n\n\nflatten\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\nplot\nPlot all the results\n\n\nto_df\nMerge all results dataframes into one\n\n\n\n\n\nresults.Results.append(arg, key=None)\nThis is activated by adding as well, e.g. results += result\n\n\n\nresults.Results.flatten(sep='_', only_results=True, keep_case=False, **kwargs)\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\n\nresults.Results.plot(style='fancy', fig_kw=None, plot_kw=None)\nPlot all the results\n\n\n\nresults.Results.to_df(sep='_', descend=False, **kwargs)\nMerge all results dataframes into one Args: sep (str): separator for the column names descend (bool): whether to descend into nested results kwargs: passed to the to_df method, can include instructions for summarizing results by time",
    "crumbs": [
      "**Utilities**",
      "results"
    ]
  },
  {
    "objectID": "api/people.html",
    "href": "api/people.html",
    "title": "people",
    "section": "",
    "text": "people\nDefines the People class and functions associated with making people\n\n\n\n\n\nName\nDescription\n\n\n\n\nPeople\nA class to perform all the operations on the people\n\n\nPerson\nA simple class to hold all attributes of a person\n\n\n\n\n\npeople.People(self, n_agents, age_data=None, extra_states=None)\nA class to perform all the operations on the people This class is usually created automatically by the sim. The only required input argument is the population size, but typically the full parameters dictionary will get passed instead since it will be needed before the People object is initialized.\nNote that this class handles the mechanics of updating the actual people, as well as the additional housekeeping methods (saving, loading, exporting, etc.).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\ndict\nthe sim parameters, e.g. sim.pars – alternatively, if a number, interpreted as n_agents\nrequired\n\n\nage_data\ndataframe\na dataframe of years and population sizes, if available\nNone\n\n\nextra_states\nlist\nnon-default states to initialize\nNone\n\n\n\nExamples: ppl = ss.People(2000)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndead\nDead boolean\n\n\nmale\nMale boolean\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_module\nAdd a Module to the People instance\n\n\nget_age_dist\nReturn an age distribution based on provided data\n\n\ngrow\nIncrease the number of agents\n\n\ninit_vals\nPopulate states with initial values, the final step of initialization\n\n\nlink_sim\nInitialization\n\n\nperson\nGet all the properties for a single person.\n\n\nplot_ages\nPlot the age distribution\n\n\nremove_dead\nRemove dead agents\n\n\nrequest_death\nExternal-facing function to request an agent die at the current timestep\n\n\nscale_flows\nReturn the scaled versions of the flows – replacement for len(inds)\n\n\nstep_die\nCarry out any deaths that took place this timestep\n\n\nupdate_post\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.People.add_module(module, force=False)\nAdd a Module to the People instance\nThis method is used to add a module to the People. It will register any module states with this people instance for dynamic resizing, and expose the states contained in the module to the user via People.states.&lt;module_name&gt;.&lt;state_name&gt;\nThe entries created below make it possible to do sim.people.hiv.susceptible or sim.people.states['hiv.susceptible'] and have both of them work\n\n\n\npeople.People.get_age_dist(age_data)\nReturn an age distribution based on provided data\nThe data should be provided in the form of either an Nx2 array, a pandas series with age as the index and counts/probability as the value, or a pandas DataFrame with “age” and “value” as columns. Each of these should look like e.g.:\nage      value\n0      220.548\n1      206.188\n2      195.792\n3      187.442\nThe ages will be interpreted as lower bin edges. An upper bin edge will automatically be added based on the final age plus the difference of the last two bins. To explicitly control the width of the upper age bin, add an extra entry to the age_data with a value of 0 and an age value corresponding to the desired upper age bound.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nage_data\n\nAn array/series/dataframe with an index corresponding to age values, and a value corresponding to histogram counts or relative proportions. A distribution will be estimated based on the histogram. The histogram will be assumed to correspond to probability densitiy if the sum of the histogram values is equal to 1, otherwise it will be assumed to correspond to counts.\nrequired\n\n\n\nNote: age_data can also be provided as a string\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn ss.Dist instance that returns an age for newly created agents\n\n\n\n\n\n\n\npeople.People.grow(n=None, new_slots=None)\nIncrease the number of agents\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\n\nInteger number of agents to add\nNone\n\n\nnew_slots\n\nOptionally specify the slots to assign for the new agents. Otherwise, it will default to the new UIDs\nNone\n\n\n\n\n\n\n\npeople.People.init_vals()\nPopulate states with initial values, the final step of initialization\n\n\n\npeople.People.link_sim(sim)\nInitialization\n\n\n\npeople.People.person(ind)\nGet all the properties for a single person.\nExample:\nsim = ss.Sim(diseases='sir', networks='random', n_agents=100).run()\nprint(sim.people.person(5)) # The 5th agent in the simulation\n\n\n\npeople.People.plot_ages()\nPlot the age distribution\n\n\n\npeople.People.remove_dead()\nRemove dead agents\n\n\n\npeople.People.request_death(uids)\nExternal-facing function to request an agent die at the current timestep\nIn general, users should not directly interact with People.ti_dead to minimize interactions between modules (e.g., if a module requesting a future death, overwrites death due to a different module taking place at the current timestep).\nModules that have a future time of death (e.g., due to disease duration) should keep track of that internally. When the module is ready to cause the agent to die, it should call this method, and can update its own results for the cause of death. This way, if multiple modules request death on the same day, they can each record a death due to their own cause.\nThe actual deaths are resolved after modules have all run, but before analyzers. That way, regardless of whether removing dead agents is enabled or not, analyzers will be able to see and record outcomes for agents that died this timestep.\nWARNING - this function allows multiple modules to each independently carry out and record state changes associated with death. It is therefore important that they can guarantee that after requesting death, the death is guaranteed to occur.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\n\nAgent IDs to request deaths for\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nUIDs of agents that have been scheduled to die on this timestep\n\n\n\n\n\n\n\npeople.People.scale_flows(inds)\nReturn the scaled versions of the flows – replacement for len(inds) followed by scale factor multiplication\n\n\n\npeople.People.step_die()\nCarry out any deaths that took place this timestep\n\n\n\npeople.People.update_post()\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.Person()\nA simple class to hold all attributes of a person\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_df\nConvert to a dataframe\n\n\n\n\n\npeople.Person.to_df()\nConvert to a dataframe",
    "crumbs": [
      "**Basics**",
      "people"
    ]
  },
  {
    "objectID": "api/people.html#classes",
    "href": "api/people.html#classes",
    "title": "people",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nPeople\nA class to perform all the operations on the people\n\n\nPerson\nA simple class to hold all attributes of a person\n\n\n\n\n\npeople.People(self, n_agents, age_data=None, extra_states=None)\nA class to perform all the operations on the people This class is usually created automatically by the sim. The only required input argument is the population size, but typically the full parameters dictionary will get passed instead since it will be needed before the People object is initialized.\nNote that this class handles the mechanics of updating the actual people, as well as the additional housekeeping methods (saving, loading, exporting, etc.).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\ndict\nthe sim parameters, e.g. sim.pars – alternatively, if a number, interpreted as n_agents\nrequired\n\n\nage_data\ndataframe\na dataframe of years and population sizes, if available\nNone\n\n\nextra_states\nlist\nnon-default states to initialize\nNone\n\n\n\nExamples: ppl = ss.People(2000)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndead\nDead boolean\n\n\nmale\nMale boolean\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_module\nAdd a Module to the People instance\n\n\nget_age_dist\nReturn an age distribution based on provided data\n\n\ngrow\nIncrease the number of agents\n\n\ninit_vals\nPopulate states with initial values, the final step of initialization\n\n\nlink_sim\nInitialization\n\n\nperson\nGet all the properties for a single person.\n\n\nplot_ages\nPlot the age distribution\n\n\nremove_dead\nRemove dead agents\n\n\nrequest_death\nExternal-facing function to request an agent die at the current timestep\n\n\nscale_flows\nReturn the scaled versions of the flows – replacement for len(inds)\n\n\nstep_die\nCarry out any deaths that took place this timestep\n\n\nupdate_post\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.People.add_module(module, force=False)\nAdd a Module to the People instance\nThis method is used to add a module to the People. It will register any module states with this people instance for dynamic resizing, and expose the states contained in the module to the user via People.states.&lt;module_name&gt;.&lt;state_name&gt;\nThe entries created below make it possible to do sim.people.hiv.susceptible or sim.people.states['hiv.susceptible'] and have both of them work\n\n\n\npeople.People.get_age_dist(age_data)\nReturn an age distribution based on provided data\nThe data should be provided in the form of either an Nx2 array, a pandas series with age as the index and counts/probability as the value, or a pandas DataFrame with “age” and “value” as columns. Each of these should look like e.g.:\nage      value\n0      220.548\n1      206.188\n2      195.792\n3      187.442\nThe ages will be interpreted as lower bin edges. An upper bin edge will automatically be added based on the final age plus the difference of the last two bins. To explicitly control the width of the upper age bin, add an extra entry to the age_data with a value of 0 and an age value corresponding to the desired upper age bound.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nage_data\n\nAn array/series/dataframe with an index corresponding to age values, and a value corresponding to histogram counts or relative proportions. A distribution will be estimated based on the histogram. The histogram will be assumed to correspond to probability densitiy if the sum of the histogram values is equal to 1, otherwise it will be assumed to correspond to counts.\nrequired\n\n\n\nNote: age_data can also be provided as a string\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn ss.Dist instance that returns an age for newly created agents\n\n\n\n\n\n\n\npeople.People.grow(n=None, new_slots=None)\nIncrease the number of agents\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\n\nInteger number of agents to add\nNone\n\n\nnew_slots\n\nOptionally specify the slots to assign for the new agents. Otherwise, it will default to the new UIDs\nNone\n\n\n\n\n\n\n\npeople.People.init_vals()\nPopulate states with initial values, the final step of initialization\n\n\n\npeople.People.link_sim(sim)\nInitialization\n\n\n\npeople.People.person(ind)\nGet all the properties for a single person.\nExample:\nsim = ss.Sim(diseases='sir', networks='random', n_agents=100).run()\nprint(sim.people.person(5)) # The 5th agent in the simulation\n\n\n\npeople.People.plot_ages()\nPlot the age distribution\n\n\n\npeople.People.remove_dead()\nRemove dead agents\n\n\n\npeople.People.request_death(uids)\nExternal-facing function to request an agent die at the current timestep\nIn general, users should not directly interact with People.ti_dead to minimize interactions between modules (e.g., if a module requesting a future death, overwrites death due to a different module taking place at the current timestep).\nModules that have a future time of death (e.g., due to disease duration) should keep track of that internally. When the module is ready to cause the agent to die, it should call this method, and can update its own results for the cause of death. This way, if multiple modules request death on the same day, they can each record a death due to their own cause.\nThe actual deaths are resolved after modules have all run, but before analyzers. That way, regardless of whether removing dead agents is enabled or not, analyzers will be able to see and record outcomes for agents that died this timestep.\nWARNING - this function allows multiple modules to each independently carry out and record state changes associated with death. It is therefore important that they can guarantee that after requesting death, the death is guaranteed to occur.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\n\nAgent IDs to request deaths for\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nUIDs of agents that have been scheduled to die on this timestep\n\n\n\n\n\n\n\npeople.People.scale_flows(inds)\nReturn the scaled versions of the flows – replacement for len(inds) followed by scale factor multiplication\n\n\n\npeople.People.step_die()\nCarry out any deaths that took place this timestep\n\n\n\npeople.People.update_post()\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.Person()\nA simple class to hold all attributes of a person\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_df\nConvert to a dataframe\n\n\n\n\n\npeople.Person.to_df()\nConvert to a dataframe",
    "crumbs": [
      "**Basics**",
      "people"
    ]
  },
  {
    "objectID": "api/disease.html",
    "href": "api/disease.html",
    "title": "disease",
    "section": "",
    "text": "disease\nBase classes for diseases\n\n\n\n\n\nName\nDescription\n\n\n\n\nDisease\nBase module class for diseases\n\n\nInfection\nBase class for infectious diseases used in Starsim\n\n\nInfectionLog\nRecord infections\n\n\n\n\n\ndisease.Disease(self, **kwargs)\nBase module class for diseases\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_pre\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\ninit_results\nInitialize results\n\n\nset_prognoses\nSet prognoses upon infection/acquisition\n\n\nstep\nHandle the main disease updates, e.g. add new cases\n\n\nstep_die\nCarry out state changes upon death\n\n\nstep_state\nCarry out updates at the start of the timestep (prior to transmission);\n\n\nupdate_results\nUpdate results\n\n\n\n\n\ndisease.Disease.init_pre(sim)\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\n\ndisease.Disease.init_results()\nInitialize results\nBy default, diseases all report on counts for any explicitly defined “States”, e.g. if a disease contains a boolean state ‘susceptible’ it will automatically contain a Result for ‘n_susceptible’.\n\n\n\ndisease.Disease.set_prognoses(uids, sources=None)\nSet prognoses upon infection/acquisition\nThis function assigns state values upon infection or acquisition of the disease. It would normally be called somewhere towards the end of Disease.make_new_cases(). Infections will optionally be added to the log as part of this operation if logging is enabled (in the Disease parameters)\nThe sources are relevant for infectious diseases, but would be left as None for NCDs.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nUIDs for agents to assign disease prongoses to\nrequired\n\n\nsources\narray\nOptionally specify the infecting agent\nNone\n\n\n\n\n\n\n\ndisease.Disease.step()\nHandle the main disease updates, e.g. add new cases\nThis method is agnostic as to the mechanism by which new cases occur. This could be through transmission (parametrized in different ways, which may or may not use the contact networks) or it may be based on risk factors/seeding, as may be the case for non-communicable diseases.\nIt is expected that this method will internally call Disease.set_prognoses() at some point.\n\n\n\ndisease.Disease.step_die(uids)\nCarry out state changes upon death\nThis function is triggered after deaths are resolved, and before analyzers are run. See the SIR example model for a typical use case - deaths are requested as an autonomous update, to take effect after transmission on the same timestep. State changes that occur upon death (e.g., clearing an infected flag) are executed in this function. That also allows an intervention to avert a death scheduled on the same timestep, without having to undo any state changes that have already been applied (because they only run via this function if the death actually occurs).\nUnlike other methods during the integration loop, this method is not called directly by the sim; instead, it is called by people.step_die(), which reconciles the UIDs of the agents who will die.\nDepending on the module and the results it produces, it may or may not be necessary to implement this.\n\n\n\ndisease.Disease.step_state()\nCarry out updates at the start of the timestep (prior to transmission); these are typically state changes\n\n\n\ndisease.Disease.update_results()\nUpdate results\nThis function is executed after transmission in all modules has been resolved. This allows result updates at this point to capture outcomes dependent on multiple modules, where relevant.\n\n\n\n\n\ndisease.Infection(self, **kwargs)\nBase class for infectious diseases used in Starsim\nThis class contains specializations for infectious transmission (i.e., implements network-based transmission with directional beta values) and defines attributes that connectors operate on to capture co-infection\n\n\n\n\n\nName\nDescription\n\n\n\n\ninfectious\nGenerally defined as an alias for infected, although these may differ in some diseases.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCompute the probability of a-&gt;b transmission\n\n\ninfect\nDetermine who gets infected on this timestep via transmission on the network\n\n\ninit_post\nSet initial values for states. This could involve passing in a full set of initial conditions,\n\n\ninit_results\nInitialize results\n\n\nstep\nPerform key infection updates, including infection and setting prognoses\n\n\nvalidate_beta\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndisease.Infection.compute_transmission(\n    src,\n    trg,\n    rel_trans,\n    rel_sus,\n    beta_per_dt,\n    randvals,\n)\nCompute the probability of a-&gt;b transmission\n\n\n\ndisease.Infection.infect()\nDetermine who gets infected on this timestep via transmission on the network\n\n\n\ndisease.Infection.init_post()\nSet initial values for states. This could involve passing in a full set of initial conditions, or using init_prev, or other. Note that this is different to initialization of the Arr objects i.e., creating their dynamic array, linking them to a People instance. That should have already taken place by the time this method is called.\n\n\n\ndisease.Infection.init_results()\nInitialize results\n\n\n\ndisease.Infection.step()\nPerform key infection updates, including infection and setting prognoses\n\n\n\ndisease.Infection.validate_beta(run_checks=False)\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndisease.InfectionLog()\nRecord infections\nThe infection log records transmission events and optionally other data associated with each transmission. Basic functionality is to track transmission with\n\n\n\nDisease.log.append(source, target, t)\n\n\n\nSeed infections can be recorded with a source of None, although all infections should have a target and a time. Other data can be captured in the log, either at the time of creation, or later on. For example\n\n\n\nDisease.log.append(source, target, t, network=‘msm’)\n\n\n\ncould be used by a module to track the network in which transmission took place. Modules can optionally add per-infection outcomes later as well, for example\n\n\n\nDisease.log.add_data(source, t_dead=2024.25)\n\n\n\nThis would be equivalent to having specified the data at the original time the log entry was created - however, it is more useful for tracking events that may or may not occur after the infection and could be modified by interventions (e.g., tracking diagnosis, treatment, notification etc.)\nA table of outcomes can be returned using InfectionLog.line_list()\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_data\nRecord extra infection data\n\n\nline_list\nReturn a tabular representation of the log\n\n\n\n\n\ndisease.InfectionLog.add_data(uids, **kwargs)\nRecord extra infection data\nThis method can be used to add data to an existing transmission event. The most recent transmission event will be used\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nThe UIDs of the target nodes (the agents that were infected)\nrequired\n\n\nkwargs\ndict\nRemaining arguments are stored as edge data\n{}\n\n\n\n\n\n\n\ndisease.InfectionLog.line_list()\nReturn a tabular representation of the log\nThis function returns a dataframe containing columns for all quantities recorded in the log. Note that the log will contain NaN for quantities that are defined for some edges and not others (and which are missing for a particular entry)",
    "crumbs": [
      "**Modules**",
      "disease"
    ]
  },
  {
    "objectID": "api/disease.html#classes",
    "href": "api/disease.html#classes",
    "title": "disease",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDisease\nBase module class for diseases\n\n\nInfection\nBase class for infectious diseases used in Starsim\n\n\nInfectionLog\nRecord infections\n\n\n\n\n\ndisease.Disease(self, **kwargs)\nBase module class for diseases\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_pre\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\ninit_results\nInitialize results\n\n\nset_prognoses\nSet prognoses upon infection/acquisition\n\n\nstep\nHandle the main disease updates, e.g. add new cases\n\n\nstep_die\nCarry out state changes upon death\n\n\nstep_state\nCarry out updates at the start of the timestep (prior to transmission);\n\n\nupdate_results\nUpdate results\n\n\n\n\n\ndisease.Disease.init_pre(sim)\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\n\ndisease.Disease.init_results()\nInitialize results\nBy default, diseases all report on counts for any explicitly defined “States”, e.g. if a disease contains a boolean state ‘susceptible’ it will automatically contain a Result for ‘n_susceptible’.\n\n\n\ndisease.Disease.set_prognoses(uids, sources=None)\nSet prognoses upon infection/acquisition\nThis function assigns state values upon infection or acquisition of the disease. It would normally be called somewhere towards the end of Disease.make_new_cases(). Infections will optionally be added to the log as part of this operation if logging is enabled (in the Disease parameters)\nThe sources are relevant for infectious diseases, but would be left as None for NCDs.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nUIDs for agents to assign disease prongoses to\nrequired\n\n\nsources\narray\nOptionally specify the infecting agent\nNone\n\n\n\n\n\n\n\ndisease.Disease.step()\nHandle the main disease updates, e.g. add new cases\nThis method is agnostic as to the mechanism by which new cases occur. This could be through transmission (parametrized in different ways, which may or may not use the contact networks) or it may be based on risk factors/seeding, as may be the case for non-communicable diseases.\nIt is expected that this method will internally call Disease.set_prognoses() at some point.\n\n\n\ndisease.Disease.step_die(uids)\nCarry out state changes upon death\nThis function is triggered after deaths are resolved, and before analyzers are run. See the SIR example model for a typical use case - deaths are requested as an autonomous update, to take effect after transmission on the same timestep. State changes that occur upon death (e.g., clearing an infected flag) are executed in this function. That also allows an intervention to avert a death scheduled on the same timestep, without having to undo any state changes that have already been applied (because they only run via this function if the death actually occurs).\nUnlike other methods during the integration loop, this method is not called directly by the sim; instead, it is called by people.step_die(), which reconciles the UIDs of the agents who will die.\nDepending on the module and the results it produces, it may or may not be necessary to implement this.\n\n\n\ndisease.Disease.step_state()\nCarry out updates at the start of the timestep (prior to transmission); these are typically state changes\n\n\n\ndisease.Disease.update_results()\nUpdate results\nThis function is executed after transmission in all modules has been resolved. This allows result updates at this point to capture outcomes dependent on multiple modules, where relevant.\n\n\n\n\n\ndisease.Infection(self, **kwargs)\nBase class for infectious diseases used in Starsim\nThis class contains specializations for infectious transmission (i.e., implements network-based transmission with directional beta values) and defines attributes that connectors operate on to capture co-infection\n\n\n\n\n\nName\nDescription\n\n\n\n\ninfectious\nGenerally defined as an alias for infected, although these may differ in some diseases.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCompute the probability of a-&gt;b transmission\n\n\ninfect\nDetermine who gets infected on this timestep via transmission on the network\n\n\ninit_post\nSet initial values for states. This could involve passing in a full set of initial conditions,\n\n\ninit_results\nInitialize results\n\n\nstep\nPerform key infection updates, including infection and setting prognoses\n\n\nvalidate_beta\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndisease.Infection.compute_transmission(\n    src,\n    trg,\n    rel_trans,\n    rel_sus,\n    beta_per_dt,\n    randvals,\n)\nCompute the probability of a-&gt;b transmission\n\n\n\ndisease.Infection.infect()\nDetermine who gets infected on this timestep via transmission on the network\n\n\n\ndisease.Infection.init_post()\nSet initial values for states. This could involve passing in a full set of initial conditions, or using init_prev, or other. Note that this is different to initialization of the Arr objects i.e., creating their dynamic array, linking them to a People instance. That should have already taken place by the time this method is called.\n\n\n\ndisease.Infection.init_results()\nInitialize results\n\n\n\ndisease.Infection.step()\nPerform key infection updates, including infection and setting prognoses\n\n\n\ndisease.Infection.validate_beta(run_checks=False)\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndisease.InfectionLog()\nRecord infections\nThe infection log records transmission events and optionally other data associated with each transmission. Basic functionality is to track transmission with\n\n\n\nDisease.log.append(source, target, t)\n\n\n\nSeed infections can be recorded with a source of None, although all infections should have a target and a time. Other data can be captured in the log, either at the time of creation, or later on. For example\n\n\n\nDisease.log.append(source, target, t, network=‘msm’)\n\n\n\ncould be used by a module to track the network in which transmission took place. Modules can optionally add per-infection outcomes later as well, for example\n\n\n\nDisease.log.add_data(source, t_dead=2024.25)\n\n\n\nThis would be equivalent to having specified the data at the original time the log entry was created - however, it is more useful for tracking events that may or may not occur after the infection and could be modified by interventions (e.g., tracking diagnosis, treatment, notification etc.)\nA table of outcomes can be returned using InfectionLog.line_list()\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_data\nRecord extra infection data\n\n\nline_list\nReturn a tabular representation of the log\n\n\n\n\n\ndisease.InfectionLog.add_data(uids, **kwargs)\nRecord extra infection data\nThis method can be used to add data to an existing transmission event. The most recent transmission event will be used\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nThe UIDs of the target nodes (the agents that were infected)\nrequired\n\n\nkwargs\ndict\nRemaining arguments are stored as edge data\n{}\n\n\n\n\n\n\n\ndisease.InfectionLog.line_list()\nReturn a tabular representation of the log\nThis function returns a dataframe containing columns for all quantities recorded in the log. Note that the log will contain NaN for quantities that are defined for some edges and not others (and which are missing for a particular entry)",
    "crumbs": [
      "**Modules**",
      "disease"
    ]
  },
  {
    "objectID": "api/interventions.html",
    "href": "api/interventions.html",
    "title": "interventions",
    "section": "",
    "text": "interventions\nDefine interventions\n\n\n\n\n\nName\nDescription\n\n\n\n\nBaseScreening\nBase class for screening.\n\n\nBaseTest\nBase class for screening and triage.\n\n\nBaseTreatment\nBase treatment class.\n\n\nBaseTriage\nBase class for triage.\n\n\nBaseVaccination\nBase vaccination class for determining who will receive a vaccine.\n\n\nCampaignDelivery\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\nIntervention\nBase class for interventions.\n\n\nRoutineDelivery\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\ncampaign_screening\nCampaign screening - an instance of base screening combined with campaign delivery.\n\n\ncampaign_triage\nCampaign triage - an instance of base triage combined with campaign delivery.\n\n\ncampaign_vx\nCampaign vaccination - an instance of base vaccination combined with campaign delivery.\n\n\nroutine_screening\nRoutine screening - an instance of base screening combined with routine delivery.\n\n\nroutine_triage\nRoutine triage - an instance of base triage combined with routine delivery.\n\n\nroutine_vx\nRoutine vaccination - an instance of base vaccination combined with routine delivery.\n\n\ntreat_num\nTreat a fixed number of people each timestep.\n\n\n\n\n\ninterventions.BaseScreening(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase class for screening.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nCheck eligibility\n\n\nstep\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseScreening.check_eligibility()\nCheck eligibility\n\n\n\ninterventions.BaseScreening.step()\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase class for screening and triage.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct\n(Product)\nthe diagnostic to use\nNone\n\n\nprob\n(float/arr)\nannual probability of eligible people receiving the diagnostic\nNone\n\n\neligibility\n(inds/callable)\nindices OR callable that returns inds\nNone\n\n\nkwargs\n(dict)\npassed to Intervention()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeliver\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest.deliver()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTreatment(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase treatment class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct\n(str/Product)\nthe treatment product to use\nNone\n\n\nprob\n(float/arr)\nprobability of treatment aong those eligible\nNone\n\n\neligibility\n(inds/callable)\nindices OR callable that returns inds\nNone\n\n\nkwargs\n(dict)\npassed to Intervention()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_accept_inds\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\nget_candidates\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\nstep\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTreatment.get_accept_inds()\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\n\ninterventions.BaseTreatment.get_candidates()\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\n\ninterventions.BaseTreatment.step()\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTriage(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase class for triage.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\ninterventions.BaseVaccination(\n    self,\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nBase vaccination class for determining who will receive a vaccine.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct\n(str/Product)\nthe vaccine to use\nNone\n\n\nprob\n(float/arr)\nannual probability of eligible population getting vaccinated\nNone\n\n\nlabel\n(str)\nthe name of vaccination strategy\nNone\n\n\nkwargs\n(dict)\npassed to Intervention()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseVaccination.step()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.CampaignDelivery(\n    self,\n    *args,\n    years=None,\n    interpolate=None,\n    prob=None,\n    **kwargs,\n)\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\n\ninterventions.Intervention(self, *args, eligibility=None, **kwargs)\nBase class for interventions.\nThe key method of the intervention is step(), which is called with the sim on each timestep.\n\n\n\n\n\nName\nDescription\n\n\n\n\nhas_product\nCheck if the intervention has a product\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.Intervention.check_eligibility()\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.RoutineDelivery(\n    self,\n    *args,\n    years=None,\n    start_year=None,\n    end_year=None,\n    prob=None,\n    annual_prob=True,\n    **kwargs,\n)\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\n\ninterventions.campaign_screening(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign screening - an instance of base screening combined with campaign delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.campaign_screening(product=my_prod, prob=0.2, years=2030) # Screen 20% of the eligible population in 2020\nscreen2 = ss.campaign_screening(product=my_prod, prob=0.02, years=[2025,2030]) # Screen 20% of the eligible population in 2025 and again in 2030\n\n\n\ninterventions.campaign_triage(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign triage - an instance of base triage combined with campaign delivery. See base classes for a description of input arguments.\nExamples: # Example: In 2030, triage all positive screens into confirmatory testing screened_pos = lambda sim: sim.interventions.screening.outcomes[‘positive’] triage1 = ss.campaign_triage(product=my_triage, eligibility=screen_pos, prob=0.9, years=2030)\n\n\n\ninterventions.campaign_vx(\n    self,\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nCampaign vaccination - an instance of base vaccination combined with campaign delivery. See base classes for a description of input arguments.\n\n\n\ninterventions.routine_screening(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nRoutine screening - an instance of base screening combined with routine delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.routine_screening(product=my_prod, prob=0.02) # Screen 2% of the eligible population every year\nscreen2 = ss.routine_screening(product=my_prod, prob=0.02, start_year=2020) # Screen 2% every year starting in 2020\nscreen3 = ss.routine_screening(product=my_prod, prob=np.linspace(0.005,0.025,5), years=np.arange(2020,2025)) # Scale up screening over 5 years starting in 2020\n\n\n\ninterventions.routine_triage(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nRoutine triage - an instance of base triage combined with routine delivery. See base classes for a description of input arguments.\nExample: # Example: Triage positive screens into confirmatory testing screened_pos = lambda sim: sim.interventions.screening.outcomes[‘positive’] triage = ss.routine_triage(product=my_triage, eligibility=screen_pos, prob=0.9, start_year=2030)\n\n\n\ninterventions.routine_vx(\n    self,\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nRoutine vaccination - an instance of base vaccination combined with routine delivery. See base classes for a description of input arguments.\n\n\n\ninterventions.treat_num(self, max_capacity=None, **kwargs)\nTreat a fixed number of people each timestep.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_capacity\nint\nmaximum number who can be treated each timestep\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_to_queue\nAdd people who are willing to accept treatment to the queue\n\n\nget_candidates\nGet the indices of people who are candidates for treatment\n\n\nstep\nApply treatment. On each timestep, this method will add eligible people who are willing to accept treatment to a\n\n\n\n\n\ninterventions.treat_num.add_to_queue()\nAdd people who are willing to accept treatment to the queue\n\n\n\ninterventions.treat_num.get_candidates()\nGet the indices of people who are candidates for treatment\n\n\n\ninterventions.treat_num.step()\nApply treatment. On each timestep, this method will add eligible people who are willing to accept treatment to a queue, and then will treat as many people in the queue as there is capacity for.",
    "crumbs": [
      "**Modules**",
      "interventions"
    ]
  },
  {
    "objectID": "api/interventions.html#classes",
    "href": "api/interventions.html#classes",
    "title": "interventions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBaseScreening\nBase class for screening.\n\n\nBaseTest\nBase class for screening and triage.\n\n\nBaseTreatment\nBase treatment class.\n\n\nBaseTriage\nBase class for triage.\n\n\nBaseVaccination\nBase vaccination class for determining who will receive a vaccine.\n\n\nCampaignDelivery\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\nIntervention\nBase class for interventions.\n\n\nRoutineDelivery\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\ncampaign_screening\nCampaign screening - an instance of base screening combined with campaign delivery.\n\n\ncampaign_triage\nCampaign triage - an instance of base triage combined with campaign delivery.\n\n\ncampaign_vx\nCampaign vaccination - an instance of base vaccination combined with campaign delivery.\n\n\nroutine_screening\nRoutine screening - an instance of base screening combined with routine delivery.\n\n\nroutine_triage\nRoutine triage - an instance of base triage combined with routine delivery.\n\n\nroutine_vx\nRoutine vaccination - an instance of base vaccination combined with routine delivery.\n\n\ntreat_num\nTreat a fixed number of people each timestep.\n\n\n\n\n\ninterventions.BaseScreening(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase class for screening.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nCheck eligibility\n\n\nstep\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseScreening.check_eligibility()\nCheck eligibility\n\n\n\ninterventions.BaseScreening.step()\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase class for screening and triage.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct\n(Product)\nthe diagnostic to use\nNone\n\n\nprob\n(float/arr)\nannual probability of eligible people receiving the diagnostic\nNone\n\n\neligibility\n(inds/callable)\nindices OR callable that returns inds\nNone\n\n\nkwargs\n(dict)\npassed to Intervention()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeliver\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest.deliver()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTreatment(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase treatment class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct\n(str/Product)\nthe treatment product to use\nNone\n\n\nprob\n(float/arr)\nprobability of treatment aong those eligible\nNone\n\n\neligibility\n(inds/callable)\nindices OR callable that returns inds\nNone\n\n\nkwargs\n(dict)\npassed to Intervention()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_accept_inds\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\nget_candidates\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\nstep\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTreatment.get_accept_inds()\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\n\ninterventions.BaseTreatment.get_candidates()\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\n\ninterventions.BaseTreatment.step()\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTriage(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nBase class for triage.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\ninterventions.BaseVaccination(\n    self,\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nBase vaccination class for determining who will receive a vaccine.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct\n(str/Product)\nthe vaccine to use\nNone\n\n\nprob\n(float/arr)\nannual probability of eligible population getting vaccinated\nNone\n\n\nlabel\n(str)\nthe name of vaccination strategy\nNone\n\n\nkwargs\n(dict)\npassed to Intervention()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseVaccination.step()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.CampaignDelivery(\n    self,\n    *args,\n    years=None,\n    interpolate=None,\n    prob=None,\n    **kwargs,\n)\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\n\ninterventions.Intervention(self, *args, eligibility=None, **kwargs)\nBase class for interventions.\nThe key method of the intervention is step(), which is called with the sim on each timestep.\n\n\n\n\n\nName\nDescription\n\n\n\n\nhas_product\nCheck if the intervention has a product\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.Intervention.check_eligibility()\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.RoutineDelivery(\n    self,\n    *args,\n    years=None,\n    start_year=None,\n    end_year=None,\n    prob=None,\n    annual_prob=True,\n    **kwargs,\n)\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\n\ninterventions.campaign_screening(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign screening - an instance of base screening combined with campaign delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.campaign_screening(product=my_prod, prob=0.2, years=2030) # Screen 20% of the eligible population in 2020\nscreen2 = ss.campaign_screening(product=my_prod, prob=0.02, years=[2025,2030]) # Screen 20% of the eligible population in 2025 and again in 2030\n\n\n\ninterventions.campaign_triage(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign triage - an instance of base triage combined with campaign delivery. See base classes for a description of input arguments.\nExamples: # Example: In 2030, triage all positive screens into confirmatory testing screened_pos = lambda sim: sim.interventions.screening.outcomes[‘positive’] triage1 = ss.campaign_triage(product=my_triage, eligibility=screen_pos, prob=0.9, years=2030)\n\n\n\ninterventions.campaign_vx(\n    self,\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nCampaign vaccination - an instance of base vaccination combined with campaign delivery. See base classes for a description of input arguments.\n\n\n\ninterventions.routine_screening(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nRoutine screening - an instance of base screening combined with routine delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.routine_screening(product=my_prod, prob=0.02) # Screen 2% of the eligible population every year\nscreen2 = ss.routine_screening(product=my_prod, prob=0.02, start_year=2020) # Screen 2% every year starting in 2020\nscreen3 = ss.routine_screening(product=my_prod, prob=np.linspace(0.005,0.025,5), years=np.arange(2020,2025)) # Scale up screening over 5 years starting in 2020\n\n\n\ninterventions.routine_triage(\n    self,\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nRoutine triage - an instance of base triage combined with routine delivery. See base classes for a description of input arguments.\nExample: # Example: Triage positive screens into confirmatory testing screened_pos = lambda sim: sim.interventions.screening.outcomes[‘positive’] triage = ss.routine_triage(product=my_triage, eligibility=screen_pos, prob=0.9, start_year=2030)\n\n\n\ninterventions.routine_vx(\n    self,\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nRoutine vaccination - an instance of base vaccination combined with routine delivery. See base classes for a description of input arguments.\n\n\n\ninterventions.treat_num(self, max_capacity=None, **kwargs)\nTreat a fixed number of people each timestep.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_capacity\nint\nmaximum number who can be treated each timestep\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_to_queue\nAdd people who are willing to accept treatment to the queue\n\n\nget_candidates\nGet the indices of people who are candidates for treatment\n\n\nstep\nApply treatment. On each timestep, this method will add eligible people who are willing to accept treatment to a\n\n\n\n\n\ninterventions.treat_num.add_to_queue()\nAdd people who are willing to accept treatment to the queue\n\n\n\ninterventions.treat_num.get_candidates()\nGet the indices of people who are candidates for treatment\n\n\n\ninterventions.treat_num.step()\nApply treatment. On each timestep, this method will add eligible people who are willing to accept treatment to a queue, and then will treat as many people in the queue as there is capacity for.",
    "crumbs": [
      "**Modules**",
      "interventions"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html",
    "href": "tutorials/t2_model.html",
    "title": "T2 - Building your model",
    "section": "",
    "text": "The purpose of this tutorial is to introduce you to the idea of model components. In brief, these are: people, demographics, networks, diseases, interventions, analyzers, and connectors. Within Starsim, these are the ingredients of a model. On a more basic level, you can think of these as the ingredients of an epidemic. Because Starsim is intended to be very modular, you can build up all these things independently and then piece them together to make a model. Or, if that’s too complex for your needs, there are also shortcuts you can take to make life simpler!\nIn this tutorial we’ll focus on people, demographics, networks, diseases. The remaining components (interventions, analyzers, and connectors) will be covered later.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#simple-sir-model",
    "href": "tutorials/t2_model.html#simple-sir-model",
    "title": "T2 - Building your model",
    "section": "Simple SIR model",
    "text": "Simple SIR model\nLet’s revisit the simple SIR model from Tutorial 1:\n\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 5_000,     # Number of agents to simulate\n    networks = dict(      # *Networks* add detail on how the agents interact with each other \n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 4    # Each person has an average of 4 contacts with other people\n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model \n        type = 'sir',     # Here, we're creating an SIR disease \n        init_prev = 0.1,  # Proportion of the population initially infected \n        beta = 0.1,       # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\n\nNow let’s look at the pars dictionary in more detail. The one we’ve created here has 3 things in it: the number of agents (n_agents), detail on how the agents interact with each other (networks) and detail on what disease we’re modeling (diseases). When we create and run the model, what happens ‘under the hood’ is that the simulation creates 5,000 people, and allows them to the interact with one another over the network and transmit the infection.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#simple-sir-model-built-with-components",
    "href": "tutorials/t2_model.html#simple-sir-model-built-with-components",
    "title": "T2 - Building your model",
    "section": "Simple SIR model built with components",
    "text": "Simple SIR model built with components\nThe example above is a nice simple way to get started, but you might want to have more control over the networks, diseases, and people that you’re creating. Here’s another version of the exact same model, but written slightly differently:\n\npeople = ss.People(n_agents=5_000)\nnetwork = ss.RandomNet(n_contacts=4)\nsir = ss.SIR(init_prev=0.1, beta=0.1)\nsim = ss.Sim(diseases=sir, people=people, networks=network)\nsim.run()\nsim.plot()\n\nRather than bundling everything under pars, we’re now defining components individually for people, networks, and diseases. As for the disease/network details, instead of putting all information in one bucket (pars['diseases'] = dict(name='sir', init_prev=0.1, beta=0.1)), we’re now using ss.SIR()which serves as a prepared ‘template’ where we fill in the details. This new way provides us more flexibility to adjust details of the disease as we need.\nDon’t worry if you have not seen or used these ‘templates’ (called custom classes in programming) before, but imagine them as special containers that come with predefined tools (aka built-in methods) to streamline your modelling process. Even if you’re not an expert programmer, these ‘templates’ are intuitive to use and they will serve as our go-to solution as we move through the examples.\nNow, let’s look at a few useful ways to improve our model by extending these three components (people, networks, and diseases).",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#making-changes-to-our-components",
    "href": "tutorials/t2_model.html#making-changes-to-our-components",
    "title": "T2 - Building your model",
    "section": "Making changes to our components",
    "text": "Making changes to our components\nOne of the main advantages of agent-based models is they allow you to capture heterogeneity between people. In real life, it’s not realistic that everyone in a population has the same number of contacts with other people. Let’s make our contact network more realistic by adding some variation here. For this, we’ll use a Poisson distribution. The two lines below both do the same thing:\n\nnetwork = ss.RandomNet(n_contacts= ss.poisson(4))\nnetwork = ss.RandomNet(n_contacts=dict(type='poisson', lam=4))\n\nIf we use this network, our agents will have varying numbers of contacts.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#accessing-results",
    "href": "tutorials/t2_model.html#accessing-results",
    "title": "T2 - Building your model",
    "section": "Accessing results",
    "text": "Accessing results\nOnce you’ve run a model, you will want to see what the results look like! We’ve seen a few basic plotting commands above, but if you want to inspect the results for yourself, you can take a look in sim.results. This is a dictionary with keys corresponding to core components of interest. For example, the sim we created in the code block above will have the following keys: ['n_alive', 'new_deaths', 'births', 'deaths', 'sir']. Then sim.results.sir is also a dictionary and contains all the results relating to this disease over time. For example, new_infections is a kind of array showing annual new infections.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#matters-of-time",
    "href": "tutorials/t2_model.html#matters-of-time",
    "title": "T2 - Building your model",
    "section": "Matters of time",
    "text": "Matters of time\nThe default for Starsim models is the start simulations in 1995 and simulate with an annual timestep for 35 years. All of this can be easily changed within the main pars dictionary or by passing alternative values straight to the sim, e.g. \n\nsim = ss.Sim(start='2020-01-01', stop='2021-01-01', dt=ss.Dur(months=1), diseases='sis', networks=network)  # Simulate from 2020 for 1 year with a monthly timestep\nsim.run().plot()",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#loading-and-saving",
    "href": "tutorials/t2_model.html#loading-and-saving",
    "title": "T2 - Building your model",
    "section": "Loading and saving",
    "text": "Loading and saving\nYou can save a sim to disk with sim.save(), and then reload it:\n\nsim.save('example.sim')\nnew_sim = ss.load('example.sim')\n\nBy default, to save space, this saves a “shrunken” version of the sim with most of the large objects (e.g. the People) removed. To save everything (for example, if you want to save a partially run sim, then reload it and continue running), you can use shrink=False:\n\nsim.save('example-big.sim', shrink=False)\n\nAll Starsim objects can also be saved via ss.save(); this will save the entire object. This is useful for quickly storing objects for use by other Python functions, for example:\n\ndf = sim.to_df()\nss.save('example.df', df)\nnew_df = ss.load('example.df')\n\nHowever, for a human-readable format, you may want to use a different format. For example, if you’ve exported the results as a dataframe, you can then save as an Excel file:\n\ndf.to_excel('example.xlsx')",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#summary",
    "href": "tutorials/t2_model.html#summary",
    "title": "T2 - Building your model",
    "section": "Summary",
    "text": "Summary\nYou’ve now seen how to create models using the “sim” class (ss.Sim), either by defining a dictionary of parameters or by passing in sim components (demographics, people, diseases, and networks). This means you’ve got the basic skills needed to start making models to answer a range of different questions. We’ll close this tutorial with a few examples that you might like to try out for yourself.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#exercises",
    "href": "tutorials/t2_model.html#exercises",
    "title": "T2 - Building your model",
    "section": "Exercises",
    "text": "Exercises\n\nHow would you model an outbreak of an SIR-like disease within a refugee camp of 20,000 people? Suppose you were interested in the cumulative number of people who got infected over 1 year - how would you find this out?\nWhether an epidemic ‘takes off’ depends to a large extent on the basic reproduction number, which is the expected number of cases that an infected individual generates. In an agent based model like the one we’ve created here, that depends largely on three things: beta (the transmissibility parameter for the disease), n_contacts (the number of contacts each person has), and dur_inf (another disease-related parameter that determines the duration of infection). Experiment with different values for each of these and compare the trajectory of sim.results.sir.n_infected with different parameter values.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/solutions.html",
    "href": "tutorials/solutions.html",
    "title": "Solutions",
    "section": "",
    "text": "These are the solutions to the problems from each of the tutorials.\nLet’s start with the simplest version of a Starsim model. We’ll make a version of a classic SIR model. Here’s how our code would look:"
  },
  {
    "objectID": "tutorials/solutions.html#t1-solutions",
    "href": "tutorials/solutions.html#t1-solutions",
    "title": "Solutions",
    "section": "T1 Solutions",
    "text": "T1 Solutions\n\nQuestion 1\nQ: To simulate a susceptible-infectious-susceptible (SIS) model instead of SIR, what would we change in the example above?\nA: We would simply change 'sir' to 'sis':\n\nimport starsim as ss\nimport sciris as sc\n\n# Define the parameters\npars = sc.objdict( # We use objdict to allow \".\" access\n    n_agents = 10_000,\n    networks = sc.objdict(\n        type = 'random',\n        n_contacts = 10,\n    ),\n    diseases = sc.objdict(\n        type = 'sis', # &lt;-- change this\n        init_prev = 0.01,\n        beta = 0.05,\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\nsim.diseases.sis.plot() # &lt;-- change this\n\n\n\nQuestion 2\nQ: How do the results change if we increase/decrease beta?\nIncreasing beta makes the curves steeper:\n\npars.diseases.type = 'sir' # Switch back to SIR\npars2 = sc.dcp(pars) # copy to new dictionary\npars2.diseases.beta = 0.10\nsim2 = ss.Sim(pars2).run()\nsim2.diseases.sir.plot()\n\nDecreasing beta makes the curves shallower:\n\npars3 = sc.dcp(pars)\npars3.diseases.beta = 0.02\nsim3 = ss.Sim(pars3).run()\nsim3.diseases.sir.plot()\n\n\n\nQuestion 3\nQ: How do the results change if we reduce the number of agents to 200?\nWe get a similar result as before, except less smooth, since random effects are more important with small numbers of agents:\n\npars4 = sc.dcp(pars)\npars4.n_agents = 200\nsim4 = ss.Sim(pars4).run()\nsim4.diseases.sir.plot()"
  },
  {
    "objectID": "tutorials/solutions.html#t2-solutions",
    "href": "tutorials/solutions.html#t2-solutions",
    "title": "Solutions",
    "section": "T2 Solutions",
    "text": "T2 Solutions\n\nQuestion 1\nQ: How would you model an outbreak of an SIR-like disease within a refugee camp of 20,000 people? Suppose you were interested in the cumulative number of people who got infected over 1 year - how would you find this out?\nThe answer obviously depends on the disease parameters. However, we can make some simple assumptions and use cum_infections to determine the total number of infections:\n\nimport starsim as ss\n\npars = sc.objdict(\n    n_agents = 20_000,\n    start = '2025-01-01',\n    dur = 365,\n    unit = 'day',\n    verbose = 1/30, # Print every month\n)\nsir = ss.SIR(\n    dur_inf = 14,\n    beta = 0.02,\n    init_prev = 0.001,\n)\nnet = ss.RandomNet(n_contacts=4)\n\nsim = ss.Sim(pars, diseases=sir, networks=net)\nsim.run()\nsim.plot()\n\nanswer = sim.results.sir.cum_infections[-1]\nprint(f'Cumulative infections over one year: {answer}')"
  },
  {
    "objectID": "tutorials/solutions.html#question-2-1",
    "href": "tutorials/solutions.html#question-2-1",
    "title": "Solutions",
    "section": "Question 2",
    "text": "Question 2\nSolution pending."
  },
  {
    "objectID": "tutorials/solutions.html#t3-solutions",
    "href": "tutorials/solutions.html#t3-solutions",
    "title": "Solutions",
    "section": "T3 Solutions",
    "text": "T3 Solutions\n\nQuestion 1\nQ: In Niger, the crude birth rate is 45 and the crude death rate is 9. Assuming these rates stay constant, and starting with a total population of 24 million in 2020, how many people will there be in 2040? (You do not need to include any diseases in your model.)\nA: We can build our simple demographic model with these parameters, then run it and plot the results:\n\nimport starsim as ss\nimport sciris as sc\n\npars = sc.objdict(\n    start = 2020,\n    stop = 2040,\n    total_pop = 24e6,\n    birth_rate = 45,\n    death_rate = 9,\n)\nsim = ss.Sim(pars)\nsim.run()\nsim.plot('n_alive')\n\nanswer = sim.results.n_alive[-1]/1e6\nprint(f'Population size in year {pars.stop}: {answer} million')"
  },
  {
    "objectID": "tutorials/solutions.html#t4-solutions",
    "href": "tutorials/solutions.html#t4-solutions",
    "title": "Solutions",
    "section": "T4 Solutions",
    "text": "T4 Solutions\n\nQuestion 1\nSolution pending."
  },
  {
    "objectID": "tutorials/solutions.html#t5-solutions",
    "href": "tutorials/solutions.html#t5-solutions",
    "title": "Solutions",
    "section": "T5 Solutions",
    "text": "T5 Solutions\n\nQuestion 1\nSolution pending."
  },
  {
    "objectID": "tutorials/solutions.html#t6-solutions",
    "href": "tutorials/solutions.html#t6-solutions",
    "title": "Solutions",
    "section": "T6 Solutions",
    "text": "T6 Solutions\n\nQuestion 1\nQ: If we change the disease from SIR to SIS and set coverage to 100%, what minimum efficacy of vaccine is required to eradicate the disease by 2050?\nA: There are many ways we could solve this, including with formal numerical optimization packages. However, since we are only varying a single parameter, we can also just use a simple binay search or grid search. This solution illustrates both approaches.\n\nimport numpy as np\nimport sciris as sc\nimport starsim as ss\n\npars = dict(\n    n_agents = 5_000,\n    birth_rate = 20,\n    death_rate = 15,\n    networks = dict(\n        type = 'random',\n        n_contacts = 4\n    ),\n    diseases = dict(\n        type = 'sis',\n        dur_inf = 10,\n        beta = 0.1,\n    ),\n    verbose = False,\n)\n\nclass sis_vaccine(ss.Vx):\n    \"\"\" A simple vaccine against \"SIS\" \"\"\"\n    def __init__(self, efficacy=1.0, **kwargs):\n        super().__init__()\n        self.define_pars(efficacy=efficacy)\n        self.update_pars(**kwargs)\n        return\n\n    def administer(self, people, uids):\n        people.sis.rel_sus[uids] *= 1-self.pars.efficacy\n        return\n    \ndef run_sim(efficacy):\n    \"\"\" Run a simulation with a given vaccine efficacy \"\"\"\n    # Create the vaccine product\n    product = sis_vaccine(efficacy=efficacy)\n\n    # Create the intervention\n    intervention = ss.routine_vx(\n        start_year=2015, # Begin vaccination in 2015\n        prob=1.0,        # 100% coverage\n        product=product  # Use the SIS vaccine\n    )\n\n    # Now create two sims: a baseline sim and one with the intervention\n    sim = ss.Sim(pars=pars, interventions=intervention)\n    sim.run()\n    return sim\n\ndef objective(efficacy, penalty=10, boolean=False, verbose=False):\n    \"\"\" Calculate the objective from the simulation \"\"\"\n    sim = run_sim(efficacy=efficacy)\n    transmission = sim.results.sis.new_infections[-1] &gt; 0\n    if boolean:\n        return not transmission\n    else:\n        loss = efficacy + penalty*transmission\n        if verbose:\n            print(f'Trial: {efficacy=}, {transmission=}, {loss=}')\n        return loss\n\ndef grid_search(n=5, reps=2):\n    \"\"\" Perform a grid search over the objective function \"\"\"\n    sc.heading('Performing grid search ...')\n    lb = 0 # Lower bound for efficacy\n    ub = 1 # Upper bound for efficacy\n    for rep in range(reps):\n        print(f'Grid search {rep+1} of {reps}...')\n        efficacy = np.linspace(lb, ub, n)\n        transmission = sc.parallelize(objective, efficacy, boolean=True)\n        lb = efficacy[sc.findlast(transmission, False)]\n        ub = efficacy[sc.findfirst(transmission, True)]\n        print(f'  Trials: {dict(zip(efficacy, transmission))}')\n        print(f'  Results: lower={lb}, upper={ub}')\n    mid = (lb+ub)/2\n    print(sc.ansi.bold(f'Result: {mid}'))\n    return mid, lb, ub\n\ndef auto_search(efficacy=1.0):\n    \"\"\" Perform automatic search \"\"\"\n    sc.heading('Performing automatic search...')\n    out = sc.asd(objective, x=efficacy, xmin=0, xmax=1, maxiters=10, verbose=True)\n    print(sc.ansi.bold(f'Result: {out.x}'))\n    return out\n\n# Run both optimizations\nmid, lb, ub = grid_search()\nout = auto_search()"
  },
  {
    "objectID": "tutorials/t5_networks.html",
    "href": "tutorials/t5_networks.html",
    "title": "T5 - Networks",
    "section": "",
    "text": "An interactive version of this notebook is available on Google Colab or Binder.\nMany infectious diseases transmit when people come into contact with one another. In the basic SIR example that we covered in the first two tutorials, we used a ‘random’ contact network, which creates random pairings of people. Generally speaking, the structure of network that you use depends on what disease you’re modeling.\nStarsim contains two different approaches to disease transmission.\nContact network: Disease transmits on individual person-to-person relationships. These are networks in the sense that each agent (person) can be viewed as a node and each contact is an edge. Networks are undirected in the sense that an edge will allow transmission in both directions, however you can make transmission stronger one way (p1–&gt;p2) than the other (p2–&gt;p1). The framework includes several pre-built contact network algorithms, each of which manages a list of edges that can change on each simulation step. In addition to the ‘random’ network, the framework include algorithms representing basic sexual networks for modeling sexually transmitted infections (STIs) and a ‘maternal’ network for modeling mother-to-child transmission.\nMixing pools: Simulate well-mixed transmission from one group of agents to another. Each mixing pool simulates directed transmission from a group of source agents to a group of destination agents. Instead of simulating individual edges like in a contact network, mixing pools first compute the total “contagion” that is shed by the source group. This total contagion value is normalized by the number of agents in the source group to arrive at a value that represents a typical infectious source agent. Then, each destination agent is exposed to this typical (average) infectious agent, likely resulting in new infections in the destination group. Multiple mixing pools can be run simultaneously to simulate heterogeneous transmission between various source and destination groups. Mixing pools could be used with age contact matrices like those developed by Prem et al.\nNote that contact networks and mixing pools can be used together in a single simulation.\nIn this tutorial, we’ll demonstrate a couple of the built-in contact networks, and give an overview of how you might create your own for your own disease modeling work. We’ll also demonstrate how to use mixing pools.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#overview-of-starsims-contact-network-structure",
    "href": "tutorials/t5_networks.html#overview-of-starsims-contact-network-structure",
    "title": "T5 - Networks",
    "section": "Overview of Starsim’s contact network structure",
    "text": "Overview of Starsim’s contact network structure\nStarsim’s networks are stored in the networks.py file. At the top of this file you’ll see the Network class, which provides the template for all the other networks. At a high level, all you need to know is that network stores various parameters that determine how pairs of people form and dissolve, and a collection of all the edges that exist at a given point in time. Let’s look at a simple example of the random network:\n\nimport numpy as np\nimport sciris as sc\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Make random network\nrandom = ss.RandomNet()\n\nThe network we just made stores two very important things: the list of contacts (found in random.edges) and the parameters (random.pars).\nIf we just make a network on its own like this, it’s not very interesting. Like all components of Starsim, it needs to be initialized within a sim before the database of contacts gets populated:\n\nnet = ss.RandomNet()\nsir = ss.SIR()\nsim = ss.Sim(n_agents=100, diseases=sir, networks=net) # Decreasing n_agents so we can plot the network below\nsim.init()\n\nWe can easily take a look at the list of edges between agents. All networks are stored in sim.networks, and individual networks can be found at their class name after conversion to lower case. So for this example, sim.networks.randomnet.edges has all the information about which agents (referenced by their UID) are paired with which other agents as well as a per-edge transmission multiplier called beta and a per-edge duration, dur.\n\nsim.networks.randomnet\n\nNetworks provide some basic functionality, for example to identify contacts. Additionally, the edge list can be quickly converted to a pandas dataframe or networkx graph for further analysis and manipulation:\n\nnet = sim.networks.randomnet\n\n# Use the \"find_contacts\" function to find all contacts of agent with uid 0\ncontacts_of_agent_0 = net.find_contacts([0])\nprint('The following agents were identified as contacts of agent 0:', contacts_of_agent_0)\n\n# Convert to a pandas DataFrame and manually find all edges involving agent with uid 0\ndf = net.to_df()\nuid0_edges = df.loc[(df['p1']==0) | (df['p2']==0)]\nprint('\\nEdges involving UID 0 extracted from the edge list data frame:')\ndisplay(uid0_edges)\n\nimport networkx as nx\nG = net.to_graph()\nnx.draw(G, with_labels=True)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#sexual-networks",
    "href": "tutorials/t5_networks.html#sexual-networks",
    "title": "T5 - Networks",
    "section": "Sexual networks",
    "text": "Sexual networks\nStarsim contains a few basic sexual networks, including an mf network for modeling heterosexual partnerships and an msm network for men having sex with men. Modeling STIs is a straightforward extension of the SIR example we looked at previously. Here’s an example modeling syphilis:\n\n# Create the disease\nsyph = ss.Syphilis(\n    beta = {'mf': [0.25, 0.15]},    # See notes below \n)\n\n# Create a heterosexual network\nmf = ss.MFNet(\n    duration=1/24,  # Using very short relationships so that we get more transmission \n    acts=80,        # Distribution of the number of coital acts/year\n)\n\npars = dict(start=2000, dur=20, dt=1/12)\nsim = ss.Sim(pars=pars, diseases=syph, networks=mf)\n\nThe main difference here is that we’ve added the line syph.pars['beta'] = {'mf': [0.25, 0.15]}. Because STIs are generally more transmissible from males to females than vice versa, we can specify beta as a list, and we can also allow it to vary between networks. For instance, if we also had an MSM network here, we could set\nsyph.pars.update(beta = {'mf': [0.25, 0.15], 'msm': [0.4, 0.4]})\nThe sexual network itself is structurally similar to the random network that we looked at previously, and can be customized by changing the pars dictionary that’s used to construct it.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#maternal-networks",
    "href": "tutorials/t5_networks.html#maternal-networks",
    "title": "T5 - Networks",
    "section": "Maternal networks",
    "text": "Maternal networks\nMaternal networks are useful for capturing mother-to-child transmission. If you want to use them, you also need to model pregnancy. As new agents are born via pregnancy, edges are automatically added between mother and prenatal child in the maternal network. Here’s an example showing how you would do this for syphilis:\n\nsyph = ss.Syphilis(\n    beta = {'mf': [0.25, 0.15], 'maternal': [0.99, 0]}\n)\n\n# Make demographic modules\npregnancy = ss.Pregnancy(fertility_rate=20)\ndeath = ss.Deaths(death_rate=15)\n\n# Make maternal network\nmaternal = ss.MaternalNet()\n\n# Make sim\nsim = ss.Sim(pars=pars, diseases=syph, networks=[mf, maternal], demographics=[pregnancy, death], dur=10)\nsim.run().plot(show_module=False)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#making-your-own-contact-network",
    "href": "tutorials/t5_networks.html#making-your-own-contact-network",
    "title": "T5 - Networks",
    "section": "Making your own contact network",
    "text": "Making your own contact network\nIf you want to make your own network, a good place to start is by inheriting from one of the templates in networks.py. For example, if you wanted to make an mf network that has more age structure, you could do something like this:\n\nclass age_mf(ss.MFNet):\n    def add_pairs(self, people, ti=None):\n        # Custom code to select pairs based on age\n        return \n\nThis network would operate exactly like the existing mf network, but you could control how new pairs were added.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#step-5-introduction-to-mixing-pools",
    "href": "tutorials/t5_networks.html#step-5-introduction-to-mixing-pools",
    "title": "T5 - Networks",
    "section": "Step 5: Introduction to mixing pools",
    "text": "Step 5: Introduction to mixing pools\nWhile contact networks model individual relationships, mixing pools model group-level transmission. This is useful for: - Large populations where individual contacts are impractical - Age-structured mixing (like school, work, household contacts) - When you have contact matrices from epidemiological studies\nHere’s a simple comparison:",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#what-youve-learned",
    "href": "tutorials/t5_networks.html#what-youve-learned",
    "title": "T5 - Networks",
    "section": "What you’ve learned",
    "text": "What you’ve learned\nCongratulations! You’ve now learned how to: - ✅ Use basic contact networks for disease transmission - ✅ Model disease-specific networks (sexual, maternal) - ✅ Create custom networks with your own connection rules - ✅ Understand the difference between contact networks and mixing pools\nFor more advanced mixing pool techniques (age-structured mixing, contact matrices, multi-group models), see the Networks implementation guide.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#exercises",
    "href": "tutorials/t5_networks.html#exercises",
    "title": "T5 - Networks",
    "section": "Exercises",
    "text": "Exercises\n\nMulti-network STI model: Adapt the syphilis example to include both MF and MSM transmission\nCustom network parameters: Modify the AgeMFNet to have different age bins and mixing probabilities\nNetwork comparison: Compare random vs age-structured networks - how do they affect epidemic dynamics?",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t1_intro.html",
    "href": "tutorials/t1_intro.html",
    "title": "T1 - Getting started",
    "section": "",
    "text": "Starsim is a highly flexible framework for creating agent-based models. Starsim was designed by a team with expertise in infectious diseases, so many of the examples that we’ll cover throughout these tutorials are examples of infectious diseases. However, you can also use Starsim for modeling other things, like non-communicable diseases (NCDs) or family planning and maternal health.\nInstalling and getting started with Starsim is quite simple.\nTo install, just type pip install starsim. If it worked, you should be able to import Starsim with import starsim as ss.\nThe basic design philosophy of Starsim is: common tasks should be simple. Since Starsim is most commonly used for modeling infectious diseases, everything related to that should be straightforward. The most common tasks that you are likely to do are:\nThis tutorial walks you through the simplest possible version of how to do these things.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T1 - Getting started"
    ]
  },
  {
    "objectID": "tutorials/t1_intro.html#hello-world",
    "href": "tutorials/t1_intro.html#hello-world",
    "title": "T1 - Getting started",
    "section": "Hello world",
    "text": "Hello world\nLet’s start with the simplest version of a Starsim model. We’ll make a version of a classic SIR model. Here’s how our code would look:\n\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 10_000,    # Number of agents to simulate\n    networks = dict(      # *Networks* add detail on how the agents interact with each other \n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 10   # Each person has an average of 10 contacts with other people\n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model \n        type = 'sir',     # Here, we're creating an SIR disease \n        init_prev = 0.01, # Proportion of the population initially infected \n        beta = 0.05,      # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\nsim.diseases.sir.plot()\n\nAs the tutorials progress we’ll show how to extend this different diseases with different transmission pathways, and how to customize the model in lots of different ways.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T1 - Getting started"
    ]
  },
  {
    "objectID": "tutorials/t1_intro.html#exercises",
    "href": "tutorials/t1_intro.html#exercises",
    "title": "T1 - Getting started",
    "section": "Exercises",
    "text": "Exercises\n\nTo simulate a susceptible-infectious-susceptible (SIS) model instead of SIR, what would we change in the example above?\nHow do the results change if we increase/decrease beta?\nHow do the results change if we reduce the number of agents to 200?",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T1 - Getting started"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html",
    "href": "user_guide/modules_networks.html",
    "title": "Network",
    "section": "",
    "text": "This guide provides technical reference for implementing and customizing networks in Starsim. For learning-oriented examples, see the Networks tutorial.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Network"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#transmission-routes-and-the-route-base-class",
    "href": "user_guide/modules_networks.html#transmission-routes-and-the-route-base-class",
    "title": "Network",
    "section": "Transmission routes and the Route base class",
    "text": "Transmission routes and the Route base class\nAll disease transmission in Starsim occurs via routes - pathways through which infectious agents can spread. Both contact networks and mixing pools inherit from the base ss.Route class, which defines the interface for transmission mechanisms.\n\nRoute hierarchy\nss.Route (base class for all transmission pathways)\n├── ss.Network (contact-based transmission)\n│   └── ss.DynamicNetwork (time-varying connections)\n│       └── ss.SexualNetwork (sexual partnership networks)\n└── ss.MixingPool (group-based transmission)\nWhen diseases calculate transmission, they iterate through all routes in the simulation and call each route’s transmission methods. This unified interface allows diseases to work seamlessly with any combination of networks and mixing pools.\n\n\nHow transmission works via routes\n\nDisease calls route: Each disease loops through sim.networks (which contains all routes)\nRoute calculates transmission: Each route computes new infections based on its transmission model\nRoute returns new cases: UIDs of newly infected agents are returned to the disease\nDisease processes infections: The disease handles state changes and prognoses for new cases\n\nThis separation allows you to mix and match different transmission mechanisms in a single simulation.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Network"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#network-architecture-overview",
    "href": "user_guide/modules_networks.html#network-architecture-overview",
    "title": "Network",
    "section": "Network architecture overview",
    "text": "Network architecture overview\nContact networks inherit from ss.Network and manage collections of edges (connections between agents). All networks must implement methods for creating, updating, and removing connections between agents.\n\nKey network components:\n\nEdges: The fundamental unit - connections between two agents with transmission parameters\nParameters: Network-specific settings that control connection behavior\nState management: Tracking which agents can form connections\nUpdate methods: Logic for adding/removing connections over time",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Network"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#comparison-of-networks",
    "href": "user_guide/modules_networks.html#comparison-of-networks",
    "title": "Network",
    "section": "Comparison of networks",
    "text": "Comparison of networks\nStarsim provides different network types for different transmission scenarios:\n\nBase classes\n\n\n\n\n\n\n\n\n\nClass\nPurpose\nKey Features\nWhen to Use\n\n\n\n\nRoute\nBase for all transmission pathways\nDefines transmission interface\nNever directly - inherit from this\n\n\nNetwork\nBase contact network\nEdge management, validation\nRarely - use concrete classes\n\n\nDynamicNetwork\nTime-varying connections\nAdds/removes edges over time\nWhen relationships form/dissolve\n\n\nSexualNetwork\nSexual partnerships\nAge of debut, acts per partnership\nFor STI modeling\n\n\n\n\n\nContact network implementations\n\n\n\n\n\n\n\n\n\nClass\nPurpose\nKey Parameters\nUse Case\n\n\n\n\nStaticNet\nNetworkX graph conversion\ngraph, p, n_contacts\nPre-defined network structures\n\n\nRandomNet\nRandom connections\nn_contacts, dur\nGeneral infectious diseases\n\n\nErdosRenyiNet\nProbabilistic edges\np (edge probability), dur\nTheoretical network studies\n\n\nDiskNet\nSpatial proximity\nr (radius), v (velocity)\nGeographic transmission\n\n\nNullNet\nSelf-connections only\nn_people\nDebugging, placeholders\n\n\nMFNet\nMale-female partnerships\nduration, acts, debut\nHeterosexual STI transmission\n\n\nMSMNet\nMale-male partnerships\nduration, acts, participation\nMSM STI transmission\n\n\nEmbeddingNet\nAge-assortative MF\nmale_shift, embedding_func\nAge-structured STI modeling\n\n\nMaternalNet\nMother-child (base)\ndur, start, end\nVertical transmission\n\n\nPrenatalNet\nPrenatal transmission\nInherits from MaternalNet\nIn-utero transmission\n\n\nPostnatalNet\nPostnatal transmission\nInherits from MaternalNet\nBreastfeeding, birth canal\n\n\n\n\n\nMixing pool classes\n\n\n\n\n\n\n\n\n\nClass\nPurpose\nKey Parameters\nUse Case\n\n\n\n\nAgeGroup\nAge-based filtering\nlow, high, do_cache\nDefining age groups for mixing\n\n\nMixingPool\nSingle group transmission\nsrc, dst, beta, contacts\nSimple group-to-group mixing\n\n\nMixingPools\nMulti-group mixing\nsrc, dst, contacts (matrix)\nComplex age/risk structured mixing\n\n\n\n\n\nChoosing the right network type\nFor respiratory diseases (flu, COVID-19, measles): - RandomNet: Simple random mixing; the default in most cases - MixingPools: Age-structured mixing with contact matrices\nFor sexually transmitted infections: - MFNet: Male-female (heterosexual) transmission - MSMNet: Transmission between men who have sex with men (MSM) - EmbeddingNet: Age-assortative heterosexual mixing\nFor mother-to-child transmission: - PrenatalNet: In-utero transmission (HIV, syphilis) - PostnatalNet: Birth/breastfeeding transmission (HIV, HBV)\nFor special purposes: - StaticNet: Use existing NetworkX graphs - DiskNet: Proof-of-concept spatial/geographic transmission\n- NullNet: Testing/debugging without transmission - ErdosRenyiNet: Theoretical network analysis",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Network"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#core-implementation-methods",
    "href": "user_guide/modules_networks.html#core-implementation-methods",
    "title": "Network",
    "section": "Core implementation methods",
    "text": "Core implementation methods\nAll networks inherit key methods from the base classes. Override these to create custom network behavior:\n\n\n\n\n\n\n\n\nMethod\nPurpose\nWhen to override\n\n\n\n\n__init__()\nInitialize parameters and state\nAlways for custom networks\n\n\ninit_pre()\nPre-simulation initialization\nRarely\n\n\ninit_post()\nPost-simulation initialization\nWhen you need access to people\n\n\nadd_pairs()\nCreate new connections\nKey method for custom logic\n\n\nremove_pairs()\nRemove existing connections\nFor dynamic networks\n\n\nupdate()\nMain update method each timestep\nRarely - calls add/remove pairs\n\n\nfind_contacts()\nQuery network connections\nOverride for custom queries\n\n\n\nLet’s compare a simple SIR model configured with transmission using a single Mixing Pool to a similar model using a contact network. Mixing pools are not the same as contact networks, so the results are not expected to be identical.\n\nimport starsim as ss\n\n# Transmission using a mixing pool\nmp = ss.MixingPool(beta=ss.timeprob(0.1), contacts=ss.poisson(lam=3)) # A single mixing pool\nsir = ss.SIR() # Beta doesn't matter, that's just for networks\nsim1 = ss.Sim(diseases=sir, networks=mp, verbose=0, label='Mixing Pool')\n\n# Transmission using a network\nnet = ss.RandomNet(n_contacts=ss.poisson(lam=3))\nsir = ss.SIR(beta=ss.timeprob(0.1))\nsim2 = ss.Sim(diseases=sir, networks=net, verbose=0, label='Contact Network')\n\nmsim = ss.MultiSim([sim1, sim2]).run()\nmsim.plot()\n\nEach MixingPool has several configuration parameters, including src and dst. The value of these parameters can either be an array of uids, like ss.uids([0,1,2]) or a callable function that takes sim as an argument and returns an array of uids (or a BoolArr) like lambda sim: sim.people.age&lt;10. One helper class we have created is called AgeGroup, which takes low and high ages as parameters. This class has some performance advantages when using multiple pools via MixingPools through caching.\nWhile mixing pools do not represent individual agent-to-agent connections, each agent does have an “effective” number of contacts, typically drawn from a Poisson distribution. Individuals retain their number of contacts within each pool for the duration of the simulation. Effective contacts are used on the acquisition sides. On the transmission side, the “average” infection level, called trans, against which susceptible agents are challenged is computed as:\ntrans = np.mean(disease.infectious[self.src_uids] * disease.rel_trans[self.src_uids])\nAnd on the acquisition side, each susceptible agent can be thought of as connected to eff_contacts average infectious agents, computed as:\nacq = self.eff_contacts[self.dst_uids] * disease.susceptible[self.dst_uids] * disease.rel_sus[self.dst_uids]\nUltimately, the acquisition probability for each susceptible agent in dst_uids is computed as\np = self.pars.beta * trans * acq\nYou can see the beta parameter here, which is another pool parameter and should use ss.timeprob() to automatically adjust for time units. Mixing pools do not currently use the beta parameters configured in individual disease modules.\n\nmp = ss.MixingPool(\n    diseases = 'sir', # Use this pool only for SIR, not other diseases (HIV in this example)\n    src = lambda sim: sim.people.age &lt; 15, # Infection sources will be agents under age 15\n    dst = ss.AgeGroup(low=15, high=None), # Here demonstrating the AgeGroup class, identical to lambda sim: sim.people.age &gt;= 15\n    contacts = ss.poisson(lam=2), # Contacts will be poisson distributed with a mean of 2\n    beta = ss.timeprob(0.2), # And we set beta to 0.2, automatically adjusting for time units via the ss.beta wrapper\n)\nsim = ss.Sim(diseases=['sir', 'hiv'], networks=mp) # Two diseases, only \"sir\" will have transmission\nsim.run()\nsim.plot()\n\nMixingPools (plural) allows you to configure multiple individual MixingPool pools. This first example shows how to do age mixing. Like MixingPool, MixingPools also takes src and dst, however each of these parameters must be a dictionary with key specifying the name of each group and value as in the singlular mixing pool proving the uids by a callable function or list of uids.\n\nimport numpy as np\nimport sciris as sc\nimport matplotlib.pyplot as plt\n\nbin_size = 5\nlows = np.arange(0, 80, bin_size)\nhighs = sc.cat(lows[1:], 100)\ngroups = ss.ndict([ss.AgeGroup(low=low, high=high) for low, high in zip(lows, highs)])\nn_groups = len(groups)\n\n# Let's create a random contact matrix. If using contact matrices from Prem et al., put data here.\ncm = np.random.random((n_groups, n_groups)) + 3*np.diag(np.random.rand(n_groups))\n\nprint('The first axis (rows) of the contact matrix is the SOURCE group')\nprint('The second axis (columns) of the contact matrix is the DESTINATION group')\nplt.imshow(cm)\n\nmps = ss.MixingPools(\n    contacts = cm,\n    beta = ss.timeprob(0.2),\n    src = groups,\n    dst = groups,\n)\n\n# Track new infections by age using an Analyzer, you'll learn about these in a subsequent tutorial\nclass InfectionsByAge(ss.Analyzer):\n    def __init__(self, bins, **kwargs):\n        super().__init__()\n        self.bins = bins\n        self.update_pars(**kwargs)\n\n    def init_post(self):\n        super().init_post()\n        self.new_cases = np.zeros((len(self), len(self.bins)-1))\n\n    def step(self):\n        new_inf = self.sim.diseases.sir.ti_infected == self.ti\n        if not new_inf.any(): return\n        self.new_cases[self.ti, :] = np.histogram(self.sim.people.age[new_inf], bins=self.bins)[0]\n\n    def plot(self):\n        fig, ax = plt.subplots()\n        ax.set_prop_cycle('color', plt.cm.nipy_spectral(np.linspace(0, 1, len(self.bins))))\n\n        for i, (b1, b2) in enumerate(zip(self.bins[:-1], self.bins[1:])):\n            ax.plot(self.timevec, self.new_cases[:,i], label=f'Age {b1}-{b2}')\n        ax.legend(); ax.set_xlabel('Year'); ax.set_ylabel('New Infections')\n\naz = InfectionsByAge(np.concatenate([lows, [1000]]))\n\nsir = ss.SIR()\nsim = ss.Sim(diseases=sir, networks=mps, analyzers=az, dur=5, dt=1/4, n_agents=1000, verbose=0)\nsim.run()\nsim.analyzers[0].plot()\nprint('↑ The default age distribution is uniform, so the 75+ group contains many more people than the other age groups, explaining the larger number of new infections.')\n\nMixing pools work well with properties other than age. Here’s an example that mixes by socio-economic status (SES).\n\n# Define SES states\nses = sc.dictobj(low=0, mid=1, high=2)\n\n# Create 5,000 people adding 50% LOW, 30% MID, and 20% HIGH SES\nses_arr = ss.FloatArr('ses', default=ss.choice(a=ses.values(), p=[0.5, 0.3, 0.2]))\nppl = ss.People(n_agents=5_000, extra_states=ses_arr)\n\n# Create the mixing pools, note that the contact matrix need not be symmetric\nmps = ss.MixingPools(\n    src = {k: lambda sim, s=v: ss.uids(sim.people.ses == s) for k,v in ses.items()},\n    dst = {k: lambda sim, s=v: ss.uids(sim.people.ses == s) for k,v in ses.items()[:-1]}, # People in the HIGH group have no route to acquire new infections, for demonstration purposes here\n\n    # src on rows (1st dimension), dst on cols (2nd dimension)\n    contacts = np.array([\n        [2.50, 0.00], # low→low,  low→mid\n        [0.05, 1.75], # mid→low,  mid→mid\n        [0.00, 0.15], # high→low, high→mid\n    ]),\n\n    beta = ss.timeprob(0.2),\n)\n\n# Create an analyzer to track results by SES group\nclass New_Infections_By_SES(ss.Analyzer):\n    def init_results(self):\n        self.new_cases = np.zeros((len(self), len(ses)))\n\n    def step(self):\n        new_inf = self.sim.diseases.sir.ti_infected == self.ti\n        if not new_inf.any():\n            return\n\n        for value in ses.values():\n            self.new_cases[self.ti, value] = np.count_nonzero(new_inf & (self.sim.people.ses==value))\n\naz = New_Infections_By_SES()\n\ndef seeding(self, sim, uids):\n    p = np.zeros(len(uids))\n    high_ses = ss.uids(sim.people.ses == ses.high)\n    p[high_ses] = 0.1 # Seed infections into 10% of SES HIGH\n    return p\nsir = ss.SIR(init_prev = ss.bernoulli(p=seeding)) # The probability of being selected as a seed is determined on a per-agent basis by the above 'seeding' function\n\nsim = ss.Sim(people=ppl, diseases=sir, networks=mps, analyzers=az, dt=1/12, dur=35, verbose=0)\nsim.run()\n\nfig, ax = plt.subplots()\nnew_cases = sim.analyzers[0].new_cases\nfor key,value in ses.items():\n    ax.plot(sim.results.timevec, new_cases[:,value], label=key)\nax.legend()\nax.set_xlabel('Year')\nax.set_ylabel('New Infections')\nplt.show()\n\nIn the above figure, infections are seeded into the high group at the beginning of the simulation, explaining the spike in new cases at that time. High SES can only infect mid SES, so the mid (orange) wave follows. Low SES can only become infected by mid SES in this example, so the blue wave follows. This example intentionally demonstrates the directional nature of mixing pools and includes strong mixing within groups and bottlenecks between groups to make the point.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Network"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html",
    "href": "user_guide/advanced_indexing.html",
    "title": "Advanced indexing",
    "section": "",
    "text": "This tutorial covers advanced indexing concepts in Starsim, including universal identifiers (UIDs), active UIDs (auids), and proper array operations.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Advanced indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#overview",
    "href": "user_guide/advanced_indexing.html#overview",
    "title": "Advanced indexing",
    "section": "Overview",
    "text": "Overview\nStarsim uses an indexing system built on NumPy arrays to efficiently manage agents throughout their lifecycle, including when they die or are removed from the simulation. Understanding this system is crucial for writing correct and efficient code.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Advanced indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#key-concepts",
    "href": "user_guide/advanced_indexing.html#key-concepts",
    "title": "Advanced indexing",
    "section": "Key concepts",
    "text": "Key concepts\n\nUniversal identifiers (UIDs)\nEvery agent in Starsim has a unique identifier called a universal identifier or UID. UIDs are integers that:\n\nAre assigned sequentially starting from 0\nNever change during an agent’s lifetime\nAre not reused when agents die\nCan be used to index any agent, whether alive or dead\n\n\n\nActive UIDs (auids)\nThe simulation also maintains a list of active UIDs (auids), which are the UIDs of agents who are currently alive and active in the simulation. This is a dynamic subset of all UIDs.\n\n\nArray structure\nStarsim arrays have two main components: - raw: Contains data for all agents ever created (indexed by UID) - values: Contains data for active agents only (indexed by position in auids)\nLet’s see this in action:\n\nimport starsim as ss\n\n# Create a simple simulation to demonstrate indexing\npars = dict(\n    n_agents=10,\n    diseases=dict(type='sir', init_prev=0.5, p_death=0.2),\n    networks='random',\n)\n\nsim = ss.Sim(pars)\nsim.run()\n\nprint(f\"Number of agents: {len(sim.people)}\")\nprint(f\"UIDs: {sim.people.uid}\")\nprint(f\"Active UIDs (auids): {sim.people.auids}\")\nprint(f\"All UIDs: {sim.people.uid.raw}\")\nprint(f\"Alive: {sim.people.alive.raw}\")\nprint(f\"Ages (values): {sim.people.age}\")\nprint(f\"Ages (raw): {sim.people.age.raw}\")",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Advanced indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#operations-on-active-vs-all-agents",
    "href": "user_guide/advanced_indexing.html#operations-on-active-vs-all-agents",
    "title": "Advanced indexing",
    "section": "Operations on active vs all agents",
    "text": "Operations on active vs all agents\nThis is a crucial distinction in Starsim:\n\nStatistical operations (like .mean(), .sum(), .std()) operate on active agents only\nIndexing operations depend on what type of index you use:\n\nint or slice: operates on active agents (values)\nss.uids(): operates on all agents (raw)\n\n\nLet’s demonstrate this:\n\nprint(f\"After simulation:\")\nprint(f\"Total agents ever created: {len(sim.people.uid.raw)}\")\nprint(f\"Active agents: {len(sim.people.auids)}\")\nprint(f\"Active UIDs: {sim.people.auids}\")\n\n# Statistical operations work on active agents only\nprint(f\"\\nMean age (active agents): {sim.people.age.mean():.2f}\")\nprint(f\"Mean age (manual calculation): {sim.people.age.values.mean():.2f}\")\n\n# This would be different if we included all agents (including dead ones)\nprint(f\"Mean age (all agents, including dead): {sim.people.age.raw[sim.people.age.raw != sim.people.age.nan].mean():.2f}\")",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Advanced indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#proper-indexing-examples",
    "href": "user_guide/advanced_indexing.html#proper-indexing-examples",
    "title": "Advanced indexing",
    "section": "Proper indexing examples",
    "text": "Proper indexing examples\nHere are examples of correct and incorrect ways to index Starsim arrays:\n\nCorrect indexing patterns\n\n# ✅ Using integer indices (works on active agents)\nage_of_first_active = sim.people.age[0]\nprint(f\"Age of first active agent: {age_of_first_active}\")\n\n# ✅ Using ss.uids() for specific UIDs\nspecific_uids = ss.uids([0, 1, 2])\nages_by_uid = sim.people.age[specific_uids]\nprint(f\"Ages of UIDs {specific_uids}: {ages_by_uid}\")\n\n# ✅ Using boolean arrays from states\nfemale_uids = sim.people.female.uids  # This gets UIDs of female agents\nfemale_ages = sim.people.age[female_uids]\nprint(f\"Ages of female agents: {female_ages}\")\n\n# ✅ Using .true() and .false() methods\nalive_uids = sim.people.alive.true()\ndead_uids = sim.people.alive.false()\nprint(f\"Alive UIDs: {alive_uids}\")\nprint(f\"Dead UIDs: {dead_uids}\")\n\n\n\nIncorrect indexing patterns\nThese examples show what NOT to do:\n\nimport sciris as sc\n\n# ❌ Don't index with raw lists of integers - this is ambiguous!\nwith sc.tryexcept() as tc:\n    print('This raises an error:')\n    sim.people.age[[0, 1, 2]]  # This would raise an error\n\n# ❌ Don't mix up .values and .raw\nage = sim.people.age\nprint('Mean age:', age.mean())\nprint('Mean age (values):', age.values.mean()) # &lt;- same as above\nprint('Mean age (raw):', age.raw.mean()) # &lt;- different since includes dead agents",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Advanced indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#best-practices-and-common-pitfalls",
    "href": "user_guide/advanced_indexing.html#best-practices-and-common-pitfalls",
    "title": "Advanced indexing",
    "section": "Best practices and common pitfalls",
    "text": "Best practices and common pitfalls\n\nDo:\n\nUse ss.uids() when you need to index by specific UIDs\nUse statistical methods (.mean(), .sum(), etc.) directly on arrays - they automatically work on active agents\nUse .uids property of boolean arrays to get UIDs of agents matching criteria\nUse .true() and .false() methods for cleaner boolean array handling\nRemember that integer indexing works on active agents, not UIDs\n\n\n\nDon’t:\n\nDon’t index with raw lists of integers - use ss.uids() instead\nDon’t use .raw arrays for statistics unless you specifically need to include dead agents\nDon’t use boolean operators (&, |) on non-boolean arrays - use comparison operators instead\nDon’t forget to check if UID arrays are empty before performing operations on them\n\n\n\nPerformance tips:\n\nBoolean indexing is efficient - use it to filter large populations\nUID operations are optimized - use set operations like .intersect() and .union() when appropriate\nStatistical operations on arrays are fast - they use NumPy under the hood\nAvoid loops when possible - vectorized operations are much faster",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Advanced indexing"
    ]
  },
  {
    "objectID": "user_guide/workflows_calibration.html",
    "href": "user_guide/workflows_calibration.html",
    "title": "Calibration",
    "section": "",
    "text": "Disease models typically require contextualization to a relevant setting of interest prior to addressing “what-if” scenario questions. The process of tuning model input parameters so that model outputs match observed data is known as calibration. There are many approaches to model calibration, ranging from manual tuning to fully Bayesian methods.\nFor many applications, we have found that an optimization-based approach is sufficient. Such methods avoid the tedious process of manual tuning and are less computationally expensive than fully Bayesian methods. One such optimization-based approach is the Optuna library, which is a Bayesian hyperparameter optimization framework. Optuna is designed for tuning hyperparameters of machine learning models, but it can also be used to calibrate disease models.\nCalibration libraries often treat the disease model as a black box, where the input parameters are the “hyperparameters” to be tuned. The calibration process is often iterative and requires a combination of expert knowledge and computational tools. The optimization algorithm iteratively chooses new parameter values to evaluate, and the model is run with these values to generate outputs. The outputs are compared to observed data, and a loss function is calculated to quantify the difference between the model outputs and the observed data. The optimization algorithm then uses this loss function to update its search strategy and choose new parameter values to evaluate. This process continues until the algorithm converges to a set of parameter values that minimize the loss function.\nWhile many optimization algorithms are available, Starsim has a built-in interface to the Optuna library, which we will demonstrate in this tutorial. We will use a simple Susceptible-Infected-Recovered (SIR) model as an example. We will tune three input parameters, the infectivity parameter, beta, the initial prevalence parameter, init_prev, and the Poisson-distributed degree distribution parameter, n_contacts. We will calibrate the model using a beta-binomial likelihood function so as to match prevalence at three distinct time points.\nWe begin with a few imports and default settings:\n\n##%% Imports and settings\nimport sciris as sc\nimport starsim as ss\nimport numpy as np\nimport pandas as pd\nimport matplotlib.dates as mdates\n\nn_agents = 2e3\ndebug = False # If true, will run in serial\n\nThe calibration class will require a base Sim object. This sim will later be modified according to parameters selected by the optimization engine. The following function creates the base Sim object.\n\ndef make_sim():\n    sir = ss.SIR(\n        beta = ss.TimeProb(0.075),\n        init_prev = ss.bernoulli(0.02),\n    )\n    random = ss.RandomNet(n_contacts=ss.poisson(4))\n\n    sim = ss.Sim(\n        n_agents = n_agents,\n        start = ss.Date('2020-01-01'),\n        stop = ss.Date('2020-02-12'),\n        dt = ss.days(1),\n        diseases = sir,\n        networks = random,\n        verbose = 0,\n    )\n\n    return sim\n\nNow let’s define the calibration parameters. These are the inputs that Optuna will be able to modify. Here, we define three such parameters, beta, init_prev, and n_contacts.\nEach parameter entry should have range defined by low and high as well as a guess values. The guess value is not used by Optuna, rather only for a check after calibration completes to see if the new parameters are better than the guess values.\nYou’ll notice there are a few other parameters that can be specified. For example, the data type of the parameter appears in suggest_type. Possible values are listed in the Optuna documentation, and include suggest_float for float values and suggest_int for integer types.\nTo make things easier for the search algorithm, it’s helpful to indicate how outputs are expected to change with inputs. For example, increasing beta from 0.01 to 0.02 should double disease transmission, but increasing from 0.11 to 0.12 will have a small effect. Thus, we indicate that this parameter should be calibrated with log=True.\n\n# Define the calibration parameters\ncalib_pars = dict(\n    beta = dict(low=0.01, high=0.30, guess=0.15, suggest_type='suggest_float', log=True), # Note the log scale\n    init_prev = dict(low=0.01, high=0.05, guess=0.15), # Default type is suggest_float, no need to re-specify\n    n_contacts = dict(low=2, high=10, guess=3, suggest_type='suggest_int'), # Suggest int just for this demo\n)\n\nThe optimization engine iteratively chooses input parameters to simulate. Those parameters are passed into the following build_sim function as a dictionary of calib_pars along with the base sim and any other key word arguments. The calib_pars will be as above, but importantly will have an additional key named value containing the value selected by Optuna.\nWhen modifying a sim, it is important to realize that the simulation has not been initialized yet. Nonetheless, the configuration is available for modification at sim.pars, as demonstrated in the function below for the SIR example.\n\ndef build_sim(sim, calib_pars, n_reps=1, **kwargs):\n    \"\"\"\n    Modify the base simulation by applying calib_pars. The result can be a\n    single simulation or multiple simulations if n_reps&gt;1. Note that here we are\n    simply building the simulation by modifying the base sim. Running the sims\n    and extracting results will be done by the calibration function.\n    \"\"\"\n\n    sir = sim.pars.diseases # There is only one disease in this simulation and it is a SIR\n    net = sim.pars.networks # There is only one network in this simulation and it is a RandomNet\n\n    for k, pars in calib_pars.items(): # Loop over the calibration parameters\n        if k == 'rand_seed':\n            sim.pars.rand_seed = v\n            continue\n\n        # Each item in calib_pars is a dictionary with keys like 'low', 'high',\n        # 'guess', 'suggest_type', and importantly 'value'. The 'value' key is\n        # the one we want to use as that's the one selected by the algorithm\n        v = pars['value']\n        if k == 'beta':\n            sir.pars.beta = ss.TimeProb(v)\n        elif k == 'init_prev':\n            sir.pars.init_prev = ss.bernoulli(v)\n        elif k == 'n_contacts':\n            net.pars.n_contacts = ss.poisson(v)\n        else:\n            raise NotImplementedError(f'Parameter {k} not recognized')\n\n    # If just one simulation per parameter set, return the single simulation\n    if n_reps == 1:\n        return sim\n\n    # But if you'd like to run multiple simulations with the same parameters, we return a MultiSim instead\n    # Note that each simulation will have a different random seed, you can set specific seeds if you like\n    # Also note that parallel=False and debug=True are important to avoid issues with parallelism in the calibration\n    # Advanced: If running multiple reps, you can choose if/how they are combined using the \"combine_reps\" argument to each CalibComponent, introduced below.\n    ms = ss.MultiSim(sim, iterpars=dict(rand_seed=np.random.randint(0, 1e6, n_reps)), initialize=True, debug=True, parallel=False)\n    return ms\n\nThe Starsim framework has been integrated with the Optuna hyperparameter optimization algorithm to facilitate calibration through the Calibration class. Recall that an optimization-based approach to calibration minimizes a function of the input parameters. This function is key to achieving an acceptable calibration.\nThere are two ways to describe the goodness-of-fit function for the Calibration. The first method is to directly provide a function that the algorithm will call. The eval_fn will be passed each completed sim after running, and is expected to return a float representing the mismatch (lower is better as the optimization algorithm is configured to minimize). Data can be passed into the eval_fn via eval_kwargs.\nAs an alternative to directly specifying the evaluation function, you can use CalibComponents. Each component includes real data, for example from a survey, that is compared against simulation data from the model. Several components and be used at the same time, for example one for disease prevalence and another for treatment coverage. Each component computes a likelihood of the data given the input parameters, as assessed via simulation. Components are combined assuming independence.\nThe base class for a component is called CalibComponent, which you can use to define your own likelihood. However, we have provided components for several key likelihood functions including BetaBinomial, Binomial, DirichletMultinomial, GammaPoisson, and Normal. The Normal component is most like a traditional squared error. Each component takes in a name and a weight, which is used when combining log likelihoods.\nImportantly, each component takes in the calibration target, the real data that was observed, in an argument called expected. This argument should be a Pandas Dataframe with one row per time point and columns that will depend on the specific component type. For example, the Binomial component requires columns of n (trials) and x (successes).\nThe components also handle extracting data from each simulation using the extract_fn argument. The value of this argument should be a function that takes in a simulation and returns a Pandas DataFrame. The specifics of the columns will depend a bit on the type of component (e.g. BetaBinomial is different from Normal), but often looks like a simulated version of expected. We will see examples below.\nWe’ll also see how to use the conform argument, the purpose of which is to temporally align the simulation output to the real data. This argument works along with the extract_fn to produce the final simulation outputs that are used in the likelihood function. The conformer is a function that takes in the expected data you provided and the actual simulation result the comes out of the extract_fn. The conformers we have built in are as follows: * step_containing: Conform by simply choosing the simulated timestep that contains the time indicated in the real data (expected) * prevalent: Interpolate the simulated timepoints to estimate the values that would have occurred at each real timepoint * incident: While the two methods above capture the state of the model at a particular point in time (stocks), this component allows you to capture the behavior of the model over time (flows). Instead of just giving one time value, t, you’ll provide a second time value as well called t1. This conformer will add up events occurring between the two time points.\nLet’s make a Binomial component, as might be used to calibrate disease prevalence.\n\nprevalence = ss.Normal(\n    name = 'Disease prevalence',\n    conform = 'prevalent',\n\n    expected = pd.DataFrame({\n        'x': [0.13, 0.16, 0.06],    # Prevalence of infection\n    }, index=pd.Index([ss.Date(d) for d in ['2020-01-12', '2020-01-25', '2020-02-02']], name='t')), # On these dates\n    \n    extract_fn = lambda sim: pd.DataFrame({\n        'x': sim.results.sir.prevalence,\n    }, index=pd.Index(sim.results.timevec, name='t')),\n\n    # You can specify the variance as well, but it's optional (max likelihood estimates will be used if not provided)\n    # This could be a single float or an array with the same shape as the expected values\n    sigma2 = 0.05, # e.g. (num_replicates/sigma2_model + 1/sigma2_data)^-1\n    #sigma2 = np.array([0.05, 0.25, 0.01])\n)\n\nFinally, we can bring all the pieces together. We make a single base simulation and create an instance of a Starsim Calibration object. This object requires a few arguments, like the calib_pars and sim. We also pass in the function that modifies the base sim, here our build_sim function. No additional build_kw are required in this example.\nWe also pass in a list of components. Instead of using this “component-based” system, a user could simply provide an eval_fn, which takes in a completed sim an any eval_kwargs and returns a “mismatch” score to be minimized.\nWe can also specify the total number of trials to run, the number of parallel works, and a few other parameters.\n\nsc.heading('Beginning calibration')\n\n# Make the sim and data\nsim = make_sim()\n\n# Make the calibration\ncalib = ss.Calibration(\n    calib_pars = calib_pars,\n    sim = sim,\n    build_fn = build_sim,\n    build_kw = dict(n_reps=3), # Run 3 replicates for each parameter set\n    reseed = True, # If true, a different random seed will be provided to each configuration\n    components = [prevalence],\n    total_trials = 100,\n    n_workers = None, # None indicates to use all available CPUs\n    die = True,\n    debug = debug, # Run in serial if True\n)\n\n# Perform the calibration\nsc.printcyan('\\nPeforming calibration...')\ncalib.calibrate();\n\nLet’s look at the best parameters that were found. Note that the rand_seed was selected at random, but the other parameters are meaningful.\n\ncalib.best_pars\n\nOnce the calibration is complete, we can compare the guess values to the best values found by calling check_fit.\n\n# Confirm - Note the comparison is here configured over n_reps=15 replicates\nsc.printcyan('\\nConfirming fit...')\n\n# Increase replicates to 15 for more representative results when running check_fit\ncalib.build_kw['n_reps'] = 15\n\ncalib.check_fit(do_plot=False)\n\nAfter calling check_fit, we can plot the results. This first plot shows the Normal likelihood distributions from each of the 15 simulations we did in check_fit as the colored lines. The vertical dashed line is located at the real (expected) data. Top row is the “guess” values and the bottom row is the new “best” parameters. We want the vertical dashed line to cross the Gaussians at high points, representing high likelihood.\n\ncalib.plot();\n\nAnother way to plot the results is via bootstrapping. Here we repeatedly choose 15 from the n_reps=15 simulations (with replacement), compute the average (or sum for some components), and repeatedly calculate the mean. We then plot the distribution of means, and hope it lands near the vertical dashed lines representing the real data.\n\ncalib.plot(bootstrap=True); # Pass bootstrap=True to produce this plot\n\nWe can view some plots of the final fitted results. Whereas the two plots above were from the check_fit, running both “guess” and “best” parameters, here we make make new simulations to visualize the results.\n\ng = calib.plot_final(); # Run the model for build_kw['n_reps'] = 15 replicates\nfor ax in g.axes: # Fix the date formatting\n    ax.xaxis.set_major_formatter(mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\nOptuna has lots of diagnostic plots that we can explore. Possible plots include: * plot_contour * plot_edf * plot_hypervolume_history * plot_intermediate_values * plot_optimization_history * plot_parallel_coordinate * plot_param_importances * plot_pareto_front * plot_rank * plot_slice * plot_terminator_improvement * plot_timeline\nHere are some examples:\n\ncalib.plot_optuna('plot_optimization_history'); # Plot the optimization history\n\n\ncalib.plot_optuna('plot_contour');\n\n\ncalib.plot_optuna('plot_param_importances');\n\nIf you choose not to use components, you can always create your own mismatch function, as in the following example:\n\nmy_data = (ss.Date('2020-01-12'), 0.13)\n\ndef eval(sim, expected):\n    # Compute the squared error at one point in time.\n    # expected will contain my_data in this example due to eval_kw\n    date, p = expected\n    if not isinstance(sim, ss.MultiSim):\n        sim = ss.MultiSim(sims=[sim])\n\n    ret = 0\n    for s in sim.sims:\n        ind = np.searchsorted(s.results.timevec, date, side='left')\n        prev = s.results.sir.prevalence[ind]\n        ret += (prev - p)**2\n    return ret\n\n\n# Define the calibration parameters\ncalib_pars = dict(\n    beta = dict(low=0.01, high=0.30, guess=0.15, suggest_type='suggest_float', log=True),\n)\n\n# Make the sim and data\nsim = make_sim()\n\n# Make the calibration\ncalib = ss.Calibration(\n    calib_pars = calib_pars,\n    sim = sim,\n    build_fn = build_sim,\n    build_kw = dict(n_reps=2), # Two reps per point\n    reseed = True,\n    eval_fn = eval, # Will call my_function(msim, eval_kwargs)\n    eval_kw = dict(expected=my_data), # Will call eval(sim, **eval_kw)\n    total_trials = 10,\n    n_workers = None, # None indicates to use all available CPUs\n    die = True,\n    debug = debug,\n)\n\n# Perform the calibration\nsc.printcyan('\\nPeforming calibration...')\ncalib.calibrate()\n\n# Check\ncalib.check_fit()\n\nFor more, take a look at test_calibration.py in the tests directory.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Calibration"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html",
    "href": "user_guide/basics_model.html",
    "title": "Model structure",
    "section": "",
    "text": "Starsim models are designed to capture disease dynamics within a population of agents, which typically represent people (but may represent animals or other things). In keeping with this, the basic ingredients of a Starsim model are the People class, which store all the relevant attributes about people, a collection of Modules that determine what happens to people on each time step, and the Sim class, which pulls all the components together, runs the simulation, and stores the Results.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-people",
    "href": "user_guide/basics_model.html#overview-of-people",
    "title": "Model structure",
    "section": "Overview of People",
    "text": "Overview of People\nMore details on the People class are in the separate user guide page, but we give a basic introduction here since people are so central to the model structure. When people are created, by default they come with basic states that are stored for each person. These basic states include age, sex, and whether the person is alive. All of these states are stored as arrays, so the basic structure of the People class can be easily exported to a dataframe, e.g. \n\nimport starsim as ss\n\nsim = ss.Sim(n_agents=10)\nsim.init()\ndf = sim.people.to_df()\nprint(df)\n\nWhen a module is added to a sim, this can add additional states to people. Tracking and updating the states of people is one of the main ways in which Starsim models disease dynamics. For example:\n\nimport starsim as ss\n\nsim = ss.Sim(n_agents=20, diseases=dict(type='sis', init_prev=0.2), networks='random')\nsim.run()\ndf = sim.people.to_df()\ndf.disp()\n\nWe can see even in this very simple example with only one disease and 20 agents, a lot of data is generated!",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-modules",
    "href": "user_guide/basics_model.html#overview-of-modules",
    "title": "Model structure",
    "section": "Overview of Modules",
    "text": "Overview of Modules\nStarsim contains the following kinds of modules, listed below in the order that they are typically updated: * Demographics * Diseases * Connectors * Networks * Interventions * Analyzers\nModules typically store parameters (e.g. the transmission probability), states of people (e.g. whether they are susceptible, infected, or recovered), and results (e.g. the number of people infected at each point in time).",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-a-sim",
    "href": "user_guide/basics_model.html#overview-of-a-sim",
    "title": "Model structure",
    "section": "Overview of a Sim",
    "text": "Overview of a Sim\nThe Sim object is responsible for storing assembling, initializing, and running the model. The Sim class contains some top-level parameters (including the number of agents in the simulation, the start and stop times, and the random seed) and results (e.g. the population size over time), but almost all other parameters and results are specific to modules and stored within them. There are more details on the Sim on the linked page.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#what-happens-when-you-add-a-module",
    "href": "user_guide/basics_model.html#what-happens-when-you-add-a-module",
    "title": "Model structure",
    "section": "What happens when you add a module?",
    "text": "What happens when you add a module?\nWhen you add a module to a Sim, the module’s parameters, states, and results will be added to the centralized collections of parameters, states, and results that are maintained within the Sim. To illustrate this, let’s create a Sim with an SIR disease module and a random contact network:\n\nimport starsim as ss \nsir = ss.SIR(dur_inf=10, beta=0.2, init_prev=0.4, p_death=0.2)\nsim = ss.Sim(diseases=sir, networks='random')\nsim.init()  # Initialize the sim to create \n\nThe call to sim.init() means that the SIR module gets added to sim.diseases and the RandomNet network gets added to sim.networks. In addition, the following updates are made: * the parameters of the modules are added to the sim’s centralized parameter dictionary, so you can access them via either sim.pars.sir.init_prev or sim.diseases.sir.pars.init_prev * the states specific to each module are added to People, so you can access them via sim.diseases.sir.infected or sim.people.sir.infected * the results specific to each module are added to the centralized Results dictionary of the Sim, so you can access them via sim.diseases.sir.results.n_infected or sim.results.sir.n_infected.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-results",
    "href": "user_guide/basics_model.html#overview-of-results",
    "title": "Model structure",
    "section": "Overview of Results",
    "text": "Overview of Results\nOnce you’ve run a Sim, all the results are stored under sim.results. This is structured similarly to a nested dictionary, with results specific to each module stored in their own dictionaries, like the sim.results.sir.n_infected example above.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html",
    "href": "user_guide/modules_connectors.html",
    "title": "Connectors",
    "section": "",
    "text": "Connectors enable interactions between different modules in Starsim, particularly between disease models. They allow you to model complex epidemiological scenarios where one disease affects the transmission or progression of another disease. For example, you might want to model how having syphilis increases susceptibility to HIV, or how HIV affects the treatment outcomes of other sexually transmitted infections.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#basic-concepts",
    "href": "user_guide/modules_connectors.html#basic-concepts",
    "title": "Connectors",
    "section": "Basic concepts",
    "text": "Basic concepts\nA connector inherits from ss.Connector and implements custom logic to modify disease parameters or agent states based on the presence of other diseases. Connectors are called during each simulation timestep and can dynamically adjust transmission parameters, susceptibility, or other disease characteristics. Specifically, connectors are called after demographics and disease state updates, but before networks, interventions, and disease transmission updates. This means they can influence disease transmission for the current timestep.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#simple-usage",
    "href": "user_guide/modules_connectors.html#simple-usage",
    "title": "Connectors",
    "section": "Simple usage",
    "text": "Simple usage\nThe most straightforward way to use connectors is to define a custom class that inherits from ss.Connector and implements a step() method. This method is called during each simulation timestep and can modify disease parameters based on the current state of the simulation.\nHere’s a simple example showing how HIV and “SIS” diseases can interact, and also illustrates how you would use an analyzer to compare the two simulations:\n\nimport starsim as ss\nimport sciris as sc\nimport numpy as np\nimport matplotlib.pyplot as plt\nsc.options(jupyter=True)\n\nclass SIS_HIV(ss.Connector):\n    \"\"\"\n    Simple connector that modifies HIV susceptibility based on SIS infection status.\n    People with SIS infection are protected from HIV (rel_sus = 0),\n    while susceptible people have normal HIV susceptibility (rel_sus = 1).\n    \"\"\"\n    \n    def step(self):\n        # Get disease modules\n        hiv = self.sim.diseases.hiv\n        sis = self.sim.diseases.sis\n        sis_pos = (sis.infected).uids\n        sis_neg = (sis.susceptible).uids\n        \n        # Modify HIV relative susceptibility based on SIS infection status\n        hiv.rel_sus[sis_neg] = 1.0  # Reset to baseline\n        hiv.rel_sus[sis_pos] = 0  # SIS-infected people cannot acquire HIV\n        return\n\n\nclass check_connector(ss.Analyzer):\n    \"\"\"\n    Analyzer that tracks and plots HIV relative susceptibility and disease prevalence over time.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.time = sc.autolist()     # Store timesteps\n        self.rel_sus = sc.autolist()  # Store mean HIV relative susceptibility\n        self.sis_prev = sc.autolist() # Store SIS prevalence\n        self.hiv_prev = sc.autolist() # Store HIV prevalence\n        return\n\n    def step(self):\n        \"\"\"Record data at each timestep\"\"\"\n        # Get disease references\n        sis = self.sim.diseases.sis\n        hiv = self.sim.diseases.hiv\n        \n        # Append current timestep data\n        self.time += self.ti\n        self.rel_sus += hiv.rel_sus.mean()  # Average HIV relative susceptibility\n        self.sis_prev += sis.results.prevalence[self.ti]  # SIS prevalence\n        self.hiv_prev += hiv.results.prevalence[self.ti]  # HIV prevalence\n        return\n\n    def plot(self):\n        \"\"\"\n        Plot the time series of relative susceptibility and disease prevalence.\n        \"\"\"\n        fig = plt.figure()\n        \n        # Plot each metric\n        for key in ['rel_sus', 'sis_prev', 'hiv_prev']:\n            plt.plot(self.time, self[key], label=key)\n        \n        plt.legend()\n        plt.title(self.sim.label)\n        plt.show()\n        return fig\n    \n# Create disease models\nhiv = ss.HIV(beta=dict(mf=0.1, random=0), init_prev=0.001)\nsis = ss.SIS(beta=dict(mf=0.0, random=0.05))\nmf = ss.MFNet(duration=ss.lognorm_ex(mean=ss.years(5), std=ss.years(5)))\n\n# Configure simulation parameters\npars = dict(\n    diseases=[hiv, sis],\n    networks=[mf,'random'],\n    analyzers=check_connector(),\n    verbose=0\n)\n\n# Create simulations with and without connector\ns1 = ss.Sim(label='Without connector', **pars)\ns2 = ss.Sim(label='With connector', **pars, connectors=SIS_HIV())\n\n# Run simulations in parallel\nmsim = ss.parallel(s1, s2)\n\n# Plot results\nmsim.plot()\nfor sim in msim.sims:\n    sim.analyzers[0].plot()\n\nIn this example, the connector modifies HIV susceptibility based on SIS infection status. You can see that when the connector is active, HIV transmission is significantly reduced because SIS-infected individuals cannot acquire HIV.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#advanced-usage-with-parameters",
    "href": "user_guide/modules_connectors.html#advanced-usage-with-parameters",
    "title": "Connectors",
    "section": "Advanced usage with parameters",
    "text": "Advanced usage with parameters\nFor more complex interactions, you can define parameters in your connector class to control the strength and nature of the interactions. Here’s an example showing bi-directional interactions between HIV and syphilis:\n\nclass HIV_Syphilis(ss.Connector):\n    \"\"\"\n    Advanced connector showing bi-directional interactions between HIV and syphilis.\n    Models how HIV affects syphilis susceptibility/transmission and vice versa,\n    with different effects based on CD4 count (AIDS progression).\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            label='HIV-Syphilis',\n            rel_sus_syph_hiv=2,      # People with HIV are 2x more likely to acquire syphilis\n            rel_sus_syph_aids=5,     # People with AIDS are 5x more likely to acquire syphilis\n            rel_trans_syph_hiv=1.5,  # People with HIV are 1.5x more likely to transmit syphilis\n            rel_trans_syph_aids=3,   # People with AIDS are 3x more likely to transmit syphilis\n            rel_sus_hiv_syph=2.7,    # People with syphilis are 2.7x more likely to acquire HIV\n            rel_trans_hiv_syph=2.7,  # People with syphilis are 2.7x more likely to transmit HIV\n        )\n        self.update_pars(**kwargs)\n        return\n\n    def step(self):\n        \"\"\"Apply HIV-syphilis interactions based on CD4 count and infection status\"\"\"\n        diseases = self.sim.diseases\n        syph = diseases.syphilis\n        hiv = diseases.hiv\n        cd4 = self.sim.people.hiv.cd4\n\n        # Reset relative susceptibility and transmission to baseline\n        syph.rel_sus[:] = 1.0\n        syph.rel_trans[:] = 1.0\n        hiv.rel_sus[:] = 1.0\n        hiv.rel_trans[:] = 1.0\n\n        # People with HIV are more likely to acquire syphilis\n        syph.rel_sus[cd4 &lt; 500] = self.pars.rel_sus_syph_hiv\n        syph.rel_sus[cd4 &lt; 200] = self.pars.rel_sus_syph_aids  # AIDS stage\n\n        # People with HIV are more likely to transmit syphilis\n        syph.rel_trans[cd4 &lt; 500] = self.pars.rel_trans_syph_hiv\n        syph.rel_trans[cd4 &lt; 200] = self.pars.rel_trans_syph_aids\n\n        # People with syphilis are more likely to acquire HIV\n        hiv.rel_sus[syph.active] = self.pars.rel_sus_hiv_syph\n\n        # People with syphilis are more likely to transmit HIV\n        hiv.rel_trans[syph.active] = self.pars.rel_trans_hiv_syph\n        return\n\n# Create disease models\nhiv = ss.HIV(beta={'mf': [0.0008, 0.0004]}, init_prev=0.2)\nsyph = ss.Syphilis(beta={'mf': [0.1, 0.05]}, init_prev=0.05)\n\n# Create network\nmf = ss.MFNet()\n\n# Configure simulation parameters\nkw = dict(\n    diseases=[hiv, syph], \n    networks=mf,\n    n_agents=2000,\n    verbose=0\n)\n\n# Create simulations\ns1 = ss.Sim(label='Without connector', **kw)\ns2 = ss.Sim(label='With connector', connectors=HIV_Syphilis(), **kw)\n\n# Run simulations\nmsim = ss.parallel(s1, s2)\n\n# Compare results\nprint(\"\\nFinal infection counts:\")\nprint(f\"HIV infections - Without connector: {s1.results.hiv.n_infected[-1]}\")\nprint(f\"HIV infections - With connector: {s2.results.hiv.n_infected[-1]}\")\nprint(f\"Syphilis infections - Without connector: {s1.results.syphilis.n_infected[-1]}\")\nprint(f\"Syphilis infections - With connector: {s2.results.syphilis.n_infected[-1]}\")\n\n# Plot comparative results\nfig = plt.figure(figsize=(12, 4))\n\n# HIV infections\nplt.subplot(121)\nplt.plot(s1.timevec, s1.results.hiv.n_infected, label='Without connector', alpha=0.8)\nplt.plot(s2.timevec, s2.results.hiv.n_infected, label='With connector', alpha=0.8)\nplt.title('HIV infections over time')\nplt.xlabel('Year')\nplt.ylabel('Number infected')\nplt.legend()\n\n# Syphilis infections\nplt.subplot(122)\nplt.plot(s1.timevec, s1.results.syphilis.n_infected, label='Without connector', alpha=0.8)\nplt.plot(s2.timevec, s2.results.syphilis.n_infected, label='With connector', alpha=0.8)\nplt.title('Syphilis infections over time')\nplt.xlabel('Year')\nplt.ylabel('Number infected')\nplt.legend()\nplt.show()\n\nThis more complex example demonstrates several important concepts:\n\nParameter definition: Using define_pars() to set configurable parameters for the interaction strengths\nBi-directional effects: Both diseases affect each other’s transmission and susceptibility\nDisease progression considerations: Different effects based on HIV progression (CD4 count)\nMultiple attributes: Modifying both relative susceptibility (rel_sus) and relative transmission (rel_trans)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#combining-connectors-with-interventions",
    "href": "user_guide/modules_connectors.html#combining-connectors-with-interventions",
    "title": "Connectors",
    "section": "Combining connectors with interventions",
    "text": "Combining connectors with interventions\nConnectors can work alongside interventions to model complex treatment scenarios. Here’s an example that combines the HIV-syphilis connector with a treatment intervention:\n\nclass Penicillin(ss.Intervention):\n    \"\"\"\n    Penicillin treatment intervention for syphilis.\n    Also resets HIV transmission/susceptibility parameters when syphilis is cured.\n    \"\"\"\n    \n    def __init__(self, year=2020, prob=0.8):\n        super().__init__()\n        self.prob = prob  # Probability of receiving treatment\n        self.year = ss.date(year)  # Year treatment becomes available\n        return\n\n    def step(self):\n        sim = self.sim\n        if sim.now &gt;= self.year:\n            syphilis = sim.diseases.syphilis\n\n            # Define who is eligible for treatment (currently infected)\n            eligible_ids = syphilis.infected.uids\n            n_eligible = len(eligible_ids)\n\n            if n_eligible &gt; 0:\n                # Determine who receives treatment\n                is_treated = np.random.rand(n_eligible) &lt; self.prob\n                treat_ids = eligible_ids[is_treated]\n\n                # Cure syphilis\n                syphilis.infected[treat_ids] = False\n                syphilis.susceptible[treat_ids] = True\n\n                # Reset HIV parameters (removes syphilis co-infection effects)\n                sim.diseases.hiv.rel_sus[treat_ids] = 1.0\n                sim.diseases.hiv.rel_trans[treat_ids] = 1.0\n        return\n\n# Create simulations with different combinations\nsims = {}\n\n# Base configuration\nbase_kw = dict(\n    diseases=[ss.HIV(beta={'mf': [0.0008, 0.0004]}, init_prev=0.2),\n              ss.Syphilis(beta={'mf': [0.1, 0.05]}, init_prev=0.05)], \n    networks=ss.MFNet(),\n    n_agents=2000,\n    verbose=0\n)\n\n# 1. No connector, no treatment\nsims['baseline'] = ss.Sim(label='Baseline (no connector, no treatment)', **base_kw)\n\n# 2. Connector only\nsims['connector'] = ss.Sim(label='With connector only', \n                          connectors=HIV_Syphilis(), **base_kw)\n\n# 3. Connector + treatment\nsims['both'] = ss.Sim(label='Connector + treatment', \n                     connectors=HIV_Syphilis(), \n                     interventions=Penicillin(year=2020, prob=0.8), **base_kw)\n\n# Run all simulations\nmsim = ss.parallel(*sims.values())\n\n# Create comparison plot\nfig, ax = plt.subplots(2, 2, figsize=(12, 8))\n\n# HIV infections\nax[0,0].set_title('HIV infections over time')\nfor sim in sims.values():\n    ax[0,0].plot(sim.timevec, sim.results.hiv.n_infected, label=sim.label, alpha=0.8)\nax[0,0].axvline(2020, color='red', linestyle='--', alpha=0.5, label='Treatment start')\nax[0,0].set_xlabel('Year')\nax[0,0].set_ylabel('Number infected')\nax[0,0].legend()\n\n# Syphilis infections\nax[0,1].set_title('Syphilis infections over time')\nfor sim in sims.values():\n    ax[0,1].plot(sim.timevec, sim.results.syphilis.n_infected, label=sim.label, alpha=0.8)\nax[0,1].axvline(2020, color='red', linestyle='--', alpha=0.5, label='Treatment start')\nax[0,1].set_xlabel('Year')\nax[0,1].set_ylabel('Number infected')\nax[0,1].legend()\n\n# Cumulative HIV infections\nax[1,0].set_title('Cumulative HIV infections')\nfor sim in sims.values():\n    ax[1,0].plot(sim.timevec, sim.results.hiv.cum_infections, label=sim.label, alpha=0.8)\nax[1,0].set_xlabel('Year')\nax[1,0].set_ylabel('Cumulative infections')\nax[1,0].legend()\n\n# Cumulative syphilis infections\nax[1,1].set_title('Cumulative syphilis infections')\nfor sim in sims.values():\n    ax[1,1].plot(sim.timevec, sim.results.syphilis.cum_infections, label=sim.label, alpha=0.8)\nax[1,1].set_xlabel('Year')\nax[1,1].set_ylabel('Cumulative infections')\nax[1,1].legend()\n\nplt.tight_layout()\nplt.show()\n\n# Print summary statistics\nsc.heading(\"Final results summary:\")\nfor sim in sims.values():\n    hiv_final = sim.results.hiv.n_infected[-1]\n    syph_final = sim.results.syphilis.n_infected[-1]\n    hiv_cum = sim.results.hiv.cum_infections[-1]\n    syph_cum = sim.results.syphilis.cum_infections[-1]\n    print(f\"{sim.label}:\")\n    print(f\"  HIV: {hiv_final:3.0f} current, {hiv_cum:4.0f} cumulative\")\n    print(f\"  Syphilis: {syph_final:3.0f} current, {syph_cum:4.0f} cumulative\")\n\nThis example demonstrates how interventions and connectors work together. The treatment intervention not only cures syphilis but also resets the HIV transmission parameters, effectively removing the co-infection effects when syphilis is treated.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/advanced_random.html",
    "href": "user_guide/advanced_random.html",
    "title": "Random numbers",
    "section": "",
    "text": "The Starsim framework implements a novel approach to sampling from distributions that prevents random number noise from corrupting differences between two simulations. This user guide will demonstrate how to use the common random number (CRN) feature to achieve low-variance differences in simulation results. This feature is important for scenario and sensitivity analyses, where the goal is to isolate the effects of specific changes in model parameters or configurations.\nFor technical details and additional examples, please refer to the following publication: D. J. Klein, R. G. Abeysuriya, R. M. Stuart, and C. C. Kerr, “Noise-free comparison of stochastic agent-based simulations using common random numbers.” arXiv preprint arXiv:2409.02086 (2024).\nThis guide builds on the Advanced Distribution User Guide, so please familiarize yourself with that guide before proceeding.\nIn this user guide, you will: - Understand the concept of common random numbers (CRN) - Learn how to sample from distributions using common random numbers - See the benefits of using CRN for low-variance differences",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Random numbers"
    ]
  },
  {
    "objectID": "user_guide/advanced_random.html#understanding-common-random-numbers-crn",
    "href": "user_guide/advanced_random.html#understanding-common-random-numbers-crn",
    "title": "Random numbers",
    "section": "Understanding Common Random Numbers (CRN)",
    "text": "Understanding Common Random Numbers (CRN)\nCommon Random Numbers (CRN) is a sophisticated technique that enables noise-free accounting of the effects of different parameters or interventions on outcomes like infections averted or lives saved. Starsim is the first and only simulation framework that fully supports CRN, including agent-agent interactions like disease transmission and vital dynamics including births.\nTo understand CRN, you first have to know a little about where random numbers come from. As discussed in the Advanced Distribution User Guide, random numbers are used to make stochastic decisions within the model. Individuals realizations are generated from a pseudo-random number generator (PRNG) using a user-specified seed. The PRNG produces a sequence of numbers that appear random but are actually deterministic, meaning that the same seed will always produce the same sequence of numbers. Here is a simple demonstration using the numpy library:\n\nimport numpy as np\nnp.random.seed(42) # Set the seed to 42\ndraws1 = np.random.random(size=10) # Draw 10 realizations\nprint(f'First draws: {draws1.round(2)}')\n\nnp.random.seed(42) # Reset the seed to 42\ndraws2 = np.random.random(size=10) # Draw 10 realizations\nprint(f'Second draws: {draws2.round(2)}')\n\nassert np.array_equal(draws1, draws2), \"The two sets of draws should be equal since the seed is the same.\"\n\n\nThe problem solved by CRN in agent-based simulation modeling\nMost agent-based modeling frameworks dole out random numbers to agents sequentially, as needed, drawing values from a single centralized random number generator. The problem arises when you want to compare two similar, but different simulations.\nEven if the two simulations are run with the same seed, the difference in outcomes will be a combination of 1. Real and meaningful “mechanistic” differences caused by the different inputs, and 2. Random number noise caused by “stochastic branching.”\nStochastic branching is just a technical term used to describe which random numbers are used to make each decision. The random number noise obscures the real differences, making it difficult to determine the true impact of the changes made in the second simulation.\n\n\nExample of stochastic branching: Fishing 🎣\nAs a simple example, consider the following two simulations of a Fishing module. - Simulation A has 20 agents who are trying to catch fish. On each time step, each agent has a 50% chance of going fishing, and a 20% chance of catching a fish if they go fishing. - Simulation B is identical to Simulation A, except that agent 0 is banned from fishing.\nBoth simulations will use the same random number seed. Because the agents do not interact (they’re not actually competing for the same fish!), the only difference in outcomes should be that agent 0 does not go fishing and therefore will never catch a fish. However, because of the way random numbers are generated, the two simulations will use the same random numbers for different purposes. This means that banning agent 0 from fishing will change which other agents go fishing and catch fish!\nNOTE: We have to specifically disable Starsim’s CRN to observe the problem that all other agent-based modeling frameworks face. To do that in Starsim, we set the _centralized option to True in this example.\nAs a first step, we will create a Fishing module.\n\nimport starsim as ss\n\nclass Fishing(ss.Module):\n    def __init__(self, pars=None, **kwargs):\n        super().__init__()\n        self.define_pars(\n            p_fishing = ss.bernoulli(p=0.5),\n            p_catch = ss.bernoulli(p=0.2),\n            banned_uids = [],\n            verbose = True\n        )\n        self.update_pars(pars=pars, **kwargs)\n        self.define_states(\n            ss.State('fish_caught', default=0)\n        )\n        return\n\n    def step(self):\n        going_fishing_uids = self.pars.p_fishing.filter() # Filter with no arguments tests all agents\n\n        # Remove banned agents from going fishing\n        going_fishing_uids = going_fishing_uids.remove(self.pars.banned_uids)\n\n        catch_uids = self.pars.p_catch.filter(going_fishing_uids)\n        if self.pars.verbose:\n            print(f'Time step {self.ti}:')\n            print(f' * Agents going fishing: {going_fishing_uids}')\n            print(f' * Agents that caught fish: {catch_uids}')\n        self.fish_caught[catch_uids] = self.fish_caught[catch_uids] + 1 # Increment the number of fish caught for each agent that caught a fish\n        return\n\nNow we can build and run the two simulations to compare the results.\n\n# NOTE: For this example, we configure the simulation to be centralized!\nss.options.set(_centralized=True)\n\n# Shared parameters for both simulations\npars = dict(n_agents=20, dur=1, rand_seed=42, start=0)\n\nprint('SIMULATION A: WITHOUT BANNED AGENTS', '-'*25)\nsimA = ss.Sim(interventions=Fishing(), **pars)\nsimA.run()\n\nprint('\\nSIMULATION B: WITH AGENT 0 BANNED', '-'*25)\nsimB = ss.Sim(interventions=Fishing(banned_uids=[0]), **pars)\nsimB.run()\n\nIn simulation A, agents 16 and 18 catch fish on the first time step, but in simulation B, agents 17 and 19 catch fish. Then on the second timestep, we can see that different agents go fishing and that 1, 15, and 19 catch fish in A but only 3 is lucky in B – what?! All we did was to ban agent 0 from fishing. The agents do not interact, so there should not have been a difference!\nWhat we are seeing here is a simple example of the stochastic branching problem. This “random number noise” could easily make it look like banning agent 0 could result in more fish being caught, which should be physically impossible as there are fewer agents fishing.\nTo see the benefit of CRN, we can simply repeat the above example, but this time restoring the _centralized option to its default value of False. This will ensure that the same random numbers are used for the exact same decisions in both simulations, allowing us to see the true impact of banning agent 1 from fishing.\n\n# Restore the _centralized option to False (this is the default, so you don't have to do this)\nss.options.set(_centralized=False)\n\nprint('SIMULATION A: WITHOUT BANNED AGENTS', '-'*25)\nsimA = ss.Sim(interventions=Fishing(), **pars)\nsimA.run()\n\nprint('\\nSIMULATION B: WITH AGENT 1 BANNED', '-'*25)\nsimB = ss.Sim(interventions=Fishing(banned_uids=[1]), **pars)\nsimB.run()\n\nWith CRN, banning agent 0 only prevents agent 0 from catching fish. Everything else is identical, as expected. This is the power of common random numbers.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Random numbers"
    ]
  },
  {
    "objectID": "user_guide/advanced_random.html#tips-for-crn-enabled-sampling-in-starsim",
    "href": "user_guide/advanced_random.html#tips-for-crn-enabled-sampling-in-starsim",
    "title": "Random numbers",
    "section": "Tips for CRN-enabled sampling in Starsim",
    "text": "Tips for CRN-enabled sampling in Starsim\nThis advanced CRN functionality is built into every distribution in Starsim! You will automatically get the benefits of CRN whenever you properly use distributions in your modules. Here are a few tips to ensure proper usage: 1. Use a separate distribution for each “decision” in your code. Ideally, each distribution would only be called one time per time step. 1. Create each distribution one time per module. The __init__ method is a great place to do this. Do not create a new distribution on every step. 1. When sampling from a distribution, pass uids or a boolean mask with length equal to the number of agents in the simulation. This ensures that each agent gets the right random number. 1. If the parameters of your distribution change every step, set the parameter values to a callable function that performs the calculation.\nPreferred and avoided usage examples:\n# PREFERRED: use uids\nall_uids = self.sim.people.auids\nvalues = self.dist.rvs(all_uids)\n\n# PREFERRED: use a boolean mask\nmask = (self.infected) & (self.ti &gt;= self.ti_next_event)\nvalues = self.dist.rvs(mask)\n\n# PREFERRED: set dynamic parameters using a callable\ndef dynamic_p(self, sim, uids):\n    p = np.full_like(uids, fill_value=0.5, dtype=float)\n    p[sim.people.age[uids] &lt; 18] = 0.1\n    return p\ndef __init__(self):\n    self.dist = self.bernoulli(p=dynamic_p)\nuids = self.dist.filter(mask) # Reminder: filter returns the uids where the bernoulli trial is True\n\n# AVOID calling a distribution with a scalar argument\nvalues = self.dist.rvs(len(all_uids))\n\n# AVOID: numpy random\nvalues = np.random.rand(len(all_uids))\n\n# AVOID creating a new distribution every time\ndef step(self):\n    new_dist_every_time = self.bernoulli(p=0.5)\n    values = new_dist_every_time.rvs(all_uids) \n\n# AVOID using the same distribution for multiple decisions\nmy_bernoulli = self.bernoulli(p=0)\nmy_bernoulli.set(p=p_infection)\ninfected_uids = my_bernoulli.filter()\nmy_bernoulli.set(p=p_die)\ndied_uids = my_bernoulli.filter()\n\n# Try to AVOID calling rvs multiple times per step\n# (It's better to get all the values you need in one call)\nfor uid in all_uids:\n    value = self.dist.rvs(uid)\n\n# Try to AVOID overriding parameters every time step\n# (Use dynamic parameters instead)\ndef step(self):\n    my_p_vec = np.full(self.sim.n, fill_value=0.5)\n    my_p_vec[self.sim.people.age &lt; 18] = 0.1\n    self.dist.set(p=my_p_vec)\n    uids = self.dist.filter(mask)\nPlease don’t hesitate to create issues related to any problems you encounter or reach out to use at info@starsim.org.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Random numbers"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html",
    "href": "user_guide/advanced_distributions.html",
    "title": "Distributions",
    "section": "",
    "text": "Agent-based models draw random numbers from distributions to simulate various phenomena. Realizations (also called draws or samples) from distributions are used to model everything from the duration of each infection to the number of contacts each individual has in a network to the outcomes of individual diagnostic tests. The Starsim framework includes state of the art functionality for specifying and sampling from statistical distributions.\nIn this guide, you will: - Learn which distributions are available in Starsim. - See how to use Starsim framework functionality to create a frozen distribution, generate samples, visualize the distribution, and extract statistics. - Set or update model parameters that are distributions. - Use distributions with “dynamic parameters” that depend on agent attributes, the simulation time, or other factors. - Build an example Starsim intervention that uses a distribution with dynamic parameters.\nOne key advantage of Starsim distributions is that they enable low-variance comparison between simulations through a technique called “common random numbers” (CRN). To learn more about CRN, see the Common Random Numbers guide.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#available-distributions",
    "href": "user_guide/advanced_distributions.html#available-distributions",
    "title": "Distributions",
    "section": "Available distributions",
    "text": "Available distributions\nThe starsim framework includes a wide range of distributions that can be used to model various phenomena. The following distributions are available:\n\n\n\n\n\n\n\n\n\nDistribution\nStarsim Dist\nParameters\nDescription\n\n\n\n\nRandom\nrandom\nNone\nRandom number between 0 and 1.\n\n\nUniform\nuniform\nlow, high\nRandom number between a specified minimum and maximum.\n\n\nNormal\nnormal\nloc (mean), scale (standard deviation)\nRandom number from a normal (Gaussian) distribution with specified mean and standard deviation.\n\n\nLognormal (implicit)\nlognormal_im\nmean, sigma (of the underlying normal distribution)\nRandom number from a lognormal distribution specified by the mean and standard deviation of the underlying normal distribution.\n\n\nLognormal (explicit)\nlognormal_ex\nmean, std (of the distribution itself; mean must be positive)\nRandom number from a lognormal distribution specified by the mean and standard deviation of the distribution itself.\n\n\nExponential\nexpon\nscale (mean of the distribution, equivalent to 1/λ)\nRandom number from an exponential distribution with specified scale parameter.\n\n\nPoisson\npoisson\nlam\nRandom number from a Poisson distribution with specified rate parameter.\n\n\nNegative Binomial\nnbinom\nn, p (number of successes, probability of success)\nRandom number from a negative binomial distribution with specified parameters.\n\n\nWeibull\nweibull\nc (shape parameter, sometimes called “k”), loc (shifts the distribution), scale (sometimes called “λ”)\nRandom number from a Weibull distribution with specified parameters, uses scipy’s weibull_min.\n\n\nGamma\ngamma\na (shape parameter, sometimes called “k”), loc (shifts the distribution), scale (sometimes called “θ”)\nRandom number from a gamma distribution with specified shape and scale parameters.\n\n\nConstant\nconstant\nv\nConstant value, useful for fixed parameters and testing.\n\n\nRandom Integer\nrandint\nlow, high\nRandom integer between a specified minimum and maximum.\n\n\nBernoulli\nbernoulli\np\nRandom number from a Bernoulli distribution with specified probability of success. Bernoulli distributions are used frequently to determine binary outcomes, such as whether an agent is infected or not.\n\n\nChoice\nchoice\na (int or list of choices), p (probability of each choice)\nRandomly select from a list of values. This distribution only supports fixed parameters.\n\n\nHistogram\nhistogram\nvalues, bins, density, data\nRandom number from a histogram distribution specified by a list of values and their corresponding probabilities.\n\n\n\nSee the API reference for more details.\nYou can also create a custom distribution by extending the Dist class from Starsim.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#how-to-use-starsim-distributions",
    "href": "user_guide/advanced_distributions.html#how-to-use-starsim-distributions",
    "title": "Distributions",
    "section": "How to use Starsim distributions",
    "text": "How to use Starsim distributions\nParameters for Starsim distributions can have fixed parameters (the same for all agents) or vary dynamically. We will start with a simple normal distribution with fixed parameters.\n\nimport starsim as ss\nimport numpy as np\n\n# Create a Normal distribution with mean 0 and standard deviation 1\n# The \"strict\" flag is needed only for this example to avoid warnings\nd = ss.normal(name=\"Normal with fixed parameters\", loc=0, scale=1, strict=False)\n# ^^^ The above \"d\" object is the \"frozen\" distribution.\n\nprint(d)\n\n\nDrawing samples\nSamples from a distribution can be drawn using the rvs method.\nWhile possible to request a specific number of samples, as shown below, please know that this is not the preferred way to use distribution in Starsim.\n\ndraws = d.rvs(5)\nprint(draws)\n\nThe above approach is better than calling numpy.random directly, but still not ideal because it does not allow for dynamic parameter nor low-noise sampling. Therefore, please instead call the rvs method with the unique identifiers (uids) of the agents for which you need samples. Alternatively, you can pass a boolean mask of length equal to the number of agents in the simulation.\n\n # Create a simulation for context\n # [you will not need to do this when working within the framework]\nsim = ss.Sim(n_agents=10).init()\n\n# Specify the distribution, here a random integer between -10 and 10\nd_sim = ss.randint(name=\"Random integer with fixed parameters\", low=-10, high=10)\nd_sim.init(sim=sim) # Initialize the distribution [done automatically in the framework]\n\n# Instead of requesting 5 random numbers, the preferred pattern is to request\n# random numbers for specific agents by passing a list of agent IDs. Doing so\n# enable the powerful dynamic parameters to be used while also supporting the\n# low-noise common random number sampling.\ndraws = d_sim.rvs([3, 5, 2, 9, 4]) # Draw samples for specific agents by UID\nprint(f\"Draws for agents 3, 5, 2, 9, and 4: {draws}\")\n\nmask = sim.people.age &lt; 25\ndraws_mask = d_sim.rvs(mask) # Draw samples for agents under 25 from a boolean mask\nprint(f\"Draws for agents under 25: {draws_mask}\")\n\ndraws_all = d_sim.rvs(sim.people.uid) # Draw samples for all agents\nprint(f\"Draws for all agents (0, 1, 2, ..., n_agents): {draws_all}\")\n\n\n\nVisualizing distributions\nLet’s take a look at the distribution by plotting a histogram of samples.\n\nrvs = d.plot_hist(n=1000, bins=30)\n\n\n\nExtracting distribution statistics\nWe can quickly calculate statistics of the distribution by accessing the underlying “dist” property of the distribution.\n\nunderlying_dist = d.dist\nprint(\"Mean:\", underlying_dist.mean())\nprint(\"Standard Deviation:\", underlying_dist.std())\nprint(\"95% Interval:\", underlying_dist.ppf([0.025, 0.975]))",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#setting-model-parameters-that-are-distributions",
    "href": "user_guide/advanced_distributions.html#setting-model-parameters-that-are-distributions",
    "title": "Distributions",
    "section": "Setting model parameters that are distributions",
    "text": "Setting model parameters that are distributions\nMany Starsim modules directly expose distributions as parameters for user customization. For example, the SIR disease module has three parameters are distributions:\n\n\n\n\n\n\n\n\nParameter\nMeaning\nDefault Value\n\n\n\n\ninit_prev\nInitial prevalence of infection\nss.bernoulli(p=0.01)\n\n\ndur_inf\nDuration of infection\nss.lognorm_ex(mean=ss.dur(6))\n\n\np_death\nProbability of death given infection\nss.bernoulli(p=0.01)\n\n\n\nYou can change these parameters away from their defaults by passing in a different distribution, as demonstrated below:\n\nsir = ss.SIR(\n    # Set the init_prev parameter to randomly infect 15% of the population\n    init_prev = ss.bernoulli(p=0.15),\n\n    # Set the dur_inf parameter to a Weibull\n    dur_inf = ss.weibull(c=2, loc=1, scale=2)\n)\n\n# Alternatively, update parameters of a default distribution\nsir.pars.p_death.set(p=0.5) # Update the death probability to 50%\n\n# Create, run, and plot a sim using the SIR disease model\nsim = ss.Sim(n_agents=100, diseases=sir, dur=15, dt=1, start=0, networks=ss.RandomNet())\nsim.run().plot()\n\nIt’s easy to inspect distributions, for example dur_inf of the SIR module using plot_hist.\nNOTE: in the code below that we access dur_inf at sim.diseases.sir.pars rather than at sir.pars (referencing the module in the previous cell) because Starsim makes a copy. The sir is not initialized and does not have the sim context.\n\nrvs = sim.diseases.sir.pars.dur_inf.plot_hist()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#using-distributions-with-dynamic-parameters",
    "href": "user_guide/advanced_distributions.html#using-distributions-with-dynamic-parameters",
    "title": "Distributions",
    "section": "Using distributions with dynamic parameters",
    "text": "Using distributions with dynamic parameters\nUp to this point, the distributions we have used have had fixed parameters. Every agent draws will draw from the same distribution at every time step. But Starsim has a powerful feature to specify distributions with dynamic parameters that can change based on agent attributes, simulation time, or other factors.\nLet’s continue with the SIR example, but make the initial prevalence of infection depend on the age of the agent. Instead of a fixed probability for all agents, let’s make it so that children under 15 years old have a 25% chance of being selected as a “seed” infection and adults over 15 years old have a 10% chance.\nTo implement dynamic parameters, we set the parameter (p in the case of a Bernoulli distribution) to a callable like a function. The callable must accept three arguments: 1. self: The module that is calling the distribution 2. sim: The simulation object 3. uids: The unique IDs of the agents being processed It should return a numpy array of the same length as uids containing the parameter value for each agent, or a scalar if the parameter is the same for all agents.\n\ndef set_p_by_age(self, sim, uids):\n    p = np.full(len(uids), fill_value=0.10)  # Default 10% infection probability\n    p[sim.people.age &lt; 15] = 0.25  # 25% for ages &lt; 15\n    \n    # For demonstration, print the age and probability for each agent:\n    for uid, age, prob in zip(uids, sim.people.age[uids], p):\n        print(f\"Agent {uid} | Age: {age:5.2f} |  Infection Seed Probability: {prob:.0%}\")\n    return p\n\nsir = ss.SIR(\n    # Set init_prev as a dynamic parameter\n    init_prev = ss.bernoulli(p=set_p_by_age),\n)\n\n# Create, run, and plot a sim using the SIR disease model\nsim = ss.Sim(n_agents=10, diseases=[sir], dur=30)\nsim.run()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#example-starsim-intervention-using-dynamic-distributions",
    "href": "user_guide/advanced_distributions.html#example-starsim-intervention-using-dynamic-distributions",
    "title": "Distributions",
    "section": "Example Starsim intervention using dynamic distributions",
    "text": "Example Starsim intervention using dynamic distributions\nTo demonstrate the use and power of distributions in the Starsim framework, we next create an intervention that delivers a vaccine to a random subset of agents using a Bernoulli distribution. The default distribution will be fixed, the same for all agents, but we’ll make it a parameter to that the user can change it without having to modify the source code.\nNOTE: That we create the distribution only one time in the __init__ method of the intervention. Here, the distribution is part of the parameters, so will appear at self.pars.p_vx. Alternatively, we could create a distribution between update_pars and return, as noted. Please avoid recreating a Starsim distribution on every time step.\n\nclass MyVx(ss.Intervention):\n    def __init__(self, pars=None, **kwargs):\n        super().__init__()\n        self.define_states(\n            ss.State('vaccinated', label=\"Vaccinated\", default=False)\n        )\n        self.define_pars(\n            # Create a Bernoulli distribution as a module parameter\n            # The value p=0.1 is a placeholder, the user will override\n            p_vx = ss.bernoulli(p=0.1, name=\"Vaccination Probability\")\n        )\n        self.update_pars(pars=pars, **kwargs)\n\n        # NOTE, this is a great place to create other distributions, for example\n        # self.my_dist = ss.normal(loc=0, scale=1)\n\n        return\n\n    def init_results(self):\n        super().init_results()\n        self.define_results(\n            ss.Result('new_vx', dtype=int, label=\"Newly Vaccinated\")\n        )\n        return\n\n    def step(self):\n        # Choose which agents to vaccinate\n        novx = self.vaccinated == False # Boolean mask\n        # Filter to select agents for which the Bernoulli sample is True\n        vx_uids = self.pars.p_vx.filter(novx) # &lt;-- can pass in mask or uids\n        self.vaccinated[vx_uids] = True  # Set the state to vaccinated\n        sim.diseases.sir.rel_sus[vx_uids] = 0.0  # Set susceptibility to 0 for vaccinated agents\n        \n        # Store the results\n        self.results.new_vx[sim.ti] = len(vx_uids)\n\nNow that we have created the intervention, we can configure it with a custom p_vx_func in “user space” and run the simulation.\n\ndef p_vx_func(self, sim, uids):\n    # Set the probability of vaccination for each agent in uids\n    # This is the \"dynamic\" callable for p_vx\n\n    # Let's only administer the vaccine on the 5th time step\n    if sim.ti != 5:\n        return 0.0 \n\n    # Set vaccination probability proportional to age\n    p = sim.people.age[uids] / 100.0  # Normalize age to a probability between 0 and 1\n    p = p.clip(0.0, 1.0)  # Ensure probabilities are between 0 and 1\n    return p # p has the same length as uids\n\n\nvx_intv = MyVx(p_vx = ss.bernoulli(p=p_vx_func))\n\n# Create, run, and plot a sim using the SIR disease model\nsim = ss.Sim(n_agents=1000, dur=10, dt=1, start=0,\n    diseases=ss.SIR(), # Default SIR disease model\n    interventions=[vx_intv],\n    networks=ss.RandomNet()\n)\nsim.run().plot('Myvx') # Verify vaccinations only on the 5th time step\n\nSee how vaccines were delivered only on time step 5? If we were to look at which agents received the vaccine, we would see probability increasing with age.\nThis concludes this user guide. If you have any questions or feedback, please create an issue or reach out to info@starsim.org.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html",
    "href": "user_guide/intro_starsim.html",
    "title": "What is Starsim?",
    "section": "",
    "text": "Starsim is a framework for modeling the spread of diseases among agents via dynamic transmission networks. Starsim supports: * Co-transmission of multiple diseases at once, capturing how they interact biologically and behaviorally * Non-infectious diseases, either on their own or as factors affecting the transmission or mortality of infectious diseases * Detailed modeling of mother-child relationships starting from conception, allowing investigation of infant and childhood diseases * Multiple types of transmission network, including theoretical (e.g. Erdős–Rényi) and realistic (e.g. age-assortative sexual partnerships) * Different intervention types, such as vaccines or treatments, and showing their impact through different delivery methods such as mass campaigns or targeted outreach * Automated calibration to data, plus careful handling of random numbers to minimize variance between simulations\nStarsim is available for both Python and R, and is fully open-source under the MIT license.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#introduction",
    "href": "user_guide/intro_starsim.html#introduction",
    "title": "What is Starsim?",
    "section": "",
    "text": "Starsim is a framework for modeling the spread of diseases among agents via dynamic transmission networks. Starsim supports: * Co-transmission of multiple diseases at once, capturing how they interact biologically and behaviorally * Non-infectious diseases, either on their own or as factors affecting the transmission or mortality of infectious diseases * Detailed modeling of mother-child relationships starting from conception, allowing investigation of infant and childhood diseases * Multiple types of transmission network, including theoretical (e.g. Erdős–Rényi) and realistic (e.g. age-assortative sexual partnerships) * Different intervention types, such as vaccines or treatments, and showing their impact through different delivery methods such as mass campaigns or targeted outreach * Automated calibration to data, plus careful handling of random numbers to minimize variance between simulations\nStarsim is available for both Python and R, and is fully open-source under the MIT license.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#types-of-disease-modeling",
    "href": "user_guide/intro_starsim.html#types-of-disease-modeling",
    "title": "What is Starsim?",
    "section": "Types of disease modeling",
    "text": "Types of disease modeling\nStarsim is an agent-based model (ABM). ABMs are most suitable for questions that are moderately complex, and have medium to large amounts of data available:\n\n\n\nTypes of Model\n\n\nFor simpler questions, statistical or compartmental models are often all that’s needed. For very complex questions, LLMs (which themselves might be trained on agent-based model outputs) may be more suitable. Examples of each type of question are: * Statistical models: “Are people who received the vaccine less likely to get infected?” * Machine learning models: “What behavioral factors influence vaccination uptake?” * Compartmental models: “What is disease prevalence going to be in 5 years given 100% vaccine uptake?” * Agent-based models: “What is disease prevalence going to be in 5 years given realistic assumptions about screening and vaccine coverage?”",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#why-starsim",
    "href": "user_guide/intro_starsim.html#why-starsim",
    "title": "What is Starsim?",
    "section": "Why Starsim?",
    "text": "Why Starsim?\nStarsim aims to address the limitations of existing ABMs, specifically along the dimensions of usability, capability, and outcome:\n\n\n\n\n\n\n\n\nDimension\nStarsim\nStatus quo\n\n\n\n\nUsability\nStarsim is fast, has a simple interface, and only requires knowledge of Python\nMany ABMs are slow, complex, or require knowledge of C++/Java\n\n\nCapability\nStarsim supports multiple custom diseases and networks, including co-transmission\nMost other disease models are single-disease or hard-coded to a handful of diseases\n\n\nOutcome\nOnce you’ve collected your data, modeling your questions with Starsim takes days to weeks\nWriting, testing, and calibrating a custom model can take months to years\n\n\n\nWhile of course not all existing aABMs have these limitations, many of them have at least one. (For a good review of general-purpose ABMs, see Antelmi et al. 2023).",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#starsim-principles",
    "href": "user_guide/intro_starsim.html#starsim-principles",
    "title": "What is Starsim?",
    "section": "Starsim principles",
    "text": "Starsim principles\nStarsim’s design philosophy has two parts. First, “Common tasks should be simple”. Examples include: - Defining parameters - Running a simulation - Plotting results\nThese are things you need to do in every single Starsim analysis, so we’ve tried to make them as easy as possible.\nThe second part of the philosophy is “Custom tasks can’t always be simple, but they should still be possible”. Examples include: - Introducing a new vaccine - Implementing a new disease - Writing a custom calibration function\nIf you’re implementing a complicated disease, there will always be some irreducible complexity involved in that. Starsim’s job is to help you where it can, but then get out of the way and let you write your code.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#should-i-use-starsim",
    "href": "user_guide/intro_starsim.html#should-i-use-starsim",
    "title": "What is Starsim?",
    "section": "Should I use Starsim?",
    "text": "Should I use Starsim?\nStarsim is suitable for many use cases, but not all. Some examples of suitable Starsim use cases are:\n\nIf you are currently doing agent-based modeling but your model is too slow/inflexible/hard to use for your research questions\n\nExample: Your model takes 14 hours for a single run, and every year you’re worried that your computing grant won’t be renewed\n\nIf you are currently doing compartmental modeling, and want to try out an agent-based model without investing 3-6 months learning how to use it\n\nExample: Your compartmental mpox model has so far been very effective, but you’ve been asked to evaluate an individually-targeted intervention that requires tracking individual agents\n\nIf you want to quickly prototype different diseases or networks before deciding whether to implement them in your full model\n\nExample: You know and love your HIV model, but you want to see what the impact would be of including syphilis co-transmission or a different type of MSM network\n\n\nHowever, there are other cases where Starsim is not suitable. These include:\n\nIf compartmental models are sufficient for your questions, you should probably stick with them (for R, consider Epidemics; for Python, consider Atomica)\nIf your current model is highly specialized to a given context, the switching cost of moving to Starsim may not be worthwhile (but we are working on AI tools to translate other disease models automatically)\nIf you are modeling malaria or other spatial simulations, Starsim doesn’t currently support spatial interactions natively (but we are considering adding it in future)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html",
    "href": "user_guide/modules_interventions.html",
    "title": "Interventions",
    "section": "",
    "text": "This guide describes how to implementing interventions in Starsim. Interventions represent actions that affect disease transmission, such as screening, treatment, and vaccination programs.\nFor learning-oriented content on interventions, see Tutorial 6 - Interventions.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html#comparison-of-intervention-classes",
    "href": "user_guide/modules_interventions.html#comparison-of-intervention-classes",
    "title": "Interventions",
    "section": "Comparison of intervention classes",
    "text": "Comparison of intervention classes\n\nBase classes\n\n\n\n\n\n\n\n\nClass\nPurpose\nKey features\n\n\n\n\nIntervention\nBase intervention class\nEligibility checking, product integration, step() method\n\n\nRoutineDelivery\nContinuous delivery over time\nInterpolated probabilities, annual/timestep rates\n\n\nCampaignDelivery\nOne-off or discrete campaigns\nSpecific years, optional interpolation\n\n\nBaseTest\nBase for screening/triage\nProduct administration, outcome tracking\n\n\nBaseScreening\nScreening programs\nPopulation-level eligibility checking\n\n\nBaseTriage\nTriage/follow-up testing\nTargeted eligibility (e.g., screen positives)\n\n\nBaseTreatment\nTreatment interventions\nQueue management, eligibility validation\n\n\nBaseVaccination\nVaccination programs\nDose tracking, vaccination state management\n\n\n\n\n\nScreening interventions\n\n\n\n\n\n\n\n\nClass\nDelivery pattern\nUse case\n\n\n\n\nroutine_screening\nContinuous\nRegular screening programs (e.g., annual STI screening)\n\n\ncampaign_screening\nDiscrete\nMass screening events (e.g., outbreak response)\n\n\nroutine_triage\nContinuous\nFollow-up testing for positives\n\n\ncampaign_triage\nDiscrete\nCampaign-based confirmatory testing\n\n\n\n\n\nTreatment interventions\n\n\n\n\n\n\n\n\nClass\nCapacity Model\nUse Case\n\n\n\n\ntreat_num\nFixed capacity per timestep\nResource-constrained treatment programs\n\n\n\n\n\nVaccination interventions\n\n\n\nClass\nDelivery Pattern\nUse Case\n\n\n\n\nroutine_vx\nContinuous\nRoutine immunization programs\n\n\ncampaign_vx\nDiscrete\nMass vaccination campaigns",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html#implementation-patterns",
    "href": "user_guide/modules_interventions.html#implementation-patterns",
    "title": "Interventions",
    "section": "Implementation patterns",
    "text": "Implementation patterns\n\nEligibility functions\nInterventions use eligibility functions to determine who can receive the intervention:\n# Lambda functions for simple eligibility\neligible_adults = lambda sim: (sim.people.age &gt;= 18).uids\n\n# More complex eligibility combining multiple conditions  \ndef high_risk_eligibility(sim):\n    adults = sim.people.age &gt;= 18\n    sexually_active = sim.networks.mfnet.participant\n    return (adults & sexually_active).uids\n\n# Using intervention outcomes for triage\nscreen_positives = lambda sim: sim.interventions.screening.outcomes['positive']\n\n\nProduct integration\nInterventions work with products that define the actual medical intervention:\n# Using built-in products\nscreening = ss.routine_screening(\n    product='rpr',  # String reference to built-in product\n    prob=0.9,\n    start_year=2020\n)\n\n# Using custom products\nmy_vaccine = ss.sir_vaccine(efficacy=0.8)\nvaccination = ss.routine_vx(\n    product=my_vaccine,  # Product object\n    prob=0.6,\n    start_year=2015\n)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html#adding-multiple-interventions",
    "href": "user_guide/modules_interventions.html#adding-multiple-interventions",
    "title": "Interventions",
    "section": "Adding multiple interventions",
    "text": "Adding multiple interventions\nIf you want to add multiple of the same intervention, you need to give them different names. (This also applies to diseases and other modules.) This example compares simulations with 0, 1, or 2 vaccines:\n\nimport starsim as ss\n\n# Create the product - a vaccine with 80% efficacy\nvx = ss.sis_vaccine(efficacy=0.8)\n\n# Create the interventions -- low and high coverage\nintv_low  = ss.routine_vx(name='intv_low', start_year=2010, prob=0.2, product=vx)\nintv_high = ss.routine_vx(name='intv_high', start_year=2020, prob=0.6, product=vx)\n\n# Create the sims\npars = dict(n_agents=5000, networks='random', diseases='sis', verbose=0)\ns0 = ss.Sim(pars, label='Baseline')\ns1 = ss.Sim(pars, label='Low vaccine coverage', interventions=intv_low)\ns2 = ss.Sim(pars, label='Low + high vaccine coverage', interventions=[intv_low, intv_high])\n\n# Run & plot\nmsim = ss.parallel(s0, s1, s2)\nmsim.plot('sis_new_infections')",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/advanced_profiling.html",
    "href": "user_guide/advanced_profiling.html",
    "title": "Profiling and performance",
    "section": "",
    "text": "One of the main reasons people don’t use ABMs is because they can be very slow. While “vanilla Starsim” is quite fast (10,000 agents running for 100 timesteps should take about a second), custom modules, if not properly written, can be quite slow.\nThe first step of fixing a slow module is to identify the problem. To do this, Starsim includes some built-in profiling tools.\nLet’s look at a simple simulation:\n\nimport sciris as sc\nimport starsim as ss\nsc.options(jupyter=True)\n\npars = dict(\n    start = '2000-01-01',\n    stop = '2020-01-01',\n    diseases = 'sis',\n    networks = 'random'\n)\n\n# Profile sim\nsim = ss.Sim(pars)\nprof = sim.profile()\n\nThis graph (which is a shortcut to sim.loop.plot_cpu()) shows us how much time each step in the integration loop takes. We can get line-by-line detail of where each function is taking time, though:\n\nprof.disp(maxentries=5)\n\n(Note that the names of the functions here refer to the actual functions called, which may not match the graph above. That’s because, for example, ss.SIS does not define its own step() method, but instead inherits step() from Infection. In the graph, this is shown as sis.step(), but is listed in the table as Infection.step(). This is because it’s referring to the actual code being run, so refers to where those lines of code exist in the codebase; there is no code corresponding to SIS.step() since it’s just inherited from Infection.step().)\nIf you want more detail, you can also define custom functions to follow. For example, we can see that ss.SIS.infect() takes the most time in ss.SIS.step(), so let’s profile that:\n\nprof = sim.profile(follow=ss.SIS.infect, plot=False)\nprof.disp()\n\n(Note: you can only follow functions that are called as part of sim.run() this way. To follow other functions, such as those run by sim.init(), you can use sc.profile() directly.)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Profiling and performance"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html",
    "href": "user_guide/advanced_nonstandard.html",
    "title": "Nonstandard usage",
    "section": "",
    "text": "Although Starsim is primarily intended as an agent-based disease model, due to its modular structure, it can be used for other applications as well. This tutorial describes how Starsim can be used (1) as a compartmental disease model, and (2) as a general-purpose agent-based model.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html#compartmental-modeling",
    "href": "user_guide/advanced_nonstandard.html#compartmental-modeling",
    "title": "Nonstandard usage",
    "section": "Compartmental modeling",
    "text": "Compartmental modeling\nMuch of Starsim’s power comes from how it handles agents. However, agent-based modeling may be too slow or too complex for some problems. While in many cases it probably makes more sense to do compartmental disease modeling in another framework (such as Atomica), it is also possible to do it within Starsim, taking advantage of features such as demographics, time units, etc. This is especially useful for a multi-disease simulation where some diseases need the detail and flexibility of an ABM, while others can be modeled more simply (and faster) as compartmental models.\n\nSetting up the model\nHere we will define a simple compartmental susceptible-infectious-susceptible (SIS) model. The model definition here is quite similar to the agent-based implementation in Starsim’s SIR module; differences are noted in comments. Note that the model runs extremely fast, since a three-state compartmental model (susceptible, infecious, and immunity) runs as fast as an agent-based model with three agents!\n\n\"\"\"\nExample compartmental SIS model for Starsim\n\"\"\"\n\nimport starsim as ss\nimport sciris as sc\nimport matplotlib.pyplot as plt\n\n\nclass CompartmentalSIS(ss.Module): # We don't need the extra functionality of the Infection class, so just inherit from Module\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            beta = ss.Rate(0.8), # Leverage Starsim's automatic time unit handling\n            init_prev = 0.01, # NB: this is a scalar, rather than a distribution for an ABM\n            recovery = ss.Rate(0.1), # Also not a distribution\n            waning = ss.Rate(0.05),\n            imm_boost = 1.0,\n            use_immunity = True,\n        )\n        self.update_pars(**kwargs)\n        \n        # Don't need to define states; just use scalars\n        self.N = 0\n        self.S = 0\n        self.I = 0\n        self.immunity = 0\n        return\n    \n    def init_post(self):\n        \"\"\" Finish initialization \"\"\"\n        super().init_post()\n        self.N = len(self.sim.people) # Assumes a static population; could also use a dynamic population size\n        i0 = self.pars.init_prev\n        self.S = self.N*(1-i0)\n        self.I = self.N*i0\n        self.immunity = i0\n        return\n        \n    @property\n    def rel_sus(self):\n        return 1 - self.immunity\n    \n    def step(self):\n        \"\"\" Carry out disease transmission logic \"\"\"\n        self.immunity *= (1 - self.pars.waning*self.t.dt) # Update immunity from waning\n        rel_sus = self.rel_sus if self.pars.use_immunity else 1.0\n        infected = (self.S*self.I/self.N)*(self.pars.beta*self.t.dt)*rel_sus # Replaces Infection.infect()\n        recovered = self.I*self.pars.recovery*self.t.dt # Replaces setting a time to recovery and checking that time\n        net = infected - recovered # Net change in number infectious\n        self.S -= net\n        self.I += net\n        self.immunity += infected/self.N*self.pars.imm_boost # Update immunity from new infections\n        return\n    \n    def init_results(self):\n        \"\"\" Initialize results \"\"\"\n        super().init_results()\n        self.define_results(\n            ss.Result('S', label='Susceptible'),\n            ss.Result('I', label='Infectious'),\n        )\n        return\n\n    def update_results(self):\n        \"\"\" Store the current state \"\"\"\n        super().update_results()\n        self.results['S'][self.ti] = self.S\n        self.results['I'][self.ti] = self.I\n        return \n\n    def plot(self):\n        \"\"\" Default plot for SIS model \"\"\"\n        fig = plt.figure()\n        res = self.results\n        kw = dict(lw=2, alpha=0.7)\n        for rkey in ['S', 'I']:\n            plt.plot(res.timevec, res[rkey], label=res[rkey].label, **kw)\n        plt.legend(frameon=False)\n        plt.xlabel('Time')\n        plt.ylabel('Number of people')\n        plt.ylim(bottom=0)\n        sc.boxoff()\n        sc.commaticks() \n        plt.show()      \n        return\n    \n\n# Run the compartmental simulation (csim)\ncsim = ss.Sim(diseases=CompartmentalSIS(), dur=100, dt=0.1, verbose=0.01)\ncsim.run()\n\n# Plot the results\ncsim.diseases.compartmentalsis.plot()\n\nLet’s compare to our standard agent-based SIS model with similar parameters:\n\nimport starsim as ss\n\n# Run the model\nabm = ss.Sim(diseases=ss.SIS(beta=0.03), networks='random', dur=100, dt=0.1, verbose=0.01)\nabm.run()\n\n# Plot the results\nabm.diseases.sis.plot()\n\nThe results are broadly similar, although there are differences due to the network transmission, duration of infection, etc. Note that the compartmental version runs 20 times faster than the agent-based version. Does this mean that compartmental models are better than agent-based models? If all you want to simulate is a simple SIS model, then … the answer is probably yes!",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html#epiverse-epidemics-school-closure-model",
    "href": "user_guide/advanced_nonstandard.html#epiverse-epidemics-school-closure-model",
    "title": "Nonstandard usage",
    "section": "Epiverse Epidemics: School closure model",
    "text": "Epiverse Epidemics: School closure model\nThis example adapts the example from the Epidemics v0.4.0 R package:\nhttps://epiverse-trace.github.io/epidemics/\nNote that it does not use the same level of detail as the original in terms of the population or contact matrices, but produces similar results.\n\nimport numpy as np\nimport pandas as pd\nimport sciris as sc\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Intervention\nclass close_schools(ss.Intervention):\n  \"\"\" Approximate closing schools by reducing susceptibility and transmissibility of children \"\"\"\n  def __init__(self, start=50, stop=80, reduction=0.5):\n    super().__init__()\n    self.start = start\n    self.stop = stop\n    self.reduction = reduction\n    return\n  \n  def step(self):\n    disease = self.sim.diseases[0]\n    children = self.sim.people.age &lt; 20\n    if self.now == self.start:\n      disease.rel_sus[children] *= 1-self.reduction\n      disease.rel_trans[children] *= 1-self.reduction\n    elif self.now == self.stop:\n      disease.rel_sus[children] = 1.0\n      disease.rel_trans[children] = 1.0\n    return\n\n# Analyzer\nclass infections_by_age(ss.Analyzer):\n  \"\"\" Count infections by age \"\"\"\n  def __init__(self, age_bins=(0, 20, 40, 100)):\n    super().__init__()\n    self.age_bins = age_bins\n    self.mins = age_bins[:-1]\n    self.maxes = age_bins[1:]\n    self.hist = {k:[] for k in self.mins}\n    return\n  \n  def init_pre(self, sim):\n    super().init_pre(sim)\n    self.infections = np.zeros(len(self.sim.people.age))\n    return\n  \n  def step(self):\n    age = self.sim.people.age\n    disease = self.sim.diseases[0]\n    for min, max in zip(self.mins, self.maxes):\n      mask = (age &gt;= min) & (age &lt; max)\n      self.hist[min].append(disease.infected[mask].sum())\n    return\n  \n  def plot(self):\n    plt.figure()\n    for min, max in zip(self.mins, self.maxes):\n      plt.plot(self.sim.t.timevec, self.hist[min], label=f'Age {min}-{max}')\n    intv = self.sim.interventions[0]\n    for val in [intv.start, intv.stop]:\n      plt.axvline(val, linestyle=':')\n    plt.legend(frameon=False)\n    plt.xlabel('Model time (days)')\n    plt.ylabel('Individuals infected')\n    plt.ylim(bottom=0)\n    sc.boxoff()\n    plt.show()\n    return\n  \n# Run the model\nsim = ss.Sim(\n  people = ss.People(n_agents=20e3, age_data=pd.read_csv('test_data/nigeria_age.csv')),\n  diseases = dict(\n      type = 'sir',\n      init_prev = 0.001,\n      beta = 1/100,\n      dur_inf = 20.0,\n  ),\n  networks = 'random',\n  interventions = close_schools(),\n  analyzers = infections_by_age(),\n  start = 0,\n  stop = 300,\n  dt = 1.0,\n  unit = 'day',\n  verbose = False,\n)\n\nsim.run()\nsim.analyzers.infections_by_age.plot()\n\nWhile the Starsim version is longer than the Epidemics version, note that Epidemics has built-in contacts interventions and automatically reports infections by age. These have to be manually added to Starsim, but in turn Starsim provides much more control.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html#mesa-wealth-model",
    "href": "user_guide/advanced_nonstandard.html#mesa-wealth-model",
    "title": "Nonstandard usage",
    "section": "Mesa: Wealth model",
    "text": "Mesa: Wealth model\nThis example illustrates a simple “weath model”, in which each agent starts with a single unit of wealth, and on each timestep, every agent with more than zero wealth gives one unit of wealth to another agent.\nThis tutorial is adapted from the following example:\nhttps://mesa.readthedocs.io/en/stable/tutorials/intro_tutorial.html\n\nSetting up the model\nWe could define the wealth model as any type of module, since they all can store states and update them. Here we will define wealth as a subclass of ss.Intervention (though it could equally well be a subclass of ss.Demographics or even ss.Disease, if you are so inclined). All we need to do is update the wealth state (which we can store inside the “intervention”), and we can also use this class to track the wealth distribution over time and plot it. The full model looks like this:\n\n\"\"\"\nDefine the classic agent-based \"wealth model\" in Starsim\n\"\"\"\n\n# Imports\nimport numpy as np\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Define the model\nclass WealthModel(ss.Module):\n    \"\"\" A simple wealth transfer model\"\"\"\n    \n    def init_post(self, bins=10):\n        \"\"\" Define custom model attributes \"\"\"\n        super().init_post()\n        self.npts = len(self.sim) # Number of timepoints\n        self.n_agents = len(sim.people) # Number of agents\n        self.wealth = np.ones(self.n_agents) # Initial wealth of each agent\n        self.bins = np.arange(bins+1) # Bins used for plotting\n        self.wealth_dist = np.zeros((self.npts, len(self.bins)-1)) # Wealth distribution over time\n        return\n        \n    def step(self):\n        \"\"\" Transfer wealth between agents -- core model logic \"\"\"\n        self.wealth_hist() # Store the wealth at this time point\n        givers = self.wealth &gt; 0 # People need wealth to be givers\n        receivers = np.random.choice(self.sim.people.uid, size=givers.sum()) # Anyone can be a receiver\n        self.wealth[givers] -= 1 # Givers are unique, so can use vectorized version\n        for receive in receivers: # Vectorized version is: np.add.at(sim.people.wealth.raw, receivers, 1)\n            self.wealth[receive] += 1\n        return\n    \n    def wealth_hist(self):\n        \"\"\" Calculate the wealth histogram \"\"\"\n        ti = self.sim.ti # Current timestep\n        self.wealth_dist[ti,:], _ = np.histogram(self.wealth, bins=self.bins)\n        return\n    \n    def plot(self):\n        \"\"\" Plot a 2D histogram of the final wealth distribution \"\"\"\n        plt.figure()\n        plt.bar(self.bins[:-1], self.wealth_dist[-1,:])\n        plt.title('Wealth distribution at final time point')\n        plt.xlabel('Wealth')\n        plt.ylabel('Number of agents')\n        plt.show()\n        return\n    \n    def plot3d(self):\n        \"\"\" Plot a 3D heatmap of the wealth distribution over time \"\"\"\n        plt.figure()\n        plt.pcolor(self.wealth_dist.T, cmap='turbo')\n        plt.title('Wealth distribution over time')\n        plt.xlabel('Time')\n        plt.ylabel('Wealth')\n        plt.colorbar().set_label('Number of agents', rotation=270)\n        plt.show()\n        return\n\n# Create sim inputs, including the wealth model\nwealth = WealthModel()\npars = dict(\n    n_agents = 100, # Number of agents\n    start = 0,\n    stop = 100,\n    demographics = wealth,\n)\n\n# Run the model\nsim = ss.Sim(pars, copy_inputs=False) # copy_inputs=False lets us reuse the \"wealth\" object from above\nsim.run()\n\n# Plot the results\nwealth.plot()\nwealth.plot3d()\n\n\n\nComparison with Mesa\nWhile the implementation in Starsim is similar to Mesa, there are a couple key differences:\n\nBecause Starsim’s people object is vectorized, the wealth definition and update is vectorized as well.\nBoth Mesa and Starsim versions of the model are quite simple, but there is a little less boilerplate in the Starsim version.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide.html",
    "href": "user_guide.html",
    "title": "User guide",
    "section": "",
    "text": "These user guides provide a more in-depth look at each topic compared to the corresponding tutorials.\n\n\n\n\n\n\nNote\n\n\n\nYou can download these tutorials as Jupyter notebooks to run them locally. Look for the download button at the top of each tutorial.\n\n\n\n\n\n\n\n\nRunning tutorials locally\n\n\n\nTo run these tutorials locally:\n\nClone the Starsim repository\nInstall Starsim and its dependencies\nNavigate to the docs/user_guide folder\nLaunch Jupyter: jupyter lab\n\n\n\n\n\n\nIntroduction to Starsim\nStarsim “spokes”\n\n\n\n\n\nUnderstanding the model\nThe Sim object\nParameter configuration\n\n\n\n\n\nDiseases\nNetworks\nDemographics\nInterventions\nAnalyzers\nConnectors\n\n\n\n\n\nRunning simulations\nCalibration\nDeployment\nWorking with samples\n\n\n\n\n\nTime handling\nIndexing and arrays\nProbability distributions\nRandom number generation\nProfiling and optimization\nNonstandard usage"
  },
  {
    "objectID": "user_guide.html#introduction",
    "href": "user_guide.html#introduction",
    "title": "User guide",
    "section": "",
    "text": "Introduction to Starsim\nStarsim “spokes”"
  },
  {
    "objectID": "user_guide.html#basics",
    "href": "user_guide.html#basics",
    "title": "User guide",
    "section": "",
    "text": "Understanding the model\nThe Sim object\nParameter configuration"
  },
  {
    "objectID": "user_guide.html#modules",
    "href": "user_guide.html#modules",
    "title": "User guide",
    "section": "",
    "text": "Diseases\nNetworks\nDemographics\nInterventions\nAnalyzers\nConnectors"
  },
  {
    "objectID": "user_guide.html#workflows",
    "href": "user_guide.html#workflows",
    "title": "User guide",
    "section": "",
    "text": "Running simulations\nCalibration\nDeployment\nWorking with samples"
  },
  {
    "objectID": "user_guide.html#advanced-topics",
    "href": "user_guide.html#advanced-topics",
    "title": "User guide",
    "section": "",
    "text": "Time handling\nIndexing and arrays\nProbability distributions\nRandom number generation\nProfiling and optimization\nNonstandard usage"
  },
  {
    "objectID": "whatsnew.html",
    "href": "whatsnew.html",
    "title": "What’s new",
    "section": "",
    "text": "All notable changes to the codebase are documented in this file. Changes that may result in differences in model output, or are required in order to run an old parameter set with the current version, are flagged with the term “Regression information”.\n\n\n\nUpdated ss.Sim.shrink() to remove additional objects, resulting in a smaller sim size.\nss.Calibration.save_csv() has been replaced by ss.Calibration.to_df() (to save to a CSV, use ss.Calibration.to_df().to_csv().\nss.Result.shape has been renamed ss.Result._shape, so ss.Result.shape now correctly returns the actual size of the array.\nResults by default convert all result keys to lowercase; use keep_case=True to turn off this behavior.\nFixed a bug with an ss.date object converting to a pd.Timestamp upon copy.\nGitHub info: PR 865\n\n\n\n\n\nThe calibration class has been completely redesigned. Calibration now relies on “components”, which capture mismatch with a particular data type (e.g., new infections). The new approach also adds additional statistical rigor for calculating mismatches.\nss.MixingPool has been updated to be more modular, and behave more like ss.Network; in particular, compute_transmission() rather than step() is called to determine new infections.\nss.Result now has a summarize_by argument, which determines how a result should be summarized as a scalar (e.g., mean for a prevalence, sum for a count, last entry for a cumulative count).\nFixed a bug with time parameters incorrectly pulling the parent unit from the Sim, rather than the parent module.\nGitHub info: PR 831\n\n\n\n\n\nStarsim is now available for R! See https://r.starsim.org for details.\nThe Calibration class has been completely rewritten. See the calibration tutorial for more information.\nA negative binomial distribution is now available as ss.nbinom().\nss.Births() now uses a binomial draw of births per timestep, rather than the expected value.\nAdded ss.load() and ss.save() functions, and removed ss.Sim.load().\nGitHub info: PR 778\n\n\n\n\n\nAdds improved Jupyter support for plotting (to prevent plots from appearing twice); you can disable this by setting ss.options.set(jupyter=False).\nAdds auto_plot to Result objects, to indicate if it should appear in sim.plot() by default.\nAdds copy() to the Sim and modules.\nNetworks now store their length on each timestep as a result.\nImproves sim.shrink(), with typical size reductions of &gt;99%.\nAdds additional plotting options show_module (include the module name in the plot title), show_label (use the simulation label as the figure title), and show_skipped (shows results even if auto_plot=False).\nGitHub info: PR 745\n\n\n\n\n\n\n\nTime in simulations is now handled by an ss.Time() class, which unifies how time is represented between the Sim and each module.\nIn addition to networks, there is now a new way of implementing disease transmission via mixing pools.\n\n\n\n\n\nTime handling now performed by the ss.Time() class. This has inputs similar to before (start, stop, unit, dt, with dur still available as a sim input). However, instead of the previous timevec and abs_tvec arrays, there are now multiple ways of representing time (including datevec and yearvec), regardless of what the inputs were.\nDates are now represented in a native format, ss.date, that is based on pd.Timestamp.\n\n\n\n\n\nAdds a new approach to disease transmission called mixing pools. A mixing pool is a “mean field” coupling wherein susceptible agents are exposed to the average infectious agent. The user can create a single mixing pool using the ss.MixingPool class, or create many pools using MixingPools. Such mixing pools could be used to simulate contact matrices, for example as published by Prem et al.\nThere is a new ss.Route class, which is the base class for ss.Network and ss.MixingPool.\n\n\n\n\n\nDemographic modules have been updated to fix various bugs around different time units.\nThe method for hashing distribution trace strings into seeds has changed, meaning that results will be stochastically different compared to Starsim v2.0.\nFixed a bug with how timepars were updated in parameters.\nThere is a new ss.Base class, which both ss.Sim and ss.Module inherit from.\nResults now print as a single line rather than the full array. The latter is available as result.disp().\nsim.to_df() now works even if different modules have different numbers of timepoints.\nThe timepars module has been renamed to time.\nIn demographics modules, units has been renamed rate_units.\nThere are two new options, ss.options.date_sep and ss.options.license. The former sets the date separator (default ., e.g. 2024.04.0.4), and the latter sets if the license prints when Starsim is imported.\nGitHub info: PR 724\n\n\n\n\n\n\n\nVersion 2.0 contains several major changes. These include: module-specific timesteps and time-aware parameters (including a day/year unit flag for modules, and ss.dur() and ss.rate() classes for parameters), and changes to module types and integration (e.g. renaming update() and apply() methods to step();).\n\n\n\n\nAdded ss.dur(), ss.rate(), and ss.time_prob() classes, for automatic handling of time units in simulations. There are also convenience classes ss.days(), ss.years(), ss.perday(), ss.peryear(), and ss.beta() for special cases of these.\nss.dur() and ss.rate(), along with modules and the sim itself, have a unit parameter which can be 'day', 'week', 'month', or 'year' (default). Modules now also have their own timestep dt. Different units and timesteps can be mixed and matched. Time parameters have a to() method, e.g. ss.dur(1, 'year').to('day') will return ss.dur(365, unit='day').\nThe ss.Sim parameter n_years has been renamed dur; sim.yearvec is now sim.timevec, which can have units of days (usually starting at 0), dates (e.g. '2020-01-01'), or years (e.g. 2020). sim.abs_tvec is the translation of sim.timevec as a numeric array starting at 0, using the sim’s units (usually 'day' or 'year'). For example, if sim.timevec is a list of daily dates from '2022-01-01' to '2022-12-31', sim.abs_tvec will be np.arange(365).\nEach module also has its own mod.timevec; this can be different from the sim if it defines its own time unit and/or timestep. mod.abs_tvec always starts at 0 and always uses the sim’s unit.\nThere is a new Loop class which handles the integration loop. You can view the integration plan via sim.loop.to_df() or sim.loop.plot(). You can see how long each part of the sim took with sim.loop.plot_cpu().\nThere are more advanced debugging tools. You can run a single sim timestep with sim.run_one_step() (which in turn calls multiple functions), and you can run a single function from the integration loop with sim.loop.run_one_step().\n\n\n\n\n\nFunctionality has been moved from ss.Plugin to ss.Module, and the former has been removed.\nss.Connector functionality has been moved to ss.Module. ss.Module objects can be placed anywhere in the list of modules (e.g., in demographics, networks, diseases, interventions), depending on when you want them to execute. However, ss.Connector objects are applied after Disease.step_state() and before Network.step().\nMany of the module methods have been renamed; in particular, all modules now have a step() method, which replaces update() (for demographics and networks), apply() (for interventions and analyzers), and make_new_cases() (for diseases). For both the sim and modules, initialize() has been renamed init().\nAll modules are treated the same in the integration loop, except for diseases, which have step_state() and step_die() methods.\nThe Starsim module states.py has been moved to arrays.py, and network.py has been moved to networks.py.\n\n\n\n\n\nss.Arr, ss.TimePar, and ss.Result all inherit from the new class ss.BaseArr, which provides functionality similar to a NumPy array, except all values are stored in arr.values (like a pd.Series).\nWhereas before, computations on an ss.Arr usually returned a NumPy array, calculations now usually return the same type. To access the NumPy array, use arr.values.\nThere is a new ss.State class, which is a subtype of ss.BoolArr. Typically, ss.State is used for boolean disease states, such as infected, susceptible, etc., where you want to automatically generate results (e.g. n_infected). You can continue using ss.BoolArr for other agent attributes that you don’t necessarily want to automatically generate results for, e.g. ever_vaccinated.\n\n\n\n\n\nResults are now defined differently. They should be defined in ss.Module.init_results(), not ss.Module.init_pre(). They now take the module name, number of points, and time vector from the parent module. As a result, they are usually initialized via ss.Module.define_results(res1, res2) (as opposed to mod.results += [res1, res2] previously). define_results() automatically adds these properties from the parent module; they can still be defined explicitly if needed however.\nBecause results now store their own time information, they can be plotted in a self-contained way. Both ss.Result and ss.Results objects now have plot() and to_df() methods.\n\n\n\n\n\nFixed a bug in how results were defined for ss.Births and ss.Deaths.\nThe ss.Pregnancy module has been significantly rewritten, including: (1) Agents now have a parent which indicates the UID of the parent; (2) Women now track child_uid; (3) On neonatal death, the pregnancy state of the mother is corrected; (4) Pregnancy rates now adjusted for infecund rather than pregnant; (4) Pregnancy now has a burn-in, which defaults to True; (5) Pregnancy has a p_neonatal_death parameter to capture fetal and neonatal death if the mother dies.\nSlots now has a minimum, default of 100, to account for small initial population sizes that grow dramatically over time.\n\n\n\n\n\nThere have been several performance improvements. The default float type is now np.float32. Transmission is now handled by a specialized Infection.compute_transmission() method. Several additional functions now use Numba, including fastmath=True, which leverages Intel’s short vector math library.\nA new ss.multi_random() distribution class has been added, that allows random numbers to be generated by two (or more) agents. It largely replaces ss.combine_rands() and is 5-10x faster.\nA new ss.gamma() distribution has also been added.\nDistributions have a new jump_dt method that jumps by much more than a single state update.\nss.parallel() and ss.MultiSim.run() now modify simulations in place by default. Instead of sims = ss.parallel(sim1, sim2).sims; sims[0].plot(), you can now simply do ss.parallel(sim1, sim2); sim1.plot().\n\n\n\n\n\nData can now be supplied to a simulation; it will be automatically plotted by sim.plot().\nss.Calibration has been significantly reworked, and now includes more flexible parameter setting, plus plotting (calib.plot_sims() and calib.plot_trend()). It also has a debug argument (which runs in serial rather than paralell), which can be helpful for troubleshooting issues.\nMultiSim now has display methods brief() (minimal), show() (moderate), and disp (verbose).\nsim.export_df() has been renamed sim.to_df().\nMost classes now have to_json() methods (which can also export to a dict).\nFixed a bug in how the InfectionLog is added to disease modules.\nSim.gitinfo has been replaced with Sim.metadata (which includes git info).\nInfection.validate_beta() is now applied on every timestep, so changes to beta during the simulation are now honored.\nsim.get_intervention() and sim.get_analyzer() have been removed; use built-in ndict operations (e.g., the label) to find the object you’re after.\nrequires has been removed from modules, but ss.check_requires() is still available if needed. Call it manually from init_pre() if desired, e.g. a PMTCT intervention might call ss.check_requires(self.sim, ['hiv', 'maternalnet']).\nFor networks, contacts has been renamed edges except in cases where it refers to an agent’s contacts. For example, network.contacts has been renamed network.edges, but ss.find_contacts() remains the same.\nNetworks now have a to_graph() method that exports to NetworkX.\nss.diff_sims() can now handle MultiSim objects.\nSim._orig_pars has been removed.\nss.unique() has been removed.\n\n\n\n\n\nNote: the list here covers major changes only; in general, Starsim v1.0 scripts will not be compatible with Starsim v2.0.\nResults from Starsim v2.0 will be stochastically (but not statistically) different from Starsim v1.0.\nAll duration and rate parameters should now be wrapped with ss.dur() and ss.rate(). Events that represent probabilities over time (i.e. hazard rates) can also be wrapped with ss.time_prob(), although this is similar to ss.rate() unless the value is relatively large.\nss.Plugin has been removed. Use ss.Module instead.\ninit_results() is now called by init_pre(), and does not need to be called explicitly.\ndefault_pars() has been renamed define_pars().\nadd_states() has been renamed define_states()\ninitialize() has been renamed init().\nDemographics.update() has been renamed Demographics.step().\nNetwork.update() has been renamed Network.step().\nDisease.update_pre() has been renamed Disease.step_state().\nDisease.make_new_cases() has been renamed Disease.step().\nDisease.update_death() has been renamed Disease.step_die() (which is now called by People.step_die()).\nInfection._set_cases() has been renamed Infection.set_outcomes().\nIntervention.apply(sim) has been renamed Intervention.step(); ditto for Analyzer.\nModule.step() no longer takes sim as an argument (e.g., replace intervention.apply(sim) with intervention.step()).\nAll modules now have methods for start_step(), finish_step(), init_results(), and update_results().\nNetwork.contacts has been renamed Network.edges.\nsim.get_intervention() and sim.get_analyzer() have been removed; simply call directly instead (e.g. replace sim.get_intervention('vaccine') with sim.interventions['vaccine']).\nrequires is no longer an attribute of modules; call the ss.check_requires() function directly if needed.\nPeople.resolve_deaths() has been renamed People.check_deaths()\nss.unique() has been removed.\nGitHub info: PR 626\n\n\n\n\n\n\nFixes a bug in which some intervention parameters (e.g. eligibility) do not get set properly.\nGitHub info: PR 639\n\n\n\n\n\nFixes a bug in which random numbers drawn from auto-jumped distributions would overlap with random numbers drawn from subsequent timesteps.\nGitHub info: PR 639\n\n\n\n\n\nAdds a new distribution, ss.rand_raw(), that samples raw integers from the random number bit generator, for use with calculating transmission. This version is roughly 20-30% faster than the previous implementation.\nAdds interpolation to age-standardized fertility rate (ASFR) data.\nAdds flexibility to ART initiation.\nGitHub info: PR 593\n\n\n\n\n\nOfficial release of Starsim!\nAdds a Calibration class, based on Optuna, to facilitate the calibration of Starsim models.\nAdds mean(), median(), and plot() methods to MultiSim.\nAdds low and high attributes to Result objects.\nAdds a flatten() method to Results, allowing nested Results objects to be turned into flat dictionaries.\nRemoves duplicate UIDs among new infections, and adds a unique() method to ss.uids.\nFixes a bug that prevented ss.lognorm_im() from using callable parameters.\nUpdates the default Sim string representation to be a single line; the more verbose version is available via sim.disp().\nGitHub info: PR 581\n\n\n\n\n\nAdds two new common-random-number-safe networks. The first is an Erdős-Rényi network that is similar to RandomNet but parameterized differently. The second is a 2D spatial network with connectivity between agents within a given radius; these agents can also optionally move.\nGitHub info: PR 575\n\n\n\n\n\nAdded a ss.histogram() distribution, which allows generating new random values from an empirical histogram.\nWhen binned age data is provided to specify the initial ages for new agents, the ages are now distributed throughout the year/bin rather than new agents being assigned integer ages\nInitial age data is now accepted as a pd.Series rather than a pd.DataFrame where the index corresponds to the age values, thereby avoiding the need for specific dataframe column names to be used to specify the age and value\nGitHub info: PR 572\n\n\n\n\n\nRevert to making infection logging disabled by default. However, the infection log will now always be created so disease subclasses can override logging behaviour where required (e.g., to capture additional metadata)\nBackwards-compatibility notes: Logging has been moved from an argument to Disease to pars. Existing code such as Disease(log=True) should be changed to Disease(pars={'log':True}). The ‘log’ option can be added to the pars passed to any subclass e.g., ss.HIV(pars={...,log=True}).\nGitHub info: PR 573\n\n\n\n\n\nImplemented a new ss.combine_rands() function based on a bitwise-XOR, since the previous modulo-based approach could introduce correlations between pairs of agents.\nGitHub info: PR 546\n\n\n\n\n\nss.Infection.make_new_cases() now returns the index of the network associated with each transmission event\nIf a People object is provided to the Arr constructor, the arrays will be pre-initialized to index the current UIDs in the People object. This enables construction of temporary Arr instances that can be used to perform intermediate calculations (e.g., inside Intervention.apply() or within a module update step)\nDeprecated Arr(raw=...) argument to simplify initialization, as in practice the raw variable is not directly set, and this update also introduces a new pathway for initializating the raw attribute\nss.uids.to_numpy() now returns a view rather than a copy\nss.bernoulli.filter() now supports ss.BoolArr as an input, where the filtering will operate on the uids returned by ss.BoolArr.uids\nss.uids() supports construction from set objects (via np.fromiter())\nGitHub info: PR 565\n\n\n\n\n\nAdded labels to Result and state (Arr) objects.\nAdded Numba decorator to find_contacts to significantly increase performance.\nFixed bug when comparing uids and BoolArr objects.\nGitHub info: PR 562\n\n\n\n\n\nAdjusted RandomNet to avoid connections to unborn agents and use random rounding for half edges\nAdds get_analyzers and get_analyzer\nRefactor how data is pre-processed for births/pregnancy/death rates, giving about a 10% decrease in run time for the STIsim HIV model\nBoolArr.uids is automatically called when doing set operations on uids with a BoolArr\nGitHub info: PR 555\n\n\n\n\n\nss.uids class implements set operators to facilitate combining or otherwise operating on collections of UIDs\nFloatArr.isnan and FloatArr.notnan return BoolArr instances rather than UIDs (so as to facilitate logical operations with other BoolArr instances, and to align more closely with np.isnan)\nArr.true() and Arr.false() are supported for all Arr subclasses\nBoolArr.isnan and Boolarr.notnan are also implemented (although since BoolArr cannot store NaN values, these always return False and True, respectively)\nGitHub info: PR 544\n\n\n\n\n\nRenames network.contacts to network.edges.\nFor modules (including diseases, networks, etc.), renames initialize() to init_pre() and init_vals() to init_post().\nRenames ss.delta() to ss.constant().\nAllows Arr objects to be indexed by integer (which are assumed to be UIDs).\nFixes bug when using callable parameters with ss.lognorm_ex() and ss.lognorm_im().\nFixes bug when initializing ss.StaticNet().\nUpdates default birth rate from 0 to 30 (so demographics=True is meaningful).\nAdds min_age and max_age parameters to the Pregnancy module (with defaults 15 and 50 years).\nAdds an option for the sir_vaccine to be all-or-nothing instead of leaky.\nUpdates baseline test from HIV to SIR + SIS.\nFixes issue with infection log not being populated.\nGitHub info: PR 527\n\n\n\n\n\nSeparates maternal transmission into prenatal and postnatal modules.\nGitHub info: PR 509\n\n\n\n\n\n\nAll inputs to the sim and modules now use a ss.Pars() class, which handles updating and validation. It is now not necessary to ever use pars= (although you still can if you want), so what was previously:\nsim = ss.Sim(pars=dict(diseases='sir', networks='random'))\nis now just:\nsim = ss.Sim(diseases='sir', networks='random')\nUpdates happen recursively, so distributions etc. can be flexibly updated.\nThis has significantly changed how modules are initialized; what was previously:\ndef __init__(self, pars=None, **kwargs):\n\n    pars = ss.omergeleft(pars,\n        dur_inf = 6,\n        init_prev = 0.01,\n        p_death = 0.01,\n        beta = 0.5,\n    )\n\n    par_dists = ss.omergeleft(par_dists,\n        dur_inf = ss.lognorm_ex,\n        init_prev = ss.bernoulli,\n        p_death = ss.bernoulli,\n    )\n\n    super().__init__(pars=pars, par_dists=par_dists, *args, **kwargs)\nis now:\ndef __init__(self, pars=None, **kwargs):\n    super().__init__()\n    self.default_pars(\n        beta = 0.5,\n        init_prev = ss.bernoulli(0.01),\n        dur_inf = ss.lognorm_ex(6),\n        p_death = ss.bernoulli(0.01),\n    )\n    self.update_pars(pars, **kwargs)\n\n\n\n\nAdded a ss.Pars class (and a ss.SimPars subclass) that handles parameter creation, updates, and validation.\nInitialization has been moved from sim.py to parameters.py; ss.Sim.convert_plugins() has been replaced by ss.SimPars.convert_modules().\nThe key method is ss.Pars.update(), which performs all necessary validation on the parameters being updated.\n\n\n\n\n\nPreviously, the people were initialized first, then the states were initialized and the values populated, then the modules were initialized, and finally the distributions are initialized. This led to circular logic with the states being initialized based on uninitialized distributions. Now, states and modules are linked to the People and Sim objects, but further initialization is not done at this step. This ensures all distributions are created but not yet used. Next, distributions are initialized. Finally, the initial values are populated, and everything is initialized.\nNew methods supporting these changes include ss.link_dists(), dist.link_sim(), dist.link_module(), sim.init_vals(), people.init_vals(), module.init_vals(),\n\n\n\n\n\nWhereas modules previously initialized a dict of parameters and then called super().__init__(pars, **kwargs), they now call super().__init__() first, then self.default_pars(par1=x, par2=y), then finally self.update_pars(pars, **kwargs).\nWhat was previously e.g. ss.Module(pars=dict(par=x)) is now ss.Module(par=x).\npar_dists has been removed; instead, distributions are specified in the default parameters, and are updated via the Pars object.\nModules now contain a link back to the Sim object. This means that all methods that used to have sim as an argument now do not, e.g. self.update() instead of self.update(sim).\nss.module_map() maps different module types to their location in the sim.\nss.find_modules() finds all available modules (including subclasses) in Starsim.\nRemoved ss.dictmerge() and ss.dictmergeleft (now handled by ss.Pars.update()).\nRemoved ss.get_subclasses() and ss.all_subclasses() (now handled by ss.find_modules()).\nModules can no longer be initialized with a name key; it must be type (e.g. dict(type='sir') rather than dict(name='sir').\nAdded to_json() and plot() methods to Module.\nRemoved connectors.py; connectors still exist but as an empty subclass of Module.\n\n\n\n\n\nBasePeople has been removed and merged with People.\nTime parameters (ti, dt, etc.) have been removed from People. Use sim.ti, sim.dt etc. instead. One consequence of this is that people.request_death() now requires a sim argument. Another is that network methods (e.g. add_pairs()) now take sim arguments instead of people arguments.\nSexualNetwork is now a subclass of DynamicNetwork.\nRemoved ss.Networks (now just an ss.ndict).\nNetwork connectors have been removed.\nPerson has been implemented as a slice of sim.people[i].\nThere is a new parameter use_aging; this defaults to True if demographic modules are supplied, and False otherwise.\n\n\n\n\n\nBoolean arrays have new methods true(), false(), and split(), which return the UIDs for the True values (alias to arr.uids), False values, and both sets of values, respectively. ss.bernoulli.split() has been added as an alias of ss.bernoulli.filter(both=True).\nAll inputs to a sim are now copied by default. To disable, use ss.Sim(..., copy_inputs=False).\nThere is a new Plugin class, which contains shared logic for Interventions and Analyzers. It has a from_func(), which will generate an intervention/analyzer from a function.\nDiseases no longer have a default value of beta=1 assigned; beta must be defined explicitly if being used.\nIndividual diseases can now be plotted via either e.g. sim.plot('hiv') or sim.diseases.hiv.plot().\nDistributions can be created from dicts via ss.make_dist().\nA new function ss.check_sims_match() will check if the results of two or more simulations match.\nndict values can be accessed through a call; e.g. sim.diseases() is equivalent to sim.diseases.values().\nMerged test_dcp.py and test_base.py into test_other.py.\nRenamed test_simple.py to test_sim.py.\nRenamed test_dists.py to test_randomness.py.\nGitHub info: PR 488\n\n\n\n\n\n\nReplace UIDArray, ArrayView, and State with Arr, which has different subclasses for different data types (e.g. FloatArr, BoolArr, and IndexArr). States are usually represented by BoolArr (e.g. sir.infected), while other agent properties are represented by FloatArr (e.g. sir.rel_trans).\nArrays that had previously been represented using an integer data type (e.g. sir.ti_infected) are now also FloatArr, to allow the use of np.nan. Integer arrays are supported via IndexArr, but these are only intended for use for slots and UIDs.\nArr objects automatically skip over dead (or otherwise removed) agents; the “active” UIDs are stored in sim.people.auids, which is updated when agents are born or die. This array is linked to each Arr, so that e.g. sim.people.age.mean() will only calculate the mean over alive agents. To access the underlying Numpy array, use sim.people.age.raw.\nFloatArr has isnan, notnan, and notnanvals properties. BoolArr has logical operations defined. For example, ~people.female works, but ~people.ti_dead does not; people.ti_dead.notnan works, but people.female.notnan does not.\nUIDs used to be NumPy integer arrays; they are now ss.uids objects (which is a class, but is lowercase for consistency with np.array(), which it is functionally similar to). Indexing a state by an integer array rather than ss.uids() now raises an exception, due to the ambiguity involved. To index the underlying array with an integer array, use Arr.raw[int_arr]; to index only the active/alive agents, use Arr.values[int_arr].\nDead agents are no longer removed, so uid always corresponds to the position in the array. This means that no remapping is necessary, which has a significant performance benefit (roughly 2x faster for large numbers of agents).\nRenamed omerge to dictmerge and omergeleft to dictmergeleft.\nGitHub info: PR 456\n\n\n\n\n\nDefault duration of edges in ss.RandomNet changed from 1 to 0; this does not matter if dt=1, but does matter with smaller dt values.\nRemoved ss.HPVNet.\nnew_deaths now counted for cholera.\nCrude birth and death rates now take dt into account.\nThe ability to use a centralized random number generator has been restored via ss.options(_centralized=True); this option not advised, but can be used for testing.\nGitHub info: PR 473\n\n\n\n\n\nChanged Ebola model transmission logic.\nFixed bug with module names not being preserved with multiple initialization.\nGitHub info: PR 463\n\n\n\n\n\nChange to syphilis model to permit latent transmission.\nGitHub info: PR 450\n\n\n\n\n\nAdded SIS model.\nFixes distribution initialization.\nAllows interventions and analyzers to be functions.\nTidies up tests.\nPerformance improvements in UIDArray (~3x faster for large numbers of agents).\nGitHub info: PR 428\n\n\n\n\n\n\n\nReplaces ss.SingleRNG(), ss.MultiRNG(), ss.ScipyDistribution(), and ss.ScipyHistogram() with a single ss.Dist() class. The starsim.random and starsim.distributions submodules have been removed, and starsim.dists has been added.\nThe ss.Dist class uses np.random.default_rng() rather than scipy.stats by default, although a scipy.stats distribution can be supplied as an alternative. This is up to 4x faster (including, critically, for Bernoulli distributions).\nAlso removes ss.options.multirng (the new version is equivalent to it being always on).\nRemoves duplicate logic for transmission (make_new_cases())\nAdds new custom distributions such as ss.choice() and ss.delta().\nThese distributions can be called directly, e.g. dist = ss.weibull(c=2); dist(5) will return 5 random variates from a Weibull distribution.\nInstead of being manually initialized based on the name, the Sim object is parsed and all distributions will be initialized with a unique identifier based on their place in the object (e.g. sim.diseases.sir.pars.dur_inf), which is used to set their unique seed.\n\n\n\n\n\nThis PR also fixes bugs with lognormal parameters, and makes it clear whether the parameters are for the implicit normal distribution (ss.lognorm_im(), the NumPy/SciPy default, equivalent to ss.lognorm_mean() previously) or the “explicit” lognormal distribution (ss.lognorm_ex(), equivalent to ss.lognorm() previously).\nRenames ss.dx, ss.tx, ss.vx toss.Dx, ss.Tx, ss.Vx.\nRemoved set_numba_seed() as a duplicate of set_seed().\nGitHub info: PR 392\n\n\n\n\n\n\nSIR duration of infection now accounts for dt\nReworked sir_vaccine to modify rel_sus instead of moving agents from susceptible to recovered.\nn_years no longer necessarily an integer\nGitHub info: PR 389\n\n\n\n\n\nRenames and extends the multirng option in settings, now called ‘rng’, which set how random numbers are handled in Starsim with three options:\n\n\n“centralized” uses the centralized numpy random number generator for all distributions.\n“single” uses a separate (SingleRNG) random number generator for each distribution.\n“multi” uses a separate (MultiRNG) random number generator for each distribution.\n\n\nGitHub info: PR 349\n\n\n\n\n\nAdd ss.demo() to quickly create a default simulation.\nGitHub info: PR 380\n\n\n\n\n\nUpdate StaticNet with defaults and correct argument passing\nGitHub info: PR 339\n\n\n\n\n\nMake random number streams independent for SIR\nGitHub info: PR 307\n\n\n\n\n\nImprove logic for making new cases with multi-RNG\nGitHub info: PR 337\n\n\n\n\n\nImprove sim.summarize()\nImprove sim.plot()\nImprove SIR model defaults\nGitHub info: PR 320\n\n\n\n\n\nRemoves STI class\nChanges default death rate from units of per person to per thousand people\nAllows ss.Sim(demographics=True) to enable births and deaths\nFix pickling of State objects\nRename networks.py to network.py, and fix HIV mortality\nGitHub info: PRs 305, 308, 317\n\n\n\n\n\nAdd the Samples class\nGitHub info: PR 311\n\n\n\n\n\nOnly remove dead agents on certain timesteps\nGitHub info: PR 294\n\n\n\n\n\nCode reorganization, including making networks.py and disease.py to the top level\nNetworks moved from People to Sim\nVarious classes renamed (e.g. FusedArray to UIDArray, STI to Infection)\nBetter type checking\nAdded MultiSim\nAdded cholera, measles, and Ebola\nAdded vaccination\nMore flexible inputs\nGitHub info: PR 235\n\n\n\n\n\nTransmission based on number of contacts\nGitHub info: PR 220\n\n\n\n\n\nPerformance enhancement for disease transmission, leading to a 10% decrease in runtime.\nGitHub info: PR 217\n\n\n\n\n\nAdds template interventions and products for diagnostics and treatment\nAdds syphilis screening & treatment interventions\nGitHub info: PR 210\n\n\n\n\n\nRenamed stisim to starsim.\nGitHub info: PR 200\n\n\n\n\n\nAdds a syphilis module\nGitHub info: PR 206\n\n\n\n\n\nRead in age distributions for people initializations\nGitHub info: PR 205\n\n\n\n\n\nFunctionality for converting birth & fertility data to a callable parameter within SciPy distributions\nGitHub info: PR 203\n\n\n\n\n\nImproving performance of MultiRNG\nNow factoring the timestep, dt, into transmission calculations\nGitHub info: PRs 204\n\n\n\n\n\nAllows SciPy distributions to be used as parameters\nOptionally use multiple random number streams and other tricks to maintain coherence between simulations\nAdding functionality to convert death rate data to a callable parameter within a SciPy distribution\nGitHub info: PRs 170 and 202\n\n\n\n\n\nEnable removing people from simulations following death\nGitHub info: PR 121\n\n\n\n\n\nRefactor distributions to use new Distribution class\nGitHub info: PR 112\n\n\n\n\n\nChanges agent IDs from index-based to UID-based\nAllows states to store their own data and live within modules\nGitHub info: PR 88\n\n\n\n\n\nRefactor file structure\nGitHub info: PRs 77 and 86\n\n\n\n\n\nAdds in basic Starsim functionality\nGitHub info: PR 17\n\n\n\n\n\nInitial version.",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.3.1-2025-02-25",
    "href": "whatsnew.html#version-2.3.1-2025-02-25",
    "title": "What’s new",
    "section": "",
    "text": "Updated ss.Sim.shrink() to remove additional objects, resulting in a smaller sim size.\nss.Calibration.save_csv() has been replaced by ss.Calibration.to_df() (to save to a CSV, use ss.Calibration.to_df().to_csv().\nss.Result.shape has been renamed ss.Result._shape, so ss.Result.shape now correctly returns the actual size of the array.\nResults by default convert all result keys to lowercase; use keep_case=True to turn off this behavior.\nFixed a bug with an ss.date object converting to a pd.Timestamp upon copy.\nGitHub info: PR 865",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.3.0-2025-02-14",
    "href": "whatsnew.html#version-2.3.0-2025-02-14",
    "title": "What’s new",
    "section": "",
    "text": "The calibration class has been completely redesigned. Calibration now relies on “components”, which capture mismatch with a particular data type (e.g., new infections). The new approach also adds additional statistical rigor for calculating mismatches.\nss.MixingPool has been updated to be more modular, and behave more like ss.Network; in particular, compute_transmission() rather than step() is called to determine new infections.\nss.Result now has a summarize_by argument, which determines how a result should be summarized as a scalar (e.g., mean for a prevalence, sum for a count, last entry for a cumulative count).\nFixed a bug with time parameters incorrectly pulling the parent unit from the Sim, rather than the parent module.\nGitHub info: PR 831",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.2.0-2024-11-18",
    "href": "whatsnew.html#version-2.2.0-2024-11-18",
    "title": "What’s new",
    "section": "",
    "text": "Starsim is now available for R! See https://r.starsim.org for details.\nThe Calibration class has been completely rewritten. See the calibration tutorial for more information.\nA negative binomial distribution is now available as ss.nbinom().\nss.Births() now uses a binomial draw of births per timestep, rather than the expected value.\nAdded ss.load() and ss.save() functions, and removed ss.Sim.load().\nGitHub info: PR 778",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.1.1-2024-11-08",
    "href": "whatsnew.html#version-2.1.1-2024-11-08",
    "title": "What’s new",
    "section": "",
    "text": "Adds improved Jupyter support for plotting (to prevent plots from appearing twice); you can disable this by setting ss.options.set(jupyter=False).\nAdds auto_plot to Result objects, to indicate if it should appear in sim.plot() by default.\nAdds copy() to the Sim and modules.\nNetworks now store their length on each timestep as a result.\nImproves sim.shrink(), with typical size reductions of &gt;99%.\nAdds additional plotting options show_module (include the module name in the plot title), show_label (use the simulation label as the figure title), and show_skipped (shows results even if auto_plot=False).\nGitHub info: PR 745",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.1.0-2024-11-07",
    "href": "whatsnew.html#version-2.1.0-2024-11-07",
    "title": "What’s new",
    "section": "",
    "text": "Time in simulations is now handled by an ss.Time() class, which unifies how time is represented between the Sim and each module.\nIn addition to networks, there is now a new way of implementing disease transmission via mixing pools.\n\n\n\n\n\nTime handling now performed by the ss.Time() class. This has inputs similar to before (start, stop, unit, dt, with dur still available as a sim input). However, instead of the previous timevec and abs_tvec arrays, there are now multiple ways of representing time (including datevec and yearvec), regardless of what the inputs were.\nDates are now represented in a native format, ss.date, that is based on pd.Timestamp.\n\n\n\n\n\nAdds a new approach to disease transmission called mixing pools. A mixing pool is a “mean field” coupling wherein susceptible agents are exposed to the average infectious agent. The user can create a single mixing pool using the ss.MixingPool class, or create many pools using MixingPools. Such mixing pools could be used to simulate contact matrices, for example as published by Prem et al.\nThere is a new ss.Route class, which is the base class for ss.Network and ss.MixingPool.\n\n\n\n\n\nDemographic modules have been updated to fix various bugs around different time units.\nThe method for hashing distribution trace strings into seeds has changed, meaning that results will be stochastically different compared to Starsim v2.0.\nFixed a bug with how timepars were updated in parameters.\nThere is a new ss.Base class, which both ss.Sim and ss.Module inherit from.\nResults now print as a single line rather than the full array. The latter is available as result.disp().\nsim.to_df() now works even if different modules have different numbers of timepoints.\nThe timepars module has been renamed to time.\nIn demographics modules, units has been renamed rate_units.\nThere are two new options, ss.options.date_sep and ss.options.license. The former sets the date separator (default ., e.g. 2024.04.0.4), and the latter sets if the license prints when Starsim is imported.\nGitHub info: PR 724",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.0.0-2024-10-01",
    "href": "whatsnew.html#version-2.0.0-2024-10-01",
    "title": "What’s new",
    "section": "",
    "text": "Version 2.0 contains several major changes. These include: module-specific timesteps and time-aware parameters (including a day/year unit flag for modules, and ss.dur() and ss.rate() classes for parameters), and changes to module types and integration (e.g. renaming update() and apply() methods to step();).\n\n\n\n\nAdded ss.dur(), ss.rate(), and ss.time_prob() classes, for automatic handling of time units in simulations. There are also convenience classes ss.days(), ss.years(), ss.perday(), ss.peryear(), and ss.beta() for special cases of these.\nss.dur() and ss.rate(), along with modules and the sim itself, have a unit parameter which can be 'day', 'week', 'month', or 'year' (default). Modules now also have their own timestep dt. Different units and timesteps can be mixed and matched. Time parameters have a to() method, e.g. ss.dur(1, 'year').to('day') will return ss.dur(365, unit='day').\nThe ss.Sim parameter n_years has been renamed dur; sim.yearvec is now sim.timevec, which can have units of days (usually starting at 0), dates (e.g. '2020-01-01'), or years (e.g. 2020). sim.abs_tvec is the translation of sim.timevec as a numeric array starting at 0, using the sim’s units (usually 'day' or 'year'). For example, if sim.timevec is a list of daily dates from '2022-01-01' to '2022-12-31', sim.abs_tvec will be np.arange(365).\nEach module also has its own mod.timevec; this can be different from the sim if it defines its own time unit and/or timestep. mod.abs_tvec always starts at 0 and always uses the sim’s unit.\nThere is a new Loop class which handles the integration loop. You can view the integration plan via sim.loop.to_df() or sim.loop.plot(). You can see how long each part of the sim took with sim.loop.plot_cpu().\nThere are more advanced debugging tools. You can run a single sim timestep with sim.run_one_step() (which in turn calls multiple functions), and you can run a single function from the integration loop with sim.loop.run_one_step().\n\n\n\n\n\nFunctionality has been moved from ss.Plugin to ss.Module, and the former has been removed.\nss.Connector functionality has been moved to ss.Module. ss.Module objects can be placed anywhere in the list of modules (e.g., in demographics, networks, diseases, interventions), depending on when you want them to execute. However, ss.Connector objects are applied after Disease.step_state() and before Network.step().\nMany of the module methods have been renamed; in particular, all modules now have a step() method, which replaces update() (for demographics and networks), apply() (for interventions and analyzers), and make_new_cases() (for diseases). For both the sim and modules, initialize() has been renamed init().\nAll modules are treated the same in the integration loop, except for diseases, which have step_state() and step_die() methods.\nThe Starsim module states.py has been moved to arrays.py, and network.py has been moved to networks.py.\n\n\n\n\n\nss.Arr, ss.TimePar, and ss.Result all inherit from the new class ss.BaseArr, which provides functionality similar to a NumPy array, except all values are stored in arr.values (like a pd.Series).\nWhereas before, computations on an ss.Arr usually returned a NumPy array, calculations now usually return the same type. To access the NumPy array, use arr.values.\nThere is a new ss.State class, which is a subtype of ss.BoolArr. Typically, ss.State is used for boolean disease states, such as infected, susceptible, etc., where you want to automatically generate results (e.g. n_infected). You can continue using ss.BoolArr for other agent attributes that you don’t necessarily want to automatically generate results for, e.g. ever_vaccinated.\n\n\n\n\n\nResults are now defined differently. They should be defined in ss.Module.init_results(), not ss.Module.init_pre(). They now take the module name, number of points, and time vector from the parent module. As a result, they are usually initialized via ss.Module.define_results(res1, res2) (as opposed to mod.results += [res1, res2] previously). define_results() automatically adds these properties from the parent module; they can still be defined explicitly if needed however.\nBecause results now store their own time information, they can be plotted in a self-contained way. Both ss.Result and ss.Results objects now have plot() and to_df() methods.\n\n\n\n\n\nFixed a bug in how results were defined for ss.Births and ss.Deaths.\nThe ss.Pregnancy module has been significantly rewritten, including: (1) Agents now have a parent which indicates the UID of the parent; (2) Women now track child_uid; (3) On neonatal death, the pregnancy state of the mother is corrected; (4) Pregnancy rates now adjusted for infecund rather than pregnant; (4) Pregnancy now has a burn-in, which defaults to True; (5) Pregnancy has a p_neonatal_death parameter to capture fetal and neonatal death if the mother dies.\nSlots now has a minimum, default of 100, to account for small initial population sizes that grow dramatically over time.\n\n\n\n\n\nThere have been several performance improvements. The default float type is now np.float32. Transmission is now handled by a specialized Infection.compute_transmission() method. Several additional functions now use Numba, including fastmath=True, which leverages Intel’s short vector math library.\nA new ss.multi_random() distribution class has been added, that allows random numbers to be generated by two (or more) agents. It largely replaces ss.combine_rands() and is 5-10x faster.\nA new ss.gamma() distribution has also been added.\nDistributions have a new jump_dt method that jumps by much more than a single state update.\nss.parallel() and ss.MultiSim.run() now modify simulations in place by default. Instead of sims = ss.parallel(sim1, sim2).sims; sims[0].plot(), you can now simply do ss.parallel(sim1, sim2); sim1.plot().\n\n\n\n\n\nData can now be supplied to a simulation; it will be automatically plotted by sim.plot().\nss.Calibration has been significantly reworked, and now includes more flexible parameter setting, plus plotting (calib.plot_sims() and calib.plot_trend()). It also has a debug argument (which runs in serial rather than paralell), which can be helpful for troubleshooting issues.\nMultiSim now has display methods brief() (minimal), show() (moderate), and disp (verbose).\nsim.export_df() has been renamed sim.to_df().\nMost classes now have to_json() methods (which can also export to a dict).\nFixed a bug in how the InfectionLog is added to disease modules.\nSim.gitinfo has been replaced with Sim.metadata (which includes git info).\nInfection.validate_beta() is now applied on every timestep, so changes to beta during the simulation are now honored.\nsim.get_intervention() and sim.get_analyzer() have been removed; use built-in ndict operations (e.g., the label) to find the object you’re after.\nrequires has been removed from modules, but ss.check_requires() is still available if needed. Call it manually from init_pre() if desired, e.g. a PMTCT intervention might call ss.check_requires(self.sim, ['hiv', 'maternalnet']).\nFor networks, contacts has been renamed edges except in cases where it refers to an agent’s contacts. For example, network.contacts has been renamed network.edges, but ss.find_contacts() remains the same.\nNetworks now have a to_graph() method that exports to NetworkX.\nss.diff_sims() can now handle MultiSim objects.\nSim._orig_pars has been removed.\nss.unique() has been removed.\n\n\n\n\n\nNote: the list here covers major changes only; in general, Starsim v1.0 scripts will not be compatible with Starsim v2.0.\nResults from Starsim v2.0 will be stochastically (but not statistically) different from Starsim v1.0.\nAll duration and rate parameters should now be wrapped with ss.dur() and ss.rate(). Events that represent probabilities over time (i.e. hazard rates) can also be wrapped with ss.time_prob(), although this is similar to ss.rate() unless the value is relatively large.\nss.Plugin has been removed. Use ss.Module instead.\ninit_results() is now called by init_pre(), and does not need to be called explicitly.\ndefault_pars() has been renamed define_pars().\nadd_states() has been renamed define_states()\ninitialize() has been renamed init().\nDemographics.update() has been renamed Demographics.step().\nNetwork.update() has been renamed Network.step().\nDisease.update_pre() has been renamed Disease.step_state().\nDisease.make_new_cases() has been renamed Disease.step().\nDisease.update_death() has been renamed Disease.step_die() (which is now called by People.step_die()).\nInfection._set_cases() has been renamed Infection.set_outcomes().\nIntervention.apply(sim) has been renamed Intervention.step(); ditto for Analyzer.\nModule.step() no longer takes sim as an argument (e.g., replace intervention.apply(sim) with intervention.step()).\nAll modules now have methods for start_step(), finish_step(), init_results(), and update_results().\nNetwork.contacts has been renamed Network.edges.\nsim.get_intervention() and sim.get_analyzer() have been removed; simply call directly instead (e.g. replace sim.get_intervention('vaccine') with sim.interventions['vaccine']).\nrequires is no longer an attribute of modules; call the ss.check_requires() function directly if needed.\nPeople.resolve_deaths() has been renamed People.check_deaths()\nss.unique() has been removed.\nGitHub info: PR 626",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.3-2024-09-26",
    "href": "whatsnew.html#version-1.0.3-2024-09-26",
    "title": "What’s new",
    "section": "",
    "text": "Fixes a bug in which some intervention parameters (e.g. eligibility) do not get set properly.\nGitHub info: PR 639",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.2-2024-09-25",
    "href": "whatsnew.html#version-1.0.2-2024-09-25",
    "title": "What’s new",
    "section": "",
    "text": "Fixes a bug in which random numbers drawn from auto-jumped distributions would overlap with random numbers drawn from subsequent timesteps.\nGitHub info: PR 639",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.1-2024-07-22",
    "href": "whatsnew.html#version-1.0.1-2024-07-22",
    "title": "What’s new",
    "section": "",
    "text": "Adds a new distribution, ss.rand_raw(), that samples raw integers from the random number bit generator, for use with calculating transmission. This version is roughly 20-30% faster than the previous implementation.\nAdds interpolation to age-standardized fertility rate (ASFR) data.\nAdds flexibility to ART initiation.\nGitHub info: PR 593",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.0-2024-07-10",
    "href": "whatsnew.html#version-1.0.0-2024-07-10",
    "title": "What’s new",
    "section": "",
    "text": "Official release of Starsim!\nAdds a Calibration class, based on Optuna, to facilitate the calibration of Starsim models.\nAdds mean(), median(), and plot() methods to MultiSim.\nAdds low and high attributes to Result objects.\nAdds a flatten() method to Results, allowing nested Results objects to be turned into flat dictionaries.\nRemoves duplicate UIDs among new infections, and adds a unique() method to ss.uids.\nFixes a bug that prevented ss.lognorm_im() from using callable parameters.\nUpdates the default Sim string representation to be a single line; the more verbose version is available via sim.disp().\nGitHub info: PR 581",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.10-2024-07-03",
    "href": "whatsnew.html#version-0.5.10-2024-07-03",
    "title": "What’s new",
    "section": "",
    "text": "Adds two new common-random-number-safe networks. The first is an Erdős-Rényi network that is similar to RandomNet but parameterized differently. The second is a 2D spatial network with connectivity between agents within a given radius; these agents can also optionally move.\nGitHub info: PR 575",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.9-2024-06-30",
    "href": "whatsnew.html#version-0.5.9-2024-06-30",
    "title": "What’s new",
    "section": "",
    "text": "Added a ss.histogram() distribution, which allows generating new random values from an empirical histogram.\nWhen binned age data is provided to specify the initial ages for new agents, the ages are now distributed throughout the year/bin rather than new agents being assigned integer ages\nInitial age data is now accepted as a pd.Series rather than a pd.DataFrame where the index corresponds to the age values, thereby avoiding the need for specific dataframe column names to be used to specify the age and value\nGitHub info: PR 572",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.8-2024-06-30",
    "href": "whatsnew.html#version-0.5.8-2024-06-30",
    "title": "What’s new",
    "section": "",
    "text": "Revert to making infection logging disabled by default. However, the infection log will now always be created so disease subclasses can override logging behaviour where required (e.g., to capture additional metadata)\nBackwards-compatibility notes: Logging has been moved from an argument to Disease to pars. Existing code such as Disease(log=True) should be changed to Disease(pars={'log':True}). The ‘log’ option can be added to the pars passed to any subclass e.g., ss.HIV(pars={...,log=True}).\nGitHub info: PR 573",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.7-2024-06-27",
    "href": "whatsnew.html#version-0.5.7-2024-06-27",
    "title": "What’s new",
    "section": "",
    "text": "Implemented a new ss.combine_rands() function based on a bitwise-XOR, since the previous modulo-based approach could introduce correlations between pairs of agents.\nGitHub info: PR 546",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.6-2024-06-22",
    "href": "whatsnew.html#version-0.5.6-2024-06-22",
    "title": "What’s new",
    "section": "",
    "text": "ss.Infection.make_new_cases() now returns the index of the network associated with each transmission event\nIf a People object is provided to the Arr constructor, the arrays will be pre-initialized to index the current UIDs in the People object. This enables construction of temporary Arr instances that can be used to perform intermediate calculations (e.g., inside Intervention.apply() or within a module update step)\nDeprecated Arr(raw=...) argument to simplify initialization, as in practice the raw variable is not directly set, and this update also introduces a new pathway for initializating the raw attribute\nss.uids.to_numpy() now returns a view rather than a copy\nss.bernoulli.filter() now supports ss.BoolArr as an input, where the filtering will operate on the uids returned by ss.BoolArr.uids\nss.uids() supports construction from set objects (via np.fromiter())\nGitHub info: PR 565",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.5-2024-06-19",
    "href": "whatsnew.html#version-0.5.5-2024-06-19",
    "title": "What’s new",
    "section": "",
    "text": "Added labels to Result and state (Arr) objects.\nAdded Numba decorator to find_contacts to significantly increase performance.\nFixed bug when comparing uids and BoolArr objects.\nGitHub info: PR 562",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.4-2024-06-18",
    "href": "whatsnew.html#version-0.5.4-2024-06-18",
    "title": "What’s new",
    "section": "",
    "text": "Adjusted RandomNet to avoid connections to unborn agents and use random rounding for half edges\nAdds get_analyzers and get_analyzer\nRefactor how data is pre-processed for births/pregnancy/death rates, giving about a 10% decrease in run time for the STIsim HIV model\nBoolArr.uids is automatically called when doing set operations on uids with a BoolArr\nGitHub info: PR 555",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.3-2024-06-10",
    "href": "whatsnew.html#version-0.5.3-2024-06-10",
    "title": "What’s new",
    "section": "",
    "text": "ss.uids class implements set operators to facilitate combining or otherwise operating on collections of UIDs\nFloatArr.isnan and FloatArr.notnan return BoolArr instances rather than UIDs (so as to facilitate logical operations with other BoolArr instances, and to align more closely with np.isnan)\nArr.true() and Arr.false() are supported for all Arr subclasses\nBoolArr.isnan and Boolarr.notnan are also implemented (although since BoolArr cannot store NaN values, these always return False and True, respectively)\nGitHub info: PR 544",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.2-2024-06-04",
    "href": "whatsnew.html#version-0.5.2-2024-06-04",
    "title": "What’s new",
    "section": "",
    "text": "Renames network.contacts to network.edges.\nFor modules (including diseases, networks, etc.), renames initialize() to init_pre() and init_vals() to init_post().\nRenames ss.delta() to ss.constant().\nAllows Arr objects to be indexed by integer (which are assumed to be UIDs).\nFixes bug when using callable parameters with ss.lognorm_ex() and ss.lognorm_im().\nFixes bug when initializing ss.StaticNet().\nUpdates default birth rate from 0 to 30 (so demographics=True is meaningful).\nAdds min_age and max_age parameters to the Pregnancy module (with defaults 15 and 50 years).\nAdds an option for the sir_vaccine to be all-or-nothing instead of leaky.\nUpdates baseline test from HIV to SIR + SIS.\nFixes issue with infection log not being populated.\nGitHub info: PR 527",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.1-2024-05-15",
    "href": "whatsnew.html#version-0.5.1-2024-05-15",
    "title": "What’s new",
    "section": "",
    "text": "Separates maternal transmission into prenatal and postnatal modules.\nGitHub info: PR 509",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.0-2024-05-14",
    "href": "whatsnew.html#version-0.5.0-2024-05-14",
    "title": "What’s new",
    "section": "",
    "text": "All inputs to the sim and modules now use a ss.Pars() class, which handles updating and validation. It is now not necessary to ever use pars= (although you still can if you want), so what was previously:\nsim = ss.Sim(pars=dict(diseases='sir', networks='random'))\nis now just:\nsim = ss.Sim(diseases='sir', networks='random')\nUpdates happen recursively, so distributions etc. can be flexibly updated.\nThis has significantly changed how modules are initialized; what was previously:\ndef __init__(self, pars=None, **kwargs):\n\n    pars = ss.omergeleft(pars,\n        dur_inf = 6,\n        init_prev = 0.01,\n        p_death = 0.01,\n        beta = 0.5,\n    )\n\n    par_dists = ss.omergeleft(par_dists,\n        dur_inf = ss.lognorm_ex,\n        init_prev = ss.bernoulli,\n        p_death = ss.bernoulli,\n    )\n\n    super().__init__(pars=pars, par_dists=par_dists, *args, **kwargs)\nis now:\ndef __init__(self, pars=None, **kwargs):\n    super().__init__()\n    self.default_pars(\n        beta = 0.5,\n        init_prev = ss.bernoulli(0.01),\n        dur_inf = ss.lognorm_ex(6),\n        p_death = ss.bernoulli(0.01),\n    )\n    self.update_pars(pars, **kwargs)\n\n\n\n\nAdded a ss.Pars class (and a ss.SimPars subclass) that handles parameter creation, updates, and validation.\nInitialization has been moved from sim.py to parameters.py; ss.Sim.convert_plugins() has been replaced by ss.SimPars.convert_modules().\nThe key method is ss.Pars.update(), which performs all necessary validation on the parameters being updated.\n\n\n\n\n\nPreviously, the people were initialized first, then the states were initialized and the values populated, then the modules were initialized, and finally the distributions are initialized. This led to circular logic with the states being initialized based on uninitialized distributions. Now, states and modules are linked to the People and Sim objects, but further initialization is not done at this step. This ensures all distributions are created but not yet used. Next, distributions are initialized. Finally, the initial values are populated, and everything is initialized.\nNew methods supporting these changes include ss.link_dists(), dist.link_sim(), dist.link_module(), sim.init_vals(), people.init_vals(), module.init_vals(),\n\n\n\n\n\nWhereas modules previously initialized a dict of parameters and then called super().__init__(pars, **kwargs), they now call super().__init__() first, then self.default_pars(par1=x, par2=y), then finally self.update_pars(pars, **kwargs).\nWhat was previously e.g. ss.Module(pars=dict(par=x)) is now ss.Module(par=x).\npar_dists has been removed; instead, distributions are specified in the default parameters, and are updated via the Pars object.\nModules now contain a link back to the Sim object. This means that all methods that used to have sim as an argument now do not, e.g. self.update() instead of self.update(sim).\nss.module_map() maps different module types to their location in the sim.\nss.find_modules() finds all available modules (including subclasses) in Starsim.\nRemoved ss.dictmerge() and ss.dictmergeleft (now handled by ss.Pars.update()).\nRemoved ss.get_subclasses() and ss.all_subclasses() (now handled by ss.find_modules()).\nModules can no longer be initialized with a name key; it must be type (e.g. dict(type='sir') rather than dict(name='sir').\nAdded to_json() and plot() methods to Module.\nRemoved connectors.py; connectors still exist but as an empty subclass of Module.\n\n\n\n\n\nBasePeople has been removed and merged with People.\nTime parameters (ti, dt, etc.) have been removed from People. Use sim.ti, sim.dt etc. instead. One consequence of this is that people.request_death() now requires a sim argument. Another is that network methods (e.g. add_pairs()) now take sim arguments instead of people arguments.\nSexualNetwork is now a subclass of DynamicNetwork.\nRemoved ss.Networks (now just an ss.ndict).\nNetwork connectors have been removed.\nPerson has been implemented as a slice of sim.people[i].\nThere is a new parameter use_aging; this defaults to True if demographic modules are supplied, and False otherwise.\n\n\n\n\n\nBoolean arrays have new methods true(), false(), and split(), which return the UIDs for the True values (alias to arr.uids), False values, and both sets of values, respectively. ss.bernoulli.split() has been added as an alias of ss.bernoulli.filter(both=True).\nAll inputs to a sim are now copied by default. To disable, use ss.Sim(..., copy_inputs=False).\nThere is a new Plugin class, which contains shared logic for Interventions and Analyzers. It has a from_func(), which will generate an intervention/analyzer from a function.\nDiseases no longer have a default value of beta=1 assigned; beta must be defined explicitly if being used.\nIndividual diseases can now be plotted via either e.g. sim.plot('hiv') or sim.diseases.hiv.plot().\nDistributions can be created from dicts via ss.make_dist().\nA new function ss.check_sims_match() will check if the results of two or more simulations match.\nndict values can be accessed through a call; e.g. sim.diseases() is equivalent to sim.diseases.values().\nMerged test_dcp.py and test_base.py into test_other.py.\nRenamed test_simple.py to test_sim.py.\nRenamed test_dists.py to test_randomness.py.\nGitHub info: PR 488",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.4.0-2024-04-24",
    "href": "whatsnew.html#version-0.4.0-2024-04-24",
    "title": "What’s new",
    "section": "",
    "text": "Replace UIDArray, ArrayView, and State with Arr, which has different subclasses for different data types (e.g. FloatArr, BoolArr, and IndexArr). States are usually represented by BoolArr (e.g. sir.infected), while other agent properties are represented by FloatArr (e.g. sir.rel_trans).\nArrays that had previously been represented using an integer data type (e.g. sir.ti_infected) are now also FloatArr, to allow the use of np.nan. Integer arrays are supported via IndexArr, but these are only intended for use for slots and UIDs.\nArr objects automatically skip over dead (or otherwise removed) agents; the “active” UIDs are stored in sim.people.auids, which is updated when agents are born or die. This array is linked to each Arr, so that e.g. sim.people.age.mean() will only calculate the mean over alive agents. To access the underlying Numpy array, use sim.people.age.raw.\nFloatArr has isnan, notnan, and notnanvals properties. BoolArr has logical operations defined. For example, ~people.female works, but ~people.ti_dead does not; people.ti_dead.notnan works, but people.female.notnan does not.\nUIDs used to be NumPy integer arrays; they are now ss.uids objects (which is a class, but is lowercase for consistency with np.array(), which it is functionally similar to). Indexing a state by an integer array rather than ss.uids() now raises an exception, due to the ambiguity involved. To index the underlying array with an integer array, use Arr.raw[int_arr]; to index only the active/alive agents, use Arr.values[int_arr].\nDead agents are no longer removed, so uid always corresponds to the position in the array. This means that no remapping is necessary, which has a significant performance benefit (roughly 2x faster for large numbers of agents).\nRenamed omerge to dictmerge and omergeleft to dictmergeleft.\nGitHub info: PR 456",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.4-2024-04-18",
    "href": "whatsnew.html#version-0.3.4-2024-04-18",
    "title": "What’s new",
    "section": "",
    "text": "Default duration of edges in ss.RandomNet changed from 1 to 0; this does not matter if dt=1, but does matter with smaller dt values.\nRemoved ss.HPVNet.\nnew_deaths now counted for cholera.\nCrude birth and death rates now take dt into account.\nThe ability to use a centralized random number generator has been restored via ss.options(_centralized=True); this option not advised, but can be used for testing.\nGitHub info: PR 473",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.3-2024-04-16",
    "href": "whatsnew.html#version-0.3.3-2024-04-16",
    "title": "What’s new",
    "section": "",
    "text": "Changed Ebola model transmission logic.\nFixed bug with module names not being preserved with multiple initialization.\nGitHub info: PR 463",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.2-2024-04-08",
    "href": "whatsnew.html#version-0.3.2-2024-04-08",
    "title": "What’s new",
    "section": "",
    "text": "Change to syphilis model to permit latent transmission.\nGitHub info: PR 450",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.1-2024-03-31",
    "href": "whatsnew.html#version-0.3.1-2024-03-31",
    "title": "What’s new",
    "section": "",
    "text": "Added SIS model.\nFixes distribution initialization.\nAllows interventions and analyzers to be functions.\nTidies up tests.\nPerformance improvements in UIDArray (~3x faster for large numbers of agents).\nGitHub info: PR 428",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.0-2024-03-30",
    "href": "whatsnew.html#version-0.3.0-2024-03-30",
    "title": "What’s new",
    "section": "",
    "text": "Replaces ss.SingleRNG(), ss.MultiRNG(), ss.ScipyDistribution(), and ss.ScipyHistogram() with a single ss.Dist() class. The starsim.random and starsim.distributions submodules have been removed, and starsim.dists has been added.\nThe ss.Dist class uses np.random.default_rng() rather than scipy.stats by default, although a scipy.stats distribution can be supplied as an alternative. This is up to 4x faster (including, critically, for Bernoulli distributions).\nAlso removes ss.options.multirng (the new version is equivalent to it being always on).\nRemoves duplicate logic for transmission (make_new_cases())\nAdds new custom distributions such as ss.choice() and ss.delta().\nThese distributions can be called directly, e.g. dist = ss.weibull(c=2); dist(5) will return 5 random variates from a Weibull distribution.\nInstead of being manually initialized based on the name, the Sim object is parsed and all distributions will be initialized with a unique identifier based on their place in the object (e.g. sim.diseases.sir.pars.dur_inf), which is used to set their unique seed.\n\n\n\n\n\nThis PR also fixes bugs with lognormal parameters, and makes it clear whether the parameters are for the implicit normal distribution (ss.lognorm_im(), the NumPy/SciPy default, equivalent to ss.lognorm_mean() previously) or the “explicit” lognormal distribution (ss.lognorm_ex(), equivalent to ss.lognorm() previously).\nRenames ss.dx, ss.tx, ss.vx toss.Dx, ss.Tx, ss.Vx.\nRemoved set_numba_seed() as a duplicate of set_seed().\nGitHub info: PR 392",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.10-2024-03-18",
    "href": "whatsnew.html#version-0.2.10-2024-03-18",
    "title": "What’s new",
    "section": "",
    "text": "SIR duration of infection now accounts for dt\nReworked sir_vaccine to modify rel_sus instead of moving agents from susceptible to recovered.\nn_years no longer necessarily an integer\nGitHub info: PR 389",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.9-2024-03-18",
    "href": "whatsnew.html#version-0.2.9-2024-03-18",
    "title": "What’s new",
    "section": "",
    "text": "Renames and extends the multirng option in settings, now called ‘rng’, which set how random numbers are handled in Starsim with three options:\n\n\n“centralized” uses the centralized numpy random number generator for all distributions.\n“single” uses a separate (SingleRNG) random number generator for each distribution.\n“multi” uses a separate (MultiRNG) random number generator for each distribution.\n\n\nGitHub info: PR 349",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.8-2024-03-13",
    "href": "whatsnew.html#version-0.2.8-2024-03-13",
    "title": "What’s new",
    "section": "",
    "text": "Add ss.demo() to quickly create a default simulation.\nGitHub info: PR 380",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.7-2024-03-09",
    "href": "whatsnew.html#version-0.2.7-2024-03-09",
    "title": "What’s new",
    "section": "",
    "text": "Update StaticNet with defaults and correct argument passing\nGitHub info: PR 339",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.6-2024-02-29",
    "href": "whatsnew.html#version-0.2.6-2024-02-29",
    "title": "What’s new",
    "section": "",
    "text": "Make random number streams independent for SIR\nGitHub info: PR 307",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.5-2024-02-29",
    "href": "whatsnew.html#version-0.2.5-2024-02-29",
    "title": "What’s new",
    "section": "",
    "text": "Improve logic for making new cases with multi-RNG\nGitHub info: PR 337",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.4-2024-02-27",
    "href": "whatsnew.html#version-0.2.4-2024-02-27",
    "title": "What’s new",
    "section": "",
    "text": "Improve sim.summarize()\nImprove sim.plot()\nImprove SIR model defaults\nGitHub info: PR 320",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.3-2024-02-26",
    "href": "whatsnew.html#version-0.2.3-2024-02-26",
    "title": "What’s new",
    "section": "",
    "text": "Removes STI class\nChanges default death rate from units of per person to per thousand people\nAllows ss.Sim(demographics=True) to enable births and deaths\nFix pickling of State objects\nRename networks.py to network.py, and fix HIV mortality\nGitHub info: PRs 305, 308, 317",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.2-2024-02-26",
    "href": "whatsnew.html#version-0.2.2-2024-02-26",
    "title": "What’s new",
    "section": "",
    "text": "Add the Samples class\nGitHub info: PR 311",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.1-2024-02-22",
    "href": "whatsnew.html#version-0.2.1-2024-02-22",
    "title": "What’s new",
    "section": "",
    "text": "Only remove dead agents on certain timesteps\nGitHub info: PR 294",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.0-2024-02-15",
    "href": "whatsnew.html#version-0.2.0-2024-02-15",
    "title": "What’s new",
    "section": "",
    "text": "Code reorganization, including making networks.py and disease.py to the top level\nNetworks moved from People to Sim\nVarious classes renamed (e.g. FusedArray to UIDArray, STI to Infection)\nBetter type checking\nAdded MultiSim\nAdded cholera, measles, and Ebola\nAdded vaccination\nMore flexible inputs\nGitHub info: PR 235",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.8-2024-01-30",
    "href": "whatsnew.html#version-0.1.8-2024-01-30",
    "title": "What’s new",
    "section": "",
    "text": "Transmission based on number of contacts\nGitHub info: PR 220",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.7-2024-01-27",
    "href": "whatsnew.html#version-0.1.7-2024-01-27",
    "title": "What’s new",
    "section": "",
    "text": "Performance enhancement for disease transmission, leading to a 10% decrease in runtime.\nGitHub info: PR 217",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.6-2024-01-23",
    "href": "whatsnew.html#version-0.1.6-2024-01-23",
    "title": "What’s new",
    "section": "",
    "text": "Adds template interventions and products for diagnostics and treatment\nAdds syphilis screening & treatment interventions\nGitHub info: PR 210",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.5-2024-01-23",
    "href": "whatsnew.html#version-0.1.5-2024-01-23",
    "title": "What’s new",
    "section": "",
    "text": "Renamed stisim to starsim.\nGitHub info: PR 200",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.4-2024-01-23",
    "href": "whatsnew.html#version-0.1.4-2024-01-23",
    "title": "What’s new",
    "section": "",
    "text": "Adds a syphilis module\nGitHub info: PR 206",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.3-2024-01-22",
    "href": "whatsnew.html#version-0.1.3-2024-01-22",
    "title": "What’s new",
    "section": "",
    "text": "Read in age distributions for people initializations\nGitHub info: PR 205",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.2-2024-01-19",
    "href": "whatsnew.html#version-0.1.2-2024-01-19",
    "title": "What’s new",
    "section": "",
    "text": "Functionality for converting birth & fertility data to a callable parameter within SciPy distributions\nGitHub info: PR 203",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.1-2024-01-12",
    "href": "whatsnew.html#version-0.1.1-2024-01-12",
    "title": "What’s new",
    "section": "",
    "text": "Improving performance of MultiRNG\nNow factoring the timestep, dt, into transmission calculations\nGitHub info: PRs 204",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.0-2023-12-10",
    "href": "whatsnew.html#version-0.1.0-2023-12-10",
    "title": "What’s new",
    "section": "",
    "text": "Allows SciPy distributions to be used as parameters\nOptionally use multiple random number streams and other tricks to maintain coherence between simulations\nAdding functionality to convert death rate data to a callable parameter within a SciPy distribution\nGitHub info: PRs 170 and 202",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.8-2023-10-04",
    "href": "whatsnew.html#version-0.0.8-2023-10-04",
    "title": "What’s new",
    "section": "",
    "text": "Enable removing people from simulations following death\nGitHub info: PR 121",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.7-2023-09-08",
    "href": "whatsnew.html#version-0.0.7-2023-09-08",
    "title": "What’s new",
    "section": "",
    "text": "Refactor distributions to use new Distribution class\nGitHub info: PR 112",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.6-2023-08-30",
    "href": "whatsnew.html#version-0.0.6-2023-08-30",
    "title": "What’s new",
    "section": "",
    "text": "Changes agent IDs from index-based to UID-based\nAllows states to store their own data and live within modules\nGitHub info: PR 88",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.5-2023-08-29",
    "href": "whatsnew.html#version-0.0.5-2023-08-29",
    "title": "What’s new",
    "section": "",
    "text": "Refactor file structure\nGitHub info: PRs 77 and 86",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.2-2023-06-29",
    "href": "whatsnew.html#version-0.0.2-2023-06-29",
    "title": "What’s new",
    "section": "",
    "text": "Adds in basic Starsim functionality\nGitHub info: PR 17",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.1-2023-06-22",
    "href": "whatsnew.html#version-0.0.1-2023-06-22",
    "title": "What’s new",
    "section": "",
    "text": "Initial version.",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Starsim",
    "section": "",
    "text": "Starsim is an agent-based modeling framework for simulating the spread of diseases among agents via dynamic transmission networks. Starsim supports the co-transmission of multiple diseases at once, capturing how they interact biologically and behaviorally. Users can also include non-infectious diseases either on their own or as factors affecting infectious diseases. Starsim allows detailed modeling of mother-child relationships from conception to study birth-related diseases. Additionally, Starsim lets users compare different intervention strategies, like vaccines or treatments, to see their impact through various delivery methods such as mass campaigns or targeted outreach.\nExamples of diseases that have already been implemented in Starsim include sexually transmitted infections (HIV, HPV, and syphilis, including co-transmission), respiratory infections (tuberculosis and RSV), plus other diseases (Ebola and cholera) and underlying determinants of health (such as malnutrition).\nNote: Starsim is a general-purpose, multi-disease framework that builds on our previous suite of disease-specific models, which included Covasim, HPVsim, and FPsim. In cases where a distinction needs to be made, Starsim is also known as “the Starsim framework” or “Starsim Core”, while this collection of other models is known as the “Starsim suite”.\nFor more information about Starsim, please see the documentation. Information about Starsim for R is available at r.starsim.org.\n\n\nPython 3.9-3.13 or R.\nWe recommend, but do not require, installing Starsim in a virtual environment, such as Miniconda.\n\n\n\n\n\nStarsim is most easily installed via PyPI:\npip install starsim\nOr with uv:\nuv init example\ncd example\nuv add starsim\nStarsim can also be installed locally. To do this, clone first this repository, then run:\npip install -e .\n(Don’t forget the dot at the end!)\n\n\n\nR-Starsim is still under development. You can install it with:\n# install.packages(\"devtools\")\ndevtools::install_github(\"starsimhub/rstarsim\")\nlibrary(starsim)\ninit_starsim()\n\n\n\n\nFull documentation, including tutorials and an API reference, is available at docs.starsim.org.\nYou can run a simple demo via:\nimport starsim as ss\nss.demo()\nHere is a slightly more realistic example of an SIR model with random connections between agents:\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 5_000,     # Number of agents to simulate\n    networks = dict(      # Networks define how agents interact w/ each other\n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 10   # Each person has 10 contacts with other people  \n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model\n        type = 'sir',     # Here, we're creating an SIR disease\n        init_prev = 0.01, # Proportion of the population initially infected\n        beta = 0.05,      # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot() # Plot all the sim results\nsim.diseases.sir.plot() # Plot the standard SIR curves\nMore usage examples are available in the tutorials, as well as the tests folder.\n\n\n\nAll core model code is located in the starsim subfolder; standard usage is import starsim as ss.\nThe model consists of core classes including Sim, People, Disease, Network, Intervention, and more. These classes contain methods for running, building simple or dynamic networks, generating random numbers, calculating results, plotting, etc.\nThe submodules of the Starsim folder are as follows:\n\narrays.py: Classes to handle store and update states for people in networks in the simulation including living, mother, child, susceptible, infected, inoculated, recovered, etc.\ncalibration.py: Class to handle automated calibration of the model to data.\ncalib_components.py: Classes to handle additional operations related to calibration (e.g., the likelihood function).\ndemographics.py: Classes to transform initial condition input parameters for use in building and utilizing networks.\ndisease.py: Classes to manage infection rate of spread, prevalence, waning effects, and other parameters for specific diseases.\ndistributions.py: Classes that handle statistical distributions used throughout Starsim to produce random numbers.\ninterventions.py: The Intervention class, for adding interventions and dynamically modifying parameters, and classes for each of the specific interventions derived from it. The Analyzers class (for performing analyses on the sim while it’s running), and other classes and functions for analyzing simulations.\nloop.py: The logic for the main simulation integration loop.\nmodules.py: Class to handle “module” logic, such as updates (diseases, networks, etc).\nnetworks.py: Classes for creating simple and dynamic networks of people based on input parameters.\nparameters.py: Classes for creating the simulation parameters.\npeople.py: The People class, for handling updates of state for each person.\nproducts.py: Classes to manage the deployment of vaccines and treatments.\nresults.py: Classes to analyze and save results from simulations.\nrun.py: Classes for running simulations (e.g. parallel runs and the Scenarios and MultiSim classes).\nsamples.py: Class to store data from a large number of simulations.\nsettings.py: User-customizable options for Starsim (e.g. default font size).\nsim.py: The Sim class, which performs most of the heavy lifting: initializing the model, running, and plotting.\ntime.py: The Time class, which coordinates time between the Sim and different modules.\nutils.py: Helper functions.\nversion.py: Version, date, and license information.\n\nThe diseases folder within the Starsim package contains definitions of different types of diseases, including STIs, Ebola, and cholera.\n\n\n\nQuestions or comments can be directed to info@starsim.org , or on this project’s GitHub page. Full information about Starsim is provided in the documentation.\n\n\n\nThe code in this repository was developed by IDM, the Burnet Institute, and other collaborators to support our joint research on flexible agent-based modeling. We’ve made it publicly available under the MIT License to provide others with a better understanding of our research and an opportunity to build upon it for their own work. We make no representations that the code works as intended or that we will provide support, address issues that are found, or accept pull requests. You are welcome to create your own fork and modify the code to suit your own modeling needs as permitted under the MIT License.\n\n\n\n\n\nTutorials\nAn interactive tour of Starsim’s key features.\n\n\nAPI reference\nFull details on all classes and functions.\n\n\nWhat’s new\nSee what’s in the latest Starsim releases.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#requirements",
    "href": "index.html#requirements",
    "title": "Starsim",
    "section": "",
    "text": "Python 3.9-3.13 or R.\nWe recommend, but do not require, installing Starsim in a virtual environment, such as Miniconda.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Starsim",
    "section": "",
    "text": "Starsim is most easily installed via PyPI:\npip install starsim\nOr with uv:\nuv init example\ncd example\nuv add starsim\nStarsim can also be installed locally. To do this, clone first this repository, then run:\npip install -e .\n(Don’t forget the dot at the end!)\n\n\n\nR-Starsim is still under development. You can install it with:\n# install.packages(\"devtools\")\ndevtools::install_github(\"starsimhub/rstarsim\")\nlibrary(starsim)\ninit_starsim()",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#usage-and-documentation",
    "href": "index.html#usage-and-documentation",
    "title": "Starsim",
    "section": "",
    "text": "Full documentation, including tutorials and an API reference, is available at docs.starsim.org.\nYou can run a simple demo via:\nimport starsim as ss\nss.demo()\nHere is a slightly more realistic example of an SIR model with random connections between agents:\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 5_000,     # Number of agents to simulate\n    networks = dict(      # Networks define how agents interact w/ each other\n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 10   # Each person has 10 contacts with other people  \n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model\n        type = 'sir',     # Here, we're creating an SIR disease\n        init_prev = 0.01, # Proportion of the population initially infected\n        beta = 0.05,      # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot() # Plot all the sim results\nsim.diseases.sir.plot() # Plot the standard SIR curves\nMore usage examples are available in the tutorials, as well as the tests folder.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#starsim-structure",
    "href": "index.html#starsim-structure",
    "title": "Starsim",
    "section": "",
    "text": "All core model code is located in the starsim subfolder; standard usage is import starsim as ss.\nThe model consists of core classes including Sim, People, Disease, Network, Intervention, and more. These classes contain methods for running, building simple or dynamic networks, generating random numbers, calculating results, plotting, etc.\nThe submodules of the Starsim folder are as follows:\n\narrays.py: Classes to handle store and update states for people in networks in the simulation including living, mother, child, susceptible, infected, inoculated, recovered, etc.\ncalibration.py: Class to handle automated calibration of the model to data.\ncalib_components.py: Classes to handle additional operations related to calibration (e.g., the likelihood function).\ndemographics.py: Classes to transform initial condition input parameters for use in building and utilizing networks.\ndisease.py: Classes to manage infection rate of spread, prevalence, waning effects, and other parameters for specific diseases.\ndistributions.py: Classes that handle statistical distributions used throughout Starsim to produce random numbers.\ninterventions.py: The Intervention class, for adding interventions and dynamically modifying parameters, and classes for each of the specific interventions derived from it. The Analyzers class (for performing analyses on the sim while it’s running), and other classes and functions for analyzing simulations.\nloop.py: The logic for the main simulation integration loop.\nmodules.py: Class to handle “module” logic, such as updates (diseases, networks, etc).\nnetworks.py: Classes for creating simple and dynamic networks of people based on input parameters.\nparameters.py: Classes for creating the simulation parameters.\npeople.py: The People class, for handling updates of state for each person.\nproducts.py: Classes to manage the deployment of vaccines and treatments.\nresults.py: Classes to analyze and save results from simulations.\nrun.py: Classes for running simulations (e.g. parallel runs and the Scenarios and MultiSim classes).\nsamples.py: Class to store data from a large number of simulations.\nsettings.py: User-customizable options for Starsim (e.g. default font size).\nsim.py: The Sim class, which performs most of the heavy lifting: initializing the model, running, and plotting.\ntime.py: The Time class, which coordinates time between the Sim and different modules.\nutils.py: Helper functions.\nversion.py: Version, date, and license information.\n\nThe diseases folder within the Starsim package contains definitions of different types of diseases, including STIs, Ebola, and cholera.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "Starsim",
    "section": "",
    "text": "Questions or comments can be directed to info@starsim.org , or on this project’s GitHub page. Full information about Starsim is provided in the documentation.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#disclaimer",
    "href": "index.html#disclaimer",
    "title": "Starsim",
    "section": "",
    "text": "The code in this repository was developed by IDM, the Burnet Institute, and other collaborators to support our joint research on flexible agent-based modeling. We’ve made it publicly available under the MIT License to provide others with a better understanding of our research and an opportunity to build upon it for their own work. We make no representations that the code works as intended or that we will provide support, address issues that are found, or accept pull requests. You are welcome to create your own fork and modify the code to suit your own modeling needs as permitted under the MIT License.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#learn-more",
    "href": "index.html#learn-more",
    "title": "Starsim",
    "section": "",
    "text": "Tutorials\nAn interactive tour of Starsim’s key features.\n\n\nAPI reference\nFull details on all classes and functions.\n\n\nWhat’s new\nSee what’s in the latest Starsim releases.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "user_guide/intro_spokes.html",
    "href": "user_guide/intro_spokes.html",
    "title": "Starsim “spokes”",
    "section": "",
    "text": "The Starsim framework serves as a centralized “hub” for storing anything that is typically required to model the spread of diseases among agents. This includes representations of networks, diseases, populations, demographics, interventions, and products, and logic for connecting all of these things together and simulating their interactions over time.\nSpecific models that have been created using the Starsim framework are kept in their own separate repositories, or “spokes”. As of May 2025, Starsim’s spokes include the following models:\n\n\n\nSpoke\nStatus\nDescription\n\n\n\n\nHPVsim\nStable\nHuman papillomavirus (HPV) and cervical cancer\n\n\nFPsim\nStable\nFamily planning and reproductive health\n\n\nSTIsim\nBeta\nSexually transmitted infections, including HIV, bacterial vaginosis, chlamydia, gonorrhea, syphilis, and trichomoniasis\n\n\nRotasim\nPre-release\nRotavirus, with a focus on genetic diversity\n\n\nPHCsim\nPre-release\nPrimary health care and health systems\n\n\nMIGHTI\nPre-release\nModel of Inter-Generational Health, Transmission, and Interventions (HIV and other comorbidities)\n\n\nTyphoidsim\nPre-release\nTyphoid, including environmental transmission\n\n\nTBsim\nPre-release\nTuberculosis, including malnutrition\n\n\nRVFsim\nPre-release\nRift valley fever in cattle\n\n\n\nIf you’ve developed a spoke and want it included in this list, please get in touch.\nOne of the strengths of Starsim is that all of these models are inter-compatible. For example, an HIV-TB coinfection model can be created by combining the HIV module from STIsim and the TB module from TBsim.\nNote: the Starsim suite also includes Covasim (for modeling COVID-19). Covasim is built on the same principles as Starsim, but unlike the above tools, it is a separate codebase and is not inter-operable with the other models.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "Starsim \"spokes\""
    ]
  },
  {
    "objectID": "user_guide/advanced_time.html",
    "href": "user_guide/advanced_time.html",
    "title": "Time units",
    "section": "",
    "text": "TBC",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Time units"
    ]
  },
  {
    "objectID": "user_guide/modules_analyzers.html",
    "href": "user_guide/modules_analyzers.html",
    "title": "Analyzers",
    "section": "",
    "text": "Each Starsim module can have its own results, which get added to the full list of results in the Sim object. For example, the ss.Pregnancy module adds results like sim.results.pregnancy.pregnant, and the ss.HIV module adds results like sim.results.hiv.new_infections. If you are writing your own module, you can add whatever custom results you want. However, another option is to create an Analyzer to store results that you might need for one particular analysis but won’t need all the time. An Analyzer is very similar to other Starsim modules in its structure, but the general idea of an analyzer is that it gets called at the end of a timestep, and reports of the state of things after everything else has been updated without changing any of the module states itself.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Analyzers"
    ]
  },
  {
    "objectID": "user_guide/modules_analyzers.html#simple-usage",
    "href": "user_guide/modules_analyzers.html#simple-usage",
    "title": "Analyzers",
    "section": "Simple usage",
    "text": "Simple usage\nFor simple reporting, it’s possible to use a single function as an analyzer. In this case, the function receives a single argument, sim, which it has full access to. For example, if you wanted to know the number of connections in the network on each timestep, you could write a small analyzer as follows:\n\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Store the number of edges\nn_edges = []\n\ndef count_edges(sim):\n    \"\"\" Print out the number of edges in the network on each timestep \"\"\"\n    network = sim.networks[0] # Get the first network\n    n = len(network)\n    n_edges.append(n)\n    print(f'Number of edges for network {network.name} on step {sim.ti}: {n}')\n    return\n\n# Create the sim\npars = dict(\n    diseases='sis',\n    networks = 'mf',\n    analyzers = count_edges,\n    demographics = True,\n)\n\n# Run the sim\nsim = ss.Sim(pars).run()\nsim.plot()\n\n# Plot the number of edges\nplt.figure()\nplt.plot(sim.timevec, n_edges)\nplt.title('Number of edges over time')\nplt.show()\n\nIs that what you expected it to look like? The reason it looks like that is that initially, agents die (either from aging or from disease), reducing the number of edges. New agents are being born, but they don’t participate in male-female networks until the age of debut – which is 15 years old by default, which is why the trend reverses (and tracks population size) after 2015. This illustrates the importance of model burn-in!",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Analyzers"
    ]
  },
  {
    "objectID": "user_guide/modules_analyzers.html#advanced-usage",
    "href": "user_guide/modules_analyzers.html#advanced-usage",
    "title": "Analyzers",
    "section": "Advanced usage",
    "text": "Advanced usage\nSuppose we wanted to create an analyzer that would report on the number of new HIV infections in pregnant women:\n\nimport starsim as ss\nimport pandas as pd\n\nclass HIV_preg(ss.Analyzer):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        return\n    \n    def init_results(self):\n        super().init_results()\n        self.define_results(\n            ss.Result('new_infections_pregnancy'),\n        )\n        return\n\n    def step(self):\n        sim = self.sim\n        ti = sim.ti\n        hiv = sim.diseases.hiv\n        pregnant = sim.demographics.pregnancy.pregnant\n        newly_infected = hiv.ti_infected == ti\n        self.results['new_infections_pregnancy'][ti] = len((newly_infected & pregnant).uids)\n        return\n\npregnancy = ss.Pregnancy(fertility_rate=pd.read_csv('test_data/nigeria_asfr.csv'))\nhiv = ss.HIV(beta={'mfnet':[0.5,0.25]})\nsim = ss.Sim(diseases=hiv, networks='mfnet', demographics=pregnancy, analyzers=HIV_preg())\nsim.run()\nprint(f'Total infections among pregnant women: {sim.results.hiv_preg.new_infections_pregnancy.sum()}')\n\nAnalyzers are ideal for adding custom results, and because they get added to the sim in the same way as any other result, they also get automatically exported in the same format, e.g. using sim.to_df().\nHere’s a plot of the results from our HIV in pregnancy analyzer:\n\nimport matplotlib.pyplot as plt\n\nres = sim.results.hiv_preg\n\nplt.figure()\nplt.bar(res.timevec, res.new_infections_pregnancy)\nplt.title('HIV infections acquired during pregnancy')\nplt.show()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Analyzers"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html",
    "href": "user_guide/modules_demographics.html",
    "title": "Demographics",
    "section": "",
    "text": "Starsim can include detailed population dynamics through its demographics modules. These modules handle births, deaths, and pregnancy to model realistic population changes over time. By default, Starsim simulations have a fixed population size, but adding demographics allows the population to grow, shrink, and change age structure naturally.\nDemographics modules are essential for modeling disease transmission over longer time periods, understanding generational effects, and capturing realistic population dynamics.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html#simple-usage",
    "href": "user_guide/modules_demographics.html#simple-usage",
    "title": "Demographics",
    "section": "Simple usage",
    "text": "Simple usage\nLet’s start by comparing two identical simulations, one with demographics enabled and one without:\n\nimport starsim as ss\nimport sciris as sc\nsc.options(jupyter=True)\n\n# Simulation parameters\npars = dict(diseases='sis', networks='random', verbose=0)\n\n# Create simulations\nsim1 = ss.Sim(label='No demographics', **pars)\nsim2 = ss.Sim(label='With demographics', demographics=True, **pars)\n\n# Run both simulations and plot\nmsim = ss.parallel(sim1, sim2)\nmsim.plot(['n_alive', 'cum_deaths', 'sis_n_susceptible', 'sis_n_infected'])",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html#advanced-usage-pregnancy-and-births",
    "href": "user_guide/modules_demographics.html#advanced-usage-pregnancy-and-births",
    "title": "Demographics",
    "section": "Advanced usage: Pregnancy and births",
    "text": "Advanced usage: Pregnancy and births\nFor more detailed modeling, you can use the Pregnancy module instead of simple Births. The pregnancy module models: - Age-specific fertility rates - Pregnancy duration and outcomes - Maternal and neonatal mortality - Mother-to-child transmission pathways\n\nimport numpy as np\nimport pandas as pd\nimport sciris as sc\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Create age-specific birth and fertility data\n\nbirth_data = pd.DataFrame({\n    'Year': [2000, 2005, 2010, 2015, 2020, 2025, 2030],\n    'CBR': [40, 35, 30, 31, 32, 30, 28]  # Age-specific birth rates\n})\n\nfertility_data = pd.DataFrame({\n    'Time': [2020]*7,\n    'AgeGrp': [15, 20, 25, 30, 35, 40, 45],\n    'ASFR': [0.05, 0.15, 0.20, 0.15, 0.10, 0.05, 0.01]  # Age-specific fertility rates\n})\n\n# Create a simple births module\nbirths = ss.Births(birth_rate=birth_data)\n\n# Create a pregnancy module with custom parameters\npregnancy = ss.Pregnancy(\n    fertility_rate = fertility_data,\n    rel_fertility = 1000, # Whether data are per person or per 1000\n    dur_pregnancy = ss.years(0.75),           # 9 months pregnancy\n    dur_postpartum = ss.years(0.5),           # 6 months postpartum\n    p_maternal_death = ss.bernoulli(0.001),   # 0.1% maternal mortality\n    p_neonatal_death = ss.bernoulli(0.02),    # 2% neonatal mortality\n    min_age = 15,\n    max_age = 50,\n)\n\n# Create deaths module\ndeaths = ss.Deaths(death_rate=ss.peryear(8))  # 8 deaths per 1000 per year\n\n# Create simulations\nn_agents = 5_000 # Number of agents\nnga_pop_1995 = 106819805 # \nage_data = pd.read_csv('test_data/nigeria_age.csv')\nppl = ss.People(n_agents, age_data=age_data)\n\npars = dict(start=1995, people=ppl, n_agents=n_agents, diseases='sis', networks='random', verbose=0)\n\nsim1 = ss.Sim(label='Births', **pars, demographics=[births, deaths])\nsim2 = ss.Sim(label='Pregnancy', **pars, demographics=[pregnancy, deaths])\n\n# Plot histograms of the age distributions - simulated vs data at initialization\nsim1.init() # This creates the population\nbins = np.arange(0, 101, 1)\ninit_scale = nga_pop_1995 / n_agents\ncounts, bins = np.histogram(sim1.people.age, bins)\nplt.bar(bins, age_data.value.values * 1000, alpha=0.5, color='r', label='Data')\nplt.bar(bins[:-1], counts * init_scale, alpha=0.5, label='Simulated')\nplt.legend(loc='upper right')\nplt.ylabel('Population')\nplt.xlabel('Age')\nsc.SIticks()\n\n# Run nd plot simulations\nmsim = ss.parallel(sim1, sim2)\nmsim.plot()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html#summary",
    "href": "user_guide/modules_demographics.html#summary",
    "title": "Demographics",
    "section": "Summary",
    "text": "Summary\nDemographics modules enable realistic population dynamics in Starsim: - Births: Simple constant or time-varying birth rates - Deaths: Background mortality separate from disease deaths\n- Pregnancy: Detailed pregnancy modeling with maternal/neonatal outcomes\nKey considerations: - Use demographics=True for default birth/death rates - Use birth_rate and death_rate for custom constant rates - Use ss.Pregnancy() for age-specific fertility, pregnancy modeling, and mother-to-child transmission - Demographics automatically enables aging; if you want to use aging without demographics, set use_aging=True",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html",
    "href": "user_guide/workflows_samples.html",
    "title": "Managing samples",
    "section": "",
    "text": "As STIsim models are usually stochastic, for a single scenario it is often desirable to run the model multiple times with different random seeds. The role of the Samples class is to facilitate working with large numbers of simulations and scenarios, to ease:\nEssentially, if we think of the processed results of a model run as being\nthen the classes Dataset and Samples manage collections of these results. In particular, the Samples class manages different random samples of the same parameters, and the Dataset class manages a collection of Samples.\nimport starsim as ss\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport sciris as sc",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Managing samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#obtaining-simulation-output",
    "href": "user_guide/workflows_samples.html#obtaining-simulation-output",
    "title": "Managing samples",
    "section": "Obtaining simulation output",
    "text": "Obtaining simulation output\nTo demonstrate usage of this class, we will first consider constructing the kinds of output that the Samples class stores. We begin by running a basic simulation using the SIR model:\n\nppl = ss.People(5000)\nnet = ss.ndict(ss.RandomNet(n_contacts=ss.poisson(5)))\nsir = ss.SIR()\nsim = ss.Sim(people=ppl, networks=net, diseases=sir, rand_seed=0)\nsim.run();\n\n\nDataframe output\nA Sim instance is (in general) too large and complex to efficiently store on disk - the file size and loading time make it prohibitive to work with tens of thousands of simulations. Therefore, rather than storing entire Sim instances, we instead store dataframes containing just the simulation results and any other pre-processed calculated quantities. There are broadly speaking two types of outputs\n\nScalar outputs at each timepoint (e.g., daily new cases)\nScalar outputs for each simulation (e.g., total number of deaths)\n\nThese outputs can each be produced from a Sim - the former has a tabular structure, and the latter has a dictionary structure (which can later be assembled into a table where the rows correspond to each simulation). The export_df method is a quick way to obtain a dataframe with the appropriate structure retaining all results from the Sim.\n\nIn real-world use, it is often helpful to write your own function to extract a dataframe of simulation outputs, because typically some of the outputs need to be extracted from custom Analyzers.\n\n\nsim.to_df()\n\n\n\nScalar/summary outputs\nWe can also consider extracting a summary dictionary of scalar values. For example:\n\nsummary = {}\nsummary['seed'] = sim.pars['rand_seed']\nsummary['p_death'] = sim.diseases[0].pars.p_death.pars.p\nsummary['cum_infections'] = sum(sim.results.sir.new_infections)\nsummary['cum_deaths'] = sum(sim.results.new_deaths)\nsummary\n\n\nNotice how in the example above, the summary contains both simulation inputs (seed, probability of death) as well as simulation outputs (total infections, total deaths). The simulation summary should contain sufficient information about the simulation inputs to identify the simulation. The seed should generally be present. The other inputs normally correspond to variables that scenarios are being run over. In this example, we will run scenarios comparing simulations with different probabilities of death. Therefore, we need to include the death probability in the simulation summary.\n\n\n\nRunning the model\nFor usage at scale, the steps of creating a simulation, running it and producing these outputs are usually encapsulated in functions\n\ndef get_sim(seed, p_death):\n    ppl = ss.People(5000)\n    net = ss.RandomNet(n_contacts=ss.poisson(5))\n    sir = ss.SIR(p_death=p_death)\n    sim = ss.Sim(people=ppl, networks=net, diseases=sir, rand_seed=seed)\n    sim.init(verbose=0)\n    return sim\n    \ndef run_sim(seed, p_death):\n    sim = get_sim(seed, p_death)\n    sim.run(verbose=0)\n    df = sim.to_df()\n    \n    summary = {}\n    summary['seed'] = sim.pars['rand_seed']\n    summary['p_death']= sim.diseases[0].pars.p_death.pars.p\n    summary['cum_infections'] = sum(sim.results.sir.new_infections)\n    summary['cum_deaths'] = sum(sim.results.new_deaths)\n    \n    return df, summary\n\n\nThe functions above could be combined into a single function. However, in real world usage it is often convenient to be able to construct a simulation independently of running it (e.g., for diagnostic purposes or to allow running the sim in a range of different ways). The suggested structure above, with a get_sim() function and a run_sim() function are recommended as standard practice.\n\nNow running a simulation for a given beta/seed value and returning the processed outputs can be done in a single step\n\n# Scalar output\ndf, summary = run_sim(0, 0.2);\nsummary\n\nWe can produce all of the samples associated with a scenario by iterating over the input seed values. This is being done in a basic loop here, but could be done in more sophistical ways to leverage parallel computing (e.g., with sc.parallelize for single host parallelization, or with celery for distributed computation).\n\n# Run a collection of sims\nn = 20\nseeds = np.arange(n)\noutputs = [run_sim(seed, 0.2) for seed in seeds]",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Managing samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#saving-and-loading-the-samples",
    "href": "user_guide/workflows_samples.html#saving-and-loading-the-samples",
    "title": "Managing samples",
    "section": "Saving and loading the samples",
    "text": "Saving and loading the samples\nWe have now produced simulation outputs (dataframes and summary statistics) for 20 simulation runs. The outputs here are a list of tuples, containing the dataframe and dictionary outputs for each sample. This list can be passed to the cvv.Samples class to produce a single compressed file on disk\n\nresultsdir = Path('results')\nresultsdir.mkdir(exist_ok=True, parents=True)\nss.Samples.new(resultsdir, outputs, identifiers=[\"p_death\"])\nlist(resultsdir.iterdir())\n\nNotice that a list of identifiers should be passed to the Samples constructor. This is a list of keys in the simulation summary dictionaries that identifies the scenario. These would be model inputs rather than model outputs, and they should be the same for all of the outputs passed into the Samples object. If no file name is explicitly provided, the file will automatically be assigned a name based on the identifiers.\n\nThe Samples file internally contains metadata recording the identifiers. When Samples are accessed using the Dataset class, they can be accessed via the internal metadata. Therefore for a typical workflow, the file name largely doesn’t matter, and it usually doesn’t need to be manually specified.\n\nThe saved file can be loaded and accessed via the Samples class. Importantly, individual files can be extracted from a .zip file without decompressing the entire archive. This means that loading the summary dataframe and using it to selectively load the full outputs for individual runs can be done efficiently. For example, loading retrieving a single result from a Samples file would take a similar amount of time regardless of whether the file contained 10 samples or 100000 samples.\n\n# Load the samples\nres = ss.Samples('results/0.2.zip')\nres.summary\n\nWhen the Samples file was created, a dictionary of scalars was provided for each result. These are automatically used to populate a ‘summary’ dataframe, where each identifier (and the seed) are used as the index, and the remaining keys appear as columns, as shown above. As a shortcut, columns of the summary dataframe can be accessed by indexing the Samples object directly, without having to access the .summary attribute e.g.,\n\nres['cum_infections']\n\nEach simulation is uniquely identified by its seed, and the time series dataframe for each simulation can be accessed by indexing the Samples object with the seed:\n\nres[0]\n\nThe dataframes in the Samples object are cached, so that the dataframes don’t all need to be loaded in order to start working with the file. The first time a dataframe is accessed, it will be loaded from disk. Subsequent requests for the dataframe will return a cached version instead. The cached dataframe is copied each time it is retrieved, to prevent accidentally modifying the original data.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Managing samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#common-analysis-operations",
    "href": "user_guide/workflows_samples.html#common-analysis-operations",
    "title": "Managing samples",
    "section": "Common analysis operations",
    "text": "Common analysis operations\nHere are some examples of common analyses that can be performed using functionality in the Samples class\n\nPlotting summary quantities\nOften it’s useful to be able plot distributions of summary quantities, such as the total infections. This can be performed by directly indexing the Samples object and then using the appropriate plotting command:\n\nplt.hist(res['cum_infections'], density=True)\n\nplt.xlabel('Total infections')\nplt.ylabel('Probability density')\n\n\n\nPlotting time series\nTime series plots can be obtained by accessing the dataframes associated with each seed, and then plotting quantities from those. For convenience, iterating over the Samples object will automatically iterate over all of the dataframes associated with each seed. For example:\n\nfor df in res:\n    plt.plot(df['sir_new_infections'], color='b', alpha=0.1)\n\n\n\nOther ways to access content\nWe have seen so far that we can use\n\nres.summary - retrieve dataframe of summary outputs\nres[summary_column] - retrieve a column of the summary dataframe\nres[seed] - retrieve the time series dataframe associated with one of the simulations\nfor df in res - iterate over time series dataframes\n\nSometimes it is useful to have access to both the summary dictionary and the time series dataframe associated with a single sample. These can be accessed using the get method, which takes in a seed, and returns both outputs for that seed together:\n\nres.get(0) # Retrieve both summary quantities and dataframes\n\nIn the same way that it is possible to index the Samples object directly in order to retrieve columns from the summary dataframe, it is also possible to directly index the Samples object to get a column of the time series dataframe. In this case, pass a tuple of items to the Samples object, where the first item is the seed, and the second is a column from the time series dataframe. For example:\n\nres[0,'sir_n_infected'] # Equivalent to `res[0]['sir.n_infected']`\n\n\n\nFiltering results\nThe .seeds attribute contains a listing of seeds, which can be helpful for iteration\n\nres.seeds\n\nThe seeds are drawn from the summary dataframe, which defines which seeds are accessible via the Samples object. Therefore, you can drop rows from the summary dataframe to filter the results. For example, suppose we only wanted to analyze simulations with over 4900 deaths. We could retrieve a copy of the summary dataframe that only contains matching simulations:\n\nres.summary.loc[res['cum_infections']&gt;4900]\n\nWe can then make a copy of the results and write the reduced summary dataframe back to that object\n\nres2 = res.copy()\nres2.summary = res.summary.loc[res['cum_infections']&gt;4900]\n\n\nUnlike sc.dcp(), copying using the .copy() method only deep copies the summary dataframe. It does not duplicate the time series dataframes or the cache. For Samples objects, it is therefore generally preferable to use .copy().\n\nNow notice that there are fewer samples, and the seeds have been filtered\n\nlen(res)\n\n\nlen(res2)\n\n\nres2.seeds\n\n\nplt.hist(res2['cum_infections'], density=True)\nplt.xlabel('Total infections')\nplt.ylabel('Probability density')\n\n\n\nApplying functions and transformations\nSometimes it might be necessary to calculate quantities that are derived from the time series dataframes. These could be simple scalar values, such as totals or averages that had not been computed ahead of time, or extracting values from each simulation at a particular point in time. As an alternative to writing a loop that iterates over the seeds, the .apply() method takes in a function and maps it to every dataframe. This makes it quick to construct lists or arrays with scalar values extracted from the time series. For example, suppose we wanted to extract the peak number of people infected from each simulation:\n\npeak_infections = lambda df: df['sir_n_infected'].max()\nres.apply(peak_infections)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Managing samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#options-when-loading",
    "href": "user_guide/workflows_samples.html#options-when-loading",
    "title": "Managing samples",
    "section": "Options when loading",
    "text": "Options when loading\nThere are two options available when loading that can change how the Samples class interacts with the file on disk:\n\nmemory_buffer - copy the entire file into memory. This prevents the file from being locked on disk and allows scripts to be re-run and results regenerated while still running the analysis notebook. This defaults to True for convenience, but loading the entire file into memory can be problematic if the file is large (e.g., &gt;1GB) in which case setting memory_buffer=False may be preferable\npreload - Populate the cache in one step. This facilitates interactive usage of the analysis notebook by making the runtime of analysis functions predictable (since all results will be retrieved from the cache) at the expense of a long initial load time\n\n\nImplementation details\nIf the file is loaded from a memory buffer, the ._zipfile attribute will be populated. A helper property .zipfile is used to access the buffer, so if caching is not used, .zipfile returns the actual file on disk rather than the buffer\n\nres = ss.Samples('results/0.2.zip', memory_buffer=True) # Copy the entire file into memory\nprint(res._zipfile)\nprint(res.zipfile)\n\n\nres = ss.Samples('results/0.2.zip', memory_buffer=False) # Copy the entire file into memory\nprint(res._zipfile)\nprint(res.zipfile)\n\nThe dataframes associated with the individual dataframes are cached on access, so pd.read_csv() only needs to be called once. The cache starts out empty:\n\nres._cache\n\nWhen a dataframe is accessed, it is automatically stored in the cache:\n\nres[0]\nres._cache.keys()\n\nThis means that iterating through the dataframes the first time can be slow (but in general, iterating over all dataframes is avoided in favour of either only using summary outputs, or accessing a subset of the runs)\n\nwith sc.Timer():\n    for df in res:\n        continue\n\n\nwith sc.Timer():\n    for df in res:\n        continue\n\nThe preload option populates the entire cache in advance. This makes creating the Samples object slower, but operating on the dataframes afterwards will be consistently fast. This type of usage can be useful when wanting to load large files in the background and then interactively work with them afterwards.\n\nwith sc.Timer():\n    res = ss.Samples('results/0.2.zip', preload=True)\n\n\nwith sc.Timer():\n    for df in res:\n        continue\n\n\nwith sc.Timer():\n    for df in res:\n        continue\n\nTogether, these options provide some flexibility in terms of memory and time demands to suit analyses at various different scales.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Managing samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#running-scenarios",
    "href": "user_guide/workflows_samples.html#running-scenarios",
    "title": "Managing samples",
    "section": "Running scenarios",
    "text": "Running scenarios\nSuppose we wanted to compare a range of different p_death values and initial values (initial number of infections). We might define these runs as\n\ninitials = np.arange(1,4)\np_deaths = np.arange(0,1,0.25)\n\nRecall that our run_sim() function had an argument for p_death. We can extend this to include the initial parameter too. We can actually generalize this further by passing the parameters as keyword arguments to avoid needing to hard-code all of them. Note that we also need to add the initial value to the summary outputs:\n\ndef get_sim(seed, **kwargs):\n    ppl = ss.People(5000)\n    net = ss.RandomNet(n_contacts=ss.poisson(5))\n    sir = ss.SIR(pars=kwargs)\n    sim = ss.Sim(people=ppl, networks=net, diseases=sir, rand_seed=seed)\n    sim.init(verbose=0)\n    return sim\n    \ndef run_sim(seed, **kwargs):\n    sim = get_sim(seed, **kwargs)\n    sim.run(verbose=0)\n    df = sim.to_df()\n    sir = sim.diseases.sir\n    \n    summary = {}\n    summary['seed'] = sim.pars.rand_seed\n    summary['p_death']= sir.pars.p_death.pars.p\n    summary['initial']= sir.pars.init_prev.pars.p\n    summary['cum_infections'] = sum(sim.results.sir.new_infections)\n    summary['cum_deaths'] = sum(sim.results.new_deaths)\n    \n    return df, summary\n\nWe can now easily run a set of scenarios with different values of p_death and save each one to a separate Samples object. Note that when we create the Samples objects now, we also want to specify that 'init_prev' is one of the identifiers for the scenarios:\n\n# Clear the existing results\nfor file_path in resultsdir.glob('*'):\n    file_path.unlink()\n\n\n# Run the sweep over initial and p_death\nn = 20\nseeds = np.arange(n)\nfor init_prev in initials:\n    for p_death in p_deaths:\n        outputs = [run_sim(seed, init_prev=init_prev, p_death=p_death) for seed in seeds]\n        ss.Samples.new(resultsdir, outputs, [\"p_death\", \"initial\"])\n\nThe results folder now contains a collection of saved Samples objects. Notice how the automatically selected file names now contain both the p_death value and the initial value, because they were both specified as identifiers. We can load one of these objects in to see how these identifiers are stored and accessed inside the Samples class:\n\nlist(resultsdir.iterdir())\n\n\nres = ss.Samples('results/0.25-2.zip')\n\nThe ‘id’ of a Samples object is a dictionary of the identifiers, which makes it easy to access the input parameters associated with a set of scenario runs:\n\nres.id\n\nThe ‘identifier’ is a tuple of these values, which is suitable for use as a dictionary key. This can be useful for accumulating and comparing variables across scenarios\n\nres.identifier\n\n\nLoading multiple scenarios\nWe saw above that we now have a directory full of .zip files corresponding to the various scenario runs. These can be accessed using the Dataset class, which facilitates accessing multiple instances of Samples. We can pass the folder containing the results to the Dataset constructor to load them all:\n\nresults = ss.Dataset(resultsdir)\nresults\n\nThe .ids attribute lists all of the values available across scenarios in the results folder:\n\nresults.ids\n\nThe individual results can be accessed by indexing the Dataset instance using the values of the identifiers. For example:\n\nresults[0.25,2]\n\nThis indexing operation is sensitive to the order in which the identifiers are specified. The .get() method allows you to specify them as key-value pairs\n\nresults.get(initial=2, p_death=0.25)\n\nIterating over the Dataset will iterate over the Samples instances contained within it\n\nfor res in results:\n    print(res)\n\nThis can be used to extract and compare values across scenarios. For example, we could consider the use case of making a plot that compares total deaths across scenarios:\n\nlabels = []\ny = []\nyerr = []\n\nfor res in results:\n    labels.append(res.id)\n    y.append(res['cum_deaths'].median())\n\nplt.barh(np.arange(len(results)),y, tick_label=labels)\nplt.xlabel('Median total deaths');\nplt.ylabel('Scenario')\n\n\n\nFiltering scenarios\nOften plots need to be generated for a subset of scenarios e.g., for sensitivity analysis or to otherwise compare specific scenarios. Dataset.filter returns a new Dataset containing a subset of the results:\n\nfor res in results.filter(initial=2):\n    print(res)\n\n\nfor res in results.filter(p_death=0.25):\n    print(res)\n\nThis is also a quick and efficient operation, so you can easily embed filtering commands inside the analysis to select subsets of the scenarios for plotting and other output generation. For instance:\n\nfor res, color in zip(results.filter(initial=2), sc.gridcolors(4)):\n    plt.plot(res[0].index, np.median([df['new_deaths'] for df in res], axis=0), color=color, label=f'p_death = {res.id[\"p_death\"]}')\nplt.legend()\nplt.title('Sensitivity to p_death (initial = 2)')\nplt.xlabel('Year')\nplt.ylabel('New deaths')\n\n\nfor res, color in zip(results.filter(p_death=0.25), sc.gridcolors(3)):\n    plt.plot(res[0].index, np.median([df['new_deaths'] for df in res], axis=0), color=color, label=f'initial = {res.id[\"initial\"]}')\nplt.legend()\nplt.title('Sensitivity to initial infections (p_death = 0.25)')\nplt.xlabel('Year')\nplt.ylabel('New deaths')",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Managing samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_run.html",
    "href": "user_guide/workflows_run.html",
    "title": "Multiple runs",
    "section": "",
    "text": "TBC",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Multiple runs"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html",
    "href": "user_guide/workflows_deploy.html",
    "title": "Deployment",
    "section": "",
    "text": "Since Starsim is implemented in pure Python, it can easily be deployed on the cloud. Here we describe some different approaches for doing this.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html#virtual-machine",
    "href": "user_guide/workflows_deploy.html#virtual-machine",
    "title": "Deployment",
    "section": "Virtual machine",
    "text": "Virtual machine\nOne of the most common approaches is run Starsim on a single large virtual machine (VM). By default, ss.MultiSim (and ss.parallel()) will use all available cores. If your script already makes use of these, then you don’t need to make any more changes:\n\nimport sciris as sc\nimport starsim as ss\n\nbase_pars = sc.objdict(\n    n_agents = 10e3,\n    diseases = sc.objdict(\n        type = 'sis',\n        beta = 0.1,\n    ),\n    networks = 'random',\n    rand_seed = 1,\n    verbose = False,\n)\n\n# Generate sims in serial\nsims = sc.autolist() # Can also just use []\nfor i in range(10):\n    pars = base_pars.copy()\n    pars.diseases.beta *= sc.perturb()\n    pars.rand_seed = i\n    sim = ss.Sim(pars)\n    sims += sim\n\n# Run in parallel\nmsim = ss.parallel(sims)\nmsim.plot(legend=False)\n\nNote that this example uses sc.objdict() rather than dict() – either work, but it means you can use pars.diseases.beta rather than pars['diseases']['beta']. You could also create full Starsim objects (e.g. diseases = ss.SIS() and then modify pars.diseases.pars.beta).\nIn some cases, creating the sim is itself a time-consuming step (especially if hundreds or thousands are being generated). In this case, you can write a make_sim() function and parallelize that too:\n\ndef make_sim(i, pars):\n    pars.diseases.beta *= sc.perturb() # Don't need to copy pars since implicitly copied via the pickling process\n    pars.rand_seed = i\n    sim = ss.Sim(pars)\n    return sim\n\nsims = sc.parallelize(make_sim, range(10), pars=base_pars, serial=False)\nmsim = ss.parallel(sims)\nmsim.plot(legend=False)\n\nNote that parallelizing the build process pickles and unpickles the sims, which can be an expensive operation. make_sim() functions can often get quite complicated, so it’s often good software engineering practice to separate them out anyway. You can use the serial=True argument of Sciris’ sc.parallelize() function (which is what ss.parallel() calls under the hood) in order to run in serial, to see if it’s the same speed or faster.\n\nWhile the traditional way to run on a VM is via SSH and terminal, it is also possible to run remotely via VS Code (and Cursor etc.), PyCharm, or Spyder. You can also run a Jupyter server on the VM and access it that way (we like The Littlest JupyterHub).",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html#dask-and-coiled",
    "href": "user_guide/workflows_deploy.html#dask-and-coiled",
    "title": "Deployment",
    "section": "Dask and Coiled",
    "text": "Dask and Coiled\nAdapting the examples above, we can fairly easily make Starsim simulations run using other popular tools such as Dask and Joblib. Here’s a Dask example:\n\nimport dask\nimport dask.distributed as dd\nimport numpy as np\nimport starsim as ss\n\n\ndef run_sim(index, beta):\n    \"\"\" Run a standard simulation \"\"\"\n    label = f'Sim {index}, beta={beta:n}'\n    sis = ss.SIS(beta=beta)\n    sim = ss.Sim(label=label, networks='random', diseases=sis, rand_seed=index, verbose=False)\n    sim.run()\n    sim.shrink() # Remove People and other states to make pickling faster\n    return sim\n\n\nif __name__ == '__main__':\n\n    # Run settings\n    n = 8\n    n_workers = 4\n    betas = 0.1*np.sort(np.random.random(n))\n\n    # Create and queue the Dask jobs\n    client = dd.Client(n_workers=n_workers)\n    queued = []\n    for i,beta in enumerate(betas):\n        run = dask.delayed(run_sim)(i, beta)\n        queued.append(run)\n\n    # Run and process the simulations\n    sims = list(dask.compute(*queued))\n    msim = ss.MultiSim(sims)\n    msim.plot()\n\nCoiled, which is a paid service by Dask that allows auto-scaling across clusters, has a similar syntax:\nimport sciris as sc\nimport starsim as ss\nimport coiled\nimport dask.distributed as dd\n\n# Parameters\nn_workers = 50\nn = 1000\n\ndef run_sim(seed):\n    sim = ss.Sim(n_agents=100e3, dur=100, diseases='sis', networks='random', rand_seed=seed)\n    sim.run().shrink()\n    return sim\n\n# Set up cluster\ncluster = coiled.Cluster(n_workers=n_workers, workspace=\"&lt;your_coiled_workspace&gt;\")\nclient = cluster.get_client()\n\n# Set up futures\nfutures = []\nfor seed in range(n):\n    future = client.submit(run_sim, seed)\n    futures.append(future)\n\n# Run\nsims = client.gather(futures)\n\n# Plot\nmsim = ss.MultiSim(sims)\nmsim.plot()\n(Note: You will need a Coiled subscription to run this example.)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html#interactive-dashboards",
    "href": "user_guide/workflows_deploy.html#interactive-dashboards",
    "title": "Deployment",
    "section": "Interactive dashboards",
    "text": "Interactive dashboards\nAnother common desire is to make interactive dashboards. There are many ways to do this, including Shiny for Python, Voila, and Panel, but the simplest is probably Streamlit:\nimport streamlit as st\nimport starsim as ss\n\ndef run_sim(beta, n_agents):\n    sis = ss.SIS(beta=beta)\n    sim = ss.Sim(\n        n_agents = n_agents,\n        diseases = sis,\n        networks = 'random',\n    )\n    sim.run()\n    sim.label = f'Beta={beta:n} • Agents={n_agents:,} • Time={sim.timer.total:0.1f} s'\n    return sim\n\n# Create the Streamlit interface\nst.title('SIS Dashboard')\nbeta = st.slider('Transmission rate (beta)', 0.0, 1.0, 0.1)\nn_agents = st.slider('Number of agents', 1_000, 100_000, 10_000)\n\n# Run simulation and plot results\nsim = run_sim(beta, n_agents)\nfig = sim.diseases.sis.plot()\nfig.suptitle(sim.label)\nst.pyplot(fig)\nThis example is saved in this folder as streamlit.py, and (after pip install streamlit) can be run with streamlit run streamlit.py. This should give something like this:\n\n\n\nStreamlit example",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html",
    "href": "user_guide/basics_people.html",
    "title": "People, States, and Arrays",
    "section": "",
    "text": "Starsim is a framework for creating agent-based models, and the People class is where we store the agents, so it should come as no surprise that this class serves as the fundamental heart of any Starsim model. In this page we provide alternative pathways for creating people and some guidance on how to adapt these workflows depending on your needs.\nWe start by giving an overview on this page of Starsim’s custom Arr (array) classes, which are a separate but related Starsim class designed to neatly track data about people.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#starsim-states-and-arrays",
    "href": "user_guide/basics_people.html#starsim-states-and-arrays",
    "title": "People, States, and Arrays",
    "section": "Starsim States and Arrays",
    "text": "Starsim States and Arrays\nStarsim has a set of custom array classes for recording information about each agent in the population. The two fundamental types of array for storing such infomation are the State class, which is a Boolean array, and the FloatArr class, which stores numbers (we don’t distinguish between floats and integers, so all numbers are stored in these arrays). Each of these is a subclass of the Starsim Arr class.\nThe Arr class in Starsim is optimized for three key tasks that are common to almost all Starsim models: 1. Dynamic growth: as the population grows over time, the size of the arrays dynamically update in a way that avoids costly concatenation operations; 2. Indexing: over time, there are agents in the population who die. It is desirable for these agents to remain in the arrays so that we can continue to access data about them, but the indexing is set up so that dead agents are automatically excluded from most operations. 3. Stochastic states: we often want to set the values of a state by sampling from a random variable (e.g. sex might be drawn as a Bernoulli random variable). Starsim’s Arr class can be initialized with a random variables; we will provide examples of this below.\nAll agents have a uid (universal identifier), which corresponds to their position in the array. Starsim keeps track of a list of auids (active UIDs), corresponding to agents who are alive or are otherwise participating in the simulation. This way, Starsim knows to skip over dead agents (or otherwise removed, e.g. from migration) when calculating disease progression, aging, etc.\nIn most cases, you shouldn’t need to worry about uids, auids, etc. However, this example illustrates how they work:\n\nimport sciris as sc\nimport starsim as ss\n\nsim = ss.Sim(start=2000, stop=2020, n_agents=1000, diseases='sir', networks='random', demographics=True, verbose=False)\nsim.init()\n\nsc.heading('Initial state')\nppl = sim.people\nprint('Number of agents before run:', len(ppl))\nprint('Maximum UID:', ppl.uid.max())\nprint('Mean age:', ppl.age.mean())\n\nsc.heading('After running the sim')\nsim.run()\nres = sim.results\nprint('Number of agents after run:', len(ppl))\nprint('Number of agents who were born:', sim.results.births.cumulative[-1])\nprint('Number of agents who died:', sim.results.cum_deaths[-1])\nprint('Maximum UID:', ppl.uid.max())\nprint('Size of the raw arrays:', len(ppl.uid.raw))\nprint('Mean age of alive agents:', ppl.age.mean())",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#creating-default-people",
    "href": "user_guide/basics_people.html#creating-default-people",
    "title": "People, States, and Arrays",
    "section": "Creating default people",
    "text": "Creating default people\nWhen you create a sim, it automatically creates People, and you can use the n_agents argument to control the population size:\n\nimport numpy as np\nimport pandas as pd\nimport starsim as ss \nsim = ss.Sim(n_agents=1000)  # Create a sim with default people\nsim.init()\n\nThe People that are added to the Sim come with the following default states and arrays: * alive, a State that records whether each agent is alive * female, a State that records whether each agent is female * age, a FloatArr that records agent ages * ti_dead, a FloatArr that records the time of death, NaN by default * scale, a FloatArr that records the number of people that each agent represents; 1 by default.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#creating-custom-people",
    "href": "user_guide/basics_people.html#creating-custom-people",
    "title": "People, States, and Arrays",
    "section": "Creating custom people",
    "text": "Creating custom people\nRather than relying on the Sim to create people, you can create your own People and add them to the Sim as a separate argument. The example below is equivalent to the one immediately above:\n\npeople = ss.People(1000)\nsim = ss.Sim(people=people)\n\nThe main reason to create custom people is if you want to specify a particular age/sex distribution. The following example creates a population with the age distribution of Nigeria:\n\nage_data = pd.read_csv('test_data/nigeria_age.csv')\nppl = ss.People(n_agents=10e3, age_data=age_data)\nsim = ss.Sim(people=ppl, copy_inputs=False).init()\nppl.plot_ages();\n\nAnother reason to create custom people is if there are additional attributes that you want to track. Let’s say we want to add a state to track urban/rural status. The example below also illustrates how you can add a stochastic state whose values are sampled from a distribution.\n\ndef urban_function(n):\n    \"\"\" Make a function to randomly assign people to urban/rural locations \"\"\" \n    return np.random.choice(a=[True, False], p=[0.5, 0.5], size=n)\n\nurban = ss.State('urban', default=urban_function)\nppl = ss.People(10, extra_states=urban)  # Create 10 people with this state\nsim = ss.Sim(people=ppl)\nsim.init()  # Initialize the sim --&gt; essential step to create the people and sample states\nprint(f'Number of urban people: {np.count_nonzero(sim.people.urban)}')",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#modifying-people-with-modules",
    "href": "user_guide/basics_people.html#modifying-people-with-modules",
    "title": "People, States, and Arrays",
    "section": "Modifying People with modules",
    "text": "Modifying People with modules\nWe saw an example above of adding a custom state to people. However, a far more common way to add states to people is by adding a module to the Sim. All the states of the modules will automatically get added to the main People instance.\n\nppl = ss.People(30)\nsim = ss.Sim(people=ppl, diseases=ss.SIS(), networks=ss.RandomNet())\nsim.run()\nprint(f'Number of infected people: {sim.people.sis.infected.sum()}')\n\nWhen states or arrays are added by modules, they are stored as dictionaries under the name of that module.\nNote that the Starsim Arr class can be used like a Numpy array, with all the standard arithmetic operations like sums, mean, counting, etc.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#debugging-and-analyzing",
    "href": "user_guide/basics_people.html#debugging-and-analyzing",
    "title": "People, States, and Arrays",
    "section": "Debugging and analyzing",
    "text": "Debugging and analyzing\nThere are several ways to explore the People object. One way is by exporting to a dataframe:\n\ndf = sim.people.to_df()\ndf.disp()\n\nThis is usually too much information to understand directly, but can be useful for producing summary statistics; for example, let’s say we want to understand the relationship between time since recovery and immunity:\n\nimport matplotlib.pyplot as plt\nplt.scatter(df['sis.ti_recovered'], df['sis.immunity'])\nplt.xlabel('Time of recovery')\nplt.ylabel('Immunity')\nplt.show()\n\nSometimes we want to explore a single agent in more detail. For this, there is a person() method, which will return all the attributes of that particular agent (equivalent to a single row in the dataframe):\n\nsim.people.person(10)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html",
    "href": "user_guide/basics_sim.html",
    "title": "The Sim object",
    "section": "",
    "text": "As noted on the Model Structure page, the Sim is the main object for doing things with Starsim. Once you’ve created your modules for diseases and interventions, you will add them to the Sim, which will ensure that everything gets run in a sensible order, and that everything is nicely accessible afterwards.\nOn this page, we explain what happens when you create a Sim, and the particular order of steps taken when a Sim is run. We then provide a few common examples of how to create and run a Sim and when/why you might choose each one.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html#creating-and-initializing-a-sim",
    "href": "user_guide/basics_sim.html#creating-and-initializing-a-sim",
    "title": "The Sim object",
    "section": "Creating and initializing a Sim",
    "text": "Creating and initializing a Sim\nWhen you first create a sim, e.g. with sim = ss.Sim(), the resulting Sim object will be mostly empty with a few pre-set defaults. Most of the initialization is done when sim.init() is called. This completes the initialization with the following steps: * Validating the parameters; * Adding a Time module to the sim (stored under sim.t), which looks after converting parameters between timesteps; * Adding People to the Sim: if these are not supplied directly, STarsim will automatically add People with default age/sex structure; * Adding all the parameters and results from each Module to the Sim, and adding the states from each Module to the People; * Initializing any distributions contained anywhere within the parameters or states.\nA Sim is automatically initialized if sim.run() is called.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html#running-a-sim",
    "href": "user_guide/basics_sim.html#running-a-sim",
    "title": "The Sim object",
    "section": "Running a Sim",
    "text": "Running a Sim\n\nOrder of operations\nAn important function of the Sim class is that it controls the order in which the different steps of each module are executed. Starsim allows users lots of flexibility regarding the timesteps for individual modules. For example, a common usage pattern is that you may only want to update your demographic modules once a year, but you may want to update your disease modules once per month, week, or day. The Sim class stores a plan for updating each modules in the right order and with the right frequency. This is stored within a specialized Loop class housed within the Sim. Users typically won’t interact with this class directly, but it is worth knowing the order in which updates are made on each timestep.\n\nModules have a start_step method which is called first. This usually just advances random number generators forward.\nAny Demographic modules have their step method called\nAny Disease modules have their step_state method called\nAny Connectors have their step method called\nAny Networks have their step method called\nAny Interventions have their step method called\nAny Disease modules have their step method called\nThe People class has its step_die method called: this updates any people who died on this time step. Deaths are handled by modules, not by People directly, but step_die method assembles all the causes of death across disease modules and demographic modules and reconciles them. This ensures that each agent’s death is uniquely attributable to a cause.\nResults are updated for the People and the Modules\nAny Analyzer modules have their step method called\nCalls are made to finish_step for the Modules, the People, and the Sim.\n\nIf you want to see more details, have a look at sim.loop.to_df() (after calling sim.init()) and it will show a dataframe of every step in the simulation. You can also use sim.loop.plot() to visualize each step.\nNote that there are two separate update calls for diseases, step_state and then step. The step_state method happens before transmission, and the step method typically handles transmission. The step_state method typically handles disease progression, as in this example from the SIR model:\n\ndef step_state(self):\n    \"\"\" Progress infectious -&gt; recovered \"\"\"\n    recovered = (self.infected & (self.ti_recovered &lt;= self.ti)).uids\n    self.infected[recovered] = False\n    self.susceptible[recovered] = True\n    self.update_immunity()\n    return\n\nTo illustrate the ordering of all these updates, let’s consider an example of a woman infected with pre-symptomatic COVID who, in the course of a single busy day, started developing COVID symptoms, took a COVID test, moved out of her parents house and into her husband’s house, and fell pregnant. Starsim’s model update logic would order her day as follows: (1) fall pregnant, (2) develop symptoms, (3) move house, (4) transmit COVID to anyone still in her contact networks, which at this point would include her husband but not her parents, (5) get COVID test.\nThere are a few principles that guide the logic about the update ordering. Updating the demographics first makes sense because we want to make sure we capture mother-to-child transmission. Suppose that during one month, a woman became pregnant and also acquired malaria; we want to ensure that the effects of malaria on her pregnancy are captured. Updating the network before disease transmission occurs is fairly arbitrary, but it means that transmission can occur with new partners, which is particularly relevant for sexually transmitted infections, especially when it’s an instantaneously-dissolving partnership.\n\n\nPrinting progress\nIt can be useful to see how the Sim is progressing, and the sim.run() method accepts a verbose argument that controls how frequently to provide updates. With verbose=1, you will see updates on progree on every timestep; with verbose=0.1 you will see updates every 10 timesteps, and so on. If you are running monthly or daily timesteps you can also use verbose=1/12 or 1/365 to avoid having too much printed output in your Python terminal. You can also use verbose=-1, which will only print output when the sim is complete.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html#starting-and-stopping-a-run",
    "href": "user_guide/basics_sim.html#starting-and-stopping-a-run",
    "title": "The Sim object",
    "section": "Starting and stopping a run",
    "text": "Starting and stopping a run\nSimulations can be partially run, stopped, and restarted using the sim.run(until=) argument. This can be useful for a few different reasons: - To inspect the state of a simulation for mid-run (although you can also use an analyzer or the Python debugger for this) - To modify the state of a simulation before continuing (although you can also use an intervention for this) - To run part of a simulation only once, before copying it and running different scenarios (although note that copying a simulation can often take almost as much time as running it!)\nOf these, the third use case is probably the most common. The example below illustrates how to do this.\n\nimport sciris as sc\nimport starsim as ss\n\n# Define custom intervention\nclass sis_vaccine(ss.Intervention):\n\n    def __init__(self, start=2040, eff=1.0):\n        super().__init__()\n        self.start = start\n        self.eff = eff\n        return\n\n    def step(self):\n        sis = self.sim.diseases.sis\n        if sis.now == self.start:\n            sis.rel_trans[:] *= 1-self.eff\n        return\n\n# Default parameters\npars = dict(\n    start = 2000,\n    stop = 2050,\n    diseases = 'sis',\n    networks = 'random',\n    verbose = 0,\n)\n\n# Define list of efficacies to run\neffs = [0.0, 0.2, 0.5, 0.8, 1.0]\n\n\n#%% Standard parallel run\nT = sc.timer()\nsims = []\n\nfor eff in effs:\n    s = ss.Sim(pars, label=f'Efficacy={eff}', interventions=sis_vaccine(eff=eff))\n    sims.append(s)\n\nsims = ss.parallel(sims)\nT.toc('Runtime using default')\n\n\n#%% Shortcut using \"until\"\nT = sc.timer()\nsim = ss.Sim(pars, interventions=sis_vaccine())\nsim.run(until=2039)\nsims = []\n\nfor eff in effs:\n    s = sim.copy()\n    s.label = f'Efficacy={eff}'\n    s.interventions[0].eff = eff\n    sims.append(s)\n\nsims = ss.parallel(sims)\nT.toc('Runtime using \"until\"')\n\nsims.plot()\nss.show()\n\nHere, there is relatively little time saved by using until; however, with a longer burn-in period, or more scenarios, the time savings may be greater.\nYou can also use this approach to modify the parameters of a simulation before continuing:\n\nimport starsim as ss\n\nbase_sim = ss.Sim(diseases='sis', networks='random', start=2000, stop=2100, verbose=False)\nbase_sim.run(until=2030)\n\nsims = []\nbetas = [0.01, 0.02, 0.05, 0.10]\nfor beta in betas:\n    sim = base_sim.copy()\n    sim.diseases.sis.pars.beta = beta\n    sim.label = f'beta={beta}'\n    sims.append(sim)\n\nmsim = ss.parallel(sims)\nmsim.plot()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_parameters.html",
    "href": "user_guide/basics_parameters.html",
    "title": "Parameters",
    "section": "",
    "text": "When you create a module using Starsim, you have the opportunity to define the default format for parameters. Let’s look at an example from the SIR disease model:\n\nimport starsim as ss\n\nclass SIR(ss.Infection):\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            beta = ss.TimeProb(0.1),\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=ss.Dur(6)),\n            p_death = ss.bernoulli(p=0.01),\n        )\n        self.update_pars(**kwargs)\n\n        self.define_states(\n            ss.State('susceptible', default=True, label='Susceptible'),\n            ss.State('infected', label='Infectious'),\n            ss.State('recovered', label='Recovered'),\n            ss.FloatArr('ti_infected', label='Time of infection'),\n            ss.FloatArr('ti_recovered', label='Time of recovery'),\n            ss.FloatArr('ti_dead', label='Time of death'),\n            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),\n            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),\n        )\n        return\n\nThe point of self.define_pars() is to set the ground truth for the format that the parameters should take. When users enter their own parameters for defining an instance of this module, the parameter values they enter will be processed within self.update_pars() and will be checked for consistency with the format provided in the original parameters (define_pars). For example, the parameter p_death in the SIR example above is specified initially as a Bernoulli distribution. It would be perfectly legitimate to create an instance of the SIR model using any of the following formats:\n\nsir1 = SIR(p_death=0.02)\nsir2 = SIR(p_death=ss.bernoulli(p=0.2))\n\nHowever, it would NOT be ok to create an SIR model with e.g. SIR(p_death=ss.lognorm_ex(4)), because if a distribution is defined as a Bernoulli in the default_pars, it can’t be changed. This is only the case for Bernoulli distributions; other distributions can be changed, e.g. SIR(dur_inf=ss.normal(4)) would be okay. This is because Bernoulli distributions have different methods than other distributions, e.g. a filter() method that returns True for agents which pass the filter.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Parameters"
    ]
  },
  {
    "objectID": "user_guide/basics_parameters.html#defining-default-parameters",
    "href": "user_guide/basics_parameters.html#defining-default-parameters",
    "title": "Parameters",
    "section": "",
    "text": "When you create a module using Starsim, you have the opportunity to define the default format for parameters. Let’s look at an example from the SIR disease model:\n\nimport starsim as ss\n\nclass SIR(ss.Infection):\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            beta = ss.TimeProb(0.1),\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=ss.Dur(6)),\n            p_death = ss.bernoulli(p=0.01),\n        )\n        self.update_pars(**kwargs)\n\n        self.define_states(\n            ss.State('susceptible', default=True, label='Susceptible'),\n            ss.State('infected', label='Infectious'),\n            ss.State('recovered', label='Recovered'),\n            ss.FloatArr('ti_infected', label='Time of infection'),\n            ss.FloatArr('ti_recovered', label='Time of recovery'),\n            ss.FloatArr('ti_dead', label='Time of death'),\n            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),\n            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),\n        )\n        return\n\nThe point of self.define_pars() is to set the ground truth for the format that the parameters should take. When users enter their own parameters for defining an instance of this module, the parameter values they enter will be processed within self.update_pars() and will be checked for consistency with the format provided in the original parameters (define_pars). For example, the parameter p_death in the SIR example above is specified initially as a Bernoulli distribution. It would be perfectly legitimate to create an instance of the SIR model using any of the following formats:\n\nsir1 = SIR(p_death=0.02)\nsir2 = SIR(p_death=ss.bernoulli(p=0.2))\n\nHowever, it would NOT be ok to create an SIR model with e.g. SIR(p_death=ss.lognorm_ex(4)), because if a distribution is defined as a Bernoulli in the default_pars, it can’t be changed. This is only the case for Bernoulli distributions; other distributions can be changed, e.g. SIR(dur_inf=ss.normal(4)) would be okay. This is because Bernoulli distributions have different methods than other distributions, e.g. a filter() method that returns True for agents which pass the filter.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Parameters"
    ]
  },
  {
    "objectID": "user_guide/basics_parameters.html#using-callable-parameters",
    "href": "user_guide/basics_parameters.html#using-callable-parameters",
    "title": "Parameters",
    "section": "Using callable parameters",
    "text": "Using callable parameters\nOne of the most flexible aspects of how Starsim’s distributions are defined is that they can take callable functions as parameter values. For example, in reality the duration of infection of a disease might vary by age. We could model this as follows:\n\nimport sciris as sc\nimport matplotlib.pyplot as plt\n\n# Create and run the simulation\nsir = SIR(dur_inf=ss.normal(loc=ss.days(10)))  # Define an SIR model with a default duration of 10 days\nsir.pars.dur_inf.set(loc = lambda self, sim, uids: sim.people.age[uids] / 10)  # Change the mean duration so it scales with age\nsim = ss.Sim(n_agents=20e3, dur=10, diseases=sir, networks='random')\nsim.run()\nsim.plot()\n\n# Show the age distribution of infections\nages = sim.people.age[:]\ninfected_ages = ages[sim.diseases.sir.infected]\n\nfig = plt.figure()\n\nplt.subplot(2,1,1)\nplt.hist(ages, bins=range(0,100,5))\nplt.title('Simulation age distribution')\nplt.xlabel('Age')\nplt.ylabel('Number of people')\n\nplt.subplot(2,1,2)\nplt.hist(infected_ages, bins=range(0,100,5))\nplt.title('Infection age distribution')\nplt.xlabel('Age')\nplt.ylabel('Number of people')\n\nsc.figlayout()\nplt.show()\n\nUsing similar logic, any other parameter could be set to depend on anything that the sim is aware of, including time or agent properties like age, sex, or health attributes.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Parameters"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html",
    "href": "user_guide/modules_diseases.html",
    "title": "Diseases",
    "section": "",
    "text": "Starsim has a two-tier disease class hierarchy:\n\n\n\nDefines step methods and basic disease structure\nDoes not include transmission logic\nUsed for non-communicable diseases (NCDs)\nKey methods: define_states(), set_prognoses()\n\n\n\n\n\nIncludes transmission logic via the infect() method\nUsed for all communicable diseases\nHandles network-based transmission automatically\nApplies network-specific betas and agent susceptibility/transmissibility\n\nImportant: Almost all diseases should inherit from ss.Infection. Do not write your own infect() method unless you have very specific requirements - the built-in method correctly handles: - Looping over agents in each network - Applying network- and disease-specific transmission probabilities - Managing agent transmissibility and susceptibility - Mixing pool logic",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html#disease-class-architecture",
    "href": "user_guide/modules_diseases.html#disease-class-architecture",
    "title": "Diseases",
    "section": "",
    "text": "Starsim has a two-tier disease class hierarchy:\n\n\n\nDefines step methods and basic disease structure\nDoes not include transmission logic\nUsed for non-communicable diseases (NCDs)\nKey methods: define_states(), set_prognoses()\n\n\n\n\n\nIncludes transmission logic via the infect() method\nUsed for all communicable diseases\nHandles network-based transmission automatically\nApplies network-specific betas and agent susceptibility/transmissibility\n\nImportant: Almost all diseases should inherit from ss.Infection. Do not write your own infect() method unless you have very specific requirements - the built-in method correctly handles: - Looping over agents in each network - Applying network- and disease-specific transmission probabilities - Managing agent transmissibility and susceptibility - Mixing pool logic",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html#key-implementation-methods",
    "href": "user_guide/modules_diseases.html#key-implementation-methods",
    "title": "Diseases",
    "section": "Key implementation methods",
    "text": "Key implementation methods\n\n\n\n\n\n\n\n\nMethod\nPurpose\nWhen to override\n\n\n\n\ndefine_states()\nInitialize disease states (S, I, R, etc.)\nAlways for custom diseases\n\n\nset_prognoses()\nSet outcomes for newly infected people\n(Almost) always for custom diseases\n\n\nstep_state()\nUpdate states each timestep\nWhen adding new state transitions\n\n\nstep_die()\nHandle deaths\nWhen disease has custom states\n\n\ninfect()\nHandle transmission\nRarely - use built-in version",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html#implementation-patterns",
    "href": "user_guide/modules_diseases.html#implementation-patterns",
    "title": "Diseases",
    "section": "Implementation patterns",
    "text": "Implementation patterns\n\nPattern 1: Extending existing diseases\nWhen you need to modify an existing disease model, inherit from it and override specific methods:\n\nclass MyCustomSIR(ss.SIR):\n    def __init__(self, **kwargs):\n        super().__init__()\n        # Add custom parameters\n        self.define_pars(my_param=0.5)\n        self.update_pars(**kwargs)\n        \n    def set_prognoses(self, uids, sources=None):\n        # Custom progression logic\n        super().set_prognoses(uids, sources)\n        # Additional custom logic here\n\n\n\nPattern 2: Adding new states\nTo add states to an existing model:\n\nclass MySEIR(ss.SIR):\n    def __init__(self, **kwargs):\n        super().__init__()\n        # Add new parameters\n        self.define_pars(dur_exp=ss.lognorm_ex(0.5))\n        self.update_pars(**kwargs)\n        \n        # Add new states\n        self.define_states(\n            ss.State('exposed', label='Exposed'),\n            ss.FloatArr('ti_exposed', label='Time of exposure'),\n        )\n\n    @property\n    def infectious(self):\n        # Define who can transmit (both infected and exposed)\n        return self.infected | self.exposed\n\n    def step_state(self):\n        # Call parent state updates first\n        super().step_state()\n        \n        # Add custom state transitions\n        transitioning = self.exposed & (self.ti_infected &lt;= self.ti)\n        self.exposed[transitioning] = False\n        self.infected[transitioning] = True",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "conduct.html",
    "href": "conduct.html",
    "title": "Code of conduct",
    "section": "",
    "text": "In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n\n\nExamples of behavior that contributes to creating a positive environment include:\n\nUsing welcoming and inclusive language\nBeing respectful of differing viewpoints and experiences\nGracefully accepting constructive criticism\nFocusing on what is best for the community\nShowing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\nThe use of sexualized language or imagery and unwelcome sexual attention or advances\nTrolling, insulting/derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or electronic address, without explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting\n\n\n\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at info@starsim.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.\n\n\n\nThis Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html.\nFor answers to common questions about this code of conduct, see the FAQ.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#our-pledge",
    "href": "conduct.html#our-pledge",
    "title": "Code of conduct",
    "section": "",
    "text": "In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#our-standards",
    "href": "conduct.html#our-standards",
    "title": "Code of conduct",
    "section": "",
    "text": "Examples of behavior that contributes to creating a positive environment include:\n\nUsing welcoming and inclusive language\nBeing respectful of differing viewpoints and experiences\nGracefully accepting constructive criticism\nFocusing on what is best for the community\nShowing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\nThe use of sexualized language or imagery and unwelcome sexual attention or advances\nTrolling, insulting/derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or electronic address, without explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#our-responsibilities",
    "href": "conduct.html#our-responsibilities",
    "title": "Code of conduct",
    "section": "",
    "text": "Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#scope",
    "href": "conduct.html#scope",
    "title": "Code of conduct",
    "section": "",
    "text": "This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#enforcement",
    "href": "conduct.html#enforcement",
    "title": "Code of conduct",
    "section": "",
    "text": "Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at info@starsim.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#attribution",
    "href": "conduct.html#attribution",
    "title": "Code of conduct",
    "section": "",
    "text": "This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html.\nFor answers to common questions about this code of conduct, see the FAQ.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html",
    "href": "tutorials/t6_interventions.html",
    "title": "T6 - Interventions",
    "section": "",
    "text": "Understanding the impact of interventions is one of the most common reasons to use a disease model. This tutorial shows how to implement standard interventions, as well as how to define your own custom interventions.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#products-and-interventions",
    "href": "tutorials/t6_interventions.html#products-and-interventions",
    "title": "T6 - Interventions",
    "section": "Products and interventions",
    "text": "Products and interventions\nStarsim contains products, which can be thought of as the actual test, diagnostic, treatment, or vaccine product being used, as well as interventions, which are responsible for delivering the products to the population.\nDepending on what disease you’re modeling, you might need to define your own custom products and interventions, or you might be able to directly use some of the examples provided in Starsim.\nStarsim includes three basic “types” of products: diagnostics, treatment, and vaccination. There isn’t a lot of detail in the templates for each of these, because most of the details about products is specific to a disease. There are also some disease-specific products built in the Starsim’s library of diseases - these can generally be found in the diseases subfolder (e.g. the cholera interventions are in cholera.py.\nStarsim also includes several basic types of intervention:\n\nroutine_vx() for routine vaccination, campaign_vx() for one-off campaigns\nsimilarly, routine_screening() and campaign_screening() for different types of screening program\ntreat_num(), which treats a certain number of people each timestep (by default, as many people as need treatment, but you can also set a maximum).\n\nThese are sometimes general enough that they don’t need to be tailored to a particular disease, and you can just use them directly. That being said, you are always welcome to tailor them as you like to capture particular features of the intervention you’re modeling.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#vaccination",
    "href": "tutorials/t6_interventions.html#vaccination",
    "title": "T6 - Interventions",
    "section": "Vaccination",
    "text": "Vaccination\nTo create an example, let’s first create the parameters that we want to use for the simulation:\n\nimport starsim as ss\n\npars = dict(\n    n_agents = 5_000,\n    birth_rate = ss.peryear(20),\n    death_rate = 15,\n    networks = dict(\n        type = 'randomnet', # Or 'random'\n        n_contacts = 4\n    ),\n    diseases = dict(\n        type = 'sir',\n        dur_inf = 10,\n        beta = 0.1,\n    )\n)\n\nNow we’ll create a vaccine product and a vaccination intervention:\n\n# Create the product - a vaccine with 50% efficacy\nmy_vaccine = ss.sir_vaccine(efficacy=0.5)\n\n# Create the intervention\nmy_intervention = ss.routine_vx(\n    start_year=2015,    # Begin vaccination in 2015\n    prob=0.2,           # 20% coverage\n    product=my_vaccine   # Use the MyVaccine product\n)\n\n# Now create two sims: a baseline sim and one with the intervention\nsim_base = ss.Sim(pars=pars)\nsim_base.run()\nsim_intv = ss.Sim(pars=pars, interventions=my_intervention)\nsim_intv.run()\n\nIf we want to see the impact, we can create a plot:\n\nimport matplotlib.pyplot as plt\n\nres_base = sim_base.results\nres_intv = sim_intv.results\n\nplt.figure()\nplt.plot(res_base.timevec, res_base.sir.prevalence, label='Baseline')\nplt.plot(res_intv.timevec, res_intv.sir.prevalence, label='Vax')\nplt.axvline(x=2015, color='k', ls='--')\nplt.title('Prevalence')\nplt.legend()\nplt.show()\n\nWe can see that from the year of introducing the vaccine, prevalence starts to fall.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#custom-interventions",
    "href": "tutorials/t6_interventions.html#custom-interventions",
    "title": "T6 - Interventions",
    "section": "Custom interventions",
    "text": "Custom interventions\nThe most common way of accessing diseases for modification by interventions is via their names (e.g. sir, sis). This means that typically, different interventions need to be defined for different diseases. The example below shows how to define a simple vaccine for SIS which is just a function, rather than a class:\n\nimport starsim as ss\n\ndef simple_sis_vaccine(sim, start=2030, eff=0.9):\n    if sim.now == start:\n        sim.diseases.sis.rel_trans[:] *= 1-eff\n    return\n\npars = dict(\n    start=2000,\n    stop=2050,\n    diseases='sis',\n    networks='random',\n    interventions=simple_sis_vaccine,\n)\n\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\nss.show()",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#exercises",
    "href": "tutorials/t6_interventions.html#exercises",
    "title": "T6 - Interventions",
    "section": "Exercises",
    "text": "Exercises\n\nIf we change the disease from SIR to SIS and set coverage to 100%, what minimum efficacy of vaccine is required to eradicate the disease by 2050? You will need to implement an sis_vaccine class as well (based on ss.sir_vaccine – not the simple vaccine above), but can re-use ss.routine_vx.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html",
    "href": "tutorials/t3_demographics.html",
    "title": "T3 - Demographics",
    "section": "",
    "text": "An interactive version of this notebook is available on Google Colab or Binder.\nThere are a few basic ways to add vital dynamics to your model, e.g.\nimport starsim as ss\n\npars = dict(\n    birth_rate = ss.peryear(20),      # Annual crude birth rate (per 1000 people)\n    death_rate = ss.peryear(15),      # Annual crude death rate (per 1000 people)\n    networks = 'random',\n    diseases = 'sir'\n)\nsim = ss.Sim(pars)\nThis will apply annual birth and death rates as specified in the pars dict. Alternatively, we can make demographic components, which achieves the same thing:\ndemographics = [\n    ss.Births(birth_rate=ss.peryear(20)),\n    ss.Deaths(death_rate=ss.peryear(15))\n]\nsim = ss.Sim(demographics=demographics)\nYou can even simply set demographics=True to use default rates:\nss.Sim(demographics=True).run().plot();\nBy default, agents age if and only if at least one demographics module is included. You can override this behavior by setting use_aging, e.g. ss.Sim(use_aging=False)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html#scaling-results-to-whole-populations",
    "href": "tutorials/t3_demographics.html#scaling-results-to-whole-populations",
    "title": "T3 - Demographics",
    "section": "Scaling results to whole populations",
    "text": "Scaling results to whole populations\nEven though we’ve been simulating populations of a few thousand agents, we can also use the total_pop parameter to scale our results so that they reflect a much larger population. You can think of this as a kind of statistical sampling approximation. If we want to model the population of Nigeria, for example, it would be much too computationally intensive to simulate 200 million agents. However, we could simulate 50,000 agents and then say that each agent represents 4,000 people. Again, we can do this by passing total_pop=200e6 to the sim or in the pars dictionary. Here’s an example:\n\ndemographics = [\n    ss.Births(birth_rate=ss.peryear(20)),\n    ss.Deaths(death_rate=ss.peryear(15))\n]\nsim = ss.Sim(pars={'total_pop': 200e6, 'n_agents': 50e3}, demographics=demographics)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html#using-realistic-vital-demographics",
    "href": "tutorials/t3_demographics.html#using-realistic-vital-demographics",
    "title": "T3 - Demographics",
    "section": "Using realistic vital demographics",
    "text": "Using realistic vital demographics\nFor more realistic demographics, we can also pass in a file that has birth or death rates over time and by age/sex. There are examples of these files in the test_data folder. Here’s how we would read them in and construct realistic vital dynamics for Nigeria:\n\nimport starsim as ss\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read in age-specific fertility rates\nfertility_rates = pd.read_csv('test_data/nigeria_asfr.csv')\npregnancy = ss.Pregnancy(fertility_rate=fertility_rates)\n\ndeath_rates = pd.read_csv('test_data/nigeria_deaths.csv')\ndeath = ss.Deaths(death_rate=death_rates, rate_units=1)\n\ndemographics = [pregnancy, death]\n\n# Make people using the distribution of the population by age/sex in 1995\nn_agents = 5_000\nnga_pop_1995 = 106819805  # Population of Nigeria in 1995, the year we will start the model\nage_data = pd.read_csv('test_data/nigeria_age.csv')\nppl = ss.People(n_agents, age_data=age_data)\n\n# Make the sim, run and plot\nsim = ss.Sim(total_pop=nga_pop_1995, start=1995, people=ppl, demographics=demographics, networks='random', diseases='sir')\nsim.run()\n\n# Read in a file with the actual population size\nnigeria_popsize = pd.read_csv('test_data/nigeria_popsize.csv')\ndata = nigeria_popsize[(nigeria_popsize.year &gt;= 1995) & (nigeria_popsize.year &lt;= 2030)]\n\n# Plot the overall population size - simulated vs data\nfig, ax = plt.subplots(1, 1)\nres = sim.results\nax.scatter(data.year, data.n_alive, alpha=0.5, label='Data')\nax.plot(res.timevec, res.n_alive, color='k', label='Model')\nax.legend()\nax.set_title('Population')\nplt.show()\n\nIf you want to use realistic demographics for your model, you can adapt the data files and code snippet above to read in the relevant demographic data files for your country/setting.\nNote: In the code block above, we set the units of the mortality data to 1, as opposed to 1/1000. If your data come in the form of deaths per 1000 people, set units to 1/1000. Note also that as per standard definitions, fertility_rate is defined per woman, whereas birth_rate is defined per person.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html#exercises",
    "href": "tutorials/t3_demographics.html#exercises",
    "title": "T3 - Demographics",
    "section": "Exercises",
    "text": "Exercises\n\nIn Niger, the crude birth rate is 45 and the crude death rate is 9. Assuming these rates stay constant, and starting with a total population of 24 million in 2020, how many people will there be in 2040? (You do not need to include any diseases in your model.)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html",
    "href": "tutorials/t4_diseases.html",
    "title": "T4 - Diseases",
    "section": "",
    "text": "An interactive version of this notebook is available on Google Colab or Binder.\nDiseases are the cornerstone of almost any Starsim analysis. In this tutorial, you’ll learn how to work with diseases in Starsim, starting with simple modifications and building up to creating your own custom disease models.\nBy the end of this tutorial, you’ll understand how to: - Modify parameters of existing diseases - Run simulations with multiple diseases - Create your own custom disease from scratch",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#step-1-modifying-disease-parameters",
    "href": "tutorials/t4_diseases.html#step-1-modifying-disease-parameters",
    "title": "T4 - Diseases",
    "section": "Step 1: Modifying disease parameters",
    "text": "Step 1: Modifying disease parameters\nThe easiest way to customize a disease is by changing its parameters. Much like sims or networks, a Disease can be customized by passing in a pars dictionary containing parameters. Let’s start with a simple SIR model and see how different parameters affect the simulation:\n\nimport starsim as ss\nsir = ss.SIR(dur_inf=10, beta=0.2, init_prev=0.4, p_death=0.2)\nsim = ss.Sim(n_agents=2_000, diseases=sir, networks='random')\nsim.run().plot()\n\nNotice how we modified several key parameters: - dur_inf=10: How long people stay infectious (10 years) - beta=0.2: Transmission probability per contact - init_prev=0.4: Starting with 40% of the population infected - p_death=0.2: 20% of infected people die\nWe already saw that this model creates results that are stored in sim.results.sir. The results can also be directly accessed via sir.results.\nFor more detail on any of the diseases that are in the Starsim library of diseases, please refer to the docstrings and source code of the disease files.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#step-2-simulating-multiple-diseases",
    "href": "tutorials/t4_diseases.html#step-2-simulating-multiple-diseases",
    "title": "T4 - Diseases",
    "section": "Step 2: Simulating multiple diseases",
    "text": "Step 2: Simulating multiple diseases\nYou can add multiple diseases to the same simulation, like so. Here we are making use of a “connector”. A connector is a module in Starsim that tells you how two things relate to one another - in this case, how HIV modifies a person’s transmissibility and susceptibility to gonorrhea and vice versa. Unlike dieases, networks, interventions, etc., connectors don’t have any pre-specified location in the sim. Instead, they can be placed wherever they make the most sense (for example, a connector that mediated how two networks behaved might be placed at the beginning or end of the list of networks; for diseases, it might be placed at the beginning or end of the list of diseases).\n\nimport starsim as ss\n\nclass simple_hiv_ng(ss.Module):\n    \"\"\" Simple connector whereby rel_sus to NG (Neisseria gonorrhoeae) doubles if CD4 count is &lt;200\"\"\"\n    def __init__(self, pars=None, label='HIV-Gonorrhea', **kwargs):\n        super().__init__()\n        self.define_pars(\n            rel_trans_hiv  = 2,\n            rel_trans_aids = 5,\n            rel_sus_hiv    = 2,\n            rel_sus_aids   = 5,\n        )\n        self.update_pars(pars, **kwargs)\n        return\n\n    def step(self):\n        \"\"\" Specify how HIV increases NG rel_sus and rel_trans \"\"\"\n        ng = self.sim.people.gonorrhea\n        hiv = self.sim.people.hiv\n        p = self.pars\n        ng.rel_sus[hiv.cd4 &lt; 500] = p.rel_sus_hiv\n        ng.rel_sus[hiv.cd4 &lt; 200] = p.rel_sus_aids\n        ng.rel_trans[hiv.cd4 &lt; 500] = p.rel_trans_hiv\n        ng.rel_trans[hiv.cd4 &lt; 200] = p.rel_trans_aids\n        return\n\n# Make HIV\nhiv = ss.HIV(\n    beta = {'mf': [0.0008, 0.0004]},  # Specify transmissibility over the MF network\n    init_prev = 0.05,\n)\n\n# Make gonorrhea\nng = ss.Gonorrhea(\n    beta = {'mf': [0.05, 0.025]},  # Specify transmissibility over the MF network\n    init_prev = 0.025,\n)\n\n# Make the sim, including a connector betweeh HIV and gonorrhea:\nn_agents = 5_000\nsim = ss.Sim(n_agents=n_agents, networks='mf', diseases=[simple_hiv_ng(), hiv, ng])\nsim.run()\nsim.plot('hiv')\nsim.plot('gonorrhea')\n\nYou can see how the two diseases interact - HIV creates a vulnerable population that’s more susceptible to gonorrhea infection.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#step-3-creating-your-own-disease-model",
    "href": "tutorials/t4_diseases.html#step-3-creating-your-own-disease-model",
    "title": "T4 - Diseases",
    "section": "Step 3: Creating your own disease model",
    "text": "Step 3: Creating your own disease model\nNow for the fun part - creating your own disease from scratch! Let’s modify the SIR model to create an SEIR model, which adds an “Exposed” state where people are infected but not yet infectious.\nThis is a common pattern in epidemiology - think of it as the incubation period before someone becomes contagious.\nIf you want to make your own disease, you could either inherit from one of the templates in diseases.py, or you could copy the examples and extend them to capture features of the disease that you want to model. For example, suppose you wanted to change the SIR model to an SEIR model (i.e., add an ‘exposed’ state where people were transmissible but did not yet have symptoms. You might hope that this would be a relatively simple change to make. Here’s how it would look:\n\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\nclass SEIR(ss.SIR):\n    def __init__(self, pars=None, *args, **kwargs):\n        super().__init__()\n        self.define_pars(\n            dur_exp = ss.lognorm_ex(0.5),\n        )\n        self.update_pars(pars, **kwargs)\n\n        # Additional states beyond the SIR ones \n        self.define_states(\n            ss.State('exposed', label='Exposed'),\n            ss.FloatArr('ti_exposed', label='TIme of exposure'),\n        )\n        return\n\n    @property\n    def infectious(self):\n        return self.infected | self.exposed\n\n    def step_state(self):\n        \"\"\" Make all the updates from the SIR model \"\"\"\n        # Perform SIR updates\n        super().step_state()\n\n        # Additional updates: progress exposed -&gt; infected\n        infected = self.exposed & (self.ti_infected &lt;= self.ti)\n        self.exposed[infected] = False\n        self.infected[infected] = True\n        return\n\n    def step_die(self, uids):\n        super().step_die(uids)\n        self.exposed[uids] = False\n        return\n\n    def set_prognoses(self, uids, sources=None):\n        \"\"\" Carry out state changes associated with infection \"\"\"\n        super().set_prognoses(uids, sources)\n        ti = self.ti\n        self.susceptible[uids] = False\n        self.exposed[uids] = True\n        self.ti_exposed[uids] = ti\n\n        # Calculate and schedule future outcomes\n        p = self.pars # Shorten for convenience\n        dur_exp = p.dur_exp.rvs(uids)\n        self.ti_infected[uids] = ti + dur_exp\n        dur_inf = p.dur_inf.rvs(uids)\n        will_die = p.p_death.rvs(uids)        \n        self.ti_recovered[uids[~will_die]] = ti + dur_inf[~will_die]\n        self.ti_dead[uids[will_die]] = ti + dur_inf[will_die]\n        return\n    \n    def plot(self):\n        \"\"\" Update the plot with the exposed compartment \"\"\"\n        with ss.options.context(jupyter=False):\n            fig = super().plot()\n            ax = plt.gca()\n            res = self.results.n_exposed\n            ax.plot(res.timevec, res, label=res.label)\n            plt.legend()\n        return ss.return_fig(fig)\n\nThe new class includes the following main changes:\n\nIn __init__ we added the extra pars and states needed for our model\nWe defined infectious to include both infected and exposed people - this means that we can just reuse the existing logic for how the SIR model handles transmission\nWe updated update_pre and update_death to include changes to the exposed state\nWe rewrote set_prognoses to include the new exposed state.\n\nHere’s how it would look in practice:\n\nseir = SEIR()\nsim = ss.Sim(diseases=seir, networks='random')\nsim.run()\nsim.plot()\nsim.diseases.seir.plot()",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#exercises",
    "href": "tutorials/t4_diseases.html#exercises",
    "title": "T4 - Diseases",
    "section": "Exercises",
    "text": "Exercises\n\nParameter exploration: Try different values of dur_exp in the SEIR model - how does it affect the epidemic curve?\nSEIRS model: Adapt the SEIR example above to be SEIRS (where recovered people can become susceptible again)\nMulti-strain model: Can you create a model with two strains of the same disease that provide partial cross-immunity?",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "api/parameters.html",
    "href": "api/parameters.html",
    "title": "parameters",
    "section": "",
    "text": "parameters\nSet parameters\n\n\n\n\n\nName\nDescription\n\n\n\n\nPars\nDict-like container of parameters\n\n\nSimPars\nCreate the parameters for the simulation. Typically, this function is used\n\n\n\n\n\nparameters.Pars(self, pars=None, **kwargs)\nDict-like container of parameters\nActs like an sc.objdict(), except that adding new keys are disallowed by default, and auto-updates known types.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_key_mismatch\nCheck whether additional keys are being added to the dictionary\n\n\ndict_update\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\nto_json\nConvert to JSON representation\n\n\nupdate\nUpdate internal dict with new pars.\n\n\n\n\n\nparameters.Pars.check_key_mismatch(pars)\nCheck whether additional keys are being added to the dictionary\n\n\n\nparameters.Pars.dict_update(*args, **kwargs)\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\n\nparameters.Pars.to_json(**kwargs)\nConvert to JSON representation\n\n\n\nparameters.Pars.update(pars=None, create=False, **kwargs)\nUpdate internal dict with new pars.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\ndict\nthe parameters to update (if None, do nothing)\nNone\n\n\ncreate\nbool\nif create is False, then raise a KeyNotFoundError if the key does not already exist\nFalse\n\n\nkwargs\ndict\nmerged with pars\n{}\n\n\n\n\n\n\n\n\n\nparameters.SimPars(self, **kwargs)\nCreate the parameters for the simulation. Typically, this function is used internally rather than called by the user; e.g. typical use would be to do sim = ss.Sim() and then inspect sim.pars, rather than calling this function directly.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel\nstr\nThe name of the simulation\nrequired\n\n\nn_agents\nint / float\nThe number of agents to run (default 10,000)\nrequired\n\n\ntotal_pop\nint / float\nIf provided, scale the agents to this effective population size\nrequired\n\n\npop_scale\nfloat\nIf provided, use this agent-to-population scale factor (total_pop = n_agents*pop_scale)\nrequired\n\n\nunit\nstr\nThe time unit for the simulation (default ‘year’; other choices are ‘day’, ‘week’, ‘month’)\nrequired\n\n\nstart\nfloat / str / date\nThe starting date for the simulation (default 2000); can be a year or date\nrequired\n\n\nstop\nfloat / str / date\nIf provided, the ending date for the simulation (if not provided, calculate from “dur”)\nrequired\n\n\ndur\nint\nHow many timesteps to simulate, if “stop” is not provided (default 50)\nrequired\n\n\ndt\nfloat\nThe timestep, in units of “unit” (default 1.0)\nrequired\n\n\nrand_seed\nint\nThe overall random seed for the simulation (used to set module-specific random seeds)\nrequired\n\n\nbirth_rate\nfloat\nIf provided, include births with this rate (per 1000 people per year)\nrequired\n\n\ndeath_rate\nfloat\nIf provided, include deaths with this rate (per 1000 people per year)\nrequired\n\n\nuse_aging\nbool\nSpecify whether agents age (by default, agents age if and only if births and/or deaths are included)\nrequired\n\n\npeople\nPeople\nIf provided, use a pre-existing People object rather than creating one (in which case n_agents will be ignored)\nrequired\n\n\nnetworks\nstr / list / Module\nThe network module(s); can be a string, single module (i.e. Network), or list\nrequired\n\n\ndemographics\nstr / list / Module\nAs above\nrequired\n\n\ndiseases\nstr / list / Module\nAs above\nrequired\n\n\nconnectors\nstr / list / Module\nAs above\nrequired\n\n\ninterventions\nstr / list / Module\nAs above\nrequired\n\n\nanalyzers\nstr / list / Module\nAs above\nrequired\n\n\nverbose\nfloat\nHow much detail to print (1 = every timestep, 0.1 = every 10 timesteps, etc.)\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_modules\nConvert different types of representations for modules into a\n\n\nis_default\nCheck if the provided value matches the default\n\n\nvalidate\nCall parameter validation methods\n\n\nvalidate_agents\nCheck that n_agents is supplied and convert to an integer\n\n\nvalidate_demographics\nValidate demographics-related input parameters\n\n\nvalidate_modules\nValidate modules passed in pars\n\n\nvalidate_networks\nValidate networks\n\n\nvalidate_sim_pars\nValidate each of the parameter values\n\n\nvalidate_total_pop\nEnsure one but not both of total_pop and pop_scale are defined\n\n\nvalidate_verbose\nValidate verbosity\n\n\n\n\n\nparameters.SimPars.convert_modules()\nConvert different types of representations for modules into a standardized object representation that can be parsed and used by a Sim object. Used for starsim classes: - networks, - demographics, - diseases, - analyzers, - interventions, and - connectors.\n\n\n\nparameters.SimPars.is_default(key)\nCheck if the provided value matches the default\n\n\n\nparameters.SimPars.validate()\nCall parameter validation methods\n\n\n\nparameters.SimPars.validate_agents()\nCheck that n_agents is supplied and convert to an integer\n\n\n\nparameters.SimPars.validate_demographics()\nValidate demographics-related input parameters\n\n\n\nparameters.SimPars.validate_modules()\nValidate modules passed in pars\n\n\n\nparameters.SimPars.validate_networks()\nValidate networks\n\n\n\nparameters.SimPars.validate_sim_pars()\nValidate each of the parameter values\n\n\n\nparameters.SimPars.validate_total_pop()\nEnsure one but not both of total_pop and pop_scale are defined\n\n\n\nparameters.SimPars.validate_verbose()\nValidate verbosity\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nmake_pars\nShortcut for making a new instance of SimPars\n\n\n\n\n\nparameters.make_pars(**kwargs)\nShortcut for making a new instance of SimPars",
    "crumbs": [
      "**Basics**",
      "parameters"
    ]
  },
  {
    "objectID": "api/parameters.html#classes",
    "href": "api/parameters.html#classes",
    "title": "parameters",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nPars\nDict-like container of parameters\n\n\nSimPars\nCreate the parameters for the simulation. Typically, this function is used\n\n\n\n\n\nparameters.Pars(self, pars=None, **kwargs)\nDict-like container of parameters\nActs like an sc.objdict(), except that adding new keys are disallowed by default, and auto-updates known types.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_key_mismatch\nCheck whether additional keys are being added to the dictionary\n\n\ndict_update\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\nto_json\nConvert to JSON representation\n\n\nupdate\nUpdate internal dict with new pars.\n\n\n\n\n\nparameters.Pars.check_key_mismatch(pars)\nCheck whether additional keys are being added to the dictionary\n\n\n\nparameters.Pars.dict_update(*args, **kwargs)\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\n\nparameters.Pars.to_json(**kwargs)\nConvert to JSON representation\n\n\n\nparameters.Pars.update(pars=None, create=False, **kwargs)\nUpdate internal dict with new pars.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\ndict\nthe parameters to update (if None, do nothing)\nNone\n\n\ncreate\nbool\nif create is False, then raise a KeyNotFoundError if the key does not already exist\nFalse\n\n\nkwargs\ndict\nmerged with pars\n{}\n\n\n\n\n\n\n\n\n\nparameters.SimPars(self, **kwargs)\nCreate the parameters for the simulation. Typically, this function is used internally rather than called by the user; e.g. typical use would be to do sim = ss.Sim() and then inspect sim.pars, rather than calling this function directly.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel\nstr\nThe name of the simulation\nrequired\n\n\nn_agents\nint / float\nThe number of agents to run (default 10,000)\nrequired\n\n\ntotal_pop\nint / float\nIf provided, scale the agents to this effective population size\nrequired\n\n\npop_scale\nfloat\nIf provided, use this agent-to-population scale factor (total_pop = n_agents*pop_scale)\nrequired\n\n\nunit\nstr\nThe time unit for the simulation (default ‘year’; other choices are ‘day’, ‘week’, ‘month’)\nrequired\n\n\nstart\nfloat / str / date\nThe starting date for the simulation (default 2000); can be a year or date\nrequired\n\n\nstop\nfloat / str / date\nIf provided, the ending date for the simulation (if not provided, calculate from “dur”)\nrequired\n\n\ndur\nint\nHow many timesteps to simulate, if “stop” is not provided (default 50)\nrequired\n\n\ndt\nfloat\nThe timestep, in units of “unit” (default 1.0)\nrequired\n\n\nrand_seed\nint\nThe overall random seed for the simulation (used to set module-specific random seeds)\nrequired\n\n\nbirth_rate\nfloat\nIf provided, include births with this rate (per 1000 people per year)\nrequired\n\n\ndeath_rate\nfloat\nIf provided, include deaths with this rate (per 1000 people per year)\nrequired\n\n\nuse_aging\nbool\nSpecify whether agents age (by default, agents age if and only if births and/or deaths are included)\nrequired\n\n\npeople\nPeople\nIf provided, use a pre-existing People object rather than creating one (in which case n_agents will be ignored)\nrequired\n\n\nnetworks\nstr / list / Module\nThe network module(s); can be a string, single module (i.e. Network), or list\nrequired\n\n\ndemographics\nstr / list / Module\nAs above\nrequired\n\n\ndiseases\nstr / list / Module\nAs above\nrequired\n\n\nconnectors\nstr / list / Module\nAs above\nrequired\n\n\ninterventions\nstr / list / Module\nAs above\nrequired\n\n\nanalyzers\nstr / list / Module\nAs above\nrequired\n\n\nverbose\nfloat\nHow much detail to print (1 = every timestep, 0.1 = every 10 timesteps, etc.)\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_modules\nConvert different types of representations for modules into a\n\n\nis_default\nCheck if the provided value matches the default\n\n\nvalidate\nCall parameter validation methods\n\n\nvalidate_agents\nCheck that n_agents is supplied and convert to an integer\n\n\nvalidate_demographics\nValidate demographics-related input parameters\n\n\nvalidate_modules\nValidate modules passed in pars\n\n\nvalidate_networks\nValidate networks\n\n\nvalidate_sim_pars\nValidate each of the parameter values\n\n\nvalidate_total_pop\nEnsure one but not both of total_pop and pop_scale are defined\n\n\nvalidate_verbose\nValidate verbosity\n\n\n\n\n\nparameters.SimPars.convert_modules()\nConvert different types of representations for modules into a standardized object representation that can be parsed and used by a Sim object. Used for starsim classes: - networks, - demographics, - diseases, - analyzers, - interventions, and - connectors.\n\n\n\nparameters.SimPars.is_default(key)\nCheck if the provided value matches the default\n\n\n\nparameters.SimPars.validate()\nCall parameter validation methods\n\n\n\nparameters.SimPars.validate_agents()\nCheck that n_agents is supplied and convert to an integer\n\n\n\nparameters.SimPars.validate_demographics()\nValidate demographics-related input parameters\n\n\n\nparameters.SimPars.validate_modules()\nValidate modules passed in pars\n\n\n\nparameters.SimPars.validate_networks()\nValidate networks\n\n\n\nparameters.SimPars.validate_sim_pars()\nValidate each of the parameter values\n\n\n\nparameters.SimPars.validate_total_pop()\nEnsure one but not both of total_pop and pop_scale are defined\n\n\n\nparameters.SimPars.validate_verbose()\nValidate verbosity",
    "crumbs": [
      "**Basics**",
      "parameters"
    ]
  },
  {
    "objectID": "api/parameters.html#functions",
    "href": "api/parameters.html#functions",
    "title": "parameters",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nmake_pars\nShortcut for making a new instance of SimPars\n\n\n\n\n\nparameters.make_pars(**kwargs)\nShortcut for making a new instance of SimPars",
    "crumbs": [
      "**Basics**",
      "parameters"
    ]
  },
  {
    "objectID": "api/run.html",
    "href": "api/run.html",
    "title": "run",
    "section": "",
    "text": "run\nUtilities for running in parallel\n\n\n\n\n\nName\nDescription\n\n\n\n\nMultiSim\nClass for running multiple copies of a simulation.\n\n\n\n\n\nrun.MultiSim(\n    self,\n    sims=None,\n    base_sim=None,\n    label=None,\n    n_runs=4,\n    initialize=False,\n    inplace=True,\n    debug=False,\n    **kwargs,\n)\nClass for running multiple copies of a simulation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsims\nSim / list\na single sim or a list of sims\nNone\n\n\nbase_sim\nSim\nthe sim used for shared properties; if not supplied, the first of the sims provided\nNone\n\n\nlabel\nstr\nthe name of the multisim\nNone\n\n\nn_runs\nint\nif a single sim is provided, the number of replicates (default 4)\n4\n\n\ninitialize\nbool\nwhether or not to initialize the sims (otherwise, initialize them during run)\nFalse\n\n\ninplace\nbool\nwhether to modify the sims in-place (default True); else return new sims\nTrue\n\n\ndebug\nbool\nif True, run in serial\nFalse\n\n\nkwargs\ndict\nstored in run_args and passed to run()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrief\nA single-line display of the MultiSim; same as print(multisim)\n\n\ndisp\nDisplay the full object\n\n\ninit_sims\nInitialize the sims\n\n\nmean\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\nmedian\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\nplot\nPlot all results in the MultiSim object.\n\n\nreduce\nCombine multiple sims into a single sim statistically: by default, use\n\n\nreset\nUndo reduce() by resetting the base sim, which, and results\n\n\nrun\nRun the sims; see ss.multi_run() for additional arguments\n\n\nshow\nPrint a moderate length summary of the MultiSim. See also multisim.disp()\n\n\nshrink\nNot to be confused with reduce(), this shrinks each sim in the msim;\n\n\nsummarize\nSummarize the simulations statistically.\n\n\n\n\n\nrun.MultiSim.brief()\nA single-line display of the MultiSim; same as print(multisim)\n\n\n\nrun.MultiSim.disp()\nDisplay the full object\n\n\n\nrun.MultiSim.init_sims(**kwargs)\nInitialize the sims\n\n\n\nrun.MultiSim.mean(bounds=None, **kwargs)\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\nfloat\nmultiplier on the standard deviation for the upper and lower bounds (default, 2)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.median(quantiles=None, **kwargs)\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\nlist or dict\nupper and lower quantiles (default, 0.1 and 0.9)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.plot(\n    key=None,\n    fig=None,\n    fig_kw=None,\n    plot_kw=None,\n    fill_kw=None,\n    legend_kw=None,\n    legend=True,\n)\nPlot all results in the MultiSim object.\nIf the MultiSim object has been reduced (i.e. mean or median), then plot the best value and uncertainty bound. Otherwise, plot individual sims.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr\nthe results key to plot (by default, all)\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nfig_kw\ndict\npassed to plt.subplots()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nfill_kw\ndict\npassed to plt.fill_between()\nNone\n\n\nlegend_kw\ndict\npassed to plt.legend()\nNone\n\n\nlegend\nbool\nwhether to show the legend\nTrue\n\n\n\n\n\n\n\nrun.MultiSim.reduce(quantiles=None, use_mean=False, bounds=None, output=False)\nCombine multiple sims into a single sim statistically: by default, use the median value and the 10th and 90th percentiles for the lower and upper bounds. If use_mean=True, then use the mean and ±2 standard deviations for lower and upper bounds.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\ndict\nthe quantiles to use, e.g. [0.1, 0.9] or {‘low : ’0.1, ’high’ : 0.9}\nNone\n\n\nuse_mean\nbool\nwhether to use the mean instead of the median\nFalse\n\n\nbounds\nfloat\nif use_mean=True, the multiplier on the standard deviation for upper and lower bounds (default 2)\nNone\n\n\noutput\nbool\nwhether to return the “reduced” sim (in any case, modify the multisim in-place)\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.Sim())\nmsim.run()\nmsim.reduce()\nmsim.summarize()\n\n\n\n\nrun.MultiSim.reset()\nUndo reduce() by resetting the base sim, which, and results\n\n\n\nrun.MultiSim.run(**kwargs)\nRun the sims; see ss.multi_run() for additional arguments\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_runs\nint\nhow many replicates of each sim to run (if a list of sims is not provided)\nrequired\n\n\ninplace\nbool\nwhether to modify the sims in place (otherwise return copies)\nrequired\n\n\nkwargs\ndict\npassed to multi_run(); use run_args to pass arguments to sim.run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nNone (modifies MultiSim object in place)\n\n\n\n\n\n\n\nrun.MultiSim.show(output=False)\nPrint a moderate length summary of the MultiSim. See also multisim.disp() (detailed output) and multisim.brief() (short output).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput\nbool\nif true, return a string instead of printing output\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.demo(run=False), label='Example multisim')\nmsim.run()\nmsim.show() # Prints moderate length output\n\n\n\n\nrun.MultiSim.shrink(**kwargs)\nNot to be confused with reduce(), this shrinks each sim in the msim; see sim.shrink() for more information.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to sim.shrink() for each sim\n{}\n\n\n\n\n\n\n\nrun.MultiSim.summarize(method='mean', quantiles=None, how='default')\nSummarize the simulations statistically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\none of ‘mean’ (default: [mean, 2*std]), ‘median’ ([median, min, max]), or ‘all’ (all results)\n'mean'\n\n\nquantiles\ndict\nif method=‘median’, use these quantiles\nNone\n\n\nhow\nstr\npassed to sim.summarize()\n'default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nmulti_run\nFor running multiple sims in parallel. If the first argument is a list of sims\n\n\nparallel\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations\n\n\nsingle_run\nConvenience function to perform a single simulation run. Mostly used for\n\n\n\n\n\nrun.multi_run(\n    sim,\n    n_runs=4,\n    reseed=None,\n    iterpars=None,\n    shrink=None,\n    run_args=None,\n    sim_args=None,\n    par_args=None,\n    do_run=True,\n    parallel=True,\n    n_cpus=None,\n    verbose=None,\n    **kwargs,\n)\nFor running multiple sims in parallel. If the first argument is a list of sims rather than a single sim, exactly these will be run and most other arguments will be ignored.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\n(Sim/list\nthe sim instance to be run, or a list of sims.\nrequired\n\n\nn_runs\n(int)\nthe number of parallel runs\n4\n\n\nreseed\n(bool)\nwhether or not to generate a fresh seed for each run (default: true for single, false for list of sims)\nNone\n\n\niterpars\n(dict)\nany other parameters to iterate over the runs; see sc.parallelize() for syntax\nNone\n\n\nshrink\n(bool)\nwhether to shrink the sim after the sim run\nNone\n\n\nrun_args\n(dict)\narguments passed to sim.run()\nNone\n\n\nsim_args\n(dict)\nextra parameters to pass to the sim\nNone\n\n\npar_args\n(dict)\narguments passed to sc.parallelize()\nNone\n\n\ndo_run\n(bool)\nwhether to actually run the sim (if not, just initialize it)\nTrue\n\n\nparallel\n(bool)\nwhether to run in parallel using multiprocessing (else, just run in a loop)\nTrue\n\n\nn_cpus\n(int)\nthe number of CPUs to run on (if blank, set automatically; otherwise, passed to par_args)\nNone\n\n\nverbose\n(int)\ndetail to print\nNone\n\n\nkwargs\n(dict)\nalso passed to the sim\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nIf combine is True, a single sim object with the combined results from each sim.\n\n\n\n\nOtherwise, a list of sim objects (default).\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim()\nsims = ss.multi_run(sim, n_runs=6)\n\n\n\n\nrun.parallel(*args, **kwargs)\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations at once.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nThe simulations to run\n()\n\n\nkwargs\ndict\npassed to multi_run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA run MultiSim object.\n\n\n\nExamples:\ns1 = ss.Sim(n_agents=1000, label='Small', diseases='sis', networks='random')\ns2 = ss.Sim(n_agents=2000, label='Large', diseases='sis', networks='random')\nss.parallel(s1, s2).plot()\nmsim = ss.parallel([s1, s2], shrink=False)\n\n\n\n\nrun.single_run(\n    sim,\n    ind=0,\n    reseed=True,\n    shrink=True,\n    run_args=None,\n    sim_args=None,\n    verbose=None,\n    do_run=True,\n    **kwargs,\n)\nConvenience function to perform a single simulation run. Mostly used for parallelization, but can also be used directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\n(Sim)\nthe sim instance to be run\nrequired\n\n\nind\n(int)\nthe index of this sim\n0\n\n\nreseed\n(bool)\nwhether to generate a fresh seed for each run\nTrue\n\n\nnoise\n(float)\nthe amount of noise to add to each run\nrequired\n\n\nnoisepar\n(str)\nthe name of the parameter to add noise to\nrequired\n\n\nshrink\n(bool)\nwhether to shrink the sim after the sim run\nTrue\n\n\nrun_args\n(dict)\narguments passed to sim.run()\nNone\n\n\nsim_args\n(dict)\nextra parameters to pass to the sim, e.g. ‘n_infected’\nNone\n\n\nverbose\n(int)\ndetail to print\nNone\n\n\ndo_run\n(bool)\nwhether to actually run the sim (if not, just initialize it)\nTrue\n\n\nkwargs\n(dict)\nalso passed to the sim\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsim\nSim\na single sim object with results\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim() # Create a default simulation\nsim = ss.single_run(sim) # Run it, equivalent(ish) to sim.run()",
    "crumbs": [
      "**Workflows**",
      "run"
    ]
  },
  {
    "objectID": "api/run.html#classes",
    "href": "api/run.html#classes",
    "title": "run",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nMultiSim\nClass for running multiple copies of a simulation.\n\n\n\n\n\nrun.MultiSim(\n    self,\n    sims=None,\n    base_sim=None,\n    label=None,\n    n_runs=4,\n    initialize=False,\n    inplace=True,\n    debug=False,\n    **kwargs,\n)\nClass for running multiple copies of a simulation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsims\nSim / list\na single sim or a list of sims\nNone\n\n\nbase_sim\nSim\nthe sim used for shared properties; if not supplied, the first of the sims provided\nNone\n\n\nlabel\nstr\nthe name of the multisim\nNone\n\n\nn_runs\nint\nif a single sim is provided, the number of replicates (default 4)\n4\n\n\ninitialize\nbool\nwhether or not to initialize the sims (otherwise, initialize them during run)\nFalse\n\n\ninplace\nbool\nwhether to modify the sims in-place (default True); else return new sims\nTrue\n\n\ndebug\nbool\nif True, run in serial\nFalse\n\n\nkwargs\ndict\nstored in run_args and passed to run()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrief\nA single-line display of the MultiSim; same as print(multisim)\n\n\ndisp\nDisplay the full object\n\n\ninit_sims\nInitialize the sims\n\n\nmean\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\nmedian\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\nplot\nPlot all results in the MultiSim object.\n\n\nreduce\nCombine multiple sims into a single sim statistically: by default, use\n\n\nreset\nUndo reduce() by resetting the base sim, which, and results\n\n\nrun\nRun the sims; see ss.multi_run() for additional arguments\n\n\nshow\nPrint a moderate length summary of the MultiSim. See also multisim.disp()\n\n\nshrink\nNot to be confused with reduce(), this shrinks each sim in the msim;\n\n\nsummarize\nSummarize the simulations statistically.\n\n\n\n\n\nrun.MultiSim.brief()\nA single-line display of the MultiSim; same as print(multisim)\n\n\n\nrun.MultiSim.disp()\nDisplay the full object\n\n\n\nrun.MultiSim.init_sims(**kwargs)\nInitialize the sims\n\n\n\nrun.MultiSim.mean(bounds=None, **kwargs)\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\nfloat\nmultiplier on the standard deviation for the upper and lower bounds (default, 2)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.median(quantiles=None, **kwargs)\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\nlist or dict\nupper and lower quantiles (default, 0.1 and 0.9)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.plot(\n    key=None,\n    fig=None,\n    fig_kw=None,\n    plot_kw=None,\n    fill_kw=None,\n    legend_kw=None,\n    legend=True,\n)\nPlot all results in the MultiSim object.\nIf the MultiSim object has been reduced (i.e. mean or median), then plot the best value and uncertainty bound. Otherwise, plot individual sims.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr\nthe results key to plot (by default, all)\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nfig_kw\ndict\npassed to plt.subplots()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nfill_kw\ndict\npassed to plt.fill_between()\nNone\n\n\nlegend_kw\ndict\npassed to plt.legend()\nNone\n\n\nlegend\nbool\nwhether to show the legend\nTrue\n\n\n\n\n\n\n\nrun.MultiSim.reduce(quantiles=None, use_mean=False, bounds=None, output=False)\nCombine multiple sims into a single sim statistically: by default, use the median value and the 10th and 90th percentiles for the lower and upper bounds. If use_mean=True, then use the mean and ±2 standard deviations for lower and upper bounds.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\ndict\nthe quantiles to use, e.g. [0.1, 0.9] or {‘low : ’0.1, ’high’ : 0.9}\nNone\n\n\nuse_mean\nbool\nwhether to use the mean instead of the median\nFalse\n\n\nbounds\nfloat\nif use_mean=True, the multiplier on the standard deviation for upper and lower bounds (default 2)\nNone\n\n\noutput\nbool\nwhether to return the “reduced” sim (in any case, modify the multisim in-place)\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.Sim())\nmsim.run()\nmsim.reduce()\nmsim.summarize()\n\n\n\n\nrun.MultiSim.reset()\nUndo reduce() by resetting the base sim, which, and results\n\n\n\nrun.MultiSim.run(**kwargs)\nRun the sims; see ss.multi_run() for additional arguments\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_runs\nint\nhow many replicates of each sim to run (if a list of sims is not provided)\nrequired\n\n\ninplace\nbool\nwhether to modify the sims in place (otherwise return copies)\nrequired\n\n\nkwargs\ndict\npassed to multi_run(); use run_args to pass arguments to sim.run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nNone (modifies MultiSim object in place)\n\n\n\n\n\n\n\nrun.MultiSim.show(output=False)\nPrint a moderate length summary of the MultiSim. See also multisim.disp() (detailed output) and multisim.brief() (short output).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput\nbool\nif true, return a string instead of printing output\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.demo(run=False), label='Example multisim')\nmsim.run()\nmsim.show() # Prints moderate length output\n\n\n\n\nrun.MultiSim.shrink(**kwargs)\nNot to be confused with reduce(), this shrinks each sim in the msim; see sim.shrink() for more information.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to sim.shrink() for each sim\n{}\n\n\n\n\n\n\n\nrun.MultiSim.summarize(method='mean', quantiles=None, how='default')\nSummarize the simulations statistically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\none of ‘mean’ (default: [mean, 2*std]), ‘median’ ([median, min, max]), or ‘all’ (all results)\n'mean'\n\n\nquantiles\ndict\nif method=‘median’, use these quantiles\nNone\n\n\nhow\nstr\npassed to sim.summarize()\n'default'",
    "crumbs": [
      "**Workflows**",
      "run"
    ]
  },
  {
    "objectID": "api/run.html#functions",
    "href": "api/run.html#functions",
    "title": "run",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nmulti_run\nFor running multiple sims in parallel. If the first argument is a list of sims\n\n\nparallel\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations\n\n\nsingle_run\nConvenience function to perform a single simulation run. Mostly used for\n\n\n\n\n\nrun.multi_run(\n    sim,\n    n_runs=4,\n    reseed=None,\n    iterpars=None,\n    shrink=None,\n    run_args=None,\n    sim_args=None,\n    par_args=None,\n    do_run=True,\n    parallel=True,\n    n_cpus=None,\n    verbose=None,\n    **kwargs,\n)\nFor running multiple sims in parallel. If the first argument is a list of sims rather than a single sim, exactly these will be run and most other arguments will be ignored.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\n(Sim/list\nthe sim instance to be run, or a list of sims.\nrequired\n\n\nn_runs\n(int)\nthe number of parallel runs\n4\n\n\nreseed\n(bool)\nwhether or not to generate a fresh seed for each run (default: true for single, false for list of sims)\nNone\n\n\niterpars\n(dict)\nany other parameters to iterate over the runs; see sc.parallelize() for syntax\nNone\n\n\nshrink\n(bool)\nwhether to shrink the sim after the sim run\nNone\n\n\nrun_args\n(dict)\narguments passed to sim.run()\nNone\n\n\nsim_args\n(dict)\nextra parameters to pass to the sim\nNone\n\n\npar_args\n(dict)\narguments passed to sc.parallelize()\nNone\n\n\ndo_run\n(bool)\nwhether to actually run the sim (if not, just initialize it)\nTrue\n\n\nparallel\n(bool)\nwhether to run in parallel using multiprocessing (else, just run in a loop)\nTrue\n\n\nn_cpus\n(int)\nthe number of CPUs to run on (if blank, set automatically; otherwise, passed to par_args)\nNone\n\n\nverbose\n(int)\ndetail to print\nNone\n\n\nkwargs\n(dict)\nalso passed to the sim\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nIf combine is True, a single sim object with the combined results from each sim.\n\n\n\n\nOtherwise, a list of sim objects (default).\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim()\nsims = ss.multi_run(sim, n_runs=6)\n\n\n\n\nrun.parallel(*args, **kwargs)\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations at once.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nThe simulations to run\n()\n\n\nkwargs\ndict\npassed to multi_run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA run MultiSim object.\n\n\n\nExamples:\ns1 = ss.Sim(n_agents=1000, label='Small', diseases='sis', networks='random')\ns2 = ss.Sim(n_agents=2000, label='Large', diseases='sis', networks='random')\nss.parallel(s1, s2).plot()\nmsim = ss.parallel([s1, s2], shrink=False)\n\n\n\n\nrun.single_run(\n    sim,\n    ind=0,\n    reseed=True,\n    shrink=True,\n    run_args=None,\n    sim_args=None,\n    verbose=None,\n    do_run=True,\n    **kwargs,\n)\nConvenience function to perform a single simulation run. Mostly used for parallelization, but can also be used directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\n(Sim)\nthe sim instance to be run\nrequired\n\n\nind\n(int)\nthe index of this sim\n0\n\n\nreseed\n(bool)\nwhether to generate a fresh seed for each run\nTrue\n\n\nnoise\n(float)\nthe amount of noise to add to each run\nrequired\n\n\nnoisepar\n(str)\nthe name of the parameter to add noise to\nrequired\n\n\nshrink\n(bool)\nwhether to shrink the sim after the sim run\nTrue\n\n\nrun_args\n(dict)\narguments passed to sim.run()\nNone\n\n\nsim_args\n(dict)\nextra parameters to pass to the sim, e.g. ‘n_infected’\nNone\n\n\nverbose\n(int)\ndetail to print\nNone\n\n\ndo_run\n(bool)\nwhether to actually run the sim (if not, just initialize it)\nTrue\n\n\nkwargs\n(dict)\nalso passed to the sim\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsim\nSim\na single sim object with results\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim() # Create a default simulation\nsim = ss.single_run(sim) # Run it, equivalent(ish) to sim.run()",
    "crumbs": [
      "**Workflows**",
      "run"
    ]
  },
  {
    "objectID": "api/demographics.html",
    "href": "api/demographics.html",
    "title": "demographics",
    "section": "",
    "text": "demographics\nDefine pregnancy, deaths, migration, etc.\n\n\n\n\n\nName\nDescription\n\n\n\n\nDemographics\nA demographic module typically handles births/deaths/migration and takes\n\n\n\n\n\ndemographics.Demographics(self, name=None, label=None, **kwargs)\nA demographic module typically handles births/deaths/migration and takes place at the start of the timestep, before networks are updated and before any disease modules are executed.",
    "crumbs": [
      "**Modules**",
      "demographics"
    ]
  },
  {
    "objectID": "api/demographics.html#classes",
    "href": "api/demographics.html#classes",
    "title": "demographics",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDemographics\nA demographic module typically handles births/deaths/migration and takes\n\n\n\n\n\ndemographics.Demographics(self, name=None, label=None, **kwargs)\nA demographic module typically handles births/deaths/migration and takes place at the start of the timestep, before networks are updated and before any disease modules are executed.",
    "crumbs": [
      "**Modules**",
      "demographics"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "API reference",
    "section": "",
    "text": "Full details on all Starsim classes and functions.\n\n\n\narrays\nDefine array-handling classes, including agent states\n\n\ncalibration\nDefine the calibration class\n\n\ndemographics\nDefine pregnancy, deaths, migration, etc.\n\n\ndisease\nBase classes for diseases\n\n\ndistributions\nDefine random-number-safe distributions.\n\n\ninterventions\nDefine interventions\n\n\nloop\nParent class for the integration loop.\n\n\nmodules\nGeneral module class – base class for diseases, interventions, etc. Also\n\n\nnetworks\nNetworks that connect people within a population\n\n\nparameters\nSet parameters\n\n\npeople\nDefines the People class and functions associated with making people\n\n\nproducts\nDefine products\n\n\nresults\nResult structures.\n\n\nrun\nUtilities for running in parallel\n\n\nsamples\nCreate a class for storing a large number of simulations.\n\n\nsettings\nDefine options for Starsim.\n\n\nsim\nDefine core Sim classes\n\n\ntime\nFunctions and classes for handling time\n\n\nutils\nNumerical utilities",
    "crumbs": [
      "Home",
      "**API reference**"
    ]
  },
  {
    "objectID": "api/index.html#api-reference-1",
    "href": "api/index.html#api-reference-1",
    "title": "API reference",
    "section": "",
    "text": "Full details on all Starsim classes and functions.\n\n\n\narrays\nDefine array-handling classes, including agent states\n\n\ncalibration\nDefine the calibration class\n\n\ndemographics\nDefine pregnancy, deaths, migration, etc.\n\n\ndisease\nBase classes for diseases\n\n\ndistributions\nDefine random-number-safe distributions.\n\n\ninterventions\nDefine interventions\n\n\nloop\nParent class for the integration loop.\n\n\nmodules\nGeneral module class – base class for diseases, interventions, etc. Also\n\n\nnetworks\nNetworks that connect people within a population\n\n\nparameters\nSet parameters\n\n\npeople\nDefines the People class and functions associated with making people\n\n\nproducts\nDefine products\n\n\nresults\nResult structures.\n\n\nrun\nUtilities for running in parallel\n\n\nsamples\nCreate a class for storing a large number of simulations.\n\n\nsettings\nDefine options for Starsim.\n\n\nsim\nDefine core Sim classes\n\n\ntime\nFunctions and classes for handling time\n\n\nutils\nNumerical utilities",
    "crumbs": [
      "Home",
      "**API reference**"
    ]
  },
  {
    "objectID": "api/products.html",
    "href": "api/products.html",
    "title": "products",
    "section": "",
    "text": "products\nDefine products\n\n\n\n\n\nName\nDescription\n\n\n\n\nDx\nGeneric class for diagnostics\n\n\nProduct\nGeneric product implementation\n\n\nTx\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\nVx\nVaccine product\n\n\n\n\n\nproducts.Dx(self, df, hierarchy=None, *args, **kwargs)\nGeneric class for diagnostics\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminister a testing product.\n\n\n\n\n\nproducts.Dx.administer(uids, return_format='dict')\nAdminister a testing product.\nReturns:\n if return_format=='array': an array of length len(inds) with integer entries that map each person to one of the result_states\n if return_format=='dict': a dictionary keyed by result_states with values containing the indices of people classified into this state\n\n\n\n\n\nproducts.Product(self, name=None, label=None, **kwargs)\nGeneric product implementation\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Product.administer(uids)\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Tx(self, df, *args, **kwargs)\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Tx.administer(uids, return_format='dict')\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Vx(self, diseases=None, *args, **kwargs)\nVaccine product\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nApply the vaccine to the requested uids.\n\n\n\n\n\nproducts.Vx.administer(uids)\nApply the vaccine to the requested uids.",
    "crumbs": [
      "**Modules**",
      "products"
    ]
  },
  {
    "objectID": "api/products.html#classes",
    "href": "api/products.html#classes",
    "title": "products",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDx\nGeneric class for diagnostics\n\n\nProduct\nGeneric product implementation\n\n\nTx\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\nVx\nVaccine product\n\n\n\n\n\nproducts.Dx(self, df, hierarchy=None, *args, **kwargs)\nGeneric class for diagnostics\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminister a testing product.\n\n\n\n\n\nproducts.Dx.administer(uids, return_format='dict')\nAdminister a testing product.\nReturns:\n if return_format=='array': an array of length len(inds) with integer entries that map each person to one of the result_states\n if return_format=='dict': a dictionary keyed by result_states with values containing the indices of people classified into this state\n\n\n\n\n\nproducts.Product(self, name=None, label=None, **kwargs)\nGeneric product implementation\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Product.administer(uids)\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Tx(self, df, *args, **kwargs)\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Tx.administer(uids, return_format='dict')\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Vx(self, diseases=None, *args, **kwargs)\nVaccine product\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nApply the vaccine to the requested uids.\n\n\n\n\n\nproducts.Vx.administer(uids)\nApply the vaccine to the requested uids.",
    "crumbs": [
      "**Modules**",
      "products"
    ]
  },
  {
    "objectID": "api/modules.html",
    "href": "api/modules.html",
    "title": "modules",
    "section": "",
    "text": "modules\nGeneral module class – base class for diseases, interventions, etc. Also defines Analyzers and Connectors.\n\n\n\n\n\nName\nDescription\n\n\n\n\nAnalyzer\nBase class for Analyzers. Analyzers are used to provide more detailed information\n\n\nBase\nThe parent class for Sim and Module objects\n\n\nConnector\nBase class for Connectors, which mediate interactions between disease (or other) modules\n\n\nModule\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\n\n\n\n\n\nmodules.Analyzer(self, name=None, label=None, **kwargs)\nBase class for Analyzers. Analyzers are used to provide more detailed information about a simulation than is available by default – for example, pulling states out of sim.people on a particular timestep before they get updated on the next step.\nThe key method of the analyzer is step(), which is called with the sim on each timestep.\nTo retrieve a particular analyzer from a sim, use sim.get_analyzer().\n\n\n\nmodules.Base()\nThe parent class for Sim and Module objects\n\n\n\n\n\nName\nDescription\n\n\n\n\nnow\nShortcut to self.t.now()\n\n\nti\nGet the current module timestep\n\n\ntimevec\nShortcut to self.t.timevec\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nPerform a deep copy of the module/sim\n\n\ndisp\nDisplay the full object\n\n\n\n\n\nmodules.Base.copy(die=True)\nPerform a deep copy of the module/sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndie\nbool\nwhether to raise an exception if copy fails (else, try a shallow copy)\nTrue\n\n\n\n\n\n\n\nmodules.Base.disp(output=False, **kwargs)\nDisplay the full object\n\n\n\n\n\nmodules.Connector(self, name=None, label=None, **kwargs)\nBase class for Connectors, which mediate interactions between disease (or other) modules\nBecause connectors can do anything, they have no specified structure: it is up to the user to define how they behave.\n\n\n\nmodules.Module(self, name=None, label=None, **kwargs)\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\na short, key-like name for the module (e.g. “randomnet”)\nNone\n\n\nlabel\nstr\nthe full, human-readable name for the module (e.g. “Random network”)\nNone\n\n\nkwargs\ndict\npassed to ss.Time() (e.g. start, stop, unit, dt)\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstates\nReturn a flat list of all states\n\n\nstatesdict\nReturn a flat dictionary (objdict) of all states\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate\nCreate a module instance by name\n\n\ndefine_pars\nCreate or merge Pars objects\n\n\ndefine_results\nAdd results to the module\n\n\ndefine_states\nDefine states of the module with the same attribute name as the state\n\n\nfinalize\nPerform any final operations, such as removing unneeded data\n\n\nfinalize_results\nFinalize results\n\n\nfinish_step\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\nfrom_func\nCreate an module from a function\n\n\ninit_post\nInitialize the values of the states; the last step of initialization\n\n\ninit_pre\nPerform initialization steps\n\n\ninit_results\nInitialize any results required; part of init_pre()\n\n\nmatch_time_inds\nFind the nearest matching sim time indices for the current module\n\n\nplot\nPlot all results in the module\n\n\nset_metadata\nSet metadata for the module\n\n\nstart_step\nTasks to perform at the beginning of the step\n\n\nstep\nDefine how the module updates over time – the key part of Starsim!!\n\n\nto_json\nExport to a JSON-compatible format\n\n\nupdate_pars\nPull out recognized parameters, returning the rest\n\n\nupdate_results\nPerform any results updates on each timestep\n\n\n\n\n\nmodules.Module.create(name, *args, **kwargs)\nCreate a module instance by name\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nA string with the name of the module class in lower case, e.g. ‘sir’\nrequired\n\n\n\n\n\n\n\nmodules.Module.define_pars(inherit=True, **kwargs)\nCreate or merge Pars objects\n\n\n\nmodules.Module.define_results(*args, check=True)\nAdd results to the module\n\n\n\nmodules.Module.define_states(*args, check=True)\nDefine states of the module with the same attribute name as the state\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nstates\nlist of states to add\n()\n\n\ncheck\nbool\nwhether to check that the object being added is a state\nTrue\n\n\n\n\n\n\n\nmodules.Module.finalize()\nPerform any final operations, such as removing unneeded data\n\n\n\nmodules.Module.finalize_results()\nFinalize results\n\n\n\nmodules.Module.finish_step()\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\n\nmodules.Module.from_func(func)\nCreate an module from a function\n\n\n\nmodules.Module.init_post()\nInitialize the values of the states; the last step of initialization\n\n\n\nmodules.Module.init_pre(sim, force=False)\nPerform initialization steps\nThis method is called once, as part of initializing a Sim. Note: after initialization, initialized=False until init_vals() is called (which is after distributions are initialized).\n\n\n\nmodules.Module.init_results()\nInitialize any results required; part of init_pre()\n\n\n\nmodules.Module.match_time_inds(inds=None)\nFind the nearest matching sim time indices for the current module\n\n\n\nmodules.Module.plot()\nPlot all results in the module\n\n\n\nmodules.Module.set_metadata(name=None, label=None)\nSet metadata for the module\n\n\n\nmodules.Module.start_step()\nTasks to perform at the beginning of the step\n\n\n\nmodules.Module.step()\nDefine how the module updates over time – the key part of Starsim!!\n\n\n\nmodules.Module.to_json()\nExport to a JSON-compatible format\n\n\n\nmodules.Module.update_pars(**pars)\nPull out recognized parameters, returning the rest\n\n\n\nmodules.Module.update_results()\nPerform any results updates on each timestep\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfind_modules\nFind all subclasses of Module present in Starsim, divided by type\n\n\nmodule_map\nDefine the mapping between module names and types\n\n\n\n\n\nmodules.find_modules(key=None, flat=False)\nFind all subclasses of Module present in Starsim, divided by type\n\n\n\nmodules.module_map(key=None)\nDefine the mapping between module names and types",
    "crumbs": [
      "**Modules**",
      "modules"
    ]
  },
  {
    "objectID": "api/modules.html#classes",
    "href": "api/modules.html#classes",
    "title": "modules",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAnalyzer\nBase class for Analyzers. Analyzers are used to provide more detailed information\n\n\nBase\nThe parent class for Sim and Module objects\n\n\nConnector\nBase class for Connectors, which mediate interactions between disease (or other) modules\n\n\nModule\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\n\n\n\n\n\nmodules.Analyzer(self, name=None, label=None, **kwargs)\nBase class for Analyzers. Analyzers are used to provide more detailed information about a simulation than is available by default – for example, pulling states out of sim.people on a particular timestep before they get updated on the next step.\nThe key method of the analyzer is step(), which is called with the sim on each timestep.\nTo retrieve a particular analyzer from a sim, use sim.get_analyzer().\n\n\n\nmodules.Base()\nThe parent class for Sim and Module objects\n\n\n\n\n\nName\nDescription\n\n\n\n\nnow\nShortcut to self.t.now()\n\n\nti\nGet the current module timestep\n\n\ntimevec\nShortcut to self.t.timevec\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nPerform a deep copy of the module/sim\n\n\ndisp\nDisplay the full object\n\n\n\n\n\nmodules.Base.copy(die=True)\nPerform a deep copy of the module/sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndie\nbool\nwhether to raise an exception if copy fails (else, try a shallow copy)\nTrue\n\n\n\n\n\n\n\nmodules.Base.disp(output=False, **kwargs)\nDisplay the full object\n\n\n\n\n\nmodules.Connector(self, name=None, label=None, **kwargs)\nBase class for Connectors, which mediate interactions between disease (or other) modules\nBecause connectors can do anything, they have no specified structure: it is up to the user to define how they behave.\n\n\n\nmodules.Module(self, name=None, label=None, **kwargs)\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\na short, key-like name for the module (e.g. “randomnet”)\nNone\n\n\nlabel\nstr\nthe full, human-readable name for the module (e.g. “Random network”)\nNone\n\n\nkwargs\ndict\npassed to ss.Time() (e.g. start, stop, unit, dt)\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstates\nReturn a flat list of all states\n\n\nstatesdict\nReturn a flat dictionary (objdict) of all states\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate\nCreate a module instance by name\n\n\ndefine_pars\nCreate or merge Pars objects\n\n\ndefine_results\nAdd results to the module\n\n\ndefine_states\nDefine states of the module with the same attribute name as the state\n\n\nfinalize\nPerform any final operations, such as removing unneeded data\n\n\nfinalize_results\nFinalize results\n\n\nfinish_step\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\nfrom_func\nCreate an module from a function\n\n\ninit_post\nInitialize the values of the states; the last step of initialization\n\n\ninit_pre\nPerform initialization steps\n\n\ninit_results\nInitialize any results required; part of init_pre()\n\n\nmatch_time_inds\nFind the nearest matching sim time indices for the current module\n\n\nplot\nPlot all results in the module\n\n\nset_metadata\nSet metadata for the module\n\n\nstart_step\nTasks to perform at the beginning of the step\n\n\nstep\nDefine how the module updates over time – the key part of Starsim!!\n\n\nto_json\nExport to a JSON-compatible format\n\n\nupdate_pars\nPull out recognized parameters, returning the rest\n\n\nupdate_results\nPerform any results updates on each timestep\n\n\n\n\n\nmodules.Module.create(name, *args, **kwargs)\nCreate a module instance by name\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nA string with the name of the module class in lower case, e.g. ‘sir’\nrequired\n\n\n\n\n\n\n\nmodules.Module.define_pars(inherit=True, **kwargs)\nCreate or merge Pars objects\n\n\n\nmodules.Module.define_results(*args, check=True)\nAdd results to the module\n\n\n\nmodules.Module.define_states(*args, check=True)\nDefine states of the module with the same attribute name as the state\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nstates\nlist of states to add\n()\n\n\ncheck\nbool\nwhether to check that the object being added is a state\nTrue\n\n\n\n\n\n\n\nmodules.Module.finalize()\nPerform any final operations, such as removing unneeded data\n\n\n\nmodules.Module.finalize_results()\nFinalize results\n\n\n\nmodules.Module.finish_step()\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\n\nmodules.Module.from_func(func)\nCreate an module from a function\n\n\n\nmodules.Module.init_post()\nInitialize the values of the states; the last step of initialization\n\n\n\nmodules.Module.init_pre(sim, force=False)\nPerform initialization steps\nThis method is called once, as part of initializing a Sim. Note: after initialization, initialized=False until init_vals() is called (which is after distributions are initialized).\n\n\n\nmodules.Module.init_results()\nInitialize any results required; part of init_pre()\n\n\n\nmodules.Module.match_time_inds(inds=None)\nFind the nearest matching sim time indices for the current module\n\n\n\nmodules.Module.plot()\nPlot all results in the module\n\n\n\nmodules.Module.set_metadata(name=None, label=None)\nSet metadata for the module\n\n\n\nmodules.Module.start_step()\nTasks to perform at the beginning of the step\n\n\n\nmodules.Module.step()\nDefine how the module updates over time – the key part of Starsim!!\n\n\n\nmodules.Module.to_json()\nExport to a JSON-compatible format\n\n\n\nmodules.Module.update_pars(**pars)\nPull out recognized parameters, returning the rest\n\n\n\nmodules.Module.update_results()\nPerform any results updates on each timestep",
    "crumbs": [
      "**Modules**",
      "modules"
    ]
  },
  {
    "objectID": "api/modules.html#functions",
    "href": "api/modules.html#functions",
    "title": "modules",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfind_modules\nFind all subclasses of Module present in Starsim, divided by type\n\n\nmodule_map\nDefine the mapping between module names and types\n\n\n\n\n\nmodules.find_modules(key=None, flat=False)\nFind all subclasses of Module present in Starsim, divided by type\n\n\n\nmodules.module_map(key=None)\nDefine the mapping between module names and types",
    "crumbs": [
      "**Modules**",
      "modules"
    ]
  },
  {
    "objectID": "api/distributions.html",
    "href": "api/distributions.html",
    "title": "distributions",
    "section": "",
    "text": "distributions\nDefine random-number-safe distributions.\n\n\n\n\n\nName\nDescription\n\n\n\n\nDist\nBase class for tracking one random number generator associated with one distribution,\n\n\nDists\nClass for managing a collection of Dist objects\n\n\nmulti_random\nA class for holding two or more ss.random() distributions, and generating\n\n\n\n\n\ndistributions.Dist(\n    self,\n    dist=None,\n    distname=None,\n    name=None,\n    seed=None,\n    offset=None,\n    strict=True,\n    auto=True,\n    sim=None,\n    module=None,\n    debug=False,\n    **kwargs,\n)\nBase class for tracking one random number generator associated with one distribution, i.e. one decision per timestep.\nSee ss.dist_list for a full list of supported distributions.\nAlthough it’s possible in theory to define a custom distribution (i.e., not one from NumPy or SciPy), in practice this is difficult. The distribution needs to have both a way to return random variates (easy), as well as the probability point function (inverse CDF). In addition, the distribution must be able to take a NumPy RNG as its bit generator. It’s easier to just use a default Dist (e.g., ss.random()), and then take its output as input (i.e., quantiles) for whatever custom distribution you want to create.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndist\nrv_generic\noptional; a scipy.stats distribution (frozen or not) to get the ppf from\nNone\n\n\ndistname\nstr\nthe name for this class of distribution (e.g. “uniform”)\nNone\n\n\nname\nstr\nthe name for this particular distribution (e.g. “age_at_death”)\nNone\n\n\nseed\nint\nthe user-chosen random seed (e.g. 3)\nNone\n\n\noffset\nint\nthe seed offset; will be automatically assigned (based on hashing the name) if None\nNone\n\n\nstrict\nbool\nif True, require initialization and invalidate after each call to rvs()\nTrue\n\n\nauto\nbool\nwhether to auto-reset the state after each draw\nTrue\n\n\nsim\nSim\nusually determined on initialization; the sim to use as input to callable parameters\nNone\n\n\nmodule\nModule\nusually determined on initialization; the module to use as input to callable parameters\nNone\n\n\nkwargs\ndict\nparameters of the distribution\n{}\n\n\n\nExamples:\ndist = ss.Dist(sps.norm, loc=3)\ndist.rvs(10) # Return 10 normally distributed random numbers\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstate\nGet the current state\n\n\nstate_int\nGet the integer corresponding to the current state\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncall_par\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\ncall_pars\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\nconvert_callable\nMethod to handle how callable parameters are processed; not for the user\n\n\nconvert_timepars\nConvert time parameters (durations and rates) to scalars\n\n\ndisp\nReturn full display of object\n\n\nget_state\nReturn a copy of the state\n\n\ninit\nCalculate the starting seed and create the RNG\n\n\njump\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\njump_dt\nAutomatically jump on the next value of dt\n\n\nlink_module\nShortcut for linking the module\n\n\nlink_sim\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\nmake_history\nStore the current state in history\n\n\nmake_rvs\nReturn default random numbers for scalar parameters; not for the user\n\n\nplot_hist\nPlot the current state of the RNG as a histogram\n\n\npostprocess_timepar\nScale random variates after generation; not for the user\n\n\nppf\nReturn default random numbers for array parameters; not for the user\n\n\nprocess_dist\nEnsure the distribution works; not for the user\n\n\nprocess_pars\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\nprocess_seed\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\nprocess_size\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\nrand\nSimple way to get simple random numbers\n\n\nreset\nRestore state, allowing the same numbers to be resampled\n\n\nrvs\nGet random variates – use this!\n\n\nset\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\nshow_state\nShow the state of the object\n\n\nsync_pars\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\nto_json\nReturn a dictionary representation of the Dist\n\n\nupdate_dist_pars\nUpdate SciPy distribution parameters; not for the user\n\n\n\n\n\ndistributions.Dist.call_par(key, val, size, uids)\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\n\ndistributions.Dist.call_pars()\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\n\ndistributions.Dist.convert_callable(key, val, size, uids)\nMethod to handle how callable parameters are processed; not for the user\n\n\n\ndistributions.Dist.convert_timepars()\nConvert time parameters (durations and rates) to scalars\nThis function converts time parameters into bare numbers that will be returned by rvs() depending on the timestep of the parent module for this Dist. The conversion for these types is\n\nDurations are divided by dt (so the result will be a number of timesteps)\nRates are multiplied by dt (so the result will be a number of events, or else the equivalent multiplicate value for the timestep)\n\n\n\n\ndistributions.Dist.disp()\nReturn full display of object\n\n\n\ndistributions.Dist.get_state()\nReturn a copy of the state\n\n\n\ndistributions.Dist.init(\n    trace=None,\n    seed=None,\n    module=None,\n    sim=None,\n    slots=None,\n    force=False,\n)\nCalculate the starting seed and create the RNG\n\n\n\ndistributions.Dist.jump(to=None, delta=1, force=False)\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\n\ndistributions.Dist.jump_dt(ti=None, force=False)\nAutomatically jump on the next value of dt\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current module timestep plus one)\nNone\n\n\n\n\n\n\n\ndistributions.Dist.link_module(module=None, overwrite=False)\nShortcut for linking the module\n\n\n\ndistributions.Dist.link_sim(sim=None, overwrite=False)\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\n\ndistributions.Dist.make_history(reset=False)\nStore the current state in history\n\n\n\ndistributions.Dist.make_rvs()\nReturn default random numbers for scalar parameters; not for the user\n\n\n\ndistributions.Dist.plot_hist(n=1000, bins=None, fig_kw=None, hist_kw=None)\nPlot the current state of the RNG as a histogram\n\n\n\ndistributions.Dist.postprocess_timepar(rvs)\nScale random variates after generation; not for the user\n\n\n\ndistributions.Dist.ppf(rands)\nReturn default random numbers for array parameters; not for the user\n\n\n\ndistributions.Dist.process_dist()\nEnsure the distribution works; not for the user\n\n\n\ndistributions.Dist.process_pars(call=True)\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\n\ndistributions.Dist.process_seed(trace=None, seed=None)\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\n\ndistributions.Dist.process_size(n=1)\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\n\ndistributions.Dist.rand(size)\nSimple way to get simple random numbers\n\n\n\ndistributions.Dist.reset(state=0)\nRestore state, allowing the same numbers to be resampled\nUse 0 for original state, -1 for most recent state.\nExample:\ndist = ss.random(seed=5).init()\nr1 = dist(5)\nr2 = dist(5)\ndist.reset(-1)\nr3 = dist(5)\ndist.reset(0)\nr4 = dist(5)\nassert all(r1 != r2)\nassert all(r2 == r3)\nassert all(r4 == r1)\n\n\n\ndistributions.Dist.rvs(n=1, reset=False)\nGet random variates – use this!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint / tuple / arr\nif an int or tuple, return this many random variates; if an array, treat as UIDs\n1\n\n\nreset\nbool\nwhether to automatically reset the random number distribution state after being called\nFalse\n\n\n\n\n\n\n\ndistributions.Dist.set(*args, dist=None, **kwargs)\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\n\ndistributions.Dist.show_state(output=False)\nShow the state of the object\n\n\n\ndistributions.Dist.sync_pars()\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\n\ndistributions.Dist.to_json()\nReturn a dictionary representation of the Dist\n\n\n\ndistributions.Dist.update_dist_pars(pars=None)\nUpdate SciPy distribution parameters; not for the user\n\n\n\n\n\ndistributions.Dists(self, obj=None, *args, base_seed=None, sim=None)\nClass for managing a collection of Dist objects\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_seeds\nCheck that no two distributions share the same seed\n\n\ncopy_to_module\nCopy the Sim’s Dists object to the specified module\n\n\ninit\nSet the base seed, find and initialize all distributions in an object\n\n\njump\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\njump_dt\nAdvance all RNGs to the next timestep\n\n\nreset\nReset each RNG\n\n\n\n\n\ndistributions.Dists.check_seeds()\nCheck that no two distributions share the same seed\n\n\n\ndistributions.Dists.copy_to_module(module)\nCopy the Sim’s Dists object to the specified module\n\n\n\ndistributions.Dists.init(obj=None, base_seed=None, sim=None, force=False)\nSet the base seed, find and initialize all distributions in an object\nIn practice, the object is usually a Sim, but can be anything.\n\n\n\ndistributions.Dists.jump(to=None, delta=1, force=False)\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\n\ndistributions.Dists.jump_dt(ti=None, force=False)\nAdvance all RNGs to the next timestep\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current sim timestep)\nNone\n\n\n\n\n\n\n\ndistributions.Dists.reset()\nReset each RNG\n\n\n\n\n\ndistributions.multi_random(self, names, *args, **kwargs)\nA class for holding two or more ss.random() distributions, and generating random numbers linked to each of them. Useful for e.g. pairwise transmission probabilities.\nSee ss.combine_rands() for the manual version; in almost all cases this class should be used instead.\n\n\nmulti = ss.multi_random(‘source’, ‘target’) rvs = multi.rvs(source_uids, target_uids)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncombine_rvs\nCombine inputs into one number\n\n\ninit\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\njump\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nreset\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nrvs\nGet random variates from each of the underlying distributions and combine them efficiently\n\n\n\n\n\ndistributions.multi_random.combine_rvs(rvs_list, int_type, int_max)\nCombine inputs into one number\n\n\n\ndistributions.multi_random.init(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.jump(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.reset(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.rvs(*args)\nGet random variates from each of the underlying distributions and combine them efficiently\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nlink_dists\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\nmake_dist\nMake a distribution from a dictionary\n\n\n\n\n\ndistributions.link_dists(\n    obj,\n    sim,\n    module=None,\n    overwrite=False,\n    init=False,\n    **kwargs,\n)\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\n\ndistributions.make_dist(pars=None, **kwargs)\nMake a distribution from a dictionary",
    "crumbs": [
      "**Utilities**",
      "distributions"
    ]
  },
  {
    "objectID": "api/distributions.html#classes",
    "href": "api/distributions.html#classes",
    "title": "distributions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDist\nBase class for tracking one random number generator associated with one distribution,\n\n\nDists\nClass for managing a collection of Dist objects\n\n\nmulti_random\nA class for holding two or more ss.random() distributions, and generating\n\n\n\n\n\ndistributions.Dist(\n    self,\n    dist=None,\n    distname=None,\n    name=None,\n    seed=None,\n    offset=None,\n    strict=True,\n    auto=True,\n    sim=None,\n    module=None,\n    debug=False,\n    **kwargs,\n)\nBase class for tracking one random number generator associated with one distribution, i.e. one decision per timestep.\nSee ss.dist_list for a full list of supported distributions.\nAlthough it’s possible in theory to define a custom distribution (i.e., not one from NumPy or SciPy), in practice this is difficult. The distribution needs to have both a way to return random variates (easy), as well as the probability point function (inverse CDF). In addition, the distribution must be able to take a NumPy RNG as its bit generator. It’s easier to just use a default Dist (e.g., ss.random()), and then take its output as input (i.e., quantiles) for whatever custom distribution you want to create.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndist\nrv_generic\noptional; a scipy.stats distribution (frozen or not) to get the ppf from\nNone\n\n\ndistname\nstr\nthe name for this class of distribution (e.g. “uniform”)\nNone\n\n\nname\nstr\nthe name for this particular distribution (e.g. “age_at_death”)\nNone\n\n\nseed\nint\nthe user-chosen random seed (e.g. 3)\nNone\n\n\noffset\nint\nthe seed offset; will be automatically assigned (based on hashing the name) if None\nNone\n\n\nstrict\nbool\nif True, require initialization and invalidate after each call to rvs()\nTrue\n\n\nauto\nbool\nwhether to auto-reset the state after each draw\nTrue\n\n\nsim\nSim\nusually determined on initialization; the sim to use as input to callable parameters\nNone\n\n\nmodule\nModule\nusually determined on initialization; the module to use as input to callable parameters\nNone\n\n\nkwargs\ndict\nparameters of the distribution\n{}\n\n\n\nExamples:\ndist = ss.Dist(sps.norm, loc=3)\ndist.rvs(10) # Return 10 normally distributed random numbers\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstate\nGet the current state\n\n\nstate_int\nGet the integer corresponding to the current state\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncall_par\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\ncall_pars\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\nconvert_callable\nMethod to handle how callable parameters are processed; not for the user\n\n\nconvert_timepars\nConvert time parameters (durations and rates) to scalars\n\n\ndisp\nReturn full display of object\n\n\nget_state\nReturn a copy of the state\n\n\ninit\nCalculate the starting seed and create the RNG\n\n\njump\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\njump_dt\nAutomatically jump on the next value of dt\n\n\nlink_module\nShortcut for linking the module\n\n\nlink_sim\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\nmake_history\nStore the current state in history\n\n\nmake_rvs\nReturn default random numbers for scalar parameters; not for the user\n\n\nplot_hist\nPlot the current state of the RNG as a histogram\n\n\npostprocess_timepar\nScale random variates after generation; not for the user\n\n\nppf\nReturn default random numbers for array parameters; not for the user\n\n\nprocess_dist\nEnsure the distribution works; not for the user\n\n\nprocess_pars\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\nprocess_seed\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\nprocess_size\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\nrand\nSimple way to get simple random numbers\n\n\nreset\nRestore state, allowing the same numbers to be resampled\n\n\nrvs\nGet random variates – use this!\n\n\nset\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\nshow_state\nShow the state of the object\n\n\nsync_pars\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\nto_json\nReturn a dictionary representation of the Dist\n\n\nupdate_dist_pars\nUpdate SciPy distribution parameters; not for the user\n\n\n\n\n\ndistributions.Dist.call_par(key, val, size, uids)\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\n\ndistributions.Dist.call_pars()\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\n\ndistributions.Dist.convert_callable(key, val, size, uids)\nMethod to handle how callable parameters are processed; not for the user\n\n\n\ndistributions.Dist.convert_timepars()\nConvert time parameters (durations and rates) to scalars\nThis function converts time parameters into bare numbers that will be returned by rvs() depending on the timestep of the parent module for this Dist. The conversion for these types is\n\nDurations are divided by dt (so the result will be a number of timesteps)\nRates are multiplied by dt (so the result will be a number of events, or else the equivalent multiplicate value for the timestep)\n\n\n\n\ndistributions.Dist.disp()\nReturn full display of object\n\n\n\ndistributions.Dist.get_state()\nReturn a copy of the state\n\n\n\ndistributions.Dist.init(\n    trace=None,\n    seed=None,\n    module=None,\n    sim=None,\n    slots=None,\n    force=False,\n)\nCalculate the starting seed and create the RNG\n\n\n\ndistributions.Dist.jump(to=None, delta=1, force=False)\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\n\ndistributions.Dist.jump_dt(ti=None, force=False)\nAutomatically jump on the next value of dt\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current module timestep plus one)\nNone\n\n\n\n\n\n\n\ndistributions.Dist.link_module(module=None, overwrite=False)\nShortcut for linking the module\n\n\n\ndistributions.Dist.link_sim(sim=None, overwrite=False)\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\n\ndistributions.Dist.make_history(reset=False)\nStore the current state in history\n\n\n\ndistributions.Dist.make_rvs()\nReturn default random numbers for scalar parameters; not for the user\n\n\n\ndistributions.Dist.plot_hist(n=1000, bins=None, fig_kw=None, hist_kw=None)\nPlot the current state of the RNG as a histogram\n\n\n\ndistributions.Dist.postprocess_timepar(rvs)\nScale random variates after generation; not for the user\n\n\n\ndistributions.Dist.ppf(rands)\nReturn default random numbers for array parameters; not for the user\n\n\n\ndistributions.Dist.process_dist()\nEnsure the distribution works; not for the user\n\n\n\ndistributions.Dist.process_pars(call=True)\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\n\ndistributions.Dist.process_seed(trace=None, seed=None)\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\n\ndistributions.Dist.process_size(n=1)\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\n\ndistributions.Dist.rand(size)\nSimple way to get simple random numbers\n\n\n\ndistributions.Dist.reset(state=0)\nRestore state, allowing the same numbers to be resampled\nUse 0 for original state, -1 for most recent state.\nExample:\ndist = ss.random(seed=5).init()\nr1 = dist(5)\nr2 = dist(5)\ndist.reset(-1)\nr3 = dist(5)\ndist.reset(0)\nr4 = dist(5)\nassert all(r1 != r2)\nassert all(r2 == r3)\nassert all(r4 == r1)\n\n\n\ndistributions.Dist.rvs(n=1, reset=False)\nGet random variates – use this!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint / tuple / arr\nif an int or tuple, return this many random variates; if an array, treat as UIDs\n1\n\n\nreset\nbool\nwhether to automatically reset the random number distribution state after being called\nFalse\n\n\n\n\n\n\n\ndistributions.Dist.set(*args, dist=None, **kwargs)\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\n\ndistributions.Dist.show_state(output=False)\nShow the state of the object\n\n\n\ndistributions.Dist.sync_pars()\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\n\ndistributions.Dist.to_json()\nReturn a dictionary representation of the Dist\n\n\n\ndistributions.Dist.update_dist_pars(pars=None)\nUpdate SciPy distribution parameters; not for the user\n\n\n\n\n\ndistributions.Dists(self, obj=None, *args, base_seed=None, sim=None)\nClass for managing a collection of Dist objects\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_seeds\nCheck that no two distributions share the same seed\n\n\ncopy_to_module\nCopy the Sim’s Dists object to the specified module\n\n\ninit\nSet the base seed, find and initialize all distributions in an object\n\n\njump\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\njump_dt\nAdvance all RNGs to the next timestep\n\n\nreset\nReset each RNG\n\n\n\n\n\ndistributions.Dists.check_seeds()\nCheck that no two distributions share the same seed\n\n\n\ndistributions.Dists.copy_to_module(module)\nCopy the Sim’s Dists object to the specified module\n\n\n\ndistributions.Dists.init(obj=None, base_seed=None, sim=None, force=False)\nSet the base seed, find and initialize all distributions in an object\nIn practice, the object is usually a Sim, but can be anything.\n\n\n\ndistributions.Dists.jump(to=None, delta=1, force=False)\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\n\ndistributions.Dists.jump_dt(ti=None, force=False)\nAdvance all RNGs to the next timestep\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current sim timestep)\nNone\n\n\n\n\n\n\n\ndistributions.Dists.reset()\nReset each RNG\n\n\n\n\n\ndistributions.multi_random(self, names, *args, **kwargs)\nA class for holding two or more ss.random() distributions, and generating random numbers linked to each of them. Useful for e.g. pairwise transmission probabilities.\nSee ss.combine_rands() for the manual version; in almost all cases this class should be used instead.\n\n\nmulti = ss.multi_random(‘source’, ‘target’) rvs = multi.rvs(source_uids, target_uids)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncombine_rvs\nCombine inputs into one number\n\n\ninit\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\njump\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nreset\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nrvs\nGet random variates from each of the underlying distributions and combine them efficiently\n\n\n\n\n\ndistributions.multi_random.combine_rvs(rvs_list, int_type, int_max)\nCombine inputs into one number\n\n\n\ndistributions.multi_random.init(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.jump(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.reset(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.rvs(*args)\nGet random variates from each of the underlying distributions and combine them efficiently",
    "crumbs": [
      "**Utilities**",
      "distributions"
    ]
  },
  {
    "objectID": "api/distributions.html#functions",
    "href": "api/distributions.html#functions",
    "title": "distributions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nlink_dists\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\nmake_dist\nMake a distribution from a dictionary\n\n\n\n\n\ndistributions.link_dists(\n    obj,\n    sim,\n    module=None,\n    overwrite=False,\n    init=False,\n    **kwargs,\n)\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\n\ndistributions.make_dist(pars=None, **kwargs)\nMake a distribution from a dictionary",
    "crumbs": [
      "**Utilities**",
      "distributions"
    ]
  },
  {
    "objectID": "api/sim.html",
    "href": "api/sim.html",
    "title": "sim",
    "section": "",
    "text": "sim\nDefine core Sim classes\n\n\n\n\n\nName\nDescription\n\n\n\n\nAlreadyRunError\nRaised if trying to re-run an already-run sim without re-initializing\n\n\nSim\nThe Sim object\n\n\n\n\n\nsim.AlreadyRunError()\nRaised if trying to re-run an already-run sim without re-initializing\n\n\n\nsim.Sim(\n    self,\n    pars=None,\n    label=None,\n    people=None,\n    demographics=None,\n    diseases=None,\n    networks=None,\n    interventions=None,\n    analyzers=None,\n    connectors=None,\n    copy_inputs=True,\n    data=None,\n    **kwargs,\n)\nThe Sim object\nAll Starsim simulations run via the Sim class. It is responsible for initializing and running all modules and generating results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\nSimPars / dict\neither an ss.SimPars object, or a nested dictionary; can include all other arguments\nNone\n\n\nlabel\nstr\nthe human-readable name of the simulation\nNone\n\n\npeople\nPeople\nif provided, use this ss.People object\nNone\n\n\ndemographics\nstr / Demographics / list\na string naming the demographics module to use, the module itself, or a list\nNone\n\n\ndiseases\nstr / Disease / list\nas above, for diseases\nNone\n\n\nnetworks\nstr / Network / list\nas above, for networks\nNone\n\n\ninterventions\nstr / Intervention / list\nas above, for interventions\nNone\n\n\nanalyzers\nstr / Analyzer / list\nas above, for analyzers\nNone\n\n\nconnectors\nstr / Connector / list\nas above, for connectors\nNone\n\n\ncopy_inputs\nbool\nif True, copy modules as they’re inserted into the sim (allowing reuse in other sims, but meaning they won’t be updated)\nTrue\n\n\ndata\ndf\na dataframe (or dict) of data, with a column “time” plus data of the form “module.result”, e.g. “hiv.new_infections” (used for plotting only)\nNone\n\n\nkwargs\ndict\nmerged with pars; see ss.SimPars for all parameter values\n{}\n\n\n\nExamples:\nsim = ss.Sim(diseases='sir', networks='random') # Simplest Starsim sim; equivalent to ss.demo()\nsim = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet()) # Equivalent using objects instead of strings\nsim = ss.Sim(diseases=['sir', ss.SIS()], networks=['random', 'mf']) # Example using list inputs; can mix and match types\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nmodules\nReturn iterator over all Module instances (stored in standard places) in the Sim\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_results_ready\nCheck that results are ready\n\n\nfinalize\nCompute final results\n\n\nfinish_step\nFinish the simulation timestep\n\n\ninit\nPerform all initializations for the sim\n\n\ninit_data\nInitialize or add data to the sim\n\n\ninit_dists\nInitialize the distributions\n\n\ninit_mod_vals\nInitialize values in other modules, including networks and time parameters\n\n\ninit_mods_pre\nInitialize all the modules with the sim\n\n\ninit_people\nInitialize people within the sim\n\n\ninit_people_vals\nInitialize the People states with actual values\n\n\ninit_results\nCreate initial results that are present in all simulations\n\n\ninit_sim_attrs\nMove initialized modules to the sim\n\n\ninit_time\nTime indexing; derived values live in the sim rather than in the pars\n\n\nplot\nPlot all results in the Sim object\n\n\nprofile\nProfile the performance of the simulation\n\n\nreset_time_pars\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\nrun\nRun the model once\n\n\nrun_one_step\nRun a single sim step; only used for debugging purposes.\n\n\nsave\nSave to disk as a gzipped pickle.\n\n\nshrink\n“Shrinks” the simulation by removing the people and other memory-intensive\n\n\nstart_step\nStart the step – only print progress; all actual changes happen in the modules\n\n\nsummarize\nProvide a quick summary of the sim; returns the last entry for count and\n\n\nto_df\nExport results as a Pandas dataframe\n\n\nto_json\nExport results and parameters as JSON.\n\n\n\n\n\nsim.Sim.check_results_ready(errormsg=None)\nCheck that results are ready\n\n\n\nsim.Sim.finalize()\nCompute final results\n\n\n\nsim.Sim.finish_step()\nFinish the simulation timestep\n\n\n\nsim.Sim.init(force=False, **kwargs)\nPerform all initializations for the sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nforce\nbool\nwhether to overwrite sim attributes even if they already exist\nFalse\n\n\nkwargs\ndict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_data(data=None)\nInitialize or add data to the sim\n\n\n\nsim.Sim.init_dists()\nInitialize the distributions\n\n\n\nsim.Sim.init_mod_vals()\nInitialize values in other modules, including networks and time parameters\n\n\n\nsim.Sim.init_mods_pre()\nInitialize all the modules with the sim\n\n\n\nsim.Sim.init_people(verbose=None, **kwargs)\nInitialize people within the sim Sometimes the people are provided, in which case this just adds a few sim properties to them. Other time people are not provided and this method makes them.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbose\nint\ndetail to print\nNone\n\n\nkwargs\n(dict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_people_vals()\nInitialize the People states with actual values\n\n\n\nsim.Sim.init_results()\nCreate initial results that are present in all simulations\n\n\n\nsim.Sim.init_sim_attrs(force=False)\nMove initialized modules to the sim\n\n\n\nsim.Sim.init_time()\nTime indexing; derived values live in the sim rather than in the pars\n\n\n\nsim.Sim.plot(\n    key=None,\n    fig=None,\n    style='fancy',\n    show_data=True,\n    show_skipped=False,\n    show_module=26,\n    show_label=False,\n    fig_kw=None,\n    plot_kw=None,\n    scatter_kw=None,\n)\nPlot all results in the Sim object\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr / list\nthe results key to plot (by default, all); if a list, plot exactly those keys\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nstyle\nstr\nthe plotting style to use (default “fancy”; other options are “simple”, None, or any Matplotlib style)\n'fancy'\n\n\nshow_data\nbool\nplot the data, if available\nTrue\n\n\nshow_skipped\nbool\nshow even results that are skipped by default\nFalse\n\n\nshow_module\nbool\nwhether to show the module as well as the result name; if an int, show if the label is less than that length; if -1, use a newline\n26\n\n\nshow_label\nstr\nif ‘fig’, reset the fignum; if ‘title’, set the figure suptitle\nFalse\n\n\nfig_kw\ndict\npassed to plt.subplots()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter(), for plotting the data\nNone\n\n\n\n\n\n\n\nsim.Sim.profile(do_run=True, plot=True, **kwargs)\nProfile the performance of the simulation\n\n\n\nsim.Sim.reset_time_pars(force=True)\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\n\nsim.Sim.run(until=None, verbose=None)\nRun the model once\n\n\n\nsim.Sim.run_one_step(verbose=None)\nRun a single sim step; only used for debugging purposes.\nNote: sim.run_one_step() runs a single simulation timestep, which involves multiple function calls. In contrast, loop.run_one_step() runs a single function call.\nNote: the verbose here is only for the Loop object, not the sim.\n\n\n\nsim.Sim.save(filename=None, shrink=None, **kwargs)\nSave to disk as a gzipped pickle.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr or None\nthe name or path of the file to save to; if None, uses stored\nNone\n\n\nshrink\nbool or None\nwhether to shrink the sim prior to saving (reduces size by ~99%)\nNone\n\n\nkwargs\n\npassed to sc.makefilepath()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfilename\nstr\nthe validated absolute path to the saved file\n\n\n\nExample:\nsim.save() # Saves to a .sim file\n\n\n\n\nsim.Sim.shrink(inplace=True, size_limit=1.0)\n“Shrinks” the simulation by removing the people and other memory-intensive attributes (e.g., some interventions and analyzers), and returns a copy of the “shrunken” simulation. Used to reduce the memory required for RAM or for saved files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninplace\nbool\nwhether to perform the shrinking in place (default), or return a shrunken copy instead\nTrue\n\n\nsize_limit\nfloat\nprint a warning if any module is larger than this size limit, in units of KB per timestep (set to None to disable)\n1.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshrunken\nSim\na Sim object with the listed attributes removed\n\n\n\n\n\n\n\nsim.Sim.start_step()\nStart the step – only print progress; all actual changes happen in the modules\n\n\n\nsim.Sim.summarize(how='default')\nProvide a quick summary of the sim; returns the last entry for count and cumulative results, and the mean otherwise.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhow\nstr\nhow to summarize: can be ‘mean’, ‘median’, ‘last’, or a mapping of result keys to those\n'default'\n\n\n\n\n\n\n\nsim.Sim.to_df(sep='_', **kwargs)\nExport results as a Pandas dataframe Args: sep (str): separator for the keys kwargs: passed to results.to_df()\n\n\n\nsim.Sim.to_json(\n    filename=None,\n    keys=None,\n    tostring=False,\n    indent=2,\n    verbose=False,\n    **kwargs,\n)\nExport results and parameters as JSON.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr\nif None, return string; else, write to file\nNone\n\n\nkeys\nstr / list\nattributes to write to json (choices: ‘pars’ and/or ‘summary’)\nNone\n\n\nverbose\nbool\ndetail to print\nFalse\n\n\nkwargs\ndict\npassed to sc.jsonify()\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA dictionary representation of the parameters and/or summary results\n\n\n\n\n(or write that dictionary to a file)\n\n\n\nExamples:\njson = sim.to_json()\nsim.to_json('results.json')\nsim.to_json('summary.json', keys='summary')\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_sims_match\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\ndemo\nCreate a simple demo simulation for Starsim\n\n\ndiff_sims\nCompute the difference of the summaries of two simulations, and print any\n\n\n\n\n\nsim.check_sims_match(*args, full=False)\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\na list of 2 or more sims to compare\n()\n\n\nfull\nbool\nif True, return whether each sim matches the first\nFalse\n\n\n\nExample:\ns1 = ss.Sim(diseases='sir', networks='random')\ns2 = ss.Sim(pars=dict(diseases='sir', networks='random'))\ns3 = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet())\nassert ss.check_sims_match(s1, s2, s3)\n\n\n\n\nsim.demo(run=True, plot=True, summary=True, show=True, **kwargs)\nCreate a simple demo simulation for Starsim\nDefaults to using the SIR model with a random network, but these can be configured.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrun\nbool\nwhether to run the sim\nTrue\n\n\nplot\nbool\nwhether to plot the results\nTrue\n\n\nsummary\nbool\nwhether to print a summary of the results\nTrue\n\n\nkwargs\ndict\npassed to ss.Sim()\n{}\n\n\n\nExamples:\nss.demo() # Run, plot, and show results\nss.demo(diseases='hiv', networks='mf') # Run with different defaults\n\n\n\n\nsim.diff_sims(\n    sim1,\n    sim2,\n    skip_key_diffs=False,\n    skip=None,\n    full=False,\n    output=False,\n    die=False,\n)\nCompute the difference of the summaries of two simulations, and print any values which differ.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim1\nSim / MultiSim / dict\neither a simulation/MultiSim object or the sim.summary dictionary\nrequired\n\n\nsim2\nim / dict\nditto\nrequired\n\n\nskip_key_diffs\nbool\nwhether to skip keys that don’t match between sims\nFalse\n\n\nskip\nlist\na list of values to skip\nNone\n\n\nfull\nbool\nwhether to print out all values (not just those that differ)\nFalse\n\n\noutput\nbool\nwhether to return the output as a string (otherwise print)\nFalse\n\n\ndie\nbool\nwhether to raise an exception if the sims don’t match\nFalse\n\n\nrequire_run\nbool\nrequire that the simulations have been run\nrequired\n\n\n\nExample:\ns1 = ss.Sim(rand_seed=1).run()\ns2 = ss.Sim(rand_seed=2).run()\nss.diff_sims(s1, s2)",
    "crumbs": [
      "**Basics**",
      "sim"
    ]
  },
  {
    "objectID": "api/sim.html#classes",
    "href": "api/sim.html#classes",
    "title": "sim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAlreadyRunError\nRaised if trying to re-run an already-run sim without re-initializing\n\n\nSim\nThe Sim object\n\n\n\n\n\nsim.AlreadyRunError()\nRaised if trying to re-run an already-run sim without re-initializing\n\n\n\nsim.Sim(\n    self,\n    pars=None,\n    label=None,\n    people=None,\n    demographics=None,\n    diseases=None,\n    networks=None,\n    interventions=None,\n    analyzers=None,\n    connectors=None,\n    copy_inputs=True,\n    data=None,\n    **kwargs,\n)\nThe Sim object\nAll Starsim simulations run via the Sim class. It is responsible for initializing and running all modules and generating results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\nSimPars / dict\neither an ss.SimPars object, or a nested dictionary; can include all other arguments\nNone\n\n\nlabel\nstr\nthe human-readable name of the simulation\nNone\n\n\npeople\nPeople\nif provided, use this ss.People object\nNone\n\n\ndemographics\nstr / Demographics / list\na string naming the demographics module to use, the module itself, or a list\nNone\n\n\ndiseases\nstr / Disease / list\nas above, for diseases\nNone\n\n\nnetworks\nstr / Network / list\nas above, for networks\nNone\n\n\ninterventions\nstr / Intervention / list\nas above, for interventions\nNone\n\n\nanalyzers\nstr / Analyzer / list\nas above, for analyzers\nNone\n\n\nconnectors\nstr / Connector / list\nas above, for connectors\nNone\n\n\ncopy_inputs\nbool\nif True, copy modules as they’re inserted into the sim (allowing reuse in other sims, but meaning they won’t be updated)\nTrue\n\n\ndata\ndf\na dataframe (or dict) of data, with a column “time” plus data of the form “module.result”, e.g. “hiv.new_infections” (used for plotting only)\nNone\n\n\nkwargs\ndict\nmerged with pars; see ss.SimPars for all parameter values\n{}\n\n\n\nExamples:\nsim = ss.Sim(diseases='sir', networks='random') # Simplest Starsim sim; equivalent to ss.demo()\nsim = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet()) # Equivalent using objects instead of strings\nsim = ss.Sim(diseases=['sir', ss.SIS()], networks=['random', 'mf']) # Example using list inputs; can mix and match types\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nmodules\nReturn iterator over all Module instances (stored in standard places) in the Sim\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_results_ready\nCheck that results are ready\n\n\nfinalize\nCompute final results\n\n\nfinish_step\nFinish the simulation timestep\n\n\ninit\nPerform all initializations for the sim\n\n\ninit_data\nInitialize or add data to the sim\n\n\ninit_dists\nInitialize the distributions\n\n\ninit_mod_vals\nInitialize values in other modules, including networks and time parameters\n\n\ninit_mods_pre\nInitialize all the modules with the sim\n\n\ninit_people\nInitialize people within the sim\n\n\ninit_people_vals\nInitialize the People states with actual values\n\n\ninit_results\nCreate initial results that are present in all simulations\n\n\ninit_sim_attrs\nMove initialized modules to the sim\n\n\ninit_time\nTime indexing; derived values live in the sim rather than in the pars\n\n\nplot\nPlot all results in the Sim object\n\n\nprofile\nProfile the performance of the simulation\n\n\nreset_time_pars\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\nrun\nRun the model once\n\n\nrun_one_step\nRun a single sim step; only used for debugging purposes.\n\n\nsave\nSave to disk as a gzipped pickle.\n\n\nshrink\n“Shrinks” the simulation by removing the people and other memory-intensive\n\n\nstart_step\nStart the step – only print progress; all actual changes happen in the modules\n\n\nsummarize\nProvide a quick summary of the sim; returns the last entry for count and\n\n\nto_df\nExport results as a Pandas dataframe\n\n\nto_json\nExport results and parameters as JSON.\n\n\n\n\n\nsim.Sim.check_results_ready(errormsg=None)\nCheck that results are ready\n\n\n\nsim.Sim.finalize()\nCompute final results\n\n\n\nsim.Sim.finish_step()\nFinish the simulation timestep\n\n\n\nsim.Sim.init(force=False, **kwargs)\nPerform all initializations for the sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nforce\nbool\nwhether to overwrite sim attributes even if they already exist\nFalse\n\n\nkwargs\ndict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_data(data=None)\nInitialize or add data to the sim\n\n\n\nsim.Sim.init_dists()\nInitialize the distributions\n\n\n\nsim.Sim.init_mod_vals()\nInitialize values in other modules, including networks and time parameters\n\n\n\nsim.Sim.init_mods_pre()\nInitialize all the modules with the sim\n\n\n\nsim.Sim.init_people(verbose=None, **kwargs)\nInitialize people within the sim Sometimes the people are provided, in which case this just adds a few sim properties to them. Other time people are not provided and this method makes them.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbose\nint\ndetail to print\nNone\n\n\nkwargs\n(dict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_people_vals()\nInitialize the People states with actual values\n\n\n\nsim.Sim.init_results()\nCreate initial results that are present in all simulations\n\n\n\nsim.Sim.init_sim_attrs(force=False)\nMove initialized modules to the sim\n\n\n\nsim.Sim.init_time()\nTime indexing; derived values live in the sim rather than in the pars\n\n\n\nsim.Sim.plot(\n    key=None,\n    fig=None,\n    style='fancy',\n    show_data=True,\n    show_skipped=False,\n    show_module=26,\n    show_label=False,\n    fig_kw=None,\n    plot_kw=None,\n    scatter_kw=None,\n)\nPlot all results in the Sim object\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr / list\nthe results key to plot (by default, all); if a list, plot exactly those keys\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nstyle\nstr\nthe plotting style to use (default “fancy”; other options are “simple”, None, or any Matplotlib style)\n'fancy'\n\n\nshow_data\nbool\nplot the data, if available\nTrue\n\n\nshow_skipped\nbool\nshow even results that are skipped by default\nFalse\n\n\nshow_module\nbool\nwhether to show the module as well as the result name; if an int, show if the label is less than that length; if -1, use a newline\n26\n\n\nshow_label\nstr\nif ‘fig’, reset the fignum; if ‘title’, set the figure suptitle\nFalse\n\n\nfig_kw\ndict\npassed to plt.subplots()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter(), for plotting the data\nNone\n\n\n\n\n\n\n\nsim.Sim.profile(do_run=True, plot=True, **kwargs)\nProfile the performance of the simulation\n\n\n\nsim.Sim.reset_time_pars(force=True)\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\n\nsim.Sim.run(until=None, verbose=None)\nRun the model once\n\n\n\nsim.Sim.run_one_step(verbose=None)\nRun a single sim step; only used for debugging purposes.\nNote: sim.run_one_step() runs a single simulation timestep, which involves multiple function calls. In contrast, loop.run_one_step() runs a single function call.\nNote: the verbose here is only for the Loop object, not the sim.\n\n\n\nsim.Sim.save(filename=None, shrink=None, **kwargs)\nSave to disk as a gzipped pickle.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr or None\nthe name or path of the file to save to; if None, uses stored\nNone\n\n\nshrink\nbool or None\nwhether to shrink the sim prior to saving (reduces size by ~99%)\nNone\n\n\nkwargs\n\npassed to sc.makefilepath()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfilename\nstr\nthe validated absolute path to the saved file\n\n\n\nExample:\nsim.save() # Saves to a .sim file\n\n\n\n\nsim.Sim.shrink(inplace=True, size_limit=1.0)\n“Shrinks” the simulation by removing the people and other memory-intensive attributes (e.g., some interventions and analyzers), and returns a copy of the “shrunken” simulation. Used to reduce the memory required for RAM or for saved files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninplace\nbool\nwhether to perform the shrinking in place (default), or return a shrunken copy instead\nTrue\n\n\nsize_limit\nfloat\nprint a warning if any module is larger than this size limit, in units of KB per timestep (set to None to disable)\n1.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshrunken\nSim\na Sim object with the listed attributes removed\n\n\n\n\n\n\n\nsim.Sim.start_step()\nStart the step – only print progress; all actual changes happen in the modules\n\n\n\nsim.Sim.summarize(how='default')\nProvide a quick summary of the sim; returns the last entry for count and cumulative results, and the mean otherwise.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhow\nstr\nhow to summarize: can be ‘mean’, ‘median’, ‘last’, or a mapping of result keys to those\n'default'\n\n\n\n\n\n\n\nsim.Sim.to_df(sep='_', **kwargs)\nExport results as a Pandas dataframe Args: sep (str): separator for the keys kwargs: passed to results.to_df()\n\n\n\nsim.Sim.to_json(\n    filename=None,\n    keys=None,\n    tostring=False,\n    indent=2,\n    verbose=False,\n    **kwargs,\n)\nExport results and parameters as JSON.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr\nif None, return string; else, write to file\nNone\n\n\nkeys\nstr / list\nattributes to write to json (choices: ‘pars’ and/or ‘summary’)\nNone\n\n\nverbose\nbool\ndetail to print\nFalse\n\n\nkwargs\ndict\npassed to sc.jsonify()\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA dictionary representation of the parameters and/or summary results\n\n\n\n\n(or write that dictionary to a file)\n\n\n\nExamples:\njson = sim.to_json()\nsim.to_json('results.json')\nsim.to_json('summary.json', keys='summary')",
    "crumbs": [
      "**Basics**",
      "sim"
    ]
  },
  {
    "objectID": "api/sim.html#functions",
    "href": "api/sim.html#functions",
    "title": "sim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_sims_match\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\ndemo\nCreate a simple demo simulation for Starsim\n\n\ndiff_sims\nCompute the difference of the summaries of two simulations, and print any\n\n\n\n\n\nsim.check_sims_match(*args, full=False)\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\na list of 2 or more sims to compare\n()\n\n\nfull\nbool\nif True, return whether each sim matches the first\nFalse\n\n\n\nExample:\ns1 = ss.Sim(diseases='sir', networks='random')\ns2 = ss.Sim(pars=dict(diseases='sir', networks='random'))\ns3 = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet())\nassert ss.check_sims_match(s1, s2, s3)\n\n\n\n\nsim.demo(run=True, plot=True, summary=True, show=True, **kwargs)\nCreate a simple demo simulation for Starsim\nDefaults to using the SIR model with a random network, but these can be configured.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrun\nbool\nwhether to run the sim\nTrue\n\n\nplot\nbool\nwhether to plot the results\nTrue\n\n\nsummary\nbool\nwhether to print a summary of the results\nTrue\n\n\nkwargs\ndict\npassed to ss.Sim()\n{}\n\n\n\nExamples:\nss.demo() # Run, plot, and show results\nss.demo(diseases='hiv', networks='mf') # Run with different defaults\n\n\n\n\nsim.diff_sims(\n    sim1,\n    sim2,\n    skip_key_diffs=False,\n    skip=None,\n    full=False,\n    output=False,\n    die=False,\n)\nCompute the difference of the summaries of two simulations, and print any values which differ.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim1\nSim / MultiSim / dict\neither a simulation/MultiSim object or the sim.summary dictionary\nrequired\n\n\nsim2\nim / dict\nditto\nrequired\n\n\nskip_key_diffs\nbool\nwhether to skip keys that don’t match between sims\nFalse\n\n\nskip\nlist\na list of values to skip\nNone\n\n\nfull\nbool\nwhether to print out all values (not just those that differ)\nFalse\n\n\noutput\nbool\nwhether to return the output as a string (otherwise print)\nFalse\n\n\ndie\nbool\nwhether to raise an exception if the sims don’t match\nFalse\n\n\nrequire_run\nbool\nrequire that the simulations have been run\nrequired\n\n\n\nExample:\ns1 = ss.Sim(rand_seed=1).run()\ns2 = ss.Sim(rand_seed=2).run()\nss.diff_sims(s1, s2)",
    "crumbs": [
      "**Basics**",
      "sim"
    ]
  },
  {
    "objectID": "api/loop.html",
    "href": "api/loop.html",
    "title": "loop",
    "section": "",
    "text": "loop\nParent class for the integration loop.\n\n\n\n\n\nName\nDescription\n\n\n\n\nLoop\nBase class for integration loop\n\n\n\n\n\nloop.Loop(self, sim)\nBase class for integration loop\n\n\n\n\n\nName\nDescription\n\n\n\n\ncollect_abs_tvecs\nCollect numerical time arrays for each module\n\n\ncollect_funcs\nCollect all the callable functions (methods) that comprise the step\n\n\ninit\nParse the sim into the integration plan\n\n\nmake_plan\nCombine the module ordering and the time vectors into the integration plan\n\n\nmanual_reset\nReset the loop to run again. Note, does not reset sim quantities so should\n\n\nplot\nPlot a diagram of all the events\n\n\nplot_cpu\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\nrun\nActually run the integration loop; usually called by sim.run()\n\n\nrun_one_step\nTake a single step, i.e. call a single function; only used for debugging purposes.\n\n\nstore_time\nStore the current time in as high resolution as possible\n\n\nto_df\nReturn a user-friendly version of the plan, omitting object columns\n\n\n\n\n\nloop.Loop.collect_abs_tvecs()\nCollect numerical time arrays for each module\n\n\n\nloop.Loop.collect_funcs()\nCollect all the callable functions (methods) that comprise the step\n\n\n\nloop.Loop.init()\nParse the sim into the integration plan\n\n\n\nloop.Loop.make_plan()\nCombine the module ordering and the time vectors into the integration plan\n\n\n\nloop.Loop.manual_reset()\nReset the loop to run again. Note, does not reset sim quantities so should only be used for debugging.\n\n\n\nloop.Loop.plot(simplify=False, fig_kw=None, plot_kw=None, scatter_kw=None)\nPlot a diagram of all the events\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nif True, skip update_results and finish_step events, which are automatically applied\nFalse\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter()\nNone\n\n\n\n\n\n\n\nloop.Loop.plot_cpu(bytime=True, max_entries=10, fig_kw=None, bar_kw=None)\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbytime\nbool\nif True, order events by total time rather than actual order\nTrue\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nbar_kw\ndict\npassed to plt.bar()\nNone\n\n\n\n\n\n\n\nloop.Loop.run(until=None, verbose=None)\nActually run the integration loop; usually called by sim.run()\n\n\n\nloop.Loop.run_one_step()\nTake a single step, i.e. call a single function; only used for debugging purposes.\nCompare sim.run_one_step(), which runs a full timestep (which involves multiple function calls).\n\n\n\nloop.Loop.store_time()\nStore the current time in as high resolution as possible\n\n\n\nloop.Loop.to_df()\nReturn a user-friendly version of the plan, omitting object columns",
    "crumbs": [
      "**Basics**",
      "loop"
    ]
  },
  {
    "objectID": "api/loop.html#classes",
    "href": "api/loop.html#classes",
    "title": "loop",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLoop\nBase class for integration loop\n\n\n\n\n\nloop.Loop(self, sim)\nBase class for integration loop\n\n\n\n\n\nName\nDescription\n\n\n\n\ncollect_abs_tvecs\nCollect numerical time arrays for each module\n\n\ncollect_funcs\nCollect all the callable functions (methods) that comprise the step\n\n\ninit\nParse the sim into the integration plan\n\n\nmake_plan\nCombine the module ordering and the time vectors into the integration plan\n\n\nmanual_reset\nReset the loop to run again. Note, does not reset sim quantities so should\n\n\nplot\nPlot a diagram of all the events\n\n\nplot_cpu\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\nrun\nActually run the integration loop; usually called by sim.run()\n\n\nrun_one_step\nTake a single step, i.e. call a single function; only used for debugging purposes.\n\n\nstore_time\nStore the current time in as high resolution as possible\n\n\nto_df\nReturn a user-friendly version of the plan, omitting object columns\n\n\n\n\n\nloop.Loop.collect_abs_tvecs()\nCollect numerical time arrays for each module\n\n\n\nloop.Loop.collect_funcs()\nCollect all the callable functions (methods) that comprise the step\n\n\n\nloop.Loop.init()\nParse the sim into the integration plan\n\n\n\nloop.Loop.make_plan()\nCombine the module ordering and the time vectors into the integration plan\n\n\n\nloop.Loop.manual_reset()\nReset the loop to run again. Note, does not reset sim quantities so should only be used for debugging.\n\n\n\nloop.Loop.plot(simplify=False, fig_kw=None, plot_kw=None, scatter_kw=None)\nPlot a diagram of all the events\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nif True, skip update_results and finish_step events, which are automatically applied\nFalse\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter()\nNone\n\n\n\n\n\n\n\nloop.Loop.plot_cpu(bytime=True, max_entries=10, fig_kw=None, bar_kw=None)\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbytime\nbool\nif True, order events by total time rather than actual order\nTrue\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nbar_kw\ndict\npassed to plt.bar()\nNone\n\n\n\n\n\n\n\nloop.Loop.run(until=None, verbose=None)\nActually run the integration loop; usually called by sim.run()\n\n\n\nloop.Loop.run_one_step()\nTake a single step, i.e. call a single function; only used for debugging purposes.\nCompare sim.run_one_step(), which runs a full timestep (which involves multiple function calls).\n\n\n\nloop.Loop.store_time()\nStore the current time in as high resolution as possible\n\n\n\nloop.Loop.to_df()\nReturn a user-friendly version of the plan, omitting object columns",
    "crumbs": [
      "**Basics**",
      "loop"
    ]
  },
  {
    "objectID": "api/samples.html",
    "href": "api/samples.html",
    "title": "samples",
    "section": "",
    "text": "samples\nCreate a class for storing a large number of simulations.\nHierarchy - result: parameters, seed, beta - samples: collection of results with same parameters but different seeds - dataset: collection of samples (with different parameters)\n\n\n\n\n\nName\nDescription\n\n\n\n\nSamples\nStores CSV outputs and summary dataframes\n\n\n\n\n\nsamples.Samples(self, fname, memory_buffer=True, preload=False)\nStores CSV outputs and summary dataframes\nTo construct, use Samples.new(). To read an existing one, use Samples(fname). The sample files are just ZIP archives with plain text CSV and TXT files so they can be easily accessed externally as well.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolumns\nAlias summary dataframe columns\n\n\nid\nReturn a dictionary with the identifiers and associated values\n\n\nidentifier\nReturn tuple identifier for this run\n\n\nindex\nAlias summary dataframe index\n\n\nseeds\nReturn array of all seeds\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napply\nApply/map function to every dataframe\n\n\ncopy\nShallow copy - shared cache, copied summary\n\n\nget\nRetrieve dataframe and summary row\n\n\nitems\nIterate over seeds and dataframes\n\n\nnew\n\n\n\npreload\nLoad all dataframes into cache\n\n\n\n\n\nsamples.Samples.apply(fcn, *args, **kwargs)\nApply/map function to every dataframe\nThe function will be applied to every individual dataframe in the collection.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfcn\n\nA function to apply. It should take in a dataframe\nrequired\n\n\nargs\n\nAdditional arguments for fcn\n()\n\n\nkwargs\n\nAdditional arguments for fcn\n{}\n\n\n\nReturns: A list with the output of fcn\n\n\n\n\nsamples.Samples.copy()\nShallow copy - shared cache, copied summary\nThis allows efficient filtering of seeds within runs by removing rows from the copy’s summary, while not reloading or duplicating any of the dataframes in memory\n\n\n\nsamples.Samples.get(seed)\nRetrieve dataframe and summary row\nUse Samples[seed] to read only the dataframe. Use Samples.get(seed) to read both the dataframe and summary row\n\n\n\nsamples.Samples.items()\nIterate over seeds and dataframes\nExample usage\n\n\n\nres = Samples(…) for seed, (row, df) in res: …\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\n- seed\n\n\n\n\n- Samples.get(seed) i.e. a tuple with - the summary dataframe row for the requested seed - the corresponding CSV output for that run\n\n\n\n\n\n\n\nsamples.Samples.new(folder, outputs, identifiers=None, fname=None, verbose=True)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfolder\n\nThe folder name\nrequired\n\n\noutputs\n\nA list of tuples (df:pd.DataFrame, summary_row:dict) where the summary row as an entry ‘seed’ for the seed\nrequired\n\n\nidentifiers\n\nA list of columns to use as identifiers. These should appear in the summary dataframe and should have the same value for all samples. This is useful when generating multiple sets of results e.g., for scenarios (optional)\nNone\n\n\n\n\n\n\n\nsamples.Samples.preload()\nLoad all dataframes into cache\nThis is done based on the seeds in self.seeds, therefore if some of the seeds are removed prior to preloading, then those dataframes will not be loaded",
    "crumbs": [
      "**Utilities**",
      "samples"
    ]
  },
  {
    "objectID": "api/samples.html#classes",
    "href": "api/samples.html#classes",
    "title": "samples",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSamples\nStores CSV outputs and summary dataframes\n\n\n\n\n\nsamples.Samples(self, fname, memory_buffer=True, preload=False)\nStores CSV outputs and summary dataframes\nTo construct, use Samples.new(). To read an existing one, use Samples(fname). The sample files are just ZIP archives with plain text CSV and TXT files so they can be easily accessed externally as well.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolumns\nAlias summary dataframe columns\n\n\nid\nReturn a dictionary with the identifiers and associated values\n\n\nidentifier\nReturn tuple identifier for this run\n\n\nindex\nAlias summary dataframe index\n\n\nseeds\nReturn array of all seeds\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napply\nApply/map function to every dataframe\n\n\ncopy\nShallow copy - shared cache, copied summary\n\n\nget\nRetrieve dataframe and summary row\n\n\nitems\nIterate over seeds and dataframes\n\n\nnew\n\n\n\npreload\nLoad all dataframes into cache\n\n\n\n\n\nsamples.Samples.apply(fcn, *args, **kwargs)\nApply/map function to every dataframe\nThe function will be applied to every individual dataframe in the collection.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfcn\n\nA function to apply. It should take in a dataframe\nrequired\n\n\nargs\n\nAdditional arguments for fcn\n()\n\n\nkwargs\n\nAdditional arguments for fcn\n{}\n\n\n\nReturns: A list with the output of fcn\n\n\n\n\nsamples.Samples.copy()\nShallow copy - shared cache, copied summary\nThis allows efficient filtering of seeds within runs by removing rows from the copy’s summary, while not reloading or duplicating any of the dataframes in memory\n\n\n\nsamples.Samples.get(seed)\nRetrieve dataframe and summary row\nUse Samples[seed] to read only the dataframe. Use Samples.get(seed) to read both the dataframe and summary row\n\n\n\nsamples.Samples.items()\nIterate over seeds and dataframes\nExample usage\n\n\n\nres = Samples(…) for seed, (row, df) in res: …\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\n- seed\n\n\n\n\n- Samples.get(seed) i.e. a tuple with - the summary dataframe row for the requested seed - the corresponding CSV output for that run\n\n\n\n\n\n\n\nsamples.Samples.new(folder, outputs, identifiers=None, fname=None, verbose=True)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfolder\n\nThe folder name\nrequired\n\n\noutputs\n\nA list of tuples (df:pd.DataFrame, summary_row:dict) where the summary row as an entry ‘seed’ for the seed\nrequired\n\n\nidentifiers\n\nA list of columns to use as identifiers. These should appear in the summary dataframe and should have the same value for all samples. This is useful when generating multiple sets of results e.g., for scenarios (optional)\nNone\n\n\n\n\n\n\n\nsamples.Samples.preload()\nLoad all dataframes into cache\nThis is done based on the seeds in self.seeds, therefore if some of the seeds are removed prior to preloading, then those dataframes will not be loaded",
    "crumbs": [
      "**Utilities**",
      "samples"
    ]
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nThese tutorials will guide you through the main features of Starsim. Each tutorial is interactive and includes executable code examples.\n\n\nT1 - Introduction to Starsim\nA quick introduction to the Starsim framework.\n\n\nT2 - Building a simulation\nHow to build your first simulation.\n\n\nT3 - Demographics\nImplementing demographics: births, deaths, and population structure.\n\n\nT4 - Diseases\nHow to implement disease dynamics.\n\n\nT5 - Networks\nHow diseases spread between agents: networks and mixing pools.\n\n\nT6 - Interventions\nIt’s not all doom and gloom: implementing interventions to save lives.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can download these tutorials as Jupyter notebooks to run them locally. Look for the download button at the top of each tutorial.\n\n\n\n\n\n\n\n\nRunning tutorials locally\n\n\n\nTo run these tutorials locally:\n\nClone the Starsim repository\nInstall Starsim and its dependencies\nNavigate to the docs/tutorials directory\nLaunch Jupyter: jupyter notebook"
  }
]