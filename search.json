[
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "Contributing",
    "section": "",
    "text": "Contributing\nWelcome! We are thrilled you are interested in contributing to Starsim. This document will help you get started.\n\nWe are serious about inclusion and believe the open-source software community still has a long way to go. The Starsim community follows a code of conduct. By participating in this project, you agree to abide by its terms.\nTake a look at our house style guide. Starsim more or less follows Google’s Python style guide, but with some exceptions.\nFeel free to open an issue on more or less anything! This project is small enough that we don’t need a formal triage system.\nPull requests should be made against main. In addition to following the style guide, please make sure the tests pass (run_tests in the tests folder; they also run via GitHub actions).\n\nIf you have any other questions, please reach out to us: info@starsim.org. Thank you!",
    "crumbs": [
      "Home",
      "**Contributing**"
    ]
  },
  {
    "objectID": "api/diseases.html",
    "href": "api/diseases.html",
    "title": "diseases",
    "section": "",
    "text": "diseases\nBase classes for diseases\n\n\n\n\n\nName\nDescription\n\n\n\n\nDisease\nBase module class for diseases\n\n\nInfection\nBase class for infectious diseases used in Starsim\n\n\nInfectionLog\nRecord infections\n\n\nNCD\nExample non-communicable disease\n\n\nSIR\nExample SIR model\n\n\nSIS\nExample SIS model\n\n\n\n\n\ndiseases.Disease(pars=None, **kwargs)\nBase module class for diseases\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_pre\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\nset_prognoses\nSet prognoses upon infection/acquisition\n\n\nstep\nHandle the main disease updates, e.g. add new cases\n\n\nstep_die\nCarry out state changes upon death\n\n\nstep_state\nCarry out updates at the start of the timestep (prior to transmission);\n\n\n\n\n\ndiseases.Disease.init_pre(sim)\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\n\ndiseases.Disease.set_prognoses(uids, sources=None)\nSet prognoses upon infection/acquisition\nThis function assigns state values upon infection or acquisition of the disease. It would normally be called somewhere towards the end of Disease.make_new_cases(). Infections will optionally be added to the log as part of this operation if logging is enabled (in the Disease parameters)\nThe sources are relevant for infectious diseases, but would be left as None for NCDs.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nUIDs for agents to assign disease prongoses to\nrequired\n\n\nsources\narray\nOptionally specify the infecting agent\nNone\n\n\n\n\n\n\n\ndiseases.Disease.step()\nHandle the main disease updates, e.g. add new cases\nThis method is agnostic as to the mechanism by which new cases occur. This could be through transmission (parametrized in different ways, which may or may not use the contact networks) or it may be based on risk factors/seeding, as may be the case for non-communicable diseases.\nIt is expected that this method will internally call Disease.set_prognoses() at some point.\n\n\n\ndiseases.Disease.step_die(uids)\nCarry out state changes upon death\nThis function is triggered after deaths are resolved, and before analyzers are run. See the SIR example model for a typical use case - deaths are requested as an autonomous update, to take effect after transmission on the same timestep. State changes that occur upon death (e.g., clearing an infected flag) are executed in this function. That also allows an intervention to avert a death scheduled on the same timestep, without having to undo any state changes that have already been applied (because they only run via this function if the death actually occurs).\nUnlike other methods during the integration loop, this method is not called directly by the sim; instead, it is called by people.step_die(), which reconciles the UIDs of the agents who will die.\nDepending on the module and the results it produces, it may or may not be necessary to implement this.\n\n\n\ndiseases.Disease.step_state()\nCarry out updates at the start of the timestep (prior to transmission); these are typically state changes\n\n\n\n\n\ndiseases.Infection(pars=None, **kwargs)\nBase class for infectious diseases used in Starsim\nThis class contains specializations for infectious transmission (i.e., implements network-based transmission with directional beta values) and defines attributes that connectors operate on to capture co-infection\n\n\n\n\n\nName\nDescription\n\n\n\n\ninfectious\nGenerally defined as an alias for infected, although these may differ in some diseases.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCompute the probability of a-&gt;b transmission for networks (for other routes, the Route handles this)\n\n\ninfect\nDetermine who gets infected on this timestep via transmission on the network\n\n\ninit_post\nSet initial values for states. This could involve passing in a full set of initial conditions,\n\n\ninit_results\nInitialize results\n\n\nstep\nPerform key infection updates, including infection and setting prognoses\n\n\nvalidate_beta\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndiseases.Infection.compute_transmission(\n    src,\n    trg,\n    rel_trans,\n    rel_sus,\n    beta_per_dt,\n    randvals,\n)\nCompute the probability of a-&gt;b transmission for networks (for other routes, the Route handles this)\n\n\n\ndiseases.Infection.infect()\nDetermine who gets infected on this timestep via transmission on the network\n\n\n\ndiseases.Infection.init_post()\nSet initial values for states. This could involve passing in a full set of initial conditions, or using init_prev, or other. Note that this is different to initialization of the Arr objects i.e., creating their dynamic array, linking them to a People instance. That should have already taken place by the time this method is called.\n\n\n\ndiseases.Infection.init_results()\nInitialize results\n\n\n\ndiseases.Infection.step()\nPerform key infection updates, including infection and setting prognoses\n\n\n\ndiseases.Infection.validate_beta()\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndiseases.InfectionLog()\nRecord infections\nThe infection log records transmission events and optionally other data associated with each transmission. Basic functionality is to track transmission with\n\n\n\nDisease.infection_log.append(source, target, t)\n\n\n\nSeed infections can be recorded with a source of None, although all infections should have a target and a time. Other data can be captured in the log, either at the time of creation, or later on. For example\n\n\n\nDisease.infection_log.append(source, target, t, network=‘msm’)\n\n\n\ncould be used by a module to track the network in which transmission took place. Modules can optionally add per-infection outcomes later as well, for example\n\n\n\nDisease.infection_log.add_data(source, t_dead=2024.25)\n\n\n\nThis would be equivalent to having specified the data at the original time the log entry was created - however, it is more useful for tracking events that may or may not occur after the infection and could be modified by interventions (e.g., tracking diagnosis, treatment, notification etc.)\nA table of outcomes can be returned using InfectionLog.line_list()\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_data\nRecord extra infection data\n\n\nto_df\nReturn a tabular representation of the log as a line list dataframe\n\n\n\n\n\ndiseases.InfectionLog.add_data(uids, **kwargs)\nRecord extra infection data\nThis method can be used to add data to an existing transmission event. The most recent transmission event will be used\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nThe UIDs of the target nodes (the agents that were infected)\nrequired\n\n\nkwargs\ndict\nRemaining arguments are stored as edge data\n{}\n\n\n\n\n\n\n\ndiseases.InfectionLog.to_df()\nReturn a tabular representation of the log as a line list dataframe\nThis function returns a dataframe containing columns for all quantities recorded in the log. Note that the log will contain NaN for quantities that are defined for some edges and not others (and which are missing for a particular entry)\n\n\n\n\n\ndiseases.NCD(pars=None, initial_risk=_, dur_risk=_, prognosis=_, **kwargs)\nExample non-communicable disease\nThis class implements a basic NCD model with risk of developing a condition (e.g., hypertension, diabetes), a state for having the condition, and associated mortality.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninitial_risk\nfloat/ss.bernoulli\ninitial prevalence of risk factors\n_\n\n\ndur_risk\nfloat/ss.dur/ss.Dist\nhow long a person is at risk for\n_\n\n\nprognosis\nfloat/ss.dur/ss.Dist\ntime in years between first becoming affected and death\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_post\nSet initial values for states. This could involve passing in a full set of initial conditions,\n\n\ninit_results\nInitialize results\n\n\n\n\n\ndiseases.NCD.init_post()\nSet initial values for states. This could involve passing in a full set of initial conditions, or using init_prev, or other. Note that this is different to initialization of the State objects i.e., creating their dynamic array, linking them to a People instance. That should have already taken place by the time this method is called.\n\n\n\ndiseases.NCD.init_results()\nInitialize results\n\n\n\n\n\ndiseases.SIR(pars=None, beta=_, init_prev=_, dur_inf=_, p_death=_, **kwargs)\nExample SIR model\nThis class implements a basic SIR model with states for susceptible, infected/infectious, and recovered. It also includes deaths, and basic results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbeta\nfloat/ss.prob\nthe infectiousness\n_\n\n\ninit_prev\nfloat/ss.bernoulli\nthe fraction of people to start of being infected\n_\n\n\ndur_inf\nfloat/ss.dur/ss.Dist\nhow long (in years) people are infected for\n_\n\n\np_death\nfloat/ss.bernoulli\nthe probability of death from infection\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nplot\nDefault plot for SIR model\n\n\nset_prognoses\nSet prognoses\n\n\nstep_die\nReset infected/recovered flags for dead agents\n\n\n\n\n\ndiseases.SIR.plot(**kwargs)\nDefault plot for SIR model\n\n\n\ndiseases.SIR.set_prognoses(uids, sources=None)\nSet prognoses\n\n\n\ndiseases.SIR.step_die(uids)\nReset infected/recovered flags for dead agents\n\n\n\n\n\ndiseases.SIS(\n    pars=None,\n    beta=_,\n    init_prev=_,\n    dur_inf=_,\n    waning=_,\n    imm_boost=_,\n    **kwargs,\n)\nExample SIS model\nThis class implements a basic SIS model with states for susceptible, infected/infectious, and back to susceptible based on waning immunity. There is no death in this case.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbeta\nfloat/ss.prob\nthe infectiousness\n_\n\n\ninit_prev\nfloat/ss.bernoulli\nthe fraction of people to start of being infected\n_\n\n\ndur_inf\nfloat/ss.dur/ss.Dist\nhow long (in years) people are infected for\n_\n\n\nwaning\nfloat/ss.rate\nhow quickly immunity wanes\n_\n\n\nimm_boost\nfloat\nhow much an infection boosts immunity\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_results\nInitialize results\n\n\nplot\nDefault plot for SIS model\n\n\nset_prognoses\nSet prognoses\n\n\nstep_state\nProgress infectious -&gt; recovered\n\n\nupdate_results\nStore the population immunity (susceptibility)\n\n\n\n\n\ndiseases.SIS.init_results()\nInitialize results\n\n\n\ndiseases.SIS.plot(**kwargs)\nDefault plot for SIS model\n\n\n\ndiseases.SIS.set_prognoses(uids, sources=None)\nSet prognoses\n\n\n\ndiseases.SIS.step_state()\nProgress infectious -&gt; recovered\n\n\n\ndiseases.SIS.update_results()\nStore the population immunity (susceptibility)",
    "crumbs": [
      "**Modules**",
      "diseases"
    ]
  },
  {
    "objectID": "api/diseases.html#classes",
    "href": "api/diseases.html#classes",
    "title": "diseases",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDisease\nBase module class for diseases\n\n\nInfection\nBase class for infectious diseases used in Starsim\n\n\nInfectionLog\nRecord infections\n\n\nNCD\nExample non-communicable disease\n\n\nSIR\nExample SIR model\n\n\nSIS\nExample SIS model\n\n\n\n\n\ndiseases.Disease(pars=None, **kwargs)\nBase module class for diseases\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_pre\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\nset_prognoses\nSet prognoses upon infection/acquisition\n\n\nstep\nHandle the main disease updates, e.g. add new cases\n\n\nstep_die\nCarry out state changes upon death\n\n\nstep_state\nCarry out updates at the start of the timestep (prior to transmission);\n\n\n\n\n\ndiseases.Disease.init_pre(sim)\nLink the disease to the sim, create objects, and initialize results; see Module.init_pre() for details\n\n\n\ndiseases.Disease.set_prognoses(uids, sources=None)\nSet prognoses upon infection/acquisition\nThis function assigns state values upon infection or acquisition of the disease. It would normally be called somewhere towards the end of Disease.make_new_cases(). Infections will optionally be added to the log as part of this operation if logging is enabled (in the Disease parameters)\nThe sources are relevant for infectious diseases, but would be left as None for NCDs.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nUIDs for agents to assign disease prongoses to\nrequired\n\n\nsources\narray\nOptionally specify the infecting agent\nNone\n\n\n\n\n\n\n\ndiseases.Disease.step()\nHandle the main disease updates, e.g. add new cases\nThis method is agnostic as to the mechanism by which new cases occur. This could be through transmission (parametrized in different ways, which may or may not use the contact networks) or it may be based on risk factors/seeding, as may be the case for non-communicable diseases.\nIt is expected that this method will internally call Disease.set_prognoses() at some point.\n\n\n\ndiseases.Disease.step_die(uids)\nCarry out state changes upon death\nThis function is triggered after deaths are resolved, and before analyzers are run. See the SIR example model for a typical use case - deaths are requested as an autonomous update, to take effect after transmission on the same timestep. State changes that occur upon death (e.g., clearing an infected flag) are executed in this function. That also allows an intervention to avert a death scheduled on the same timestep, without having to undo any state changes that have already been applied (because they only run via this function if the death actually occurs).\nUnlike other methods during the integration loop, this method is not called directly by the sim; instead, it is called by people.step_die(), which reconciles the UIDs of the agents who will die.\nDepending on the module and the results it produces, it may or may not be necessary to implement this.\n\n\n\ndiseases.Disease.step_state()\nCarry out updates at the start of the timestep (prior to transmission); these are typically state changes\n\n\n\n\n\ndiseases.Infection(pars=None, **kwargs)\nBase class for infectious diseases used in Starsim\nThis class contains specializations for infectious transmission (i.e., implements network-based transmission with directional beta values) and defines attributes that connectors operate on to capture co-infection\n\n\n\n\n\nName\nDescription\n\n\n\n\ninfectious\nGenerally defined as an alias for infected, although these may differ in some diseases.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCompute the probability of a-&gt;b transmission for networks (for other routes, the Route handles this)\n\n\ninfect\nDetermine who gets infected on this timestep via transmission on the network\n\n\ninit_post\nSet initial values for states. This could involve passing in a full set of initial conditions,\n\n\ninit_results\nInitialize results\n\n\nstep\nPerform key infection updates, including infection and setting prognoses\n\n\nvalidate_beta\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndiseases.Infection.compute_transmission(\n    src,\n    trg,\n    rel_trans,\n    rel_sus,\n    beta_per_dt,\n    randvals,\n)\nCompute the probability of a-&gt;b transmission for networks (for other routes, the Route handles this)\n\n\n\ndiseases.Infection.infect()\nDetermine who gets infected on this timestep via transmission on the network\n\n\n\ndiseases.Infection.init_post()\nSet initial values for states. This could involve passing in a full set of initial conditions, or using init_prev, or other. Note that this is different to initialization of the Arr objects i.e., creating their dynamic array, linking them to a People instance. That should have already taken place by the time this method is called.\n\n\n\ndiseases.Infection.init_results()\nInitialize results\n\n\n\ndiseases.Infection.step()\nPerform key infection updates, including infection and setting prognoses\n\n\n\ndiseases.Infection.validate_beta()\nValidate beta and return as a map to match the networks\n\n\n\n\n\ndiseases.InfectionLog()\nRecord infections\nThe infection log records transmission events and optionally other data associated with each transmission. Basic functionality is to track transmission with\n\n\n\nDisease.infection_log.append(source, target, t)\n\n\n\nSeed infections can be recorded with a source of None, although all infections should have a target and a time. Other data can be captured in the log, either at the time of creation, or later on. For example\n\n\n\nDisease.infection_log.append(source, target, t, network=‘msm’)\n\n\n\ncould be used by a module to track the network in which transmission took place. Modules can optionally add per-infection outcomes later as well, for example\n\n\n\nDisease.infection_log.add_data(source, t_dead=2024.25)\n\n\n\nThis would be equivalent to having specified the data at the original time the log entry was created - however, it is more useful for tracking events that may or may not occur after the infection and could be modified by interventions (e.g., tracking diagnosis, treatment, notification etc.)\nA table of outcomes can be returned using InfectionLog.line_list()\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_data\nRecord extra infection data\n\n\nto_df\nReturn a tabular representation of the log as a line list dataframe\n\n\n\n\n\ndiseases.InfectionLog.add_data(uids, **kwargs)\nRecord extra infection data\nThis method can be used to add data to an existing transmission event. The most recent transmission event will be used\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\narray\nThe UIDs of the target nodes (the agents that were infected)\nrequired\n\n\nkwargs\ndict\nRemaining arguments are stored as edge data\n{}\n\n\n\n\n\n\n\ndiseases.InfectionLog.to_df()\nReturn a tabular representation of the log as a line list dataframe\nThis function returns a dataframe containing columns for all quantities recorded in the log. Note that the log will contain NaN for quantities that are defined for some edges and not others (and which are missing for a particular entry)\n\n\n\n\n\ndiseases.NCD(pars=None, initial_risk=_, dur_risk=_, prognosis=_, **kwargs)\nExample non-communicable disease\nThis class implements a basic NCD model with risk of developing a condition (e.g., hypertension, diabetes), a state for having the condition, and associated mortality.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninitial_risk\nfloat/ss.bernoulli\ninitial prevalence of risk factors\n_\n\n\ndur_risk\nfloat/ss.dur/ss.Dist\nhow long a person is at risk for\n_\n\n\nprognosis\nfloat/ss.dur/ss.Dist\ntime in years between first becoming affected and death\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_post\nSet initial values for states. This could involve passing in a full set of initial conditions,\n\n\ninit_results\nInitialize results\n\n\n\n\n\ndiseases.NCD.init_post()\nSet initial values for states. This could involve passing in a full set of initial conditions, or using init_prev, or other. Note that this is different to initialization of the State objects i.e., creating their dynamic array, linking them to a People instance. That should have already taken place by the time this method is called.\n\n\n\ndiseases.NCD.init_results()\nInitialize results\n\n\n\n\n\ndiseases.SIR(pars=None, beta=_, init_prev=_, dur_inf=_, p_death=_, **kwargs)\nExample SIR model\nThis class implements a basic SIR model with states for susceptible, infected/infectious, and recovered. It also includes deaths, and basic results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbeta\nfloat/ss.prob\nthe infectiousness\n_\n\n\ninit_prev\nfloat/ss.bernoulli\nthe fraction of people to start of being infected\n_\n\n\ndur_inf\nfloat/ss.dur/ss.Dist\nhow long (in years) people are infected for\n_\n\n\np_death\nfloat/ss.bernoulli\nthe probability of death from infection\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nplot\nDefault plot for SIR model\n\n\nset_prognoses\nSet prognoses\n\n\nstep_die\nReset infected/recovered flags for dead agents\n\n\n\n\n\ndiseases.SIR.plot(**kwargs)\nDefault plot for SIR model\n\n\n\ndiseases.SIR.set_prognoses(uids, sources=None)\nSet prognoses\n\n\n\ndiseases.SIR.step_die(uids)\nReset infected/recovered flags for dead agents\n\n\n\n\n\ndiseases.SIS(\n    pars=None,\n    beta=_,\n    init_prev=_,\n    dur_inf=_,\n    waning=_,\n    imm_boost=_,\n    **kwargs,\n)\nExample SIS model\nThis class implements a basic SIS model with states for susceptible, infected/infectious, and back to susceptible based on waning immunity. There is no death in this case.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbeta\nfloat/ss.prob\nthe infectiousness\n_\n\n\ninit_prev\nfloat/ss.bernoulli\nthe fraction of people to start of being infected\n_\n\n\ndur_inf\nfloat/ss.dur/ss.Dist\nhow long (in years) people are infected for\n_\n\n\nwaning\nfloat/ss.rate\nhow quickly immunity wanes\n_\n\n\nimm_boost\nfloat\nhow much an infection boosts immunity\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_results\nInitialize results\n\n\nplot\nDefault plot for SIS model\n\n\nset_prognoses\nSet prognoses\n\n\nstep_state\nProgress infectious -&gt; recovered\n\n\nupdate_results\nStore the population immunity (susceptibility)\n\n\n\n\n\ndiseases.SIS.init_results()\nInitialize results\n\n\n\ndiseases.SIS.plot(**kwargs)\nDefault plot for SIS model\n\n\n\ndiseases.SIS.set_prognoses(uids, sources=None)\nSet prognoses\n\n\n\ndiseases.SIS.step_state()\nProgress infectious -&gt; recovered\n\n\n\ndiseases.SIS.update_results()\nStore the population immunity (susceptibility)",
    "crumbs": [
      "**Modules**",
      "diseases"
    ]
  },
  {
    "objectID": "api/samples.html",
    "href": "api/samples.html",
    "title": "samples",
    "section": "",
    "text": "samples\nCreate a class for storing a large number of simulations.\nHierarchy - result: parameters, seed, beta - samples: collection of results with same parameters but different seeds - dataset: collection of samples (with different parameters)\n\n\n\n\n\nName\nDescription\n\n\n\n\nSamples\nStores CSV outputs and summary dataframes\n\n\n\n\n\nsamples.Samples(fname, memory_buffer=True, preload=False)\nStores CSV outputs and summary dataframes\nTo construct, use Samples.new(). To read an existing one, use Samples(fname). The sample files are just ZIP archives with plain text CSV and TXT files so they can be easily accessed externally as well.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolumns\nAlias summary dataframe columns\n\n\nid\nReturn a dictionary with the identifiers and associated values\n\n\nidentifier\nReturn tuple identifier for this run\n\n\nindex\nAlias summary dataframe index\n\n\nseeds\nReturn array of all seeds\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napply\nApply/map function to every dataframe\n\n\ncopy\nShallow copy - shared cache, copied summary\n\n\nget\nRetrieve dataframe and summary row\n\n\nitems\nIterate over seeds and dataframes\n\n\nnew\n\n\n\npreload\nLoad all dataframes into cache\n\n\n\n\n\nsamples.Samples.apply(fcn, *args, **kwargs)\nApply/map function to every dataframe\nThe function will be applied to every individual dataframe in the collection.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfcn\n\nA function to apply. It should take in a dataframe\nrequired\n\n\nargs\n\nAdditional arguments for fcn\n()\n\n\nkwargs\n\nAdditional arguments for fcn\n{}\n\n\n\nReturns: A list with the output of fcn\n\n\n\n\nsamples.Samples.copy()\nShallow copy - shared cache, copied summary\nThis allows efficient filtering of seeds within runs by removing rows from the copy’s summary, while not reloading or duplicating any of the dataframes in memory\n\n\n\nsamples.Samples.get(seed)\nRetrieve dataframe and summary row\nUse Samples[seed] to read only the dataframe. Use Samples.get(seed) to read both the dataframe and summary row\n\n\n\nsamples.Samples.items()\nIterate over seeds and dataframes\nExample usage\n\n\n\nres = Samples(…) for seed, (row, df) in res: …\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\n- seed\n\n\n\n\n- Samples.get(seed) i.e. a tuple with - the summary dataframe row for the requested seed - the corresponding CSV output for that run\n\n\n\n\n\n\n\nsamples.Samples.new(folder, outputs, identifiers=None, fname=None, verbose=True)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfolder\n\nThe folder name\nrequired\n\n\noutputs\n\nA list of tuples (df:pd.DataFrame, summary_row:dict) where the summary row as an entry ‘seed’ for the seed\nrequired\n\n\nidentifiers\n\nA list of columns to use as identifiers. These should appear in the summary dataframe and should have the same value for all samples. This is useful when generating multiple sets of results e.g., for scenarios (optional)\nNone\n\n\n\n\n\n\n\nsamples.Samples.preload()\nLoad all dataframes into cache\nThis is done based on the seeds in self.seeds, therefore if some of the seeds are removed prior to preloading, then those dataframes will not be loaded",
    "crumbs": [
      "**Utilities**",
      "samples"
    ]
  },
  {
    "objectID": "api/samples.html#classes",
    "href": "api/samples.html#classes",
    "title": "samples",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSamples\nStores CSV outputs and summary dataframes\n\n\n\n\n\nsamples.Samples(fname, memory_buffer=True, preload=False)\nStores CSV outputs and summary dataframes\nTo construct, use Samples.new(). To read an existing one, use Samples(fname). The sample files are just ZIP archives with plain text CSV and TXT files so they can be easily accessed externally as well.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolumns\nAlias summary dataframe columns\n\n\nid\nReturn a dictionary with the identifiers and associated values\n\n\nidentifier\nReturn tuple identifier for this run\n\n\nindex\nAlias summary dataframe index\n\n\nseeds\nReturn array of all seeds\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napply\nApply/map function to every dataframe\n\n\ncopy\nShallow copy - shared cache, copied summary\n\n\nget\nRetrieve dataframe and summary row\n\n\nitems\nIterate over seeds and dataframes\n\n\nnew\n\n\n\npreload\nLoad all dataframes into cache\n\n\n\n\n\nsamples.Samples.apply(fcn, *args, **kwargs)\nApply/map function to every dataframe\nThe function will be applied to every individual dataframe in the collection.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfcn\n\nA function to apply. It should take in a dataframe\nrequired\n\n\nargs\n\nAdditional arguments for fcn\n()\n\n\nkwargs\n\nAdditional arguments for fcn\n{}\n\n\n\nReturns: A list with the output of fcn\n\n\n\n\nsamples.Samples.copy()\nShallow copy - shared cache, copied summary\nThis allows efficient filtering of seeds within runs by removing rows from the copy’s summary, while not reloading or duplicating any of the dataframes in memory\n\n\n\nsamples.Samples.get(seed)\nRetrieve dataframe and summary row\nUse Samples[seed] to read only the dataframe. Use Samples.get(seed) to read both the dataframe and summary row\n\n\n\nsamples.Samples.items()\nIterate over seeds and dataframes\nExample usage\n\n\n\nres = Samples(…) for seed, (row, df) in res: …\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\n- seed\n\n\n\n\n- Samples.get(seed) i.e. a tuple with - the summary dataframe row for the requested seed - the corresponding CSV output for that run\n\n\n\n\n\n\n\nsamples.Samples.new(folder, outputs, identifiers=None, fname=None, verbose=True)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfolder\n\nThe folder name\nrequired\n\n\noutputs\n\nA list of tuples (df:pd.DataFrame, summary_row:dict) where the summary row as an entry ‘seed’ for the seed\nrequired\n\n\nidentifiers\n\nA list of columns to use as identifiers. These should appear in the summary dataframe and should have the same value for all samples. This is useful when generating multiple sets of results e.g., for scenarios (optional)\nNone\n\n\n\n\n\n\n\nsamples.Samples.preload()\nLoad all dataframes into cache\nThis is done based on the seeds in self.seeds, therefore if some of the seeds are removed prior to preloading, then those dataframes will not be loaded",
    "crumbs": [
      "**Utilities**",
      "samples"
    ]
  },
  {
    "objectID": "api/loop.html",
    "href": "api/loop.html",
    "title": "loop",
    "section": "",
    "text": "loop\nParent class for the integration loop.\n\n\n\n\n\nName\nDescription\n\n\n\n\nLoop\nDefine the integration loop\n\n\n\n\n\nloop.Loop(sim)\nDefine the integration loop\nThe Loop handles the order in which each function is called in the sim. The order is defined in Loop.collect_funcs(), which searches through the sim and collects all methods to call, in order, in the integration loop.\nEach type of module is called at a different time. Within each module type, they are called in the order listed. The default loop order is:\n1. sim:               start_step()     # Initialize the sim, including plotting progress\n2. all modules:       start_step()     # Initialize the modules, including the random number distribution\n3. sim.modules:       step()           # Run any custom modules\n4. sim.demographics:  step()           # Update the demographics, including adding new agents\n5. sim.diseases:      step_state()     # Update the disease states, e.g. exposed -&gt; infected\n6. sim.connectors:    step()           # Run the connectors\n7. sim.networks:      step()           # Run the networks, including adding/removing edges\n8. sim.interventions: step()           # Run the interventions\n9. sim.diseases:      step()           # Run the diseases, including transmission\n10. people:           step_die()       # Figure out who died on this timestep\n11. people:           update_results() # Update basic state results\n12. all modules:      update_results() # Update any results\n13. sim.analyzers:    step()           # Run the analyzers\n14. all modules:      finish_step()    # Do any final tidying\n15. people:           finish_step()    # Clean up dead agents\n16. sim:              finish_step()    # Increment the timestep\n\n\n\n\n\nName\nDescription\n\n\n\n\ncollect_abs_tvecs\nCollect numerical time arrays for each module\n\n\ncollect_funcs\nCollect all the callable functions (methods) that comprise the step\n\n\ninit\nParse the sim into the integration plan\n\n\ninsert\nInsert a function into the loop plan at the specified location.\n\n\nmake_plan\nCombine the module ordering and the time vectors into the integration plan\n\n\nplot\nPlot a diagram of all the events\n\n\nplot_cpu\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\nplot_step_order\nPlot the order of the module steps across timesteps – useful for debugging\n\n\nrun\nActually run the integration loop; usually called by sim.run()\n\n\nrun_one_step\nTake a single step, i.e. call a single function; only used for debugging purposes.\n\n\nshrink\nShrink the size of the loop for saving to disk\n\n\nstore_time\nStore the current time in as high resolution as possible\n\n\nto_df\nReturn a user-friendly version of the plan, omitting object columns\n\n\n\n\n\nloop.Loop.collect_abs_tvecs()\nCollect numerical time arrays for each module\n\n\n\nloop.Loop.collect_funcs()\nCollect all the callable functions (methods) that comprise the step\n\n\n\nloop.Loop.init()\nParse the sim into the integration plan\n\n\n\nloop.Loop.insert(\n    func,\n    label=None,\n    match_fn=None,\n    before=False,\n    verbose=True,\n    die=True,\n)\nInsert a function into the loop plan at the specified location.\nThe loop plan is a dataframe with columns including time (e.g. date('2025-05-05')), label (e.g. 'randomnet.step'), module (’randomnet'), and function name ('step'). By default, this method will match the conditions in the plan based on the criteria specified.\nThis functionality is similar to an analyzer or an intervention, but gives additional flexibility since can be inserted at (almost) any point in a sim.\nNote: the loop must be initialized (sim.init()) before you can call this.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfunc\nfunc\nthe function to insert; must take a single argument, sim\nrequired\n\n\nlabel\nstr\nthe label (module.name) of the function to match; see sim.loop.plan.label.unique() for choices\nNone\n\n\nmatch_fn\nfunc\nif supplied, use this function to perform the matching on the plan dataframe, returning a boolean array or list of indices of matching rows (see example below)\nNone\n\n\nbefore\nbool\nif true, insert the function before rather than after the match\nFalse\n\n\ndie\nbool\nwhether to raise an exception if no matches found\nTrue\n\n\n\nExamples:\n# Simple label matching with analyzer-like functionality\ndef check_pop_size(sim):\n    print(f'Population size is {len(sim.people)}')\n\nsim = ss.Sim(diseases='sir', networks='random', demographics=True)\nsim.init()\nsim.loop.insert(check_pop_size, label='people.finish_step')\nsim.run()\n\n# Function-based matching with intervention-like functionality\ndef match_fn(plan):\n    past_2010 = plan.time &gt; ss.date(2010)\n    is_step = (plan.label == 'sir.step') | (plan.label == 'randomnet.step')\n    return past_2010 * is_step\n\ndef update_betas(sim):\n    if not sim.metadata.get('updated'):\n        print(f'Updating beta values on {sim.now}')\n        sim.diseases.sis.beta = 0.1\n        sim.networks.randomnet.edges.beta[:] = 0.5\n        sim.metadata.updated = True\n    return\n\nsim = ss.Sim(diseases='sis', networks='random')\nsim.init()\nsim.loop.insert(update_betas, match_fn=match_fn, before=True)\nsim.run()\n\n\n\n\nloop.Loop.make_plan()\nCombine the module ordering and the time vectors into the integration plan\n\n\n\nloop.Loop.plot(\n    simplify=False,\n    max_len=100,\n    fig_kw=None,\n    plot_kw=None,\n    scatter_kw=None,\n)\nPlot a diagram of all the events\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nif True, skip update_results and finish_step events, which are automatically applied\nFalse\n\n\nmax_len\nint\nmaximum number of entries to plot\n100\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter()\nNone\n\n\n\n\n\n\n\nloop.Loop.plot_cpu(bytime=True, max_entries=10, fig_kw=None, bar_kw=None)\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbytime\nbool\nif True, order events by total time rather than actual order\nTrue\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nbar_kw\ndict\npassed to plt.bar()\nNone\n\n\n\n\n\n\n\nloop.Loop.plot_step_order(\n    which='default',\n    max_len=500,\n    plot_kw=None,\n    scatter_kw=None,\n    fig_kw=None,\n    legend_kw=None,\n)\nPlot the order of the module steps across timesteps – useful for debugging when using different time units.\nNote: generates a lot of data, best to debug with a small number of timesteps first!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhich\ndict\ncolumns and values to filter to (default: {‘func_name’:‘step’}; if None, do not filter)\n'default'\n\n\nmax_len\nint\nmaximum number of entries to plot\n500\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter()\nNone\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nlegend_kw\ndict\npassed to plt.legend()\nNone\n\n\n\nExample:\nsis = ss.SIS(dt=0.1)\nnet = ss.RandomNet(dt=0.5)\nbirths = ss.Births(dt=1)\nsim = ss.Sim(dt=0.1, dur=5, diseases=sis, networks=net, demographics=births)\nsim.init()\nsim.loop.plot_step_order()\n\n\n\n\nloop.Loop.run(until=None, verbose=None)\nActually run the integration loop; usually called by sim.run()\n\n\n\nloop.Loop.run_one_step()\nTake a single step, i.e. call a single function; only used for debugging purposes.\nCompare sim.run_one_step(), which runs a full timestep (which involves multiple function calls).\n\n\n\nloop.Loop.shrink()\nShrink the size of the loop for saving to disk\n\n\n\nloop.Loop.store_time()\nStore the current time in as high resolution as possible\n\n\n\nloop.Loop.to_df()\nReturn a user-friendly version of the plan, omitting object columns",
    "crumbs": [
      "**Basics**",
      "loop"
    ]
  },
  {
    "objectID": "api/loop.html#classes",
    "href": "api/loop.html#classes",
    "title": "loop",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLoop\nDefine the integration loop\n\n\n\n\n\nloop.Loop(sim)\nDefine the integration loop\nThe Loop handles the order in which each function is called in the sim. The order is defined in Loop.collect_funcs(), which searches through the sim and collects all methods to call, in order, in the integration loop.\nEach type of module is called at a different time. Within each module type, they are called in the order listed. The default loop order is:\n1. sim:               start_step()     # Initialize the sim, including plotting progress\n2. all modules:       start_step()     # Initialize the modules, including the random number distribution\n3. sim.modules:       step()           # Run any custom modules\n4. sim.demographics:  step()           # Update the demographics, including adding new agents\n5. sim.diseases:      step_state()     # Update the disease states, e.g. exposed -&gt; infected\n6. sim.connectors:    step()           # Run the connectors\n7. sim.networks:      step()           # Run the networks, including adding/removing edges\n8. sim.interventions: step()           # Run the interventions\n9. sim.diseases:      step()           # Run the diseases, including transmission\n10. people:           step_die()       # Figure out who died on this timestep\n11. people:           update_results() # Update basic state results\n12. all modules:      update_results() # Update any results\n13. sim.analyzers:    step()           # Run the analyzers\n14. all modules:      finish_step()    # Do any final tidying\n15. people:           finish_step()    # Clean up dead agents\n16. sim:              finish_step()    # Increment the timestep\n\n\n\n\n\nName\nDescription\n\n\n\n\ncollect_abs_tvecs\nCollect numerical time arrays for each module\n\n\ncollect_funcs\nCollect all the callable functions (methods) that comprise the step\n\n\ninit\nParse the sim into the integration plan\n\n\ninsert\nInsert a function into the loop plan at the specified location.\n\n\nmake_plan\nCombine the module ordering and the time vectors into the integration plan\n\n\nplot\nPlot a diagram of all the events\n\n\nplot_cpu\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\nplot_step_order\nPlot the order of the module steps across timesteps – useful for debugging\n\n\nrun\nActually run the integration loop; usually called by sim.run()\n\n\nrun_one_step\nTake a single step, i.e. call a single function; only used for debugging purposes.\n\n\nshrink\nShrink the size of the loop for saving to disk\n\n\nstore_time\nStore the current time in as high resolution as possible\n\n\nto_df\nReturn a user-friendly version of the plan, omitting object columns\n\n\n\n\n\nloop.Loop.collect_abs_tvecs()\nCollect numerical time arrays for each module\n\n\n\nloop.Loop.collect_funcs()\nCollect all the callable functions (methods) that comprise the step\n\n\n\nloop.Loop.init()\nParse the sim into the integration plan\n\n\n\nloop.Loop.insert(\n    func,\n    label=None,\n    match_fn=None,\n    before=False,\n    verbose=True,\n    die=True,\n)\nInsert a function into the loop plan at the specified location.\nThe loop plan is a dataframe with columns including time (e.g. date('2025-05-05')), label (e.g. 'randomnet.step'), module (’randomnet'), and function name ('step'). By default, this method will match the conditions in the plan based on the criteria specified.\nThis functionality is similar to an analyzer or an intervention, but gives additional flexibility since can be inserted at (almost) any point in a sim.\nNote: the loop must be initialized (sim.init()) before you can call this.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfunc\nfunc\nthe function to insert; must take a single argument, sim\nrequired\n\n\nlabel\nstr\nthe label (module.name) of the function to match; see sim.loop.plan.label.unique() for choices\nNone\n\n\nmatch_fn\nfunc\nif supplied, use this function to perform the matching on the plan dataframe, returning a boolean array or list of indices of matching rows (see example below)\nNone\n\n\nbefore\nbool\nif true, insert the function before rather than after the match\nFalse\n\n\ndie\nbool\nwhether to raise an exception if no matches found\nTrue\n\n\n\nExamples:\n# Simple label matching with analyzer-like functionality\ndef check_pop_size(sim):\n    print(f'Population size is {len(sim.people)}')\n\nsim = ss.Sim(diseases='sir', networks='random', demographics=True)\nsim.init()\nsim.loop.insert(check_pop_size, label='people.finish_step')\nsim.run()\n\n# Function-based matching with intervention-like functionality\ndef match_fn(plan):\n    past_2010 = plan.time &gt; ss.date(2010)\n    is_step = (plan.label == 'sir.step') | (plan.label == 'randomnet.step')\n    return past_2010 * is_step\n\ndef update_betas(sim):\n    if not sim.metadata.get('updated'):\n        print(f'Updating beta values on {sim.now}')\n        sim.diseases.sis.beta = 0.1\n        sim.networks.randomnet.edges.beta[:] = 0.5\n        sim.metadata.updated = True\n    return\n\nsim = ss.Sim(diseases='sis', networks='random')\nsim.init()\nsim.loop.insert(update_betas, match_fn=match_fn, before=True)\nsim.run()\n\n\n\n\nloop.Loop.make_plan()\nCombine the module ordering and the time vectors into the integration plan\n\n\n\nloop.Loop.plot(\n    simplify=False,\n    max_len=100,\n    fig_kw=None,\n    plot_kw=None,\n    scatter_kw=None,\n)\nPlot a diagram of all the events\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nif True, skip update_results and finish_step events, which are automatically applied\nFalse\n\n\nmax_len\nint\nmaximum number of entries to plot\n100\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter()\nNone\n\n\n\n\n\n\n\nloop.Loop.plot_cpu(bytime=True, max_entries=10, fig_kw=None, bar_kw=None)\nPlot the CPU time spent on each event; visualization of Loop.cpu_df.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbytime\nbool\nif True, order events by total time rather than actual order\nTrue\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nbar_kw\ndict\npassed to plt.bar()\nNone\n\n\n\n\n\n\n\nloop.Loop.plot_step_order(\n    which='default',\n    max_len=500,\n    plot_kw=None,\n    scatter_kw=None,\n    fig_kw=None,\n    legend_kw=None,\n)\nPlot the order of the module steps across timesteps – useful for debugging when using different time units.\nNote: generates a lot of data, best to debug with a small number of timesteps first!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhich\ndict\ncolumns and values to filter to (default: {‘func_name’:‘step’}; if None, do not filter)\n'default'\n\n\nmax_len\nint\nmaximum number of entries to plot\n500\n\n\nplot_kw\ndict\npassed to plt.plot()\nNone\n\n\nscatter_kw\ndict\npassed to plt.scatter()\nNone\n\n\nfig_kw\ndict\npassed to plt.figure()\nNone\n\n\nlegend_kw\ndict\npassed to plt.legend()\nNone\n\n\n\nExample:\nsis = ss.SIS(dt=0.1)\nnet = ss.RandomNet(dt=0.5)\nbirths = ss.Births(dt=1)\nsim = ss.Sim(dt=0.1, dur=5, diseases=sis, networks=net, demographics=births)\nsim.init()\nsim.loop.plot_step_order()\n\n\n\n\nloop.Loop.run(until=None, verbose=None)\nActually run the integration loop; usually called by sim.run()\n\n\n\nloop.Loop.run_one_step()\nTake a single step, i.e. call a single function; only used for debugging purposes.\nCompare sim.run_one_step(), which runs a full timestep (which involves multiple function calls).\n\n\n\nloop.Loop.shrink()\nShrink the size of the loop for saving to disk\n\n\n\nloop.Loop.store_time()\nStore the current time in as high resolution as possible\n\n\n\nloop.Loop.to_df()\nReturn a user-friendly version of the plan, omitting object columns",
    "crumbs": [
      "**Basics**",
      "loop"
    ]
  },
  {
    "objectID": "api/sim.html",
    "href": "api/sim.html",
    "title": "sim",
    "section": "",
    "text": "sim\nDefine core Sim classes\n\n\n\n\n\nName\nDescription\n\n\n\n\nAlreadyRunError\nRaised if trying to re-run an already-run sim without re-initializing\n\n\nSim\nThe Sim object\n\n\n\n\n\nsim.AlreadyRunError()\nRaised if trying to re-run an already-run sim without re-initializing\n\n\n\nsim.Sim(\n    pars=None,\n    label=None,\n    people=None,\n    modules=None,\n    demographics=None,\n    diseases=None,\n    networks=None,\n    interventions=None,\n    analyzers=None,\n    connectors=None,\n    copy_inputs=True,\n    data=None,\n    **kwargs,\n)\nThe Sim object\nAll Starsim simulations run via the Sim class. It is responsible for initializing and running all modules and generating results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\nSimPars / dict\neither an ss.SimPars object, or a nested dictionary; can include all other arguments\nNone\n\n\nlabel\nstr\nthe human-readable name of the simulation\nNone\n\n\npeople\nPeople\nif provided, use this ss.People object\nNone\n\n\nmodules\nModule / list\nif provided, use these modules (and divide among demographics, diseases, etc. based on type)\nNone\n\n\ndemographics\nstr / Demographics / list\na string naming the demographics module to use, the module itself, or a list\nNone\n\n\nconnectors\nstr / Connector / list\nas above, for connectors\nNone\n\n\nnetworks\nstr / Network / list\nas above, for networks\nNone\n\n\ninterventions\nstr / Intervention / list\nas above, for interventions\nNone\n\n\ndiseases\nstr / Disease / list\nas above, for diseases\nNone\n\n\nanalyzers\nstr / Analyzer / list\nas above, for analyzers\nNone\n\n\ncopy_inputs\nbool\nif True, copy modules as they’re inserted into the sim (allowing reuse in other sims, but meaning they won’t be updated)\nTrue\n\n\ndata\ndf\na dataframe (or dict) of data, with a column “time” plus data of the form “module.result”, e.g. “hiv.new_infections” (used for plotting only)\nNone\n\n\nkwargs\ndict\nmerged with pars; see ss.SimPars for all parameter values\n{}\n\n\n\nExamples:\nsim = ss.Sim(diseases='sir', networks='random') # Simplest Starsim sim; equivalent to ss.demo()\nsim = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet()) # Equivalent using objects instead of strings\nsim = ss.Sim(diseases=['sir', ss.SIS()], networks=['random', 'mf']) # Example using list inputs; can mix and match types\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nlabel\nGet the sim label from the parameters, if available.\n\n\nmodule_dict\nReturn a dictionary of all Module instances; see sim.module_list for the list version\n\n\nmodule_list\nReturn a list of all Module instances (stored in standard places) in the Sim; see sim.module_dict for the dict version\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_method_calls\nCheck if any required methods were not called.\n\n\ncheck_results_ready\nCheck that results are ready\n\n\ncprofile\nProfile the performance of the simulation using a function profiler (sc.cprofile())\n\n\nfinalize\nCompute final results\n\n\nfinalize_results\nScale the results and remove any “unused” results\n\n\nfinish_step\nFinish the simulation timestep\n\n\ninit\nPerform all initializations for the sim\n\n\ninit_data\nInitialize or add data to the sim\n\n\ninit_dists\nInitialize the distributions\n\n\ninit_module_attrs\nMove initialized modules to the sim\n\n\ninit_modules_post\nInitialize values in other modules, including networks and time parameters, and do any other post-processing\n\n\ninit_modules_pre\nInitialize all the modules with the sim\n\n\ninit_people\nInitialize people within the sim\n\n\ninit_people_vals\nInitialize the People states with actual values\n\n\ninit_results\nCreate initial results that are present in all simulations\n\n\ninit_time\nTime indexing; derived values live in the sim rather than in the pars\n\n\nplot\nPlot all results in the Sim object\n\n\nproducts\nList all products across interventions; not an ndict like the other module types\n\n\nprofile\nProfile the performance of the simulation using a line profiler (sc.profile())\n\n\nreset_time_pars\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\nrun\nRun the model – the main method for running a simulation.\n\n\nrun_one_step\nRun a single sim step; only used for debugging purposes.\n\n\nsave\nSave to disk as a gzipped pickle.\n\n\nshrink\n“Shrinks” the simulation by removing the people and other memory-intensive\n\n\nstart_step\nStart the step – only print progress; all actual changes happen in the modules\n\n\nsummarize\nProvide a quick summary of the sim; returns the last entry for count and\n\n\nto_df\nExport results as a Pandas dataframe\n\n\nto_json\nExport results and parameters as JSON.\n\n\nto_yaml\nExport results and parameters as YAML.\n\n\n\n\n\nsim.Sim.check_method_calls(die=None, warn=None, verbose=False)\nCheck if any required methods were not called.\nTypically called automatically by sim.run(); default behavior is to warn (see options.check_method_calls).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndie\nbool\nwhether to raise an exception if missing methods were found (default False)\nNone\n\n\nwarn\nbool\nwhether to raise a warning if missing methods were found (default False)\nNone\n\n\nverbose\nbool\nwhether to print the number of times each method was called (default False)\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA list of missing method calls by module\n\n\n\n\n\n\n\nsim.Sim.check_results_ready(errormsg=None)\nCheck that results are ready\n\n\n\nsim.Sim.cprofile(sort='cumtime', mintime=0.001, **kwargs)\nProfile the performance of the simulation using a function profiler (sc.cprofile())\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsort\nstr\ndefault sort column; common choices are ‘cumtime’ (total time spent in a function, includin subfunctions) and ‘selftime’ (excluding subfunctions)\n'cumtime'\n\n\nmintime\nfloat\nexclude function calls less than this time in seconds\n0.001\n\n\n**kwargs\ndict\npassed to sc.cprofile()\n{}\n\n\n\nExample:\nimport starsim as ss\n\nnet = ss.RandomNet()\nsis = ss.SIS()\nsim = ss.Sim(networks=net, diseases=sis)\nprof = sim.cprofile()\n\n\n\n\nsim.Sim.finalize()\nCompute final results\n\n\n\nsim.Sim.finalize_results()\nScale the results and remove any “unused” results\n\n\n\nsim.Sim.finish_step()\nFinish the simulation timestep\n\n\n\nsim.Sim.init(force=False, timer=False, **kwargs)\nPerform all initializations for the sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nforce\nbool\nwhether to overwrite sim attributes even if they already exist\nFalse\n\n\ntimer\nbool\nif True, count the time required for initialization (otherwise just count run time)\nFalse\n\n\nkwargs\ndict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_data(data=None)\nInitialize or add data to the sim\n\n\n\nsim.Sim.init_dists()\nInitialize the distributions\n\n\n\nsim.Sim.init_module_attrs(force=False)\nMove initialized modules to the sim\n\n\n\nsim.Sim.init_modules_post()\nInitialize values in other modules, including networks and time parameters, and do any other post-processing\n\n\n\nsim.Sim.init_modules_pre()\nInitialize all the modules with the sim\n\n\n\nsim.Sim.init_people(verbose=None, **kwargs)\nInitialize people within the sim Sometimes the people are provided, in which case this just adds a few sim properties to them. Other time people are not provided and this method makes them.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbose\nint\ndetail to print\nNone\n\n\nkwargs\ndict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_people_vals()\nInitialize the People states with actual values\n\n\n\nsim.Sim.init_results()\nCreate initial results that are present in all simulations\nThis method initializes results by calling People.init_results() to let People handle its own result initialization (including automatic BoolState results).\n\n\n\nsim.Sim.init_time()\nTime indexing; derived values live in the sim rather than in the pars\n\n\n\nsim.Sim.plot(\n    key=None,\n    fig=None,\n    show_data=True,\n    show_skipped=False,\n    show_module=None,\n    show_label=False,\n    n_ticks=None,\n    **kwargs,\n)\nPlot all results in the Sim object\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr / list\nthe results key to plot (by default, all); if a list, plot exactly those keys\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nstyle\nstr\nthe plotting style to use\nrequired\n\n\nshow_data\nbool\nplot the data, if available\nTrue\n\n\nshow_skipped\nbool\nshow even results that are skipped by default\nFalse\n\n\nshow_module\nint\nwhether to show the module as well as the result name; if an int, show if the label is less than that length (default, 26); if -1, use a newline\nNone\n\n\nshow_label\nstr\nif ‘fig’, reset the fignum; if ‘title’, set the figure suptitle\nFalse\n\n\nn_ticks\ntuple of ints\nif provided, specify how many x-axis ticks to use (default: (2,5), i.e. minimum of 2 and maximum of 5)\nNone\n\n\nfig_kw\ndict\npassed to sc.getrowscols(), then plt.subplots() and plt.figure()\nrequired\n\n\nplot_kw\ndict\npassed to plt.plot()\nrequired\n\n\ndata_kw\ndict\npassed to plt.scatter(), for plotting the data\nrequired\n\n\nstyle_kw\ndict\npassed to ss.style(), for controlling the detailed plotting style (default “starsim”; other options are “simple”, None, or any Matplotlib style)\nrequired\n\n\n**kwargs\ndict\nknown arguments (e.g. figsize, font) split between the above dicts; see ss.plot_args() for all valid options\n{}\n\n\n\nExamples:\nsim = ss.Sim(diseases='sis', networks='random').run()\n\n# Basic usage\nsim.plot()\n\n# Plot a single result\nsim.plot('sis.prevalence')\n\n# Plot with a custom figure size, font, and style\nsim.plot(figsize=(12,16), font='Raleway', style='fancy')\n\n\n\n\nsim.Sim.products()\nList all products across interventions; not an ndict like the other module types\n\n\n\nsim.Sim.profile(line=True, do_run=True, plot=True, follow=None, **kwargs)\nProfile the performance of the simulation using a line profiler (sc.profile())\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndo_run\nbool\nwhether to immediately run the sim\nTrue\n\n\nplot\nbool\nwhether to plot time spent per module step\nTrue\n\n\nfollow\nfunc / list\na list of functions/methods to follow in detail\nNone\n\n\n**kwargs\ndict\npassed to sc.profile()\n{}\n\n\n\nExample:\nimport starsim as ss\n\nnet = ss.RandomNet()\nsis = ss.SIS()\nsim = ss.Sim(networks=net, diseases=sis)\nprof = sim.profile(follow=[net.add_pairs, sis.infect])\n\n\n\n\nsim.Sim.reset_time_pars(force=True)\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\n\nsim.Sim.run(until=None, verbose=None, check_method_calls=True)\nRun the model – the main method for running a simulation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuntil\ndate / str / float\nthe date to run the sim until\nNone\n\n\nverbose\nfloat\nthe level of detail to print (default 0.1, i.e. output once every 10 steps)\nNone\n\n\ncheck_method_calls\nbool\nwhether to check that all required methods were called\nTrue\n\n\n\n\n\n\n\nsim.Sim.run_one_step(verbose=None)\nRun a single sim step; only used for debugging purposes.\nNote: sim.run_one_step() runs a single simulation timestep, which involves multiple function calls. In contrast, loop.run_one_step() runs a single function call.\nNote: the verbose here is only for the Loop object, not the sim.\n\n\n\nsim.Sim.save(filename=None, shrink=None, **kwargs)\nSave to disk as a gzipped pickle.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr or None\nthe name or path of the file to save to; if None, uses stored\nNone\n\n\nshrink\nbool or None\nwhether to shrink the sim prior to saving (reduces size by ~99%)\nNone\n\n\nkwargs\n\npassed to sc.makefilepath()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfilename\nstr\nthe validated absolute path to the saved file\n\n\n\nExample:\nsim.save() # Saves to a .sim file\n\n\n\n\nsim.Sim.shrink(inplace=True, size_limit=1.0, intercept=10, die=True)\n“Shrinks” the simulation by removing the people and other memory-intensive attributes (e.g., some interventions and analyzers), and returns a copy of the “shrunken” simulation. Used to reduce the memory required for RAM or for saved files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninplace\nbool\nwhether to perform the shrinking in place (default), or return a shrunken copy instead\nTrue\n\n\nsize_limit\nfloat\nprint a warning if any module is larger than this size limit, in units of KB per timestep (set to None to disable)\n1.0\n\n\nintercept\nfloat\nthe size (in units of size_limit) to allow for a zero-timestep sim\n10\n\n\ndie\nbool\nwhether to raise an exception if the shrink failed\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshrunken\nSim\na Sim object with the listed attributes removed\n\n\n\n\n\n\n\nsim.Sim.start_step()\nStart the step – only print progress; all actual changes happen in the modules\n\n\n\nsim.Sim.summarize(how='default')\nProvide a quick summary of the sim; returns the last entry for count and cumulative results, and the mean otherwise.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhow\nstr\nhow to summarize: can be ‘mean’, ‘median’, ‘last’, or a mapping of result keys to those\n'default'\n\n\n\n\n\n\n\nsim.Sim.to_df(sep='_', **kwargs)\nExport results as a Pandas dataframe Args: sep (str): separator for the keys kwargs: passed to results.to_df()\n\n\n\nsim.Sim.to_json(\n    filename=None,\n    keys=None,\n    tostring=False,\n    indent=2,\n    verbose=False,\n    **kwargs,\n)\nExport results and parameters as JSON.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr\nif None, return string; else, write to file\nNone\n\n\nkeys\nstr / list\nattributes to write to json (choices: ‘pars’, ‘summary’, and/or ‘results’)\nNone\n\n\nverbose\nbool\ndetail to print\nFalse\n\n\n**kwargs\ndict\npassed to sc.jsonify()\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA dictionary representation of the parameters and/or summary results\n\n\n\n\n(or write that dictionary to a file)\n\n\n\nExamples:\njson = sim.to_json() # Convert to a dict\nsim.to_json('sim.json') # Write everything\nsim.to_json('summary.json', keys='summary') # Just write the summary\n\n\n\n\nsim.Sim.to_yaml(filename=None, sort_keys=False, **kwargs)\nExport results and parameters as YAML.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr\nthe name of the file to write to (default {sim.label}.yaml)\nNone\n\n\nkwargs\ndict\npassed to sim.to_json()\n{}\n\n\n\nExample:\nsim = ss.Sim(diseases='sis', networks='random').run()\nsim.to_yaml('results.yaml', keys='results')\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_sims_match\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\ndemo\nCreate a simple demo simulation for Starsim\n\n\ndiff_sims\nCompute the difference of the summaries of two simulations, and print any\n\n\n\n\n\nsim.check_sims_match(*args, full=False)\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\na list of 2 or more sims to compare\n()\n\n\nfull\nbool\nif True, return whether each sim matches the first\nFalse\n\n\n\nExample:\ns1 = ss.Sim(diseases='sir', networks='random')\ns2 = ss.Sim(pars=dict(diseases='sir', networks='random'))\ns3 = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet())\nassert ss.check_sims_match(s1, s2, s3)\n\n\n\n\nsim.demo(run=True, plot=True, summary=True, show=True, **kwargs)\nCreate a simple demo simulation for Starsim\nDefaults to using the SIR model with a random network, but these can be configured.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrun\nbool\nwhether to run the sim\nTrue\n\n\nplot\nbool\nwhether to plot the results\nTrue\n\n\nsummary\nbool\nwhether to print a summary of the results\nTrue\n\n\nkwargs\ndict\npassed to ss.Sim()\n{}\n\n\n\nExamples:\nss.demo() # Run, plot, and show results\nss.demo(diseases='hiv', networks='mf') # Run with different defaults\n\n\n\n\nsim.diff_sims(\n    sim1,\n    sim2,\n    skip_key_diffs=False,\n    skip=None,\n    full=False,\n    output=False,\n    die=False,\n)\nCompute the difference of the summaries of two simulations, and print any values which differ.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim1\nSim / MultiSim / dict\neither a simulation/MultiSim object or the sim.summary dictionary\nrequired\n\n\nsim2\nim / dict\nditto\nrequired\n\n\nskip_key_diffs\nbool\nwhether to skip keys that don’t match between sims\nFalse\n\n\nskip\nlist\na list of values to skip\nNone\n\n\nfull\nbool\nwhether to print out all values (not just those that differ)\nFalse\n\n\noutput\nbool\nwhether to return the output as a string (otherwise print)\nFalse\n\n\ndie\nbool\nwhether to raise an exception if the sims don’t match\nFalse\n\n\n\nExample:\ns1 = ss.Sim(rand_seed=1).run()\ns2 = ss.Sim(rand_seed=2).run()\nss.diff_sims(s1, s2)",
    "crumbs": [
      "**Basics**",
      "sim"
    ]
  },
  {
    "objectID": "api/sim.html#classes",
    "href": "api/sim.html#classes",
    "title": "sim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAlreadyRunError\nRaised if trying to re-run an already-run sim without re-initializing\n\n\nSim\nThe Sim object\n\n\n\n\n\nsim.AlreadyRunError()\nRaised if trying to re-run an already-run sim without re-initializing\n\n\n\nsim.Sim(\n    pars=None,\n    label=None,\n    people=None,\n    modules=None,\n    demographics=None,\n    diseases=None,\n    networks=None,\n    interventions=None,\n    analyzers=None,\n    connectors=None,\n    copy_inputs=True,\n    data=None,\n    **kwargs,\n)\nThe Sim object\nAll Starsim simulations run via the Sim class. It is responsible for initializing and running all modules and generating results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\nSimPars / dict\neither an ss.SimPars object, or a nested dictionary; can include all other arguments\nNone\n\n\nlabel\nstr\nthe human-readable name of the simulation\nNone\n\n\npeople\nPeople\nif provided, use this ss.People object\nNone\n\n\nmodules\nModule / list\nif provided, use these modules (and divide among demographics, diseases, etc. based on type)\nNone\n\n\ndemographics\nstr / Demographics / list\na string naming the demographics module to use, the module itself, or a list\nNone\n\n\nconnectors\nstr / Connector / list\nas above, for connectors\nNone\n\n\nnetworks\nstr / Network / list\nas above, for networks\nNone\n\n\ninterventions\nstr / Intervention / list\nas above, for interventions\nNone\n\n\ndiseases\nstr / Disease / list\nas above, for diseases\nNone\n\n\nanalyzers\nstr / Analyzer / list\nas above, for analyzers\nNone\n\n\ncopy_inputs\nbool\nif True, copy modules as they’re inserted into the sim (allowing reuse in other sims, but meaning they won’t be updated)\nTrue\n\n\ndata\ndf\na dataframe (or dict) of data, with a column “time” plus data of the form “module.result”, e.g. “hiv.new_infections” (used for plotting only)\nNone\n\n\nkwargs\ndict\nmerged with pars; see ss.SimPars for all parameter values\n{}\n\n\n\nExamples:\nsim = ss.Sim(diseases='sir', networks='random') # Simplest Starsim sim; equivalent to ss.demo()\nsim = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet()) # Equivalent using objects instead of strings\nsim = ss.Sim(diseases=['sir', ss.SIS()], networks=['random', 'mf']) # Example using list inputs; can mix and match types\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nlabel\nGet the sim label from the parameters, if available.\n\n\nmodule_dict\nReturn a dictionary of all Module instances; see sim.module_list for the list version\n\n\nmodule_list\nReturn a list of all Module instances (stored in standard places) in the Sim; see sim.module_dict for the dict version\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_method_calls\nCheck if any required methods were not called.\n\n\ncheck_results_ready\nCheck that results are ready\n\n\ncprofile\nProfile the performance of the simulation using a function profiler (sc.cprofile())\n\n\nfinalize\nCompute final results\n\n\nfinalize_results\nScale the results and remove any “unused” results\n\n\nfinish_step\nFinish the simulation timestep\n\n\ninit\nPerform all initializations for the sim\n\n\ninit_data\nInitialize or add data to the sim\n\n\ninit_dists\nInitialize the distributions\n\n\ninit_module_attrs\nMove initialized modules to the sim\n\n\ninit_modules_post\nInitialize values in other modules, including networks and time parameters, and do any other post-processing\n\n\ninit_modules_pre\nInitialize all the modules with the sim\n\n\ninit_people\nInitialize people within the sim\n\n\ninit_people_vals\nInitialize the People states with actual values\n\n\ninit_results\nCreate initial results that are present in all simulations\n\n\ninit_time\nTime indexing; derived values live in the sim rather than in the pars\n\n\nplot\nPlot all results in the Sim object\n\n\nproducts\nList all products across interventions; not an ndict like the other module types\n\n\nprofile\nProfile the performance of the simulation using a line profiler (sc.profile())\n\n\nreset_time_pars\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\nrun\nRun the model – the main method for running a simulation.\n\n\nrun_one_step\nRun a single sim step; only used for debugging purposes.\n\n\nsave\nSave to disk as a gzipped pickle.\n\n\nshrink\n“Shrinks” the simulation by removing the people and other memory-intensive\n\n\nstart_step\nStart the step – only print progress; all actual changes happen in the modules\n\n\nsummarize\nProvide a quick summary of the sim; returns the last entry for count and\n\n\nto_df\nExport results as a Pandas dataframe\n\n\nto_json\nExport results and parameters as JSON.\n\n\nto_yaml\nExport results and parameters as YAML.\n\n\n\n\n\nsim.Sim.check_method_calls(die=None, warn=None, verbose=False)\nCheck if any required methods were not called.\nTypically called automatically by sim.run(); default behavior is to warn (see options.check_method_calls).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndie\nbool\nwhether to raise an exception if missing methods were found (default False)\nNone\n\n\nwarn\nbool\nwhether to raise a warning if missing methods were found (default False)\nNone\n\n\nverbose\nbool\nwhether to print the number of times each method was called (default False)\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA list of missing method calls by module\n\n\n\n\n\n\n\nsim.Sim.check_results_ready(errormsg=None)\nCheck that results are ready\n\n\n\nsim.Sim.cprofile(sort='cumtime', mintime=0.001, **kwargs)\nProfile the performance of the simulation using a function profiler (sc.cprofile())\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsort\nstr\ndefault sort column; common choices are ‘cumtime’ (total time spent in a function, includin subfunctions) and ‘selftime’ (excluding subfunctions)\n'cumtime'\n\n\nmintime\nfloat\nexclude function calls less than this time in seconds\n0.001\n\n\n**kwargs\ndict\npassed to sc.cprofile()\n{}\n\n\n\nExample:\nimport starsim as ss\n\nnet = ss.RandomNet()\nsis = ss.SIS()\nsim = ss.Sim(networks=net, diseases=sis)\nprof = sim.cprofile()\n\n\n\n\nsim.Sim.finalize()\nCompute final results\n\n\n\nsim.Sim.finalize_results()\nScale the results and remove any “unused” results\n\n\n\nsim.Sim.finish_step()\nFinish the simulation timestep\n\n\n\nsim.Sim.init(force=False, timer=False, **kwargs)\nPerform all initializations for the sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nforce\nbool\nwhether to overwrite sim attributes even if they already exist\nFalse\n\n\ntimer\nbool\nif True, count the time required for initialization (otherwise just count run time)\nFalse\n\n\nkwargs\ndict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_data(data=None)\nInitialize or add data to the sim\n\n\n\nsim.Sim.init_dists()\nInitialize the distributions\n\n\n\nsim.Sim.init_module_attrs(force=False)\nMove initialized modules to the sim\n\n\n\nsim.Sim.init_modules_post()\nInitialize values in other modules, including networks and time parameters, and do any other post-processing\n\n\n\nsim.Sim.init_modules_pre()\nInitialize all the modules with the sim\n\n\n\nsim.Sim.init_people(verbose=None, **kwargs)\nInitialize people within the sim Sometimes the people are provided, in which case this just adds a few sim properties to them. Other time people are not provided and this method makes them.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbose\nint\ndetail to print\nNone\n\n\nkwargs\ndict\npassed to ss.People()\n{}\n\n\n\n\n\n\n\nsim.Sim.init_people_vals()\nInitialize the People states with actual values\n\n\n\nsim.Sim.init_results()\nCreate initial results that are present in all simulations\nThis method initializes results by calling People.init_results() to let People handle its own result initialization (including automatic BoolState results).\n\n\n\nsim.Sim.init_time()\nTime indexing; derived values live in the sim rather than in the pars\n\n\n\nsim.Sim.plot(\n    key=None,\n    fig=None,\n    show_data=True,\n    show_skipped=False,\n    show_module=None,\n    show_label=False,\n    n_ticks=None,\n    **kwargs,\n)\nPlot all results in the Sim object\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr / list\nthe results key to plot (by default, all); if a list, plot exactly those keys\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nstyle\nstr\nthe plotting style to use\nrequired\n\n\nshow_data\nbool\nplot the data, if available\nTrue\n\n\nshow_skipped\nbool\nshow even results that are skipped by default\nFalse\n\n\nshow_module\nint\nwhether to show the module as well as the result name; if an int, show if the label is less than that length (default, 26); if -1, use a newline\nNone\n\n\nshow_label\nstr\nif ‘fig’, reset the fignum; if ‘title’, set the figure suptitle\nFalse\n\n\nn_ticks\ntuple of ints\nif provided, specify how many x-axis ticks to use (default: (2,5), i.e. minimum of 2 and maximum of 5)\nNone\n\n\nfig_kw\ndict\npassed to sc.getrowscols(), then plt.subplots() and plt.figure()\nrequired\n\n\nplot_kw\ndict\npassed to plt.plot()\nrequired\n\n\ndata_kw\ndict\npassed to plt.scatter(), for plotting the data\nrequired\n\n\nstyle_kw\ndict\npassed to ss.style(), for controlling the detailed plotting style (default “starsim”; other options are “simple”, None, or any Matplotlib style)\nrequired\n\n\n**kwargs\ndict\nknown arguments (e.g. figsize, font) split between the above dicts; see ss.plot_args() for all valid options\n{}\n\n\n\nExamples:\nsim = ss.Sim(diseases='sis', networks='random').run()\n\n# Basic usage\nsim.plot()\n\n# Plot a single result\nsim.plot('sis.prevalence')\n\n# Plot with a custom figure size, font, and style\nsim.plot(figsize=(12,16), font='Raleway', style='fancy')\n\n\n\n\nsim.Sim.products()\nList all products across interventions; not an ndict like the other module types\n\n\n\nsim.Sim.profile(line=True, do_run=True, plot=True, follow=None, **kwargs)\nProfile the performance of the simulation using a line profiler (sc.profile())\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndo_run\nbool\nwhether to immediately run the sim\nTrue\n\n\nplot\nbool\nwhether to plot time spent per module step\nTrue\n\n\nfollow\nfunc / list\na list of functions/methods to follow in detail\nNone\n\n\n**kwargs\ndict\npassed to sc.profile()\n{}\n\n\n\nExample:\nimport starsim as ss\n\nnet = ss.RandomNet()\nsis = ss.SIS()\nsim = ss.Sim(networks=net, diseases=sis)\nprof = sim.profile(follow=[net.add_pairs, sis.infect])\n\n\n\n\nsim.Sim.reset_time_pars(force=True)\nReset the time parameters in the modules; used for imposing the sim’s timestep on the modules\n\n\n\nsim.Sim.run(until=None, verbose=None, check_method_calls=True)\nRun the model – the main method for running a simulation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuntil\ndate / str / float\nthe date to run the sim until\nNone\n\n\nverbose\nfloat\nthe level of detail to print (default 0.1, i.e. output once every 10 steps)\nNone\n\n\ncheck_method_calls\nbool\nwhether to check that all required methods were called\nTrue\n\n\n\n\n\n\n\nsim.Sim.run_one_step(verbose=None)\nRun a single sim step; only used for debugging purposes.\nNote: sim.run_one_step() runs a single simulation timestep, which involves multiple function calls. In contrast, loop.run_one_step() runs a single function call.\nNote: the verbose here is only for the Loop object, not the sim.\n\n\n\nsim.Sim.save(filename=None, shrink=None, **kwargs)\nSave to disk as a gzipped pickle.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr or None\nthe name or path of the file to save to; if None, uses stored\nNone\n\n\nshrink\nbool or None\nwhether to shrink the sim prior to saving (reduces size by ~99%)\nNone\n\n\nkwargs\n\npassed to sc.makefilepath()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfilename\nstr\nthe validated absolute path to the saved file\n\n\n\nExample:\nsim.save() # Saves to a .sim file\n\n\n\n\nsim.Sim.shrink(inplace=True, size_limit=1.0, intercept=10, die=True)\n“Shrinks” the simulation by removing the people and other memory-intensive attributes (e.g., some interventions and analyzers), and returns a copy of the “shrunken” simulation. Used to reduce the memory required for RAM or for saved files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninplace\nbool\nwhether to perform the shrinking in place (default), or return a shrunken copy instead\nTrue\n\n\nsize_limit\nfloat\nprint a warning if any module is larger than this size limit, in units of KB per timestep (set to None to disable)\n1.0\n\n\nintercept\nfloat\nthe size (in units of size_limit) to allow for a zero-timestep sim\n10\n\n\ndie\nbool\nwhether to raise an exception if the shrink failed\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nshrunken\nSim\na Sim object with the listed attributes removed\n\n\n\n\n\n\n\nsim.Sim.start_step()\nStart the step – only print progress; all actual changes happen in the modules\n\n\n\nsim.Sim.summarize(how='default')\nProvide a quick summary of the sim; returns the last entry for count and cumulative results, and the mean otherwise.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhow\nstr\nhow to summarize: can be ‘mean’, ‘median’, ‘last’, or a mapping of result keys to those\n'default'\n\n\n\n\n\n\n\nsim.Sim.to_df(sep='_', **kwargs)\nExport results as a Pandas dataframe Args: sep (str): separator for the keys kwargs: passed to results.to_df()\n\n\n\nsim.Sim.to_json(\n    filename=None,\n    keys=None,\n    tostring=False,\n    indent=2,\n    verbose=False,\n    **kwargs,\n)\nExport results and parameters as JSON.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr\nif None, return string; else, write to file\nNone\n\n\nkeys\nstr / list\nattributes to write to json (choices: ‘pars’, ‘summary’, and/or ‘results’)\nNone\n\n\nverbose\nbool\ndetail to print\nFalse\n\n\n**kwargs\ndict\npassed to sc.jsonify()\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA dictionary representation of the parameters and/or summary results\n\n\n\n\n(or write that dictionary to a file)\n\n\n\nExamples:\njson = sim.to_json() # Convert to a dict\nsim.to_json('sim.json') # Write everything\nsim.to_json('summary.json', keys='summary') # Just write the summary\n\n\n\n\nsim.Sim.to_yaml(filename=None, sort_keys=False, **kwargs)\nExport results and parameters as YAML.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr\nthe name of the file to write to (default {sim.label}.yaml)\nNone\n\n\nkwargs\ndict\npassed to sim.to_json()\n{}\n\n\n\nExample:\nsim = ss.Sim(diseases='sis', networks='random').run()\nsim.to_yaml('results.yaml', keys='results')",
    "crumbs": [
      "**Basics**",
      "sim"
    ]
  },
  {
    "objectID": "api/sim.html#functions",
    "href": "api/sim.html#functions",
    "title": "sim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_sims_match\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\ndemo\nCreate a simple demo simulation for Starsim\n\n\ndiff_sims\nCompute the difference of the summaries of two simulations, and print any\n\n\n\n\n\nsim.check_sims_match(*args, full=False)\nShortcut to using ss.diff_sims() to check if multiple sims match\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\na list of 2 or more sims to compare\n()\n\n\nfull\nbool\nif True, return whether each sim matches the first\nFalse\n\n\n\nExample:\ns1 = ss.Sim(diseases='sir', networks='random')\ns2 = ss.Sim(pars=dict(diseases='sir', networks='random'))\ns3 = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet())\nassert ss.check_sims_match(s1, s2, s3)\n\n\n\n\nsim.demo(run=True, plot=True, summary=True, show=True, **kwargs)\nCreate a simple demo simulation for Starsim\nDefaults to using the SIR model with a random network, but these can be configured.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrun\nbool\nwhether to run the sim\nTrue\n\n\nplot\nbool\nwhether to plot the results\nTrue\n\n\nsummary\nbool\nwhether to print a summary of the results\nTrue\n\n\nkwargs\ndict\npassed to ss.Sim()\n{}\n\n\n\nExamples:\nss.demo() # Run, plot, and show results\nss.demo(diseases='hiv', networks='mf') # Run with different defaults\n\n\n\n\nsim.diff_sims(\n    sim1,\n    sim2,\n    skip_key_diffs=False,\n    skip=None,\n    full=False,\n    output=False,\n    die=False,\n)\nCompute the difference of the summaries of two simulations, and print any values which differ.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim1\nSim / MultiSim / dict\neither a simulation/MultiSim object or the sim.summary dictionary\nrequired\n\n\nsim2\nim / dict\nditto\nrequired\n\n\nskip_key_diffs\nbool\nwhether to skip keys that don’t match between sims\nFalse\n\n\nskip\nlist\na list of values to skip\nNone\n\n\nfull\nbool\nwhether to print out all values (not just those that differ)\nFalse\n\n\noutput\nbool\nwhether to return the output as a string (otherwise print)\nFalse\n\n\ndie\nbool\nwhether to raise an exception if the sims don’t match\nFalse\n\n\n\nExample:\ns1 = ss.Sim(rand_seed=1).run()\ns2 = ss.Sim(rand_seed=2).run()\nss.diff_sims(s1, s2)",
    "crumbs": [
      "**Basics**",
      "sim"
    ]
  },
  {
    "objectID": "api/distributions.html",
    "href": "api/distributions.html",
    "title": "distributions",
    "section": "",
    "text": "distributions\nDefine random-number-safe distributions.\n\n\n\n\n\nName\nDescription\n\n\n\n\nDist\nBase class for tracking one random number generator associated with one distribution,\n\n\nDists\nClass for managing a collection of Dist objects\n\n\nmulti_random\nA class for holding two or more ss.random() distributions, and generating\n\n\nscale_types\nDefine how distributions scale\n\n\n\n\n\ndistributions.Dist(\n    dist=None,\n    distname=None,\n    name=None,\n    unit=None,\n    seed=None,\n    offset=None,\n    strict=True,\n    auto=True,\n    sim=None,\n    module=None,\n    mock=False,\n    debug=False,\n    **kwargs,\n)\nBase class for tracking one random number generator associated with one distribution, i.e. one decision per timestep.\nSee ss.dist_list for a full list of supported distributions. Parameter inputs tend to follow SciPy’s, rather than NumPy’s, definitions (although in most cases they’re the same). See also ss.distributions.scale_types for more information on how different distributions scale by time.\nNote: by default, ss.Dist is initialized with an ss.Sim object to ensure random number reproducibility. You can override this with either ss.Dist(strict=False) on creation, or dist.init(force=True) after creation.\nAlthough it’s possible in theory to define a custom distribution (i.e., not one from NumPy or SciPy), in practice this is difficult. The distribution needs to have both a way to return random variates (easy), as well as the probability point function (inverse CDF). In addition, the distribution must be able to take a NumPy RNG as its bit generator. It’s easier to just use a default Dist (e.g., ss.random()), and then take its output as input (i.e., quantiles) for whatever custom distribution you want to create.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndist\nrv_generic\noptional; a scipy.stats distribution (frozen or not) to get the ppf from\nNone\n\n\ndistname\nstr\nthe name for this class of distribution (e.g. “uniform”)\nNone\n\n\nname\nstr\nthe name for this particular distribution (e.g. “age_at_death”)\nNone\n\n\nunit\nstr/ss.TimePar\nif provided, convert the output of the distribution to a timepar (e.g. rate or duration); can also be inferred from distribution parameters (see examples below)\nNone\n\n\nseed\nint\nthe user-chosen random seed (e.g. 3)\nNone\n\n\noffset\nint\nthe seed offset; will be automatically assigned (based on hashing the name) if None\nNone\n\n\nstrict\nbool\nif True, require initialization and invalidate after each call to rvs()\nTrue\n\n\nauto\nbool\nwhether to auto-reset the state after each draw\nTrue\n\n\nsim\nSim\nusually determined on initialization; the sim to use as input to callable parameters\nNone\n\n\nmodule\nModule\nusually determined on initialization; the module to use as input to callable parameters\nNone\n\n\nmock\nint\nif provided, then initialize with a mock Sim object (of size mock) for debugging purposes\nFalse\n\n\ndebug\nbool\nprint out additional detail\nFalse\n\n\nkwargs\ndict\nparameters of the distribution\n{}\n\n\n\nExamples:\n# Create a Bernoulli distribution\np_death = ss.bernoulli(p=0.1).init(force=True)\np_death.rvs(50) # Create 50 draws\n\n# Create a normal distribution that's also a timepar\ndur_infection = ss.normal(loc=12, scale=2, unit='years')\ndur_infection = ss.years(ss.normal(loc=12, scale=2)) # Same as above\ndur_infection = ss.normal(loc=ss.years(12), scale=2)) # Same as above\ndur_infection = ss.normal(loc=ss.years(12), scale=ss.months(24)) # Same as above, perform time unit conversion internally\ndur_infection.init(force=True).plot_hist() # Show results\n\n# Create a distribution manually\ndist = ss.Dist(dist=sps.norm, loc=3).init(force=True)\ndist.rvs(10) # Return 10 normally distributed random numbers\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstate\nGet the current state\n\n\nstate_int\nGet the integer corresponding to the current state\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncall_par\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\ncall_pars\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\nconvert_callable\nMethod to handle how callable parameters are processed; not for the user\n\n\nconvert_timepars\nConvert time parameters (durations and rates) to scalars\n\n\ndisp\nReturn full display of object\n\n\nget_state\nReturn a copy of the state\n\n\ninit\nCalculate the starting seed and create the RNG\n\n\njump\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\njump_dt\nAutomatically jump on the next value of dt\n\n\nlink_module\nShortcut for linking the module\n\n\nlink_sim\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\nmake_history\nStore the current state in history\n\n\nmake_rvs\nReturn default random numbers for scalar parameters; not for the user\n\n\nmock\nCreate a distribution using a mock sim for testing purposes\n\n\nplot_hist\nPlot the current state of the RNG as a histogram\n\n\nppf\nReturn default random numbers for array parameters; not for the user\n\n\nprocess_dist\nEnsure the distribution works; not for the user\n\n\nprocess_pars\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\nprocess_seed\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\nprocess_size\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\nrand\nSimple way to get simple random numbers\n\n\nrandround\nRound the values up or down to an integer stochastically; usually called via dist.rvs(round=True)\n\n\nreset\nRestore state, allowing the same numbers to be resampled\n\n\nrvs\nGet random variates – use this!\n\n\nset\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\nshow_state\nShow the state of the object\n\n\nshrink\nShrink the size of the module for saving to disk\n\n\nsync_pars\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\nto_json\nReturn a dictionary representation of the Dist\n\n\nupdate_dist_pars\nUpdate SciPy distribution parameters; not for the user\n\n\nvalidate_pars\nCheck if parameters are valid; only used for non-SciPy distributions\n\n\n\n\n\ndistributions.Dist.call_par(key, val, size, uids)\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\n\ndistributions.Dist.call_pars()\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\n\ndistributions.Dist.convert_callable(parkey, func, size, uids)\nMethod to handle how callable parameters are processed; not for the user\n\n\n\ndistributions.Dist.convert_timepars()\nConvert time parameters (durations and rates) to scalars\nThis function converts time parameters into bare numbers that will be returned by rvs() depending on the timestep of the parent module for this Dist. The conversion for these types is\n\nDurations are divided by dt (so the result will be a number of timesteps)\nRates are multiplied by dt (so the result will be a number of events, or else the equivalent multiplicate value for the timestep)\n\n\n\n\ndistributions.Dist.disp()\nReturn full display of object\n\n\n\ndistributions.Dist.get_state()\nReturn a copy of the state\n\n\n\ndistributions.Dist.init(\n    trace=None,\n    seed=None,\n    module=None,\n    sim=None,\n    slots=None,\n    force=False,\n)\nCalculate the starting seed and create the RNG\nTypically this is not invoked by the user, although the user can call it with force=True to initialize a distribution manually independently of a ss.Sim object (which is equivalent to setting strict=False when creating the dist).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrace\nstr\nthe distribution’s location within the sim\nNone\n\n\nseed\nint\nthe base random number seed that other random number seeds will be generated from\nNone\n\n\nmodule\nss.Module\nthe parent module\nNone\n\n\nsim\nss.Sim\nthe parent sim\nNone\n\n\nslots\narray\nthe agent slots of the parent sim\nNone\n\n\nforce\nbool\nwhether to skip validation (if the dist has already been initialized, and if any inputs are None)\nFalse\n\n\n\n\n\n\n\ndistributions.Dist.jump(to=None, delta=1, force=False)\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\n\ndistributions.Dist.jump_dt(ti=None, force=False)\nAutomatically jump on the next value of dt\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current module timestep plus one)\nNone\n\n\n\n\n\n\n\ndistributions.Dist.link_module(module=None, overwrite=False)\nShortcut for linking the module\n\n\n\ndistributions.Dist.link_sim(sim=None, overwrite=False)\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\n\ndistributions.Dist.make_history(reset=False)\nStore the current state in history\n\n\n\ndistributions.Dist.make_rvs()\nReturn default random numbers for scalar parameters; not for the user\n\n\n\ndistributions.Dist.mock(trace='mock', **kwargs)\nCreate a distribution using a mock sim for testing purposes\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrace\nstr\nthe “trace” of the distribution (normally, where it would be located in the sim)\n'mock'\n\n\n**kwargs\ndict\npassed to ss.mock_sim() as well as ss.mock_module() (typically time args, e.g. dt)\n{}\n\n\n\nExample:\ndist = ss.normal(3, 2, unit='years').mock(dt=ss.days(1))\ndist.rvs(10)\n\n\n\n\ndistributions.Dist.plot_hist(n=1000, bins=None, fig_kw=None, hist_kw=None)\nPlot the current state of the RNG as a histogram\n\n\n\ndistributions.Dist.ppf(rands)\nReturn default random numbers for array parameters; not for the user\n\n\n\ndistributions.Dist.process_dist()\nEnsure the distribution works; not for the user\n\n\n\ndistributions.Dist.process_pars(call=True)\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\n\ndistributions.Dist.process_seed(trace=None, seed=None)\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\n\ndistributions.Dist.process_size(n=1)\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\n\ndistributions.Dist.rand(size)\nSimple way to get simple random numbers\n\n\n\ndistributions.Dist.randround(rvs)\nRound the values up or down to an integer stochastically; usually called via dist.rvs(round=True)\n\n\n\ndistributions.Dist.reset(state=0)\nRestore state, allowing the same numbers to be resampled\nUse 0 for original state, -1 for most recent state.\nExample:\ndist = ss.random(seed=5).init()\nr1 = dist(5)\nr2 = dist(5)\ndist.reset(-1)\nr3 = dist(5)\ndist.reset(0)\nr4 = dist(5)\nassert all(r1 != r2)\nassert all(r2 == r3)\nassert all(r4 == r1)\n\n\n\ndistributions.Dist.rvs(n=1, round=False, reset=False)\nGet random variates – use this!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint / tuple / arr\nif an int or tuple, return this many random variates; if an array, treat as UIDs\n1\n\n\nround\nbool\nif True, randomly round up or down based on how close the value is\nFalse\n\n\nreset\nbool\nwhether to automatically reset the random number distribution state after being called\nFalse\n\n\n\n\n\n\n\ndistributions.Dist.set(*args, dist=None, **kwargs)\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\n\ndistributions.Dist.show_state(output=False)\nShow the state of the object\n\n\n\ndistributions.Dist.shrink()\nShrink the size of the module for saving to disk\n\n\n\ndistributions.Dist.sync_pars()\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\n\ndistributions.Dist.to_json()\nReturn a dictionary representation of the Dist\n\n\n\ndistributions.Dist.update_dist_pars(pars=None)\nUpdate SciPy distribution parameters; not for the user\n\n\n\ndistributions.Dist.validate_pars()\nCheck if parameters are valid; only used for non-SciPy distributions\n\n\n\n\n\ndistributions.Dists(obj=None, *args, base_seed=None, sim=None)\nClass for managing a collection of Dist objects\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_seeds\nCheck that no two distributions share the same seed\n\n\ncopy_to_module\nCopy the Sim’s Dists object to the specified module\n\n\ninit\nSet the base seed, find and initialize all distributions in an object\n\n\njump\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\njump_dt\nAdvance all RNGs to the next timestep\n\n\nreset\nReset each RNG\n\n\n\n\n\ndistributions.Dists.check_seeds()\nCheck that no two distributions share the same seed\n\n\n\ndistributions.Dists.copy_to_module(module)\nCopy the Sim’s Dists object to the specified module\n\n\n\ndistributions.Dists.init(obj=None, base_seed=None, sim=None, force=False)\nSet the base seed, find and initialize all distributions in an object\nIn practice, the object is usually a Sim, but can be anything.\n\n\n\ndistributions.Dists.jump(to=None, delta=1, force=False)\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\n\ndistributions.Dists.jump_dt(ti=None, force=False)\nAdvance all RNGs to the next timestep\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current sim timestep)\nNone\n\n\n\n\n\n\n\ndistributions.Dists.reset()\nReset each RNG\n\n\n\n\n\ndistributions.multi_random(names, *args, **kwargs)\nA class for holding two or more ss.random() distributions, and generating random numbers linked to each of them. Useful for e.g. pairwise transmission probabilities.\nSee ss.combine_rands() for the manual version; in almost all cases this class should be used instead.\n\n\nmulti = ss.multi_random(‘source’, ‘target’) rvs = multi.rvs(source_uids, target_uids)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncombine_rvs\nCombine inputs into one number\n\n\ninit\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\njump\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nreset\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nrvs\nGet random variates from each of the underlying distributions and combine them efficiently\n\n\n\n\n\ndistributions.multi_random.combine_rvs(rvs_list, int_type, int_max)\nCombine inputs into one number\n\n\n\ndistributions.multi_random.init(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.jump(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.reset(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.rvs(*args)\nGet random variates from each of the underlying distributions and combine them efficiently\n\n\n\n\n\ndistributions.scale_types()\nDefine how distributions scale\nDistributions scale in different ways, such as converting between time units. Some distributions can’t be scaled at all (e.g. ss.beta_dist() or ss.choice()). For distributions that can be scaled, some distributions can only be (linearly) scaled before the random numbers are generated (called “predraw”), some can only be scaled after (called “postdraw”), and some can be scaled in either way (“both”).\nFor example, a normal distribution is “both” since 2Normal(a, b) = Normal(2a, 2b). A Poisson distribution is “predraw” since 2Poisson(λ) ≠ Poisson(2λ), and there is no way to get the correct shape of a different Poisson distribution once the numbers have been drawn. Finally, distributions with unitless shape parameters as well as parameter that can have units (e.g. a gamma distribution with shape and scale parameters) are referred to as “postdraw” since scaling all input parameters is invalid (i.e. 2Gamma(shape, scale) ≠ Gamma(2shape, 2scale)), but they can still be scaled (i.e. 2Gamma(shape, scale) = Gamma(1shape, 2*scale)).\nTo summarize, options for dist.scaling are:\n- 'postdraw' (after the random numbers are drawn, e.g. `ss.weibull()`)\n- 'predraw' (before the draw, e.g. `ss.poisson()`)\n- 'both' (either pre or post draw, e.g. `ss.normal()`)\n- False (not at all, e.g. `ss.beta_dist()`)\nUse ss.distributions.scale_types.show() to show how each distribution scales with time.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_postdraw\nCheck if the supplied distribution supports post-draw (results) scaling\n\n\ncheck_predraw\nCheck if the supplied distribution supports pre-draw (parameter) scaling\n\n\nshow\nShow which distributions have which scale types\n\n\n\n\n\ndistributions.scale_types.check_postdraw(dist)\nCheck if the supplied distribution supports post-draw (results) scaling\n\n\n\ndistributions.scale_types.check_predraw(dist)\nCheck if the supplied distribution supports pre-draw (parameter) scaling\n\n\n\ndistributions.scale_types.show(to_df=False)\nShow which distributions have which scale types\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nlink_dists\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\nmake_dist\nMake a distribution from a dictionary\n\n\n\n\n\ndistributions.link_dists(\n    obj,\n    sim,\n    module=None,\n    overwrite=False,\n    init=False,\n    **kwargs,\n)\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\n\ndistributions.make_dist(pars=None, **kwargs)\nMake a distribution from a dictionary",
    "crumbs": [
      "**Utilities**",
      "distributions"
    ]
  },
  {
    "objectID": "api/distributions.html#classes",
    "href": "api/distributions.html#classes",
    "title": "distributions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDist\nBase class for tracking one random number generator associated with one distribution,\n\n\nDists\nClass for managing a collection of Dist objects\n\n\nmulti_random\nA class for holding two or more ss.random() distributions, and generating\n\n\nscale_types\nDefine how distributions scale\n\n\n\n\n\ndistributions.Dist(\n    dist=None,\n    distname=None,\n    name=None,\n    unit=None,\n    seed=None,\n    offset=None,\n    strict=True,\n    auto=True,\n    sim=None,\n    module=None,\n    mock=False,\n    debug=False,\n    **kwargs,\n)\nBase class for tracking one random number generator associated with one distribution, i.e. one decision per timestep.\nSee ss.dist_list for a full list of supported distributions. Parameter inputs tend to follow SciPy’s, rather than NumPy’s, definitions (although in most cases they’re the same). See also ss.distributions.scale_types for more information on how different distributions scale by time.\nNote: by default, ss.Dist is initialized with an ss.Sim object to ensure random number reproducibility. You can override this with either ss.Dist(strict=False) on creation, or dist.init(force=True) after creation.\nAlthough it’s possible in theory to define a custom distribution (i.e., not one from NumPy or SciPy), in practice this is difficult. The distribution needs to have both a way to return random variates (easy), as well as the probability point function (inverse CDF). In addition, the distribution must be able to take a NumPy RNG as its bit generator. It’s easier to just use a default Dist (e.g., ss.random()), and then take its output as input (i.e., quantiles) for whatever custom distribution you want to create.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndist\nrv_generic\noptional; a scipy.stats distribution (frozen or not) to get the ppf from\nNone\n\n\ndistname\nstr\nthe name for this class of distribution (e.g. “uniform”)\nNone\n\n\nname\nstr\nthe name for this particular distribution (e.g. “age_at_death”)\nNone\n\n\nunit\nstr/ss.TimePar\nif provided, convert the output of the distribution to a timepar (e.g. rate or duration); can also be inferred from distribution parameters (see examples below)\nNone\n\n\nseed\nint\nthe user-chosen random seed (e.g. 3)\nNone\n\n\noffset\nint\nthe seed offset; will be automatically assigned (based on hashing the name) if None\nNone\n\n\nstrict\nbool\nif True, require initialization and invalidate after each call to rvs()\nTrue\n\n\nauto\nbool\nwhether to auto-reset the state after each draw\nTrue\n\n\nsim\nSim\nusually determined on initialization; the sim to use as input to callable parameters\nNone\n\n\nmodule\nModule\nusually determined on initialization; the module to use as input to callable parameters\nNone\n\n\nmock\nint\nif provided, then initialize with a mock Sim object (of size mock) for debugging purposes\nFalse\n\n\ndebug\nbool\nprint out additional detail\nFalse\n\n\nkwargs\ndict\nparameters of the distribution\n{}\n\n\n\nExamples:\n# Create a Bernoulli distribution\np_death = ss.bernoulli(p=0.1).init(force=True)\np_death.rvs(50) # Create 50 draws\n\n# Create a normal distribution that's also a timepar\ndur_infection = ss.normal(loc=12, scale=2, unit='years')\ndur_infection = ss.years(ss.normal(loc=12, scale=2)) # Same as above\ndur_infection = ss.normal(loc=ss.years(12), scale=2)) # Same as above\ndur_infection = ss.normal(loc=ss.years(12), scale=ss.months(24)) # Same as above, perform time unit conversion internally\ndur_infection.init(force=True).plot_hist() # Show results\n\n# Create a distribution manually\ndist = ss.Dist(dist=sps.norm, loc=3).init(force=True)\ndist.rvs(10) # Return 10 normally distributed random numbers\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstate\nGet the current state\n\n\nstate_int\nGet the integer corresponding to the current state\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncall_par\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\ncall_pars\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\nconvert_callable\nMethod to handle how callable parameters are processed; not for the user\n\n\nconvert_timepars\nConvert time parameters (durations and rates) to scalars\n\n\ndisp\nReturn full display of object\n\n\nget_state\nReturn a copy of the state\n\n\ninit\nCalculate the starting seed and create the RNG\n\n\njump\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\njump_dt\nAutomatically jump on the next value of dt\n\n\nlink_module\nShortcut for linking the module\n\n\nlink_sim\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\nmake_history\nStore the current state in history\n\n\nmake_rvs\nReturn default random numbers for scalar parameters; not for the user\n\n\nmock\nCreate a distribution using a mock sim for testing purposes\n\n\nplot_hist\nPlot the current state of the RNG as a histogram\n\n\nppf\nReturn default random numbers for array parameters; not for the user\n\n\nprocess_dist\nEnsure the distribution works; not for the user\n\n\nprocess_pars\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\nprocess_seed\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\nprocess_size\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\nrand\nSimple way to get simple random numbers\n\n\nrandround\nRound the values up or down to an integer stochastically; usually called via dist.rvs(round=True)\n\n\nreset\nRestore state, allowing the same numbers to be resampled\n\n\nrvs\nGet random variates – use this!\n\n\nset\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\nshow_state\nShow the state of the object\n\n\nshrink\nShrink the size of the module for saving to disk\n\n\nsync_pars\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\nto_json\nReturn a dictionary representation of the Dist\n\n\nupdate_dist_pars\nUpdate SciPy distribution parameters; not for the user\n\n\nvalidate_pars\nCheck if parameters are valid; only used for non-SciPy distributions\n\n\n\n\n\ndistributions.Dist.call_par(key, val, size, uids)\nCheck if this parameter needs to be called to be turned into an array; not for the user\n\n\n\ndistributions.Dist.call_pars()\nCheck if any parameters need to be called to be turned into arrays; not for the user\n\n\n\ndistributions.Dist.convert_callable(parkey, func, size, uids)\nMethod to handle how callable parameters are processed; not for the user\n\n\n\ndistributions.Dist.convert_timepars()\nConvert time parameters (durations and rates) to scalars\nThis function converts time parameters into bare numbers that will be returned by rvs() depending on the timestep of the parent module for this Dist. The conversion for these types is\n\nDurations are divided by dt (so the result will be a number of timesteps)\nRates are multiplied by dt (so the result will be a number of events, or else the equivalent multiplicate value for the timestep)\n\n\n\n\ndistributions.Dist.disp()\nReturn full display of object\n\n\n\ndistributions.Dist.get_state()\nReturn a copy of the state\n\n\n\ndistributions.Dist.init(\n    trace=None,\n    seed=None,\n    module=None,\n    sim=None,\n    slots=None,\n    force=False,\n)\nCalculate the starting seed and create the RNG\nTypically this is not invoked by the user, although the user can call it with force=True to initialize a distribution manually independently of a ss.Sim object (which is equivalent to setting strict=False when creating the dist).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrace\nstr\nthe distribution’s location within the sim\nNone\n\n\nseed\nint\nthe base random number seed that other random number seeds will be generated from\nNone\n\n\nmodule\nss.Module\nthe parent module\nNone\n\n\nsim\nss.Sim\nthe parent sim\nNone\n\n\nslots\narray\nthe agent slots of the parent sim\nNone\n\n\nforce\nbool\nwhether to skip validation (if the dist has already been initialized, and if any inputs are None)\nFalse\n\n\n\n\n\n\n\ndistributions.Dist.jump(to=None, delta=1, force=False)\nAdvance the RNG, e.g. to timestep “to”, by jumping\n\n\n\ndistributions.Dist.jump_dt(ti=None, force=False)\nAutomatically jump on the next value of dt\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current module timestep plus one)\nNone\n\n\n\n\n\n\n\ndistributions.Dist.link_module(module=None, overwrite=False)\nShortcut for linking the module\n\n\n\ndistributions.Dist.link_sim(sim=None, overwrite=False)\nShortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user\n\n\n\ndistributions.Dist.make_history(reset=False)\nStore the current state in history\n\n\n\ndistributions.Dist.make_rvs()\nReturn default random numbers for scalar parameters; not for the user\n\n\n\ndistributions.Dist.mock(trace='mock', **kwargs)\nCreate a distribution using a mock sim for testing purposes\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrace\nstr\nthe “trace” of the distribution (normally, where it would be located in the sim)\n'mock'\n\n\n**kwargs\ndict\npassed to ss.mock_sim() as well as ss.mock_module() (typically time args, e.g. dt)\n{}\n\n\n\nExample:\ndist = ss.normal(3, 2, unit='years').mock(dt=ss.days(1))\ndist.rvs(10)\n\n\n\n\ndistributions.Dist.plot_hist(n=1000, bins=None, fig_kw=None, hist_kw=None)\nPlot the current state of the RNG as a histogram\n\n\n\ndistributions.Dist.ppf(rands)\nReturn default random numbers for array parameters; not for the user\n\n\n\ndistributions.Dist.process_dist()\nEnsure the distribution works; not for the user\n\n\n\ndistributions.Dist.process_pars(call=True)\nEnsure the supplied dist and parameters are valid, and initialize them; not for the user\n\n\n\ndistributions.Dist.process_seed(trace=None, seed=None)\nObtain the seed offset by hashing the path to this distribution; not for the user\n\n\n\ndistributions.Dist.process_size(n=1)\nHandle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user\n\n\n\ndistributions.Dist.rand(size)\nSimple way to get simple random numbers\n\n\n\ndistributions.Dist.randround(rvs)\nRound the values up or down to an integer stochastically; usually called via dist.rvs(round=True)\n\n\n\ndistributions.Dist.reset(state=0)\nRestore state, allowing the same numbers to be resampled\nUse 0 for original state, -1 for most recent state.\nExample:\ndist = ss.random(seed=5).init()\nr1 = dist(5)\nr2 = dist(5)\ndist.reset(-1)\nr3 = dist(5)\ndist.reset(0)\nr4 = dist(5)\nassert all(r1 != r2)\nassert all(r2 == r3)\nassert all(r4 == r1)\n\n\n\ndistributions.Dist.rvs(n=1, round=False, reset=False)\nGet random variates – use this!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint / tuple / arr\nif an int or tuple, return this many random variates; if an array, treat as UIDs\n1\n\n\nround\nbool\nif True, randomly round up or down based on how close the value is\nFalse\n\n\nreset\nbool\nwhether to automatically reset the random number distribution state after being called\nFalse\n\n\n\n\n\n\n\ndistributions.Dist.set(*args, dist=None, **kwargs)\nSet (change) the distribution type, or one or more parameters of the distribution\n\n\n\ndistributions.Dist.show_state(output=False)\nShow the state of the object\n\n\n\ndistributions.Dist.shrink()\nShrink the size of the module for saving to disk\n\n\n\ndistributions.Dist.sync_pars()\nPerform any necessary synchronizations or transformations on distribution parameters; not for the user\n\n\n\ndistributions.Dist.to_json()\nReturn a dictionary representation of the Dist\n\n\n\ndistributions.Dist.update_dist_pars(pars=None)\nUpdate SciPy distribution parameters; not for the user\n\n\n\ndistributions.Dist.validate_pars()\nCheck if parameters are valid; only used for non-SciPy distributions\n\n\n\n\n\ndistributions.Dists(obj=None, *args, base_seed=None, sim=None)\nClass for managing a collection of Dist objects\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_seeds\nCheck that no two distributions share the same seed\n\n\ncopy_to_module\nCopy the Sim’s Dists object to the specified module\n\n\ninit\nSet the base seed, find and initialize all distributions in an object\n\n\njump\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\njump_dt\nAdvance all RNGs to the next timestep\n\n\nreset\nReset each RNG\n\n\n\n\n\ndistributions.Dists.check_seeds()\nCheck that no two distributions share the same seed\n\n\n\ndistributions.Dists.copy_to_module(module)\nCopy the Sim’s Dists object to the specified module\n\n\n\ndistributions.Dists.init(obj=None, base_seed=None, sim=None, force=False)\nSet the base seed, find and initialize all distributions in an object\nIn practice, the object is usually a Sim, but can be anything.\n\n\n\ndistributions.Dists.jump(to=None, delta=1, force=False)\nAdvance all RNGs, e.g. to call “to”, by jumping\n\n\n\ndistributions.Dists.jump_dt(ti=None, force=False)\nAdvance all RNGs to the next timestep\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nti\nint\nif specified, jump to this timestep (default: current sim timestep)\nNone\n\n\n\n\n\n\n\ndistributions.Dists.reset()\nReset each RNG\n\n\n\n\n\ndistributions.multi_random(names, *args, **kwargs)\nA class for holding two or more ss.random() distributions, and generating random numbers linked to each of them. Useful for e.g. pairwise transmission probabilities.\nSee ss.combine_rands() for the manual version; in almost all cases this class should be used instead.\n\n\nmulti = ss.multi_random(‘source’, ‘target’) rvs = multi.rvs(source_uids, target_uids)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncombine_rvs\nCombine inputs into one number\n\n\ninit\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\njump\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nreset\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\nrvs\nGet random variates from each of the underlying distributions and combine them efficiently\n\n\n\n\n\ndistributions.multi_random.combine_rvs(rvs_list, int_type, int_max)\nCombine inputs into one number\n\n\n\ndistributions.multi_random.init(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.jump(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.reset(*args, **kwargs)\nNot usually needed since each dist will handle this automatically; for completeness only\n\n\n\ndistributions.multi_random.rvs(*args)\nGet random variates from each of the underlying distributions and combine them efficiently\n\n\n\n\n\ndistributions.scale_types()\nDefine how distributions scale\nDistributions scale in different ways, such as converting between time units. Some distributions can’t be scaled at all (e.g. ss.beta_dist() or ss.choice()). For distributions that can be scaled, some distributions can only be (linearly) scaled before the random numbers are generated (called “predraw”), some can only be scaled after (called “postdraw”), and some can be scaled in either way (“both”).\nFor example, a normal distribution is “both” since 2Normal(a, b) = Normal(2a, 2b). A Poisson distribution is “predraw” since 2Poisson(λ) ≠ Poisson(2λ), and there is no way to get the correct shape of a different Poisson distribution once the numbers have been drawn. Finally, distributions with unitless shape parameters as well as parameter that can have units (e.g. a gamma distribution with shape and scale parameters) are referred to as “postdraw” since scaling all input parameters is invalid (i.e. 2Gamma(shape, scale) ≠ Gamma(2shape, 2scale)), but they can still be scaled (i.e. 2Gamma(shape, scale) = Gamma(1shape, 2*scale)).\nTo summarize, options for dist.scaling are:\n- 'postdraw' (after the random numbers are drawn, e.g. `ss.weibull()`)\n- 'predraw' (before the draw, e.g. `ss.poisson()`)\n- 'both' (either pre or post draw, e.g. `ss.normal()`)\n- False (not at all, e.g. `ss.beta_dist()`)\nUse ss.distributions.scale_types.show() to show how each distribution scales with time.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_postdraw\nCheck if the supplied distribution supports post-draw (results) scaling\n\n\ncheck_predraw\nCheck if the supplied distribution supports pre-draw (parameter) scaling\n\n\nshow\nShow which distributions have which scale types\n\n\n\n\n\ndistributions.scale_types.check_postdraw(dist)\nCheck if the supplied distribution supports post-draw (results) scaling\n\n\n\ndistributions.scale_types.check_predraw(dist)\nCheck if the supplied distribution supports pre-draw (parameter) scaling\n\n\n\ndistributions.scale_types.show(to_df=False)\nShow which distributions have which scale types",
    "crumbs": [
      "**Utilities**",
      "distributions"
    ]
  },
  {
    "objectID": "api/distributions.html#functions",
    "href": "api/distributions.html#functions",
    "title": "distributions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nlink_dists\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\nmake_dist\nMake a distribution from a dictionary\n\n\n\n\n\ndistributions.link_dists(\n    obj,\n    sim,\n    module=None,\n    overwrite=False,\n    init=False,\n    **kwargs,\n)\nLink distributions to the sim and the module; used in module.init() and people.init()\n\n\n\ndistributions.make_dist(pars=None, **kwargs)\nMake a distribution from a dictionary",
    "crumbs": [
      "**Utilities**",
      "distributions"
    ]
  },
  {
    "objectID": "api/modules.html",
    "href": "api/modules.html",
    "title": "modules",
    "section": "",
    "text": "modules\nGeneral module class – base class for diseases, interventions, etc. Also defines Analyzers and Connectors.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBase\nThe parent class for Sim and Module objects\n\n\nModule\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\n\n\n\n\n\nmodules.Base()\nThe parent class for Sim and Module objects\n\n\n\n\n\nName\nDescription\n\n\n\n\ndt\nGet the current module timestep\n\n\nnow\nShortcut to self.t.now()\n\n\nti\nGet the current module timestep\n\n\ntimevec\nShortcut to self.t.timevec\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nPerform a deep copy of the module/sim\n\n\ndisp\nDisplay the full object\n\n\n\n\n\nmodules.Base.copy(die=True)\nPerform a deep copy of the module/sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndie\nbool\nwhether to raise an exception if copy fails (else, try a shallow copy)\nTrue\n\n\n\n\n\n\n\nmodules.Base.disp(output=False, **kwargs)\nDisplay the full object\n\n\n\n\n\nmodules.Module(name=None, label=None, **kwargs)\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\nBy convention, keyword arguments to modules are assigned to “_“, which is an alias for None. These are then populated with defaults by mod.define_pars(), which are then updated with mod.update_pars(), which inspects the __init__ function to get these arguments.\nNote that there is no functional difference between specifying arguments this way rather than simply via **kwargs, but having the arguments shown in the function signature can make it easier to read, and “_” is a convetion to indicate that the default is specified below.\nIt is also of course OK to specify the actual values rather than “_“; however module arguments are often complex objects (e.g. ss.bernoulli) that can’t be easily specified in the function signature.\nFinally, note that you can (and should) call super().__init__() with no arguments: the name, label, and time arguments get correctly updated via self.update_pars().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\na short, key-like name for the module (e.g. “randomnet”)\nNone\n\n\nlabel\nstr\nthe full, human-readable name for the module (e.g. “Random network”)\nNone\n\n\nkwargs\ndict\npassed to ss.Timeline() (e.g. start, stop, unit, dt)\n{}\n\n\n\nExample:\nclass SIR(ss.Module):\n    def __init__(self, pars=_, beta=_, init_prev=_, p_death=_, **kwargs):\n        super().__init__() # Call this first with no arguments\n        self.define_pars( # Then define the parameters, including their default value\n            beta = ss.peryear(0.1),\n            init_prev = ss.bernoulli(p=0.01),\n            p_death = ss.bernoulli(p=0.3),\n        )\n        self.update_pars(pars, **kwargs) # Update with any user-supplied parameters, and raise an exception if trying to set a parameter that wasn't defined in define_pars()\n        return\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauto_state_list\nList of “automatic” states with boolean type (ss.BoolState) that were added\n\n\nstate_dict\nReturn a flat dictionary (objdict) of all states\n\n\nstate_list\nReturn a flat list of all states (ss.Arr objects)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrief\nShow a brief representation of the module; used by repr\n\n\ncheck_method_calls\nCheck if any required methods were not called.\n\n\ncreate\nCreate a module instance by name\n\n\ndefine_pars\nCreate or merge Pars objects\n\n\ndefine_results\nAdd results to the module\n\n\ndefine_states\nDefine states of the module with the same attribute name as the state\n\n\nfinalize\nPerform any final operations, such as removing unneeded data\n\n\nfinalize_results\nFinalize results\n\n\nfinish_step\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\nfrom_func\nCreate an module from a function\n\n\ninit_mock\nInitialize with a mock simulation – for debugging purposes only\n\n\ninit_post\nInitialize the values of the states; the last step of initialization\n\n\ninit_pre\nPerform initialization steps\n\n\ninit_results\nInitialize results output; called during init_pre()\n\n\nlink_rates\nFind all time parameters in the module and link them to the module’s dt\n\n\nmatch_time_inds\nFind the nearest matching sim time indices for the current module\n\n\nplot\nPlot all results in the module\n\n\nset_metadata\nSet metadata for the module\n\n\nsetattribute\nMethod for setting an attribute that does not perform checking against immutable attributes\n\n\nshrink\nShrink the size of the module for saving to disk\n\n\nstart_step\nTasks to perform at the beginning of the step\n\n\nstep\nDefine how the module updates over time – the key part of Starsim!!\n\n\nto_json\nExport to a JSON-compatible format\n\n\nupdate_pars\nPull out recognized parameters, returning the rest\n\n\nupdate_results\nUpdate results; by default, compute counts of each state at each point in time\n\n\n\n\n\nmodules.Module.brief(output=False)\nShow a brief representation of the module; used by repr\n\n\n\nmodules.Module.check_method_calls()\nCheck if any required methods were not called.\nTypically called automatically by sim.run().\n\n\n\nmodules.Module.create(name, *args, **kwargs)\nCreate a module instance by name\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nA string with the name of the module class in lower case, e.g. ‘sir’\nrequired\n\n\n\n\n\n\n\nmodules.Module.define_pars(inherit=True, **kwargs)\nCreate or merge Pars objects\nNote: this method also automatically pulls in keyword arguments from the calling function (which is almost always a module’s __init__() method)\n\n\n\nmodules.Module.define_results(*args, check=True)\nAdd results to the module\n\n\n\nmodules.Module.define_states(*args, check=True, reset=False, lock=True)\nDefine states of the module with the same attribute name as the state\nIn addition to registering the state with the module by attribute, it adds it to mod._all_states, which is used by mod.state_list and mod.state_dict.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nstates\nlist of states to add\n()\n\n\ncheck\nbool\nwhether to check that the object being added is a state, and that it’s not already present\nTrue\n\n\nreset\nbool\nwhether to reset the list of module states and use only the ones provided\nFalse\n\n\nlock\nbool\nif True, prevent states from being\nTrue\n\n\n\n\n\n\n\nmodules.Module.finalize()\nPerform any final operations, such as removing unneeded data\n\n\n\nmodules.Module.finalize_results()\nFinalize results\n\n\n\nmodules.Module.finish_step()\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\n\nmodules.Module.from_func(func)\nCreate an module from a function\n\n\n\nmodules.Module.init_mock(n_agents=100, dur=10)\nInitialize with a mock simulation – for debugging purposes only\n\n\n\nmodules.Module.init_post()\nInitialize the values of the states; the last step of initialization\n\n\n\nmodules.Module.init_pre(sim, force=False)\nPerform initialization steps\nThis method is called once, as part of initializing a Sim. Note: after initialization, initialized=False until init_vals() is called (which is after distributions are initialized).\n\n\n\nmodules.Module.init_results()\nInitialize results output; called during init_pre()\nBy default, modules all report on counts for any explicitly defined “States”, e.g. if a disease contains an ss.BoolState called ‘susceptible’ it will automatically contain a Result for ‘n_susceptible’. For identical behavior that does not automatically generate results, use ss.BoolArr instead of ss.BoolState.\n\n\n\nmodules.Module.link_rates(force=False)\nFind all time parameters in the module and link them to the module’s dt\n\n\n\nmodules.Module.match_time_inds(inds=None)\nFind the nearest matching sim time indices for the current module\n\n\n\nmodules.Module.plot()\nPlot all results in the module\n\n\n\nmodules.Module.set_metadata(name=None, label=None)\nSet metadata for the module\n\n\n\nmodules.Module.setattribute(attr, value)\nMethod for setting an attribute that does not perform checking against immutable attributes\n\n\n\nmodules.Module.shrink()\nShrink the size of the module for saving to disk\n\n\n\nmodules.Module.start_step()\nTasks to perform at the beginning of the step\n\n\n\nmodules.Module.step()\nDefine how the module updates over time – the key part of Starsim!!\n\n\n\nmodules.Module.to_json()\nExport to a JSON-compatible format\n\n\n\nmodules.Module.update_pars(pars=None, **kwargs)\nPull out recognized parameters, returning the rest\n\n\n\nmodules.Module.update_results()\nUpdate results; by default, compute counts of each state at each point in time\nThis function is executed after transmission in all modules has been resolved. This allows result updates at this point to capture outcomes dependent on multiple modules, where relevant.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfind_modules\nFind all subclasses of Module present in Starsim, divided by type\n\n\nmodule_map\nDefine the mapping between module names and types; this is the source of truth about module types and ordering\n\n\nmodule_types\nReturn a list of known module types; based on module_map()\n\n\nregister_modules\nRegister custom modules with Starsim so they can be referred to by string.\n\n\nrequired\nDecorator to mark module methods as required.\n\n\n\n\n\nmodules.find_modules(key=None, flat=False, verbose=False)\nFind all subclasses of Module present in Starsim, divided by type\n\n\n\nmodules.module_map(key=None)\nDefine the mapping between module names and types; this is the source of truth about module types and ordering\n\n\n\nmodules.module_types()\nReturn a list of known module types; based on module_map()\n\n\n\nmodules.register_modules(*args)\nRegister custom modules with Starsim so they can be referred to by string.\nNote: “modules” here refers to Starsim modules. But this function registers Starsim “modules” (e.g. ss.SIR) that are found within Python “modules” (e.g. starsim).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nthe additional modules to register; can be either a module or a list of objects\n()\n\n\n\nExamples:\n# Standard use case, register modules automatically\nimport my_custom_disease_model as mcdm\nss.register_modules(mcdm)\nss.Sim(diseases='mydisease', networks='random').run() # This will work if mcdm.MyDisease() is defined\n\n# Manual usage\nmy_modules = [mcdm.MyDisease, mcdm.MyNetwork]\nss.register_modules(my_modules)\nss.Sim(diseases='mydisease', networks='mynetwork').run()\n\n\n\n\nmodules.required(val=True)\nDecorator to mark module methods as required.\nA common gotcha in Starsim is to forget to call super(), or to mistype a method name so it’s never called. This decorator lets you mark methods (of Modules only) to be sure that they are called either on sim initialization or on sim run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nval\nTrue / disable\nby default, mark method as required; if set to ‘disable’, then disable method checking for parent classes as well (i.e. remove previous “required” calls)\nTrue\n\n\n\nExample:\nclass CustomSIS(ss.SIS):\n\n    def step(self):\n        super().step()\n        self.custom_step() # Will raise an exception if this line is not here\n        return\n\n    @ss.required() # Mark this method as required on run\n    def custom_step(self):\n        pass",
    "crumbs": [
      "**Modules**",
      "modules"
    ]
  },
  {
    "objectID": "api/modules.html#classes",
    "href": "api/modules.html#classes",
    "title": "modules",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBase\nThe parent class for Sim and Module objects\n\n\nModule\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\n\n\n\n\n\nmodules.Base()\nThe parent class for Sim and Module objects\n\n\n\n\n\nName\nDescription\n\n\n\n\ndt\nGet the current module timestep\n\n\nnow\nShortcut to self.t.now()\n\n\nti\nGet the current module timestep\n\n\ntimevec\nShortcut to self.t.timevec\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nPerform a deep copy of the module/sim\n\n\ndisp\nDisplay the full object\n\n\n\n\n\nmodules.Base.copy(die=True)\nPerform a deep copy of the module/sim\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndie\nbool\nwhether to raise an exception if copy fails (else, try a shallow copy)\nTrue\n\n\n\n\n\n\n\nmodules.Base.disp(output=False, **kwargs)\nDisplay the full object\n\n\n\n\n\nmodules.Module(name=None, label=None, **kwargs)\nThe main base class for all Starsim modules: diseases, networks, interventions, etc.\nBy convention, keyword arguments to modules are assigned to “_“, which is an alias for None. These are then populated with defaults by mod.define_pars(), which are then updated with mod.update_pars(), which inspects the __init__ function to get these arguments.\nNote that there is no functional difference between specifying arguments this way rather than simply via **kwargs, but having the arguments shown in the function signature can make it easier to read, and “_” is a convetion to indicate that the default is specified below.\nIt is also of course OK to specify the actual values rather than “_“; however module arguments are often complex objects (e.g. ss.bernoulli) that can’t be easily specified in the function signature.\nFinally, note that you can (and should) call super().__init__() with no arguments: the name, label, and time arguments get correctly updated via self.update_pars().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\na short, key-like name for the module (e.g. “randomnet”)\nNone\n\n\nlabel\nstr\nthe full, human-readable name for the module (e.g. “Random network”)\nNone\n\n\nkwargs\ndict\npassed to ss.Timeline() (e.g. start, stop, unit, dt)\n{}\n\n\n\nExample:\nclass SIR(ss.Module):\n    def __init__(self, pars=_, beta=_, init_prev=_, p_death=_, **kwargs):\n        super().__init__() # Call this first with no arguments\n        self.define_pars( # Then define the parameters, including their default value\n            beta = ss.peryear(0.1),\n            init_prev = ss.bernoulli(p=0.01),\n            p_death = ss.bernoulli(p=0.3),\n        )\n        self.update_pars(pars, **kwargs) # Update with any user-supplied parameters, and raise an exception if trying to set a parameter that wasn't defined in define_pars()\n        return\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauto_state_list\nList of “automatic” states with boolean type (ss.BoolState) that were added\n\n\nstate_dict\nReturn a flat dictionary (objdict) of all states\n\n\nstate_list\nReturn a flat list of all states (ss.Arr objects)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrief\nShow a brief representation of the module; used by repr\n\n\ncheck_method_calls\nCheck if any required methods were not called.\n\n\ncreate\nCreate a module instance by name\n\n\ndefine_pars\nCreate or merge Pars objects\n\n\ndefine_results\nAdd results to the module\n\n\ndefine_states\nDefine states of the module with the same attribute name as the state\n\n\nfinalize\nPerform any final operations, such as removing unneeded data\n\n\nfinalize_results\nFinalize results\n\n\nfinish_step\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\nfrom_func\nCreate an module from a function\n\n\ninit_mock\nInitialize with a mock simulation – for debugging purposes only\n\n\ninit_post\nInitialize the values of the states; the last step of initialization\n\n\ninit_pre\nPerform initialization steps\n\n\ninit_results\nInitialize results output; called during init_pre()\n\n\nlink_rates\nFind all time parameters in the module and link them to the module’s dt\n\n\nmatch_time_inds\nFind the nearest matching sim time indices for the current module\n\n\nplot\nPlot all results in the module\n\n\nset_metadata\nSet metadata for the module\n\n\nsetattribute\nMethod for setting an attribute that does not perform checking against immutable attributes\n\n\nshrink\nShrink the size of the module for saving to disk\n\n\nstart_step\nTasks to perform at the beginning of the step\n\n\nstep\nDefine how the module updates over time – the key part of Starsim!!\n\n\nto_json\nExport to a JSON-compatible format\n\n\nupdate_pars\nPull out recognized parameters, returning the rest\n\n\nupdate_results\nUpdate results; by default, compute counts of each state at each point in time\n\n\n\n\n\nmodules.Module.brief(output=False)\nShow a brief representation of the module; used by repr\n\n\n\nmodules.Module.check_method_calls()\nCheck if any required methods were not called.\nTypically called automatically by sim.run().\n\n\n\nmodules.Module.create(name, *args, **kwargs)\nCreate a module instance by name\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nA string with the name of the module class in lower case, e.g. ‘sir’\nrequired\n\n\n\n\n\n\n\nmodules.Module.define_pars(inherit=True, **kwargs)\nCreate or merge Pars objects\nNote: this method also automatically pulls in keyword arguments from the calling function (which is almost always a module’s __init__() method)\n\n\n\nmodules.Module.define_results(*args, check=True)\nAdd results to the module\n\n\n\nmodules.Module.define_states(*args, check=True, reset=False, lock=True)\nDefine states of the module with the same attribute name as the state\nIn addition to registering the state with the module by attribute, it adds it to mod._all_states, which is used by mod.state_list and mod.state_dict.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nstates\nlist of states to add\n()\n\n\ncheck\nbool\nwhether to check that the object being added is a state, and that it’s not already present\nTrue\n\n\nreset\nbool\nwhether to reset the list of module states and use only the ones provided\nFalse\n\n\nlock\nbool\nif True, prevent states from being\nTrue\n\n\n\n\n\n\n\nmodules.Module.finalize()\nPerform any final operations, such as removing unneeded data\n\n\n\nmodules.Module.finalize_results()\nFinalize results\n\n\n\nmodules.Module.finish_step()\nDefine what should happen at the end of the step; at minimum, increment ti\n\n\n\nmodules.Module.from_func(func)\nCreate an module from a function\n\n\n\nmodules.Module.init_mock(n_agents=100, dur=10)\nInitialize with a mock simulation – for debugging purposes only\n\n\n\nmodules.Module.init_post()\nInitialize the values of the states; the last step of initialization\n\n\n\nmodules.Module.init_pre(sim, force=False)\nPerform initialization steps\nThis method is called once, as part of initializing a Sim. Note: after initialization, initialized=False until init_vals() is called (which is after distributions are initialized).\n\n\n\nmodules.Module.init_results()\nInitialize results output; called during init_pre()\nBy default, modules all report on counts for any explicitly defined “States”, e.g. if a disease contains an ss.BoolState called ‘susceptible’ it will automatically contain a Result for ‘n_susceptible’. For identical behavior that does not automatically generate results, use ss.BoolArr instead of ss.BoolState.\n\n\n\nmodules.Module.link_rates(force=False)\nFind all time parameters in the module and link them to the module’s dt\n\n\n\nmodules.Module.match_time_inds(inds=None)\nFind the nearest matching sim time indices for the current module\n\n\n\nmodules.Module.plot()\nPlot all results in the module\n\n\n\nmodules.Module.set_metadata(name=None, label=None)\nSet metadata for the module\n\n\n\nmodules.Module.setattribute(attr, value)\nMethod for setting an attribute that does not perform checking against immutable attributes\n\n\n\nmodules.Module.shrink()\nShrink the size of the module for saving to disk\n\n\n\nmodules.Module.start_step()\nTasks to perform at the beginning of the step\n\n\n\nmodules.Module.step()\nDefine how the module updates over time – the key part of Starsim!!\n\n\n\nmodules.Module.to_json()\nExport to a JSON-compatible format\n\n\n\nmodules.Module.update_pars(pars=None, **kwargs)\nPull out recognized parameters, returning the rest\n\n\n\nmodules.Module.update_results()\nUpdate results; by default, compute counts of each state at each point in time\nThis function is executed after transmission in all modules has been resolved. This allows result updates at this point to capture outcomes dependent on multiple modules, where relevant.",
    "crumbs": [
      "**Modules**",
      "modules"
    ]
  },
  {
    "objectID": "api/modules.html#functions",
    "href": "api/modules.html#functions",
    "title": "modules",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfind_modules\nFind all subclasses of Module present in Starsim, divided by type\n\n\nmodule_map\nDefine the mapping between module names and types; this is the source of truth about module types and ordering\n\n\nmodule_types\nReturn a list of known module types; based on module_map()\n\n\nregister_modules\nRegister custom modules with Starsim so they can be referred to by string.\n\n\nrequired\nDecorator to mark module methods as required.\n\n\n\n\n\nmodules.find_modules(key=None, flat=False, verbose=False)\nFind all subclasses of Module present in Starsim, divided by type\n\n\n\nmodules.module_map(key=None)\nDefine the mapping between module names and types; this is the source of truth about module types and ordering\n\n\n\nmodules.module_types()\nReturn a list of known module types; based on module_map()\n\n\n\nmodules.register_modules(*args)\nRegister custom modules with Starsim so they can be referred to by string.\nNote: “modules” here refers to Starsim modules. But this function registers Starsim “modules” (e.g. ss.SIR) that are found within Python “modules” (e.g. starsim).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nthe additional modules to register; can be either a module or a list of objects\n()\n\n\n\nExamples:\n# Standard use case, register modules automatically\nimport my_custom_disease_model as mcdm\nss.register_modules(mcdm)\nss.Sim(diseases='mydisease', networks='random').run() # This will work if mcdm.MyDisease() is defined\n\n# Manual usage\nmy_modules = [mcdm.MyDisease, mcdm.MyNetwork]\nss.register_modules(my_modules)\nss.Sim(diseases='mydisease', networks='mynetwork').run()\n\n\n\n\nmodules.required(val=True)\nDecorator to mark module methods as required.\nA common gotcha in Starsim is to forget to call super(), or to mistype a method name so it’s never called. This decorator lets you mark methods (of Modules only) to be sure that they are called either on sim initialization or on sim run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nval\nTrue / disable\nby default, mark method as required; if set to ‘disable’, then disable method checking for parent classes as well (i.e. remove previous “required” calls)\nTrue\n\n\n\nExample:\nclass CustomSIS(ss.SIS):\n\n    def step(self):\n        super().step()\n        self.custom_step() # Will raise an exception if this line is not here\n        return\n\n    @ss.required() # Mark this method as required on run\n    def custom_step(self):\n        pass",
    "crumbs": [
      "**Modules**",
      "modules"
    ]
  },
  {
    "objectID": "api/connectors.html",
    "href": "api/connectors.html",
    "title": "connectors",
    "section": "",
    "text": "connectors\nDefine connectors, which are used to mediate interactions between modules when the sim is run.\nWhile most of the\n\n\n\n\n\nName\nDescription\n\n\n\n\nConnector\nBase class for Connectors, which mediate interactions between disease (or other) modules\n\n\nseasonality\nExample connector – apply sine-wave seasonality of transmission to one or more diseases\n\n\n\n\n\nconnectors.Connector(name=None, label=None, **kwargs)\nBase class for Connectors, which mediate interactions between disease (or other) modules\nBecause connectors can do anything, they have no specified structure: it is up to the user to define how they behave.\n\n\n\nconnectors.seasonality(**kwargs)\nExample connector – apply sine-wave seasonality of transmission to one or more diseases\nThis works by modifying the disease’s rel_trans state; note that it replaces it with the seasonality variable, and will overwrite any existing values. (Note: this function would work more or less identically as an intervention, but it is closer in spirit to a connector.)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr / list\ndisease or list of diseases to apply seasonality to\nrequired\n\n\nscale\nfloat\nhow strong of a seasonality effect to apply (0.1 = 90-110% relative transmission rate depending on time of year)\nrequired\n\n\nshift\nfloat\noffset by time of year (0.5 = 6 month offset)\nrequired\n\n\n\nExample:\nimport starsim as ss\n\npars = dict(\n    n_agents = 10_000,\n    start = '2020-01-01',\n    stop = '2023-01-01',\n    dt = ss.weeks(1.0),\n    diseases = dict(\n        type = 'sis',\n        beta = ss.perweek(0.05),\n        dur_inf = ss.weeks(5),\n        waning = ss.perweek(0.1),\n        dt = ss.weeks(1),\n    ),\n    networks = 'random',\n)\n\ns1 = ss.Sim(pars, connectors=None, label='Random network')\ns2 = ss.Sim(pars, connectors=ss.seasonality(), label='Seasonality')\ns3 = ss.Sim(pars, connectors=ss.seasonality(scale=0.5, shift=0.2), label='Extreme seasonality')\n\nmsim = ss.parallel(s1, s2, s3)\nmsim.plot('sis')\n\ns3.connectors[0].plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nApply seasonality\n\n\n\n\n\nconnectors.seasonality.step(*args, **kwargs)\nApply seasonality",
    "crumbs": [
      "**Modules**",
      "connectors"
    ]
  },
  {
    "objectID": "api/connectors.html#classes",
    "href": "api/connectors.html#classes",
    "title": "connectors",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nConnector\nBase class for Connectors, which mediate interactions between disease (or other) modules\n\n\nseasonality\nExample connector – apply sine-wave seasonality of transmission to one or more diseases\n\n\n\n\n\nconnectors.Connector(name=None, label=None, **kwargs)\nBase class for Connectors, which mediate interactions between disease (or other) modules\nBecause connectors can do anything, they have no specified structure: it is up to the user to define how they behave.\n\n\n\nconnectors.seasonality(**kwargs)\nExample connector – apply sine-wave seasonality of transmission to one or more diseases\nThis works by modifying the disease’s rel_trans state; note that it replaces it with the seasonality variable, and will overwrite any existing values. (Note: this function would work more or less identically as an intervention, but it is closer in spirit to a connector.)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr / list\ndisease or list of diseases to apply seasonality to\nrequired\n\n\nscale\nfloat\nhow strong of a seasonality effect to apply (0.1 = 90-110% relative transmission rate depending on time of year)\nrequired\n\n\nshift\nfloat\noffset by time of year (0.5 = 6 month offset)\nrequired\n\n\n\nExample:\nimport starsim as ss\n\npars = dict(\n    n_agents = 10_000,\n    start = '2020-01-01',\n    stop = '2023-01-01',\n    dt = ss.weeks(1.0),\n    diseases = dict(\n        type = 'sis',\n        beta = ss.perweek(0.05),\n        dur_inf = ss.weeks(5),\n        waning = ss.perweek(0.1),\n        dt = ss.weeks(1),\n    ),\n    networks = 'random',\n)\n\ns1 = ss.Sim(pars, connectors=None, label='Random network')\ns2 = ss.Sim(pars, connectors=ss.seasonality(), label='Seasonality')\ns3 = ss.Sim(pars, connectors=ss.seasonality(scale=0.5, shift=0.2), label='Extreme seasonality')\n\nmsim = ss.parallel(s1, s2, s3)\nmsim.plot('sis')\n\ns3.connectors[0].plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nApply seasonality\n\n\n\n\n\nconnectors.seasonality.step(*args, **kwargs)\nApply seasonality",
    "crumbs": [
      "**Modules**",
      "connectors"
    ]
  },
  {
    "objectID": "api/results.html",
    "href": "api/results.html",
    "title": "results",
    "section": "",
    "text": "results\nResult structures.\n\n\n\n\n\nName\nDescription\n\n\n\n\nResult\nArray-like container for holding sim results.\n\n\nResults\nContainer for storing results\n\n\n\n\n\nresults.Result(\n    name=None,\n    label=None,\n    dtype=float,\n    shape=None,\n    scale=True,\n    auto_plot=True,\n    module=None,\n    values=None,\n    timevec=None,\n    low=None,\n    high=None,\n    summarize_by=None,\n    **kwargs,\n)\nArray-like container for holding sim results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodule\nstr\nthe name or label of the parent module, e.g. ‘SIR’\nNone\n\n\nname\nstr\nthe name of this result, e.g. ‘new_infections’\nNone\n\n\nshape\nint / tuple\nthe shape of the result array (usually module.npts)\nNone\n\n\nscale\nbool\nwhether or not the result scales by population size (e.g. a count does, a prevalence does not)\nTrue\n\n\nauto_plot\nbool\nwhether to include automatically in sim.plot() results\nTrue\n\n\nlabel\nstr\na human-readable label for the result\nNone\n\n\nvalues\narray\nprepopulate the Result with these values\nNone\n\n\ntimevec\narray\nan array of time points\nNone\n\n\nlow\narray\nvalues for the lower bound\nNone\n\n\nhigh\narray\nvalues for the upper bound\nNone\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\n\nIn most cases, ss.Result behaves exactly like np.array(), except with the additional fields listed above. To see everything contained in a result, you can use result.disp().\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfull_label\nReturn the full label of the result: : , e.g. “HIV: New infections”\n\n\nhas_dates\nCheck whether the time vector uses dates (rather than numbers)\n\n\nkey\nReturn the unique key of the result: ., e.g. “hiv.new_infections”\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_timevec\nMake sure we’re using a timevec that’s in the right format i.e. dates\n\n\ndisp\nFull display of all attributes/methods\n\n\nfrom_df\nMake a copy of the result with new values from a dataframe\n\n\ninit_values\nHandle values\n\n\nplot\nPlot a single result; kwargs are interpreted as plot_kw\n\n\nresample\nResample the result, e.g. from days to years. Leverages the pandas resample method.\n\n\nto_df\nConvert to a dataframe with timevec, value, low, and high columns\n\n\nto_series\nConvert to a series with timevec as the index and value as the data\n\n\nto_str\nConvert Result object to a string\n\n\nupdate\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Result.convert_timevec(force=False)\nMake sure we’re using a timevec that’s in the right format i.e. dates\n\n\n\nresults.Result.disp()\nFull display of all attributes/methods\n\n\n\nresults.Result.from_df(df)\nMake a copy of the result with new values from a dataframe\n\n\n\nresults.Result.init_values(values=None, dtype=None, shape=None, force=False)\nHandle values\n\n\n\nresults.Result.plot(\n    fig=None,\n    ax=None,\n    fig_kw=None,\n    plot_kw=None,\n    fill_kw=None,\n    **kwargs,\n)\nPlot a single result; kwargs are interpreted as plot_kw\n\n\n\nresults.Result.resample(\n    new_unit='year',\n    summarize_by=None,\n    col_names='vlh',\n    die=False,\n    output_form='series',\n    use_years=False,\n    sep='_',\n)\nResample the result, e.g. from days to years. Leverages the pandas resample method. Accepts all the Starsim units, plus the Pandas ones documented here: https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_unit\nstr\nthe new unit to resample to, e.g. ‘year’, ‘month’, ‘week’, ‘day’, ‘1W’, ‘2M’, etc.\n'year'\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\ncol_names\nstr\nwhether to rename the columns with the name of the result\n'vlh'\n\n\ndie\nbool\nwhether to raise an error if the summarization method cannot be determined\nFalse\n\n\noutput_form\nstr\n‘series’, ‘dataframe’, or ‘result’\n'series'\n\n\nuse_years\nbool\nwhether to use years as the unit of time\nFalse\n\n\n\n\n\n\n\nresults.Result.to_df(\n    sep='_',\n    col_names='vlh',\n    bounds=True,\n    resample=None,\n    set_date_index=False,\n    **kwargs,\n)\nConvert to a dataframe with timevec, value, low, and high columns\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsep\nstr\nseparator for the column names\n'_'\n\n\ncol_names\nstr or None\nif None, uses the name of the result. Default is ‘vlh’ which uses value, low, high\n'vlh'\n\n\nset_date_index\nbool\nif True, use the timevec as the index\nFalse\n\n\nbounds\nbool\ninclude high and low bounds as well (if and only if they exist, e.g. from a MultiSim)\nTrue\n\n\nresample\nstr\nif provided, resample the data to this frequency\nNone\n\n\nkwargs\n\npassed to the resample method if resample=True\n{}\n\n\n\n\n\n\n\nresults.Result.to_series(set_name=False, resample=None, sep='_', **kwargs)\nConvert to a series with timevec as the index and value as the data Args: set_name (bool): whether to set the name of the series to the name of the result resample (str): if provided, resample the data to this frequency kwargs: passed to the resample method\n\n\n\nresults.Result.to_str(label=True)\nConvert Result object to a string\n\n\n\nresults.Result.update(*args, **kwargs)\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Results(module, *args, strict=True, **kwargs)\nContainer for storing results\n\n\n\n\n\nName\nDescription\n\n\n\n\nall_results\nIterator over all results, skipping any nested values\n\n\nall_results_dict\nDictionary of all results, skipping any nested values\n\n\nequal_len\nCheck if all results are equal length\n\n\nis_msim\nCheck if this is a MultiSim\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nappend\nThis is activated by adding as well, e.g. results += result\n\n\nflatten\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\nplot\nPlot all the results\n\n\nto_df\nMerge all results dataframes into one\n\n\n\n\n\nresults.Results.append(arg, key=None)\nThis is activated by adding as well, e.g. results += result\n\n\n\nresults.Results.flatten(\n    sep='_',\n    only_results=True,\n    only_auto=False,\n    keep_case=False,\n    **kwargs,\n)\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\n\nresults.Results.plot(style='fancy', fig_kw=None, plot_kw=None)\nPlot all the results\n\n\n\nresults.Results.to_df(sep='_', descend=False, **kwargs)\nMerge all results dataframes into one Args: sep (str): separator for the column names descend (bool): whether to descend into nested results kwargs: passed to the Result.to_df() method, can include instructions for summarizing results by time",
    "crumbs": [
      "**Utilities**",
      "results"
    ]
  },
  {
    "objectID": "api/results.html#classes",
    "href": "api/results.html#classes",
    "title": "results",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nResult\nArray-like container for holding sim results.\n\n\nResults\nContainer for storing results\n\n\n\n\n\nresults.Result(\n    name=None,\n    label=None,\n    dtype=float,\n    shape=None,\n    scale=True,\n    auto_plot=True,\n    module=None,\n    values=None,\n    timevec=None,\n    low=None,\n    high=None,\n    summarize_by=None,\n    **kwargs,\n)\nArray-like container for holding sim results.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodule\nstr\nthe name or label of the parent module, e.g. ‘SIR’\nNone\n\n\nname\nstr\nthe name of this result, e.g. ‘new_infections’\nNone\n\n\nshape\nint / tuple\nthe shape of the result array (usually module.npts)\nNone\n\n\nscale\nbool\nwhether or not the result scales by population size (e.g. a count does, a prevalence does not)\nTrue\n\n\nauto_plot\nbool\nwhether to include automatically in sim.plot() results\nTrue\n\n\nlabel\nstr\na human-readable label for the result\nNone\n\n\nvalues\narray\nprepopulate the Result with these values\nNone\n\n\ntimevec\narray\nan array of time points\nNone\n\n\nlow\narray\nvalues for the lower bound\nNone\n\n\nhigh\narray\nvalues for the upper bound\nNone\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\n\nIn most cases, ss.Result behaves exactly like np.array(), except with the additional fields listed above. To see everything contained in a result, you can use result.disp().\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfull_label\nReturn the full label of the result: : , e.g. “HIV: New infections”\n\n\nhas_dates\nCheck whether the time vector uses dates (rather than numbers)\n\n\nkey\nReturn the unique key of the result: ., e.g. “hiv.new_infections”\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_timevec\nMake sure we’re using a timevec that’s in the right format i.e. dates\n\n\ndisp\nFull display of all attributes/methods\n\n\nfrom_df\nMake a copy of the result with new values from a dataframe\n\n\ninit_values\nHandle values\n\n\nplot\nPlot a single result; kwargs are interpreted as plot_kw\n\n\nresample\nResample the result, e.g. from days to years. Leverages the pandas resample method.\n\n\nto_df\nConvert to a dataframe with timevec, value, low, and high columns\n\n\nto_series\nConvert to a series with timevec as the index and value as the data\n\n\nto_str\nConvert Result object to a string\n\n\nupdate\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Result.convert_timevec(force=False)\nMake sure we’re using a timevec that’s in the right format i.e. dates\n\n\n\nresults.Result.disp()\nFull display of all attributes/methods\n\n\n\nresults.Result.from_df(df)\nMake a copy of the result with new values from a dataframe\n\n\n\nresults.Result.init_values(values=None, dtype=None, shape=None, force=False)\nHandle values\n\n\n\nresults.Result.plot(\n    fig=None,\n    ax=None,\n    fig_kw=None,\n    plot_kw=None,\n    fill_kw=None,\n    **kwargs,\n)\nPlot a single result; kwargs are interpreted as plot_kw\n\n\n\nresults.Result.resample(\n    new_unit='year',\n    summarize_by=None,\n    col_names='vlh',\n    die=False,\n    output_form='series',\n    use_years=False,\n    sep='_',\n)\nResample the result, e.g. from days to years. Leverages the pandas resample method. Accepts all the Starsim units, plus the Pandas ones documented here: https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_unit\nstr\nthe new unit to resample to, e.g. ‘year’, ‘month’, ‘week’, ‘day’, ‘1W’, ‘2M’, etc.\n'year'\n\n\nsummarize_by\nstr\nhow to summarize the data, e.g. ‘sum’ or ‘mean’\nNone\n\n\ncol_names\nstr\nwhether to rename the columns with the name of the result\n'vlh'\n\n\ndie\nbool\nwhether to raise an error if the summarization method cannot be determined\nFalse\n\n\noutput_form\nstr\n‘series’, ‘dataframe’, or ‘result’\n'series'\n\n\nuse_years\nbool\nwhether to use years as the unit of time\nFalse\n\n\n\n\n\n\n\nresults.Result.to_df(\n    sep='_',\n    col_names='vlh',\n    bounds=True,\n    resample=None,\n    set_date_index=False,\n    **kwargs,\n)\nConvert to a dataframe with timevec, value, low, and high columns\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsep\nstr\nseparator for the column names\n'_'\n\n\ncol_names\nstr or None\nif None, uses the name of the result. Default is ‘vlh’ which uses value, low, high\n'vlh'\n\n\nset_date_index\nbool\nif True, use the timevec as the index\nFalse\n\n\nbounds\nbool\ninclude high and low bounds as well (if and only if they exist, e.g. from a MultiSim)\nTrue\n\n\nresample\nstr\nif provided, resample the data to this frequency\nNone\n\n\nkwargs\n\npassed to the resample method if resample=True\n{}\n\n\n\n\n\n\n\nresults.Result.to_series(set_name=False, resample=None, sep='_', **kwargs)\nConvert to a series with timevec as the index and value as the data Args: set_name (bool): whether to set the name of the series to the name of the result resample (str): if provided, resample the data to this frequency kwargs: passed to the resample method\n\n\n\nresults.Result.to_str(label=True)\nConvert Result object to a string\n\n\n\nresults.Result.update(*args, **kwargs)\nUpdate parameters, and initialize values if needed\n\n\n\n\n\nresults.Results(module, *args, strict=True, **kwargs)\nContainer for storing results\n\n\n\n\n\nName\nDescription\n\n\n\n\nall_results\nIterator over all results, skipping any nested values\n\n\nall_results_dict\nDictionary of all results, skipping any nested values\n\n\nequal_len\nCheck if all results are equal length\n\n\nis_msim\nCheck if this is a MultiSim\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nappend\nThis is activated by adding as well, e.g. results += result\n\n\nflatten\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\nplot\nPlot all the results\n\n\nto_df\nMerge all results dataframes into one\n\n\n\n\n\nresults.Results.append(arg, key=None)\nThis is activated by adding as well, e.g. results += result\n\n\n\nresults.Results.flatten(\n    sep='_',\n    only_results=True,\n    only_auto=False,\n    keep_case=False,\n    **kwargs,\n)\nTurn from a nested dictionary into a flat dictionary, keeping only results by default\n\n\n\nresults.Results.plot(style='fancy', fig_kw=None, plot_kw=None)\nPlot all the results\n\n\n\nresults.Results.to_df(sep='_', descend=False, **kwargs)\nMerge all results dataframes into one Args: sep (str): separator for the column names descend (bool): whether to descend into nested results kwargs: passed to the Result.to_df() method, can include instructions for summarizing results by time",
    "crumbs": [
      "**Utilities**",
      "results"
    ]
  },
  {
    "objectID": "api/people.html",
    "href": "api/people.html",
    "title": "people",
    "section": "",
    "text": "people\nDefines the People class and functions associated with making people\n\n\n\n\n\nName\nDescription\n\n\n\n\nPeople\nA class to perform all the operations on the people\n\n\nPerson\nA simple class to hold all attributes of a person\n\n\n\n\n\npeople.People(n_agents, age_data=None, extra_states=None, mock=False)\nA class to perform all the operations on the people This class is usually created automatically by the sim. The only required input argument is the population size, but typically the full parameters dictionary will get passed instead since it will be needed before the People object is initialized.\nNote that this class handles the mechanics of updating the actual people, as well as the additional housekeeping methods (saving, loading, exporting, etc.).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_agents\nint\nthe initial number of agents in the model\nrequired\n\n\nage_data\ndataframe\na dataframe of years and population sizes, if available\nNone\n\n\nextra_states\nlist\nnon-default states to initialize\nNone\n\n\nmock\nbool\nif True, initialize the People object with a mock Sim object (for debugging only)\nFalse\n\n\n\nExamples: ppl = ss.People(2000)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauto_state_list\nList of “automatic” states with boolean type (ss.BoolState)\n\n\ndead\nDead boolean. Also includes removed agents\n\n\nmale\nMale boolean\n\n\nn_agents\nAlias for len(people)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_module\nAdd a Module to the People instance\n\n\ndisp\nFull object information\n\n\nfilter\nStore indices to allow for easy filtering of the People object.\n\n\nfind_children\nFind children whose parents are in the target set\n\n\nget_age_dist\nReturn an age distribution based on provided data\n\n\ngrow\nIncrease the number of agents\n\n\ninit_mock\nInitialize with a mock simulation (for debugging purposes only)\n\n\ninit_results\nInitialize results for People; called during Sim.init_results()\n\n\ninit_vals\nPopulate states with initial values, the final step of initialization\n\n\nlink_sim\nInitialization\n\n\nperson\nGet all the properties for a single person.\n\n\nplot\nPlot all the properties of the People object\n\n\nplot_ages\nPlot the age pyramid for males and females.\n\n\nremove_dead\nRemove agents who are exiting the population (death, migration, etc)\n\n\nrequest_death\nExternal-facing function to request an agent die at the current timestep\n\n\nrequest_removal\nRequest an agent to be removed from the simulation\n\n\nscale_flows\nReturn the scaled versions of the flows – replacement for len(inds)\n\n\nstep_die\nCarry out any deaths or removals that took place this timestep\n\n\nto_df\nExport to dataframe\n\n\nupdate_post\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.People.add_module(module)\nAdd a Module to the People instance\nThis method is used to add a module to the People. It will register any module states with this people instance for dynamic resizing, and expose the module via People, in two ways\n\nPeople.&lt;module&gt; will be a reference to the module itself, enabling access via people.hiv.susceptible\nPeople.states['&lt;module&gt;.&lt;state&gt;'] will be a reference to the state, enabling access via people.states['hiv.susceptible']\n\n\n\n\npeople.People.disp()\nFull object information\n\n\n\npeople.People.filter(criteria=None, uids=None, split=False)\nStore indices to allow for easy filtering of the People object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncriteria\nbool array\na boolean array for the filtering critria\nNone\n\n\nuids\narray\nalternatively, explicitly filter by these indices\nNone\n\n\nsplit\nbool\nif True, return separate People objects matching both True and False\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA filtered People object, which works just like a normal People object\n\n\n\n\nexcept only operates on a subset of indices.\n\n\n\n\n\n\n\npeople.People.find_children(target_parent_uids)\nFind children whose parents are in the target set\n\n\n\npeople.People.get_age_dist(age_data)\nReturn an age distribution based on provided data\nThe data should be provided in the form of either an Nx2 array, a pandas series with age as the index and counts/probability as the value, or a pandas DataFrame with “age” and “value” as columns. Each of these should look like e.g.:\nage      value\n0      220.548\n1      206.188\n2      195.792\n3      187.442\nThe ages will be interpreted as lower bin edges. An upper bin edge will automatically be added based on the final age plus the difference of the last two bins. To explicitly control the width of the upper age bin, add an extra entry to the age_data with a value of 0 and an age value corresponding to the desired upper age bound.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nage_data\n\nAn array/series/dataframe with an index corresponding to age values, and a value corresponding to histogram counts or relative proportions. A distribution will be estimated based on the histogram. The histogram will be assumed to correspond to probability densitiy if the sum of the histogram values is equal to 1, otherwise it will be assumed to correspond to counts.\nrequired\n\n\n\nNote: age_data can also be provided as a string (interpreted as a filename).\nIf no value is provided, uniform ages from 0-60 are created (to match the global mean age of ~30 years).\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn ss.Dist instance that returns an age for newly created agents\n\n\n\n\n\n\n\npeople.People.grow(n=None, new_slots=None)\nIncrease the number of agents\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\n\nInteger number of agents to add\nNone\n\n\nnew_slots\n\nOptionally specify the slots to assign for the new agents. Otherwise, it will default to the new UIDs\nNone\n\n\n\n\n\n\n\npeople.People.init_mock()\nInitialize with a mock simulation (for debugging purposes only)\n\n\n\npeople.People.init_results()\nInitialize results for People; called during Sim.init_results()\nBy default, People reports on counts for any ss.BoolState instances, e.g. if People contains a ss.BoolState called ‘alive’ it will automatically contain a Result for ‘n_alive’. For identical behavior that does not automatically generate results, use ss.BoolArr instead of ss.BoolState.\nThis method also creates the standard people-related results like new_deaths, new_emigrants, and cum_deaths.\n\n\n\npeople.People.init_vals()\nPopulate states with initial values, the final step of initialization\n\n\n\npeople.People.link_sim(sim, init=False)\nInitialization\n\n\n\npeople.People.person(ind)\nGet all the properties for a single person.\nExample:\nsim = ss.Sim(diseases='sir', networks='random', n_agents=100).run()\nprint(sim.people.person(5)) # The 5th agent in the simulation\n\n\n\npeople.People.plot(\n    key=None,\n    alive=True,\n    bins=50,\n    hist_kw=None,\n    max_plots=20,\n    figsize=(16, 12),\n    **kwargs,\n)\nPlot all the properties of the People object\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr / list\nthe state(s) to plot\nNone\n\n\nalive\nbool\nif false, use all agents in the simulation instead of active (alive) ones\nTrue\n\n\nbins\nint\nthe number of bins to use in plt.hist()\n50\n\n\nhist_kw\ndict\npassed to plt.hist()\nNone\n\n\nmax_plots\nint\nthe maximum number of plots to create\n20\n\n\nfigsize\ntuple\npassed to plt.figure(); by default large since the plots are crowded\n(16, 12)\n\n\n**kwargs\ndict\npassed to sc.getrowscols(), including fig_kw\n{}\n\n\n\n\n\n\n\npeople.People.plot_ages(bins=None, absolute=False, fig_kw=None)\nPlot the age pyramid for males and females.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbins\nlist / int\noptional list or int for binning age groups (default: 5-year bins up to max age)\nNone\n\n\nabsolute\nbool\nwhether to show absolute numbers or percentage of the population\nFalse\n\n\nfig_kw\ndict\npassed to plt.subplots()\nNone\n\n\n\nExample:\nsim = ss.demo(plot=False)\nsim.people.plot_age()\n\n\n\n\npeople.People.remove_dead()\nRemove agents who are exiting the population (death, migration, etc)\n\n\n\npeople.People.request_death(uids)\nExternal-facing function to request an agent die at the current timestep\nIn general, users should not directly interact with People.ti_dead to minimize interactions between modules (e.g., if a module requesting a future death, overwrites death due to a different module taking place at the current timestep).\nModules that have a future time of death (e.g., due to disease duration) should keep track of that internally. When the module is ready to cause the agent to die, it should call this method, and can update its own results for the cause of death. This way, if multiple modules request death on the same day, they can each record a death due to their own cause.\nThe actual deaths are resolved after modules have all run, but before analyzers. That way, regardless of whether removing dead agents is enabled or not, analyzers will be able to see and record outcomes for agents that died this timestep.\nWARNING - this function allows multiple modules to each independently carry out and record state changes associated with death. It is therefore important that they can guarantee that after requesting death, the death is guaranteed to occur.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\n\nAgent IDs to request deaths for\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nUIDs of agents that have been scheduled to die on this timestep\n\n\n\n\n\n\n\npeople.People.request_removal(uids)\nRequest an agent to be removed from the simulation Similar to request_death, but in this case the agent will be recorded as removed instead of dead\n\n\n\npeople.People.scale_flows(inds)\nReturn the scaled versions of the flows – replacement for len(inds) followed by scale factor multiplication\n\n\n\npeople.People.step_die()\nCarry out any deaths or removals that took place this timestep\n\n\n\npeople.People.to_df()\nExport to dataframe\n\n\n\npeople.People.update_post()\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.Person()\nA simple class to hold all attributes of a person\nExample:\nsim = ss.Sim(diseases='sir', networks='random', n_agents=100).run()\nprint(sim.people.person(5)) # The 5th agent in the simulation\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_df\nConvert to a dataframe\n\n\n\n\n\npeople.Person.to_df()\nConvert to a dataframe",
    "crumbs": [
      "**Basics**",
      "people"
    ]
  },
  {
    "objectID": "api/people.html#classes",
    "href": "api/people.html#classes",
    "title": "people",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nPeople\nA class to perform all the operations on the people\n\n\nPerson\nA simple class to hold all attributes of a person\n\n\n\n\n\npeople.People(n_agents, age_data=None, extra_states=None, mock=False)\nA class to perform all the operations on the people This class is usually created automatically by the sim. The only required input argument is the population size, but typically the full parameters dictionary will get passed instead since it will be needed before the People object is initialized.\nNote that this class handles the mechanics of updating the actual people, as well as the additional housekeeping methods (saving, loading, exporting, etc.).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_agents\nint\nthe initial number of agents in the model\nrequired\n\n\nage_data\ndataframe\na dataframe of years and population sizes, if available\nNone\n\n\nextra_states\nlist\nnon-default states to initialize\nNone\n\n\nmock\nbool\nif True, initialize the People object with a mock Sim object (for debugging only)\nFalse\n\n\n\nExamples: ppl = ss.People(2000)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauto_state_list\nList of “automatic” states with boolean type (ss.BoolState)\n\n\ndead\nDead boolean. Also includes removed agents\n\n\nmale\nMale boolean\n\n\nn_agents\nAlias for len(people)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_module\nAdd a Module to the People instance\n\n\ndisp\nFull object information\n\n\nfilter\nStore indices to allow for easy filtering of the People object.\n\n\nfind_children\nFind children whose parents are in the target set\n\n\nget_age_dist\nReturn an age distribution based on provided data\n\n\ngrow\nIncrease the number of agents\n\n\ninit_mock\nInitialize with a mock simulation (for debugging purposes only)\n\n\ninit_results\nInitialize results for People; called during Sim.init_results()\n\n\ninit_vals\nPopulate states with initial values, the final step of initialization\n\n\nlink_sim\nInitialization\n\n\nperson\nGet all the properties for a single person.\n\n\nplot\nPlot all the properties of the People object\n\n\nplot_ages\nPlot the age pyramid for males and females.\n\n\nremove_dead\nRemove agents who are exiting the population (death, migration, etc)\n\n\nrequest_death\nExternal-facing function to request an agent die at the current timestep\n\n\nrequest_removal\nRequest an agent to be removed from the simulation\n\n\nscale_flows\nReturn the scaled versions of the flows – replacement for len(inds)\n\n\nstep_die\nCarry out any deaths or removals that took place this timestep\n\n\nto_df\nExport to dataframe\n\n\nupdate_post\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.People.add_module(module)\nAdd a Module to the People instance\nThis method is used to add a module to the People. It will register any module states with this people instance for dynamic resizing, and expose the module via People, in two ways\n\nPeople.&lt;module&gt; will be a reference to the module itself, enabling access via people.hiv.susceptible\nPeople.states['&lt;module&gt;.&lt;state&gt;'] will be a reference to the state, enabling access via people.states['hiv.susceptible']\n\n\n\n\npeople.People.disp()\nFull object information\n\n\n\npeople.People.filter(criteria=None, uids=None, split=False)\nStore indices to allow for easy filtering of the People object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncriteria\nbool array\na boolean array for the filtering critria\nNone\n\n\nuids\narray\nalternatively, explicitly filter by these indices\nNone\n\n\nsplit\nbool\nif True, return separate People objects matching both True and False\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA filtered People object, which works just like a normal People object\n\n\n\n\nexcept only operates on a subset of indices.\n\n\n\n\n\n\n\npeople.People.find_children(target_parent_uids)\nFind children whose parents are in the target set\n\n\n\npeople.People.get_age_dist(age_data)\nReturn an age distribution based on provided data\nThe data should be provided in the form of either an Nx2 array, a pandas series with age as the index and counts/probability as the value, or a pandas DataFrame with “age” and “value” as columns. Each of these should look like e.g.:\nage      value\n0      220.548\n1      206.188\n2      195.792\n3      187.442\nThe ages will be interpreted as lower bin edges. An upper bin edge will automatically be added based on the final age plus the difference of the last two bins. To explicitly control the width of the upper age bin, add an extra entry to the age_data with a value of 0 and an age value corresponding to the desired upper age bound.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nage_data\n\nAn array/series/dataframe with an index corresponding to age values, and a value corresponding to histogram counts or relative proportions. A distribution will be estimated based on the histogram. The histogram will be assumed to correspond to probability densitiy if the sum of the histogram values is equal to 1, otherwise it will be assumed to correspond to counts.\nrequired\n\n\n\nNote: age_data can also be provided as a string (interpreted as a filename).\nIf no value is provided, uniform ages from 0-60 are created (to match the global mean age of ~30 years).\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn ss.Dist instance that returns an age for newly created agents\n\n\n\n\n\n\n\npeople.People.grow(n=None, new_slots=None)\nIncrease the number of agents\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\n\nInteger number of agents to add\nNone\n\n\nnew_slots\n\nOptionally specify the slots to assign for the new agents. Otherwise, it will default to the new UIDs\nNone\n\n\n\n\n\n\n\npeople.People.init_mock()\nInitialize with a mock simulation (for debugging purposes only)\n\n\n\npeople.People.init_results()\nInitialize results for People; called during Sim.init_results()\nBy default, People reports on counts for any ss.BoolState instances, e.g. if People contains a ss.BoolState called ‘alive’ it will automatically contain a Result for ‘n_alive’. For identical behavior that does not automatically generate results, use ss.BoolArr instead of ss.BoolState.\nThis method also creates the standard people-related results like new_deaths, new_emigrants, and cum_deaths.\n\n\n\npeople.People.init_vals()\nPopulate states with initial values, the final step of initialization\n\n\n\npeople.People.link_sim(sim, init=False)\nInitialization\n\n\n\npeople.People.person(ind)\nGet all the properties for a single person.\nExample:\nsim = ss.Sim(diseases='sir', networks='random', n_agents=100).run()\nprint(sim.people.person(5)) # The 5th agent in the simulation\n\n\n\npeople.People.plot(\n    key=None,\n    alive=True,\n    bins=50,\n    hist_kw=None,\n    max_plots=20,\n    figsize=(16, 12),\n    **kwargs,\n)\nPlot all the properties of the People object\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr / list\nthe state(s) to plot\nNone\n\n\nalive\nbool\nif false, use all agents in the simulation instead of active (alive) ones\nTrue\n\n\nbins\nint\nthe number of bins to use in plt.hist()\n50\n\n\nhist_kw\ndict\npassed to plt.hist()\nNone\n\n\nmax_plots\nint\nthe maximum number of plots to create\n20\n\n\nfigsize\ntuple\npassed to plt.figure(); by default large since the plots are crowded\n(16, 12)\n\n\n**kwargs\ndict\npassed to sc.getrowscols(), including fig_kw\n{}\n\n\n\n\n\n\n\npeople.People.plot_ages(bins=None, absolute=False, fig_kw=None)\nPlot the age pyramid for males and females.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbins\nlist / int\noptional list or int for binning age groups (default: 5-year bins up to max age)\nNone\n\n\nabsolute\nbool\nwhether to show absolute numbers or percentage of the population\nFalse\n\n\nfig_kw\ndict\npassed to plt.subplots()\nNone\n\n\n\nExample:\nsim = ss.demo(plot=False)\nsim.people.plot_age()\n\n\n\n\npeople.People.remove_dead()\nRemove agents who are exiting the population (death, migration, etc)\n\n\n\npeople.People.request_death(uids)\nExternal-facing function to request an agent die at the current timestep\nIn general, users should not directly interact with People.ti_dead to minimize interactions between modules (e.g., if a module requesting a future death, overwrites death due to a different module taking place at the current timestep).\nModules that have a future time of death (e.g., due to disease duration) should keep track of that internally. When the module is ready to cause the agent to die, it should call this method, and can update its own results for the cause of death. This way, if multiple modules request death on the same day, they can each record a death due to their own cause.\nThe actual deaths are resolved after modules have all run, but before analyzers. That way, regardless of whether removing dead agents is enabled or not, analyzers will be able to see and record outcomes for agents that died this timestep.\nWARNING - this function allows multiple modules to each independently carry out and record state changes associated with death. It is therefore important that they can guarantee that after requesting death, the death is guaranteed to occur.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuids\n\nAgent IDs to request deaths for\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nUIDs of agents that have been scheduled to die on this timestep\n\n\n\n\n\n\n\npeople.People.request_removal(uids)\nRequest an agent to be removed from the simulation Similar to request_death, but in this case the agent will be recorded as removed instead of dead\n\n\n\npeople.People.scale_flows(inds)\nReturn the scaled versions of the flows – replacement for len(inds) followed by scale factor multiplication\n\n\n\npeople.People.step_die()\nCarry out any deaths or removals that took place this timestep\n\n\n\npeople.People.to_df()\nExport to dataframe\n\n\n\npeople.People.update_post()\nFinal updates at the very end of the timestep\n\n\n\n\n\npeople.Person()\nA simple class to hold all attributes of a person\nExample:\nsim = ss.Sim(diseases='sir', networks='random', n_agents=100).run()\nprint(sim.people.person(5)) # The 5th agent in the simulation\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_df\nConvert to a dataframe\n\n\n\n\n\npeople.Person.to_df()\nConvert to a dataframe",
    "crumbs": [
      "**Basics**",
      "people"
    ]
  },
  {
    "objectID": "api/run.html",
    "href": "api/run.html",
    "title": "run",
    "section": "",
    "text": "run\nUtilities for running in parallel\n\n\n\n\n\nName\nDescription\n\n\n\n\nMultiSim\nClass for running multiple copies of a simulation.\n\n\n\n\n\nrun.MultiSim(\n    sims=None,\n    base_sim=None,\n    label=None,\n    n_runs=4,\n    initialize=False,\n    inplace=True,\n    debug=False,\n    **kwargs,\n)\nClass for running multiple copies of a simulation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsims\nSim / list\na single sim or a list of sims\nNone\n\n\nbase_sim\nSim\nthe sim used for shared properties; if not supplied, the first of the sims provided\nNone\n\n\nlabel\nstr\nthe name of the multisim\nNone\n\n\nn_runs\nint\nif a single sim is provided, the number of replicates (default 4)\n4\n\n\ninitialize\nbool\nwhether or not to initialize the sims (otherwise, initialize them during run)\nFalse\n\n\ninplace\nbool\nwhether to modify the sims in-place (default True); else return new sims\nTrue\n\n\ndebug\nbool\nif True, run in serial\nFalse\n\n\nkwargs\ndict\nstored in run_args and passed to run()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrief\nA single-line display of the MultiSim; same as print(multisim)\n\n\ndisp\nDisplay the full object\n\n\ninit_sims\nInitialize the sims\n\n\nmean\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\nmedian\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\nplot\nPlot all results in the MultiSim object.\n\n\nreduce\nCombine multiple sims into a single sim statistically: by default, use\n\n\nreset\nUndo reduce() by resetting the base sim, which, and results\n\n\nrun\nRun the sims; see ss.multi_run() for additional arguments\n\n\nshow\nPrint a moderate length summary of the MultiSim. See also multisim.disp()\n\n\nshrink\nNot to be confused with reduce(), this shrinks each sim in the msim;\n\n\nsummarize\nSummarize the simulations statistically.\n\n\n\n\n\nrun.MultiSim.brief()\nA single-line display of the MultiSim; same as print(multisim)\n\n\n\nrun.MultiSim.disp()\nDisplay the full object\n\n\n\nrun.MultiSim.init_sims(**kwargs)\nInitialize the sims\n\n\n\nrun.MultiSim.mean(bounds=None, **kwargs)\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\nfloat\nmultiplier on the standard deviation for the upper and lower bounds (default, 2)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.median(quantiles=None, **kwargs)\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\nlist or dict\nupper and lower quantiles (default, 0.1 and 0.9)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.plot(key=None, fig=None, legend=True, **kwargs)\nPlot all results in the MultiSim object.\nIf the MultiSim object has been reduced (i.e. mean or median), then plot the best value and uncertainty bound. Otherwise, plot individual sims.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr\nthe results key to plot (by default, all)\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nfig_kw\ndict\npassed to sc.getrowscols(), then plt.subplots() and plt.figure()\nrequired\n\n\nplot_kw\ndict\npassed to plt.plot()\nrequired\n\n\ndata_kw\ndict\npassed to plt.scatter(), for plotting the data\nrequired\n\n\nstyle_kw\ndict\npassed to sc.options.with_style(), for controlling the detailed plotting style\nrequired\n\n\nfill_kw\ndict\npassed to plt.fill_between()\nrequired\n\n\nlegend_kw\ndict\npassed to plt.legend()\nrequired\n\n\nlegend\nbool\nwhether to show the legend\nTrue\n\n\n**kwargs\ndict\nknown arguments (e.g. figsize, font) split between the above dicts; see ss.plot_args() for all valid options\n{}\n\n\n\n\n\n\n\nrun.MultiSim.reduce(quantiles=None, use_mean=False, bounds=None, output=False)\nCombine multiple sims into a single sim statistically: by default, use the median value and the 10th and 90th percentiles for the lower and upper bounds. If use_mean=True, then use the mean and ±2 standard deviations for lower and upper bounds.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\ndict\nthe quantiles to use, e.g. [0.1, 0.9] or {‘low : ’0.1, ’high’ : 0.9}\nNone\n\n\nuse_mean\nbool\nwhether to use the mean instead of the median\nFalse\n\n\nbounds\nfloat\nif use_mean=True, the multiplier on the standard deviation for upper and lower bounds (default 2)\nNone\n\n\noutput\nbool\nwhether to return the “reduced” sim (in any case, modify the multisim in-place)\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.Sim())\nmsim.run()\nmsim.reduce()\nmsim.summarize()\n\n\n\n\nrun.MultiSim.reset()\nUndo reduce() by resetting the base sim, which, and results\n\n\n\nrun.MultiSim.run(**kwargs)\nRun the sims; see ss.multi_run() for additional arguments\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_runs\nint\nhow many replicates of each sim to run (if a list of sims is not provided)\nrequired\n\n\ninplace\nbool\nwhether to modify the sims in place (otherwise return copies)\nrequired\n\n\nkwargs\ndict\npassed to multi_run(); use run_args to pass arguments to sim.run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nNone (modifies MultiSim object in place)\n\n\n\n\n\n\n\nrun.MultiSim.show(output=False)\nPrint a moderate length summary of the MultiSim. See also multisim.disp() (detailed output) and multisim.brief() (short output).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput\nbool\nif true, return a string instead of printing output\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.demo(run=False), label='Example multisim')\nmsim.run()\nmsim.show() # Prints moderate length output\n\n\n\n\nrun.MultiSim.shrink(**kwargs)\nNot to be confused with reduce(), this shrinks each sim in the msim; see sim.shrink() for more information.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to sim.shrink() for each sim\n{}\n\n\n\n\n\n\n\nrun.MultiSim.summarize(method='mean', quantiles=None, how='default')\nSummarize the simulations statistically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\none of ‘mean’ (default: [mean, 2*std]), ‘median’ ([median, min, max]), or ‘all’ (all results)\n'mean'\n\n\nquantiles\ndict\nif method=‘median’, use these quantiles\nNone\n\n\nhow\nstr\npassed to sim.summarize()\n'default'\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nmulti_run\nFor running multiple sims in parallel. If the first argument is a list of sims\n\n\nparallel\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations\n\n\nsingle_run\nConvenience function to perform a single simulation run. Mostly used for\n\n\n\n\n\nrun.multi_run(\n    sim,\n    n_runs=4,\n    reseed=None,\n    iterpars=None,\n    shrink=None,\n    run_args=None,\n    sim_args=None,\n    par_args=None,\n    do_run=True,\n    parallel=True,\n    n_cpus=None,\n    verbose=None,\n    **kwargs,\n)\nFor running multiple sims in parallel. If the first argument is a list of sims rather than a single sim, exactly these will be run and most other arguments will be ignored.\nNote: n_cpus=1 is not the same thing as setting parallel=False. The former still uses the parallelization methods (just on a single core), while the latter simply runs in a loop.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\nSim / list\nthe sim instance to be run, or a list of sims.\nrequired\n\n\nn_runs (int)\n\nthe number of parallel runs\nrequired\n\n\nreseed (bool)\n\nwhether or not to generate a fresh seed for each run (default: true for single, false for list of sims)\nrequired\n\n\niterpars (dict)\n\nany other parameters to iterate over the runs; see sc.parallelize() for syntax\nrequired\n\n\nshrink (bool)\n\nwhether to shrink the sim after the sim run\nrequired\n\n\nrun_args (dict)\n\narguments passed to sim.run()\nrequired\n\n\nsim_args (dict)\n\nextra parameters to pass to the sim\nrequired\n\n\npar_args (dict)\n\narguments passed to sc.parallelize()\nrequired\n\n\ndo_run (bool)\n\nwhether to actually run the sim (if not, just initialize it)\nrequired\n\n\nparallel (bool)\n\nwhether to run in parallel using multiprocessing (else, just run in a loop)\nrequired\n\n\nn_cpus (int)\n\nthe number of CPUs to run on (if blank, set automatically; otherwise, passed to par_args, and use all cores)\nrequired\n\n\nverbose (int)\n\ndetail to print\nrequired\n\n\nkwargs (dict)\n\nalso passed to the sim\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nIf combine is True, a single sim object with the combined results from each sim.\n\n\n\n\nOtherwise, a list of sim objects (default).\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim()\nsims = ss.multi_run(sim, n_runs=6)\n\n\n\n\nrun.parallel(*args, **kwargs)\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations at once.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nThe simulations to run\n()\n\n\nkwargs\ndict\npassed to multi_run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA run MultiSim object.\n\n\n\nExamples:\ns1 = ss.Sim(n_agents=1000, label='Small', diseases='sis', networks='random')\ns2 = ss.Sim(n_agents=2000, label='Large', diseases='sis', networks='random')\nss.parallel(s1, s2).plot()\nmsim = ss.parallel([s1, s2], shrink=False)\n\n\n\n\nrun.single_run(\n    sim,\n    ind=0,\n    reseed=True,\n    shrink=True,\n    run_args=None,\n    sim_args=None,\n    verbose=None,\n    do_run=True,\n    **kwargs,\n)\nConvenience function to perform a single simulation run. Mostly used for parallelization, but can also be used directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim (Sim)\n\nthe sim instance to be run\nrequired\n\n\nind (int)\n\nthe index of this sim\nrequired\n\n\nreseed (bool)\n\nwhether to generate a fresh seed for each run\nrequired\n\n\nnoise (float)\n\nthe amount of noise to add to each run\nrequired\n\n\nnoisepar (str)\n\nthe name of the parameter to add noise to\nrequired\n\n\nshrink (bool)\n\nwhether to shrink the sim after the sim run\nrequired\n\n\nrun_args (dict)\n\narguments passed to sim.run()\nrequired\n\n\nsim_args (dict)\n\nextra parameters to pass to the sim, e.g. ‘n_infected’\nrequired\n\n\nverbose (int)\n\ndetail to print\nrequired\n\n\ndo_run (bool)\n\nwhether to actually run the sim (if not, just initialize it)\nrequired\n\n\nkwargs (dict)\n\nalso passed to the sim\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsim\nSim\na single sim object with results\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim() # Create a default simulation\nsim = ss.single_run(sim) # Run it, equivalent(ish) to sim.run()",
    "crumbs": [
      "**Workflows**",
      "run"
    ]
  },
  {
    "objectID": "api/run.html#classes",
    "href": "api/run.html#classes",
    "title": "run",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nMultiSim\nClass for running multiple copies of a simulation.\n\n\n\n\n\nrun.MultiSim(\n    sims=None,\n    base_sim=None,\n    label=None,\n    n_runs=4,\n    initialize=False,\n    inplace=True,\n    debug=False,\n    **kwargs,\n)\nClass for running multiple copies of a simulation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsims\nSim / list\na single sim or a list of sims\nNone\n\n\nbase_sim\nSim\nthe sim used for shared properties; if not supplied, the first of the sims provided\nNone\n\n\nlabel\nstr\nthe name of the multisim\nNone\n\n\nn_runs\nint\nif a single sim is provided, the number of replicates (default 4)\n4\n\n\ninitialize\nbool\nwhether or not to initialize the sims (otherwise, initialize them during run)\nFalse\n\n\ninplace\nbool\nwhether to modify the sims in-place (default True); else return new sims\nTrue\n\n\ndebug\nbool\nif True, run in serial\nFalse\n\n\nkwargs\ndict\nstored in run_args and passed to run()\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrief\nA single-line display of the MultiSim; same as print(multisim)\n\n\ndisp\nDisplay the full object\n\n\ninit_sims\nInitialize the sims\n\n\nmean\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\nmedian\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\nplot\nPlot all results in the MultiSim object.\n\n\nreduce\nCombine multiple sims into a single sim statistically: by default, use\n\n\nreset\nUndo reduce() by resetting the base sim, which, and results\n\n\nrun\nRun the sims; see ss.multi_run() for additional arguments\n\n\nshow\nPrint a moderate length summary of the MultiSim. See also multisim.disp()\n\n\nshrink\nNot to be confused with reduce(), this shrinks each sim in the msim;\n\n\nsummarize\nSummarize the simulations statistically.\n\n\n\n\n\nrun.MultiSim.brief()\nA single-line display of the MultiSim; same as print(multisim)\n\n\n\nrun.MultiSim.disp()\nDisplay the full object\n\n\n\nrun.MultiSim.init_sims(**kwargs)\nInitialize the sims\n\n\n\nrun.MultiSim.mean(bounds=None, **kwargs)\nAlias for reduce(use_mean=True). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbounds\nfloat\nmultiplier on the standard deviation for the upper and lower bounds (default, 2)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.median(quantiles=None, **kwargs)\nAlias for reduce(use_mean=False). See reduce() for full description.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\nlist or dict\nupper and lower quantiles (default, 0.1 and 0.9)\nNone\n\n\nkwargs\ndict\npassed to reduce()\n{}\n\n\n\n\n\n\n\nrun.MultiSim.plot(key=None, fig=None, legend=True, **kwargs)\nPlot all results in the MultiSim object.\nIf the MultiSim object has been reduced (i.e. mean or median), then plot the best value and uncertainty bound. Otherwise, plot individual sims.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr\nthe results key to plot (by default, all)\nNone\n\n\nfig\nFigure\nif provided, plot results into an existing figure\nNone\n\n\nfig_kw\ndict\npassed to sc.getrowscols(), then plt.subplots() and plt.figure()\nrequired\n\n\nplot_kw\ndict\npassed to plt.plot()\nrequired\n\n\ndata_kw\ndict\npassed to plt.scatter(), for plotting the data\nrequired\n\n\nstyle_kw\ndict\npassed to sc.options.with_style(), for controlling the detailed plotting style\nrequired\n\n\nfill_kw\ndict\npassed to plt.fill_between()\nrequired\n\n\nlegend_kw\ndict\npassed to plt.legend()\nrequired\n\n\nlegend\nbool\nwhether to show the legend\nTrue\n\n\n**kwargs\ndict\nknown arguments (e.g. figsize, font) split between the above dicts; see ss.plot_args() for all valid options\n{}\n\n\n\n\n\n\n\nrun.MultiSim.reduce(quantiles=None, use_mean=False, bounds=None, output=False)\nCombine multiple sims into a single sim statistically: by default, use the median value and the 10th and 90th percentiles for the lower and upper bounds. If use_mean=True, then use the mean and ±2 standard deviations for lower and upper bounds.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantiles\ndict\nthe quantiles to use, e.g. [0.1, 0.9] or {‘low : ’0.1, ’high’ : 0.9}\nNone\n\n\nuse_mean\nbool\nwhether to use the mean instead of the median\nFalse\n\n\nbounds\nfloat\nif use_mean=True, the multiplier on the standard deviation for upper and lower bounds (default 2)\nNone\n\n\noutput\nbool\nwhether to return the “reduced” sim (in any case, modify the multisim in-place)\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.Sim())\nmsim.run()\nmsim.reduce()\nmsim.summarize()\n\n\n\n\nrun.MultiSim.reset()\nUndo reduce() by resetting the base sim, which, and results\n\n\n\nrun.MultiSim.run(**kwargs)\nRun the sims; see ss.multi_run() for additional arguments\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_runs\nint\nhow many replicates of each sim to run (if a list of sims is not provided)\nrequired\n\n\ninplace\nbool\nwhether to modify the sims in place (otherwise return copies)\nrequired\n\n\nkwargs\ndict\npassed to multi_run(); use run_args to pass arguments to sim.run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nNone (modifies MultiSim object in place)\n\n\n\n\n\n\n\nrun.MultiSim.show(output=False)\nPrint a moderate length summary of the MultiSim. See also multisim.disp() (detailed output) and multisim.brief() (short output).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput\nbool\nif true, return a string instead of printing output\nFalse\n\n\n\nExample:\nmsim = ss.MultiSim(ss.demo(run=False), label='Example multisim')\nmsim.run()\nmsim.show() # Prints moderate length output\n\n\n\n\nrun.MultiSim.shrink(**kwargs)\nNot to be confused with reduce(), this shrinks each sim in the msim; see sim.shrink() for more information.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to sim.shrink() for each sim\n{}\n\n\n\n\n\n\n\nrun.MultiSim.summarize(method='mean', quantiles=None, how='default')\nSummarize the simulations statistically.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\none of ‘mean’ (default: [mean, 2*std]), ‘median’ ([median, min, max]), or ‘all’ (all results)\n'mean'\n\n\nquantiles\ndict\nif method=‘median’, use these quantiles\nNone\n\n\nhow\nstr\npassed to sim.summarize()\n'default'",
    "crumbs": [
      "**Workflows**",
      "run"
    ]
  },
  {
    "objectID": "api/run.html#functions",
    "href": "api/run.html#functions",
    "title": "run",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nmulti_run\nFor running multiple sims in parallel. If the first argument is a list of sims\n\n\nparallel\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations\n\n\nsingle_run\nConvenience function to perform a single simulation run. Mostly used for\n\n\n\n\n\nrun.multi_run(\n    sim,\n    n_runs=4,\n    reseed=None,\n    iterpars=None,\n    shrink=None,\n    run_args=None,\n    sim_args=None,\n    par_args=None,\n    do_run=True,\n    parallel=True,\n    n_cpus=None,\n    verbose=None,\n    **kwargs,\n)\nFor running multiple sims in parallel. If the first argument is a list of sims rather than a single sim, exactly these will be run and most other arguments will be ignored.\nNote: n_cpus=1 is not the same thing as setting parallel=False. The former still uses the parallelization methods (just on a single core), while the latter simply runs in a loop.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\nSim / list\nthe sim instance to be run, or a list of sims.\nrequired\n\n\nn_runs (int)\n\nthe number of parallel runs\nrequired\n\n\nreseed (bool)\n\nwhether or not to generate a fresh seed for each run (default: true for single, false for list of sims)\nrequired\n\n\niterpars (dict)\n\nany other parameters to iterate over the runs; see sc.parallelize() for syntax\nrequired\n\n\nshrink (bool)\n\nwhether to shrink the sim after the sim run\nrequired\n\n\nrun_args (dict)\n\narguments passed to sim.run()\nrequired\n\n\nsim_args (dict)\n\nextra parameters to pass to the sim\nrequired\n\n\npar_args (dict)\n\narguments passed to sc.parallelize()\nrequired\n\n\ndo_run (bool)\n\nwhether to actually run the sim (if not, just initialize it)\nrequired\n\n\nparallel (bool)\n\nwhether to run in parallel using multiprocessing (else, just run in a loop)\nrequired\n\n\nn_cpus (int)\n\nthe number of CPUs to run on (if blank, set automatically; otherwise, passed to par_args, and use all cores)\nrequired\n\n\nverbose (int)\n\ndetail to print\nrequired\n\n\nkwargs (dict)\n\nalso passed to the sim\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nIf combine is True, a single sim object with the combined results from each sim.\n\n\n\n\nOtherwise, a list of sim objects (default).\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim()\nsims = ss.multi_run(sim, n_runs=6)\n\n\n\n\nrun.parallel(*args, **kwargs)\nA shortcut to ss.MultiSim(), allowing the quick running of multiple simulations at once.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nThe simulations to run\n()\n\n\nkwargs\ndict\npassed to multi_run()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA run MultiSim object.\n\n\n\nExamples:\ns1 = ss.Sim(n_agents=1000, label='Small', diseases='sis', networks='random')\ns2 = ss.Sim(n_agents=2000, label='Large', diseases='sis', networks='random')\nss.parallel(s1, s2).plot()\nmsim = ss.parallel([s1, s2], shrink=False)\n\n\n\n\nrun.single_run(\n    sim,\n    ind=0,\n    reseed=True,\n    shrink=True,\n    run_args=None,\n    sim_args=None,\n    verbose=None,\n    do_run=True,\n    **kwargs,\n)\nConvenience function to perform a single simulation run. Mostly used for parallelization, but can also be used directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim (Sim)\n\nthe sim instance to be run\nrequired\n\n\nind (int)\n\nthe index of this sim\nrequired\n\n\nreseed (bool)\n\nwhether to generate a fresh seed for each run\nrequired\n\n\nnoise (float)\n\nthe amount of noise to add to each run\nrequired\n\n\nnoisepar (str)\n\nthe name of the parameter to add noise to\nrequired\n\n\nshrink (bool)\n\nwhether to shrink the sim after the sim run\nrequired\n\n\nrun_args (dict)\n\narguments passed to sim.run()\nrequired\n\n\nsim_args (dict)\n\nextra parameters to pass to the sim, e.g. ‘n_infected’\nrequired\n\n\nverbose (int)\n\ndetail to print\nrequired\n\n\ndo_run (bool)\n\nwhether to actually run the sim (if not, just initialize it)\nrequired\n\n\nkwargs (dict)\n\nalso passed to the sim\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsim\nSim\na single sim object with results\n\n\n\nExample:\nimport starsim as ss\nsim = ss.Sim() # Create a default simulation\nsim = ss.single_run(sim) # Run it, equivalent(ish) to sim.run()",
    "crumbs": [
      "**Workflows**",
      "run"
    ]
  },
  {
    "objectID": "api/analyzers.html",
    "href": "api/analyzers.html",
    "title": "analyzers",
    "section": "",
    "text": "analyzers\nDefine analyzers, which are used to track variables when the sim is run.\nAnalyzers typically include things like additional tracking states by age or another conditional.\n\n\n\n\n\nName\nDescription\n\n\n\n\nAnalyzer\nBase class for Analyzers. Analyzers are used to provide more detailed information\n\n\ndynamics_by_age\nExample analyzer: track dynamics of a state by age.\n\n\ninfection_log\nLog infections – see ss.InfectionLog for detail\n\n\n\n\n\nanalyzers.Analyzer(name=None, label=None, **kwargs)\nBase class for Analyzers. Analyzers are used to provide more detailed information about a simulation than is available by default – for example, pulling states out of sim.people on a particular timestep before they get updated on the next step.\nThe key method of the analyzer is step(), which is called with the sim on each timestep.\n\n\n\nanalyzers.dynamics_by_age(state, age_bins=(0, 20, 40, 100))\nExample analyzer: track dynamics of a state by age.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstate\nstr\nthe name of the state to analyze\nrequired\n\n\nage_bins\nlist\nthe list of age bins to analyze by\n(0, 20, 40, 100)\n\n\n\nExample:\nby_age = ss.dynamics_by_age('sis.infected')\n\nsim = ss.Sim(diseases='sis', networks='random', analyzers=by_age)\nsim.run()\nsim.analyzers[0].plot() # Note: if Sim(copy_inputs=False), we can also use by_age.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfinalize_results\nConvert to an array\n\n\n\n\n\nanalyzers.dynamics_by_age.finalize_results()\nConvert to an array\n\n\n\n\n\nanalyzers.infection_log()\nLog infections – see ss.InfectionLog for detail\nThis analyzer activates an infection log running in each disease. This is different than other analyzers, but is required since the information required to create an infection log isn’t kept outside of the disease’s infect() step.\nExample:\nimport starsim as ss\nsim = ss.Sim(n_agents=1000, dt=0.2, dur=15, diseases='sir', networks='random', analyzers='infection_log')\nsim.run()\nsim.analyzers[0].plot()\n\n\n\n\n\nName\nDescription\n\n\n\n\nanimate\nAnimate the infection log – mostly for amusement!\n\n\nfinalize_results\nCollect the infection logs from each of the diseases\n\n\nplot\nPlot all of the infection logs\n\n\nstep\nHandled by ss.InfectionLog()\n\n\n\n\n\nanalyzers.infection_log.animate(\n    key=0,\n    framerate=10,\n    clear=False,\n    cmap='parula',\n    **kwargs,\n)\nAnimate the infection log – mostly for amusement!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nint / str\nwhich disease to animate the infection log of\n0\n\n\nframerate\nfloat\nhow many frames per second to display\n10\n\n\nclear\nbool\nwhether to clear the frame on each step\nFalse\n\n\ncmap\nstr\nthe colormap to use\n'parula'\n\n\n\n\n\n\n\nanalyzers.infection_log.finalize_results()\nCollect the infection logs from each of the diseases\n\n\n\nanalyzers.infection_log.plot(**kwargs)\nPlot all of the infection logs\n\n\n\nanalyzers.infection_log.step()\nHandled by ss.InfectionLog()",
    "crumbs": [
      "**Modules**",
      "analyzers"
    ]
  },
  {
    "objectID": "api/analyzers.html#classes",
    "href": "api/analyzers.html#classes",
    "title": "analyzers",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAnalyzer\nBase class for Analyzers. Analyzers are used to provide more detailed information\n\n\ndynamics_by_age\nExample analyzer: track dynamics of a state by age.\n\n\ninfection_log\nLog infections – see ss.InfectionLog for detail\n\n\n\n\n\nanalyzers.Analyzer(name=None, label=None, **kwargs)\nBase class for Analyzers. Analyzers are used to provide more detailed information about a simulation than is available by default – for example, pulling states out of sim.people on a particular timestep before they get updated on the next step.\nThe key method of the analyzer is step(), which is called with the sim on each timestep.\n\n\n\nanalyzers.dynamics_by_age(state, age_bins=(0, 20, 40, 100))\nExample analyzer: track dynamics of a state by age.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstate\nstr\nthe name of the state to analyze\nrequired\n\n\nage_bins\nlist\nthe list of age bins to analyze by\n(0, 20, 40, 100)\n\n\n\nExample:\nby_age = ss.dynamics_by_age('sis.infected')\n\nsim = ss.Sim(diseases='sis', networks='random', analyzers=by_age)\nsim.run()\nsim.analyzers[0].plot() # Note: if Sim(copy_inputs=False), we can also use by_age.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfinalize_results\nConvert to an array\n\n\n\n\n\nanalyzers.dynamics_by_age.finalize_results()\nConvert to an array\n\n\n\n\n\nanalyzers.infection_log()\nLog infections – see ss.InfectionLog for detail\nThis analyzer activates an infection log running in each disease. This is different than other analyzers, but is required since the information required to create an infection log isn’t kept outside of the disease’s infect() step.\nExample:\nimport starsim as ss\nsim = ss.Sim(n_agents=1000, dt=0.2, dur=15, diseases='sir', networks='random', analyzers='infection_log')\nsim.run()\nsim.analyzers[0].plot()\n\n\n\n\n\nName\nDescription\n\n\n\n\nanimate\nAnimate the infection log – mostly for amusement!\n\n\nfinalize_results\nCollect the infection logs from each of the diseases\n\n\nplot\nPlot all of the infection logs\n\n\nstep\nHandled by ss.InfectionLog()\n\n\n\n\n\nanalyzers.infection_log.animate(\n    key=0,\n    framerate=10,\n    clear=False,\n    cmap='parula',\n    **kwargs,\n)\nAnimate the infection log – mostly for amusement!\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nint / str\nwhich disease to animate the infection log of\n0\n\n\nframerate\nfloat\nhow many frames per second to display\n10\n\n\nclear\nbool\nwhether to clear the frame on each step\nFalse\n\n\ncmap\nstr\nthe colormap to use\n'parula'\n\n\n\n\n\n\n\nanalyzers.infection_log.finalize_results()\nCollect the infection logs from each of the diseases\n\n\n\nanalyzers.infection_log.plot(**kwargs)\nPlot all of the infection logs\n\n\n\nanalyzers.infection_log.step()\nHandled by ss.InfectionLog()",
    "crumbs": [
      "**Modules**",
      "analyzers"
    ]
  },
  {
    "objectID": "api/parameters.html",
    "href": "api/parameters.html",
    "title": "parameters",
    "section": "",
    "text": "parameters\nSet parameters\n\n\n\n\n\nName\nDescription\n\n\n\n\nPars\nDict-like container of parameters\n\n\nSimPars\nCreate the parameters for the simulation. Typically, this function is used\n\n\n\n\n\nparameters.Pars(pars=None, **kwargs)\nDict-like container of parameters\nActs like an sc.objdict(), except that adding new keys are disallowed by default, and auto-updates known types.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_key_mismatch\nCheck whether additional keys are being added to the dictionary\n\n\ndict_update\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\nto_json\nConvert to JSON representation\n\n\nupdate\nUpdate internal dict with new pars.\n\n\n\n\n\nparameters.Pars.check_key_mismatch(pars)\nCheck whether additional keys are being added to the dictionary\n\n\n\nparameters.Pars.dict_update(*args, **kwargs)\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\n\nparameters.Pars.to_json(**kwargs)\nConvert to JSON representation\n\n\n\nparameters.Pars.update(pars=None, create=False, **kwargs)\nUpdate internal dict with new pars.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\ndict\nthe parameters to update (if None, do nothing)\nNone\n\n\ncreate\nbool\nif create is False, then raise a KeyNotFoundError if the key does not already exist\nFalse\n\n\nkwargs\ndict\nmerged with pars\n{}\n\n\n\n\n\n\n\n\n\nparameters.SimPars(pars=None, create=True, **kwargs)\nCreate the parameters for the simulation. Typically, this function is used internally rather than called by the user; e.g. typical use would be to do sim = ss.Sim() and then inspect sim.pars, rather than calling this function directly.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel\nstr\nThe name of the simulation\nrequired\n\n\nn_agents\nint / float\nThe number of agents to run (default 10,000)\nrequired\n\n\ntotal_pop\nint / float\nIf provided, scale the agents to this effective population size\nrequired\n\n\npop_scale\nfloat\nIf provided, use this agent-to-population scale factor (total_pop = n_agents*pop_scale)\nrequired\n\n\nunit\nstr\nThe time unit for the simulation (default ‘year’; other choices are ‘day’, ‘week’, ‘month’)\nrequired\n\n\nstart\nfloat / str / date\nThe starting date for the simulation (default 2000); can be a year or date\nrequired\n\n\nstop\nfloat / str / date\nIf provided, the ending date for the simulation (if not provided, calculate from “dur”)\nrequired\n\n\ndur\nint\nHow many timesteps to simulate, if “stop” is not provided (default 50)\nrequired\n\n\ndt\nfloat\nThe timestep, in units of “unit” (default 1.0)\nrequired\n\n\nrand_seed\nint\nThe overall random seed for the simulation (used to set module-specific random seeds)\nrequired\n\n\nbirth_rate\nfloat\nIf provided, include births with this rate (per 1000 people per year)\nrequired\n\n\ndeath_rate\nfloat\nIf provided, include deaths with this rate (per 1000 people per year)\nrequired\n\n\nuse_aging\nbool\nSpecify whether agents age (by default, agents age if and only if births and/or deaths are included)\nrequired\n\n\npeople\nPeople\nIf provided, use a pre-existing People object rather than creating one (in which case n_agents will be ignored)\nrequired\n\n\nnetworks\nstr / list / Module\nThe network module(s); can be a string, single module (i.e. Network), or list\nrequired\n\n\ndemographics\nstr / list / Module\nAs above\nrequired\n\n\ndiseases\nstr / list / Module\nAs above\nrequired\n\n\nconnectors\nstr / list / Module\nAs above\nrequired\n\n\ninterventions\nstr / list / Module\nAs above\nrequired\n\n\nanalyzers\nstr / list / Module\nAs above\nrequired\n\n\nverbose\nfloat\nHow much detail to print (1 = every timestep, 0.1 = every 10 timesteps, etc.)\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_modules\nConvert different types of representations for modules into a\n\n\nis_default\nCheck if the provided value matches the default\n\n\nvalidate\nCall parameter validation methods\n\n\nvalidate_agents\nCheck that n_agents is supplied and convert to an integer\n\n\nvalidate_demographics\nValidate demographics-related input parameters\n\n\nvalidate_modules\nValidate modules passed in pars\n\n\nvalidate_networks\nValidate networks\n\n\nvalidate_sim_pars\nValidate each of the parameter values\n\n\nvalidate_total_pop\nEnsure one but not both of total_pop and pop_scale are defined\n\n\nvalidate_verbose\nValidate verbosity\n\n\n\n\n\nparameters.SimPars.convert_modules()\nConvert different types of representations for modules into a standardized object representation that can be parsed and used by a Sim object\n\n\n\nparameters.SimPars.is_default(key)\nCheck if the provided value matches the default\n\n\n\nparameters.SimPars.validate()\nCall parameter validation methods\n\n\n\nparameters.SimPars.validate_agents()\nCheck that n_agents is supplied and convert to an integer\n\n\n\nparameters.SimPars.validate_demographics()\nValidate demographics-related input parameters\n\n\n\nparameters.SimPars.validate_modules()\nValidate modules passed in pars\n\n\n\nparameters.SimPars.validate_networks()\nValidate networks\n\n\n\nparameters.SimPars.validate_sim_pars()\nValidate each of the parameter values\n\n\n\nparameters.SimPars.validate_total_pop()\nEnsure one but not both of total_pop and pop_scale are defined\n\n\n\nparameters.SimPars.validate_verbose()\nValidate verbosity",
    "crumbs": [
      "**Basics**",
      "parameters"
    ]
  },
  {
    "objectID": "api/parameters.html#classes",
    "href": "api/parameters.html#classes",
    "title": "parameters",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nPars\nDict-like container of parameters\n\n\nSimPars\nCreate the parameters for the simulation. Typically, this function is used\n\n\n\n\n\nparameters.Pars(pars=None, **kwargs)\nDict-like container of parameters\nActs like an sc.objdict(), except that adding new keys are disallowed by default, and auto-updates known types.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_key_mismatch\nCheck whether additional keys are being added to the dictionary\n\n\ndict_update\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\nto_json\nConvert to JSON representation\n\n\nupdate\nUpdate internal dict with new pars.\n\n\n\n\n\nparameters.Pars.check_key_mismatch(pars)\nCheck whether additional keys are being added to the dictionary\n\n\n\nparameters.Pars.dict_update(*args, **kwargs)\nRedefine default dict.update(), since overwritten in this class; should not usually be used\n\n\n\nparameters.Pars.to_json(**kwargs)\nConvert to JSON representation\n\n\n\nparameters.Pars.update(pars=None, create=False, **kwargs)\nUpdate internal dict with new pars.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\ndict\nthe parameters to update (if None, do nothing)\nNone\n\n\ncreate\nbool\nif create is False, then raise a KeyNotFoundError if the key does not already exist\nFalse\n\n\nkwargs\ndict\nmerged with pars\n{}\n\n\n\n\n\n\n\n\n\nparameters.SimPars(pars=None, create=True, **kwargs)\nCreate the parameters for the simulation. Typically, this function is used internally rather than called by the user; e.g. typical use would be to do sim = ss.Sim() and then inspect sim.pars, rather than calling this function directly.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel\nstr\nThe name of the simulation\nrequired\n\n\nn_agents\nint / float\nThe number of agents to run (default 10,000)\nrequired\n\n\ntotal_pop\nint / float\nIf provided, scale the agents to this effective population size\nrequired\n\n\npop_scale\nfloat\nIf provided, use this agent-to-population scale factor (total_pop = n_agents*pop_scale)\nrequired\n\n\nunit\nstr\nThe time unit for the simulation (default ‘year’; other choices are ‘day’, ‘week’, ‘month’)\nrequired\n\n\nstart\nfloat / str / date\nThe starting date for the simulation (default 2000); can be a year or date\nrequired\n\n\nstop\nfloat / str / date\nIf provided, the ending date for the simulation (if not provided, calculate from “dur”)\nrequired\n\n\ndur\nint\nHow many timesteps to simulate, if “stop” is not provided (default 50)\nrequired\n\n\ndt\nfloat\nThe timestep, in units of “unit” (default 1.0)\nrequired\n\n\nrand_seed\nint\nThe overall random seed for the simulation (used to set module-specific random seeds)\nrequired\n\n\nbirth_rate\nfloat\nIf provided, include births with this rate (per 1000 people per year)\nrequired\n\n\ndeath_rate\nfloat\nIf provided, include deaths with this rate (per 1000 people per year)\nrequired\n\n\nuse_aging\nbool\nSpecify whether agents age (by default, agents age if and only if births and/or deaths are included)\nrequired\n\n\npeople\nPeople\nIf provided, use a pre-existing People object rather than creating one (in which case n_agents will be ignored)\nrequired\n\n\nnetworks\nstr / list / Module\nThe network module(s); can be a string, single module (i.e. Network), or list\nrequired\n\n\ndemographics\nstr / list / Module\nAs above\nrequired\n\n\ndiseases\nstr / list / Module\nAs above\nrequired\n\n\nconnectors\nstr / list / Module\nAs above\nrequired\n\n\ninterventions\nstr / list / Module\nAs above\nrequired\n\n\nanalyzers\nstr / list / Module\nAs above\nrequired\n\n\nverbose\nfloat\nHow much detail to print (1 = every timestep, 0.1 = every 10 timesteps, etc.)\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_modules\nConvert different types of representations for modules into a\n\n\nis_default\nCheck if the provided value matches the default\n\n\nvalidate\nCall parameter validation methods\n\n\nvalidate_agents\nCheck that n_agents is supplied and convert to an integer\n\n\nvalidate_demographics\nValidate demographics-related input parameters\n\n\nvalidate_modules\nValidate modules passed in pars\n\n\nvalidate_networks\nValidate networks\n\n\nvalidate_sim_pars\nValidate each of the parameter values\n\n\nvalidate_total_pop\nEnsure one but not both of total_pop and pop_scale are defined\n\n\nvalidate_verbose\nValidate verbosity\n\n\n\n\n\nparameters.SimPars.convert_modules()\nConvert different types of representations for modules into a standardized object representation that can be parsed and used by a Sim object\n\n\n\nparameters.SimPars.is_default(key)\nCheck if the provided value matches the default\n\n\n\nparameters.SimPars.validate()\nCall parameter validation methods\n\n\n\nparameters.SimPars.validate_agents()\nCheck that n_agents is supplied and convert to an integer\n\n\n\nparameters.SimPars.validate_demographics()\nValidate demographics-related input parameters\n\n\n\nparameters.SimPars.validate_modules()\nValidate modules passed in pars\n\n\n\nparameters.SimPars.validate_networks()\nValidate networks\n\n\n\nparameters.SimPars.validate_sim_pars()\nValidate each of the parameter values\n\n\n\nparameters.SimPars.validate_total_pop()\nEnsure one but not both of total_pop and pop_scale are defined\n\n\n\nparameters.SimPars.validate_verbose()\nValidate verbosity",
    "crumbs": [
      "**Basics**",
      "parameters"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html",
    "href": "tutorials/t2_model.html",
    "title": "T2 - Building your model",
    "section": "",
    "text": "The purpose of this tutorial is to introduce you to the idea of model components. In brief, these are: people, demographics, networks, diseases, interventions, analyzers, and connectors. Within Starsim, these are the ingredients of a model. On a more basic level, you can think of these as the ingredients of an epidemic. Because Starsim is intended to be very modular, you can build up all these things independently and then piece them together to make a model. Or, if that’s too complex for your needs, there are also shortcuts you can take to make life simpler!\nIn this tutorial we’ll focus on people, demographics, networks, diseases. The remaining components (interventions, analyzers, and connectors) will be covered later.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#simple-sir-model",
    "href": "tutorials/t2_model.html#simple-sir-model",
    "title": "T2 - Building your model",
    "section": "Simple SIR model",
    "text": "Simple SIR model\nLet’s revisit the simple SIR model from Tutorial 1:\n\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 5_000,     # Number of agents to simulate\n    networks = dict(      # *Networks* add detail on how the agents interact with each other \n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 4    # Each person has an average of 4 contacts with other people\n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model \n        type = 'sir',     # Here, we're creating an SIR disease \n        init_prev = 0.1,  # Proportion of the population initially infected \n        beta = 0.1,       # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\n\nInitializing sim with 5000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.16 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.18 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.20 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.21 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.23 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nNow let’s look at the pars dictionary in more detail. The one we’ve created here has 3 things in it: the number of agents (n_agents), detail on how the agents interact with each other (networks) and detail on what disease we’re modeling (diseases). When we create and run the model, what happens ‘under the hood’ is that the simulation creates 5,000 people, and allows them to the interact with one another over the network and transmit the infection.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#simple-sir-model-built-with-components",
    "href": "tutorials/t2_model.html#simple-sir-model-built-with-components",
    "title": "T2 - Building your model",
    "section": "Simple SIR model built with components",
    "text": "Simple SIR model built with components\nThe example above is a nice simple way to get started, but you might want to have more control over the networks, diseases, and people that you’re creating. Here’s another version of the exact same model, but written slightly differently:\n\npeople = ss.People(n_agents=5_000)\nnetwork = ss.RandomNet(n_contacts=4)\nsir = ss.SIR(init_prev=0.1, beta=0.1)\nsim = ss.Sim(diseases=sir, people=people, networks=network)\nsim.run()\nsim.plot()\n\nInitializing sim with 5000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.02 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.04 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.06 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.07 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.09 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nRather than bundling everything under pars, we’re now defining components individually for people, networks, and diseases. As for the disease/network details, instead of putting all information in one bucket (pars['diseases'] = dict(name='sir', init_prev=0.1, beta=0.1)), we’re now using ss.SIR()which serves as a prepared ‘template’ where we fill in the details. This new way provides us more flexibility to adjust details of the disease as we need.\nDon’t worry if you have not seen or used these ‘templates’ (called custom classes in programming) before, but imagine them as special containers that come with predefined tools (aka built-in methods) to streamline your modelling process. Even if you’re not an expert programmer, these ‘templates’ are intuitive to use and they will serve as our go-to solution as we move through the examples.\nNow, let’s look at a few useful ways to improve our model by extending these three components (people, networks, and diseases).",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#making-changes-to-our-components",
    "href": "tutorials/t2_model.html#making-changes-to-our-components",
    "title": "T2 - Building your model",
    "section": "Making changes to our components",
    "text": "Making changes to our components\nOne of the main advantages of agent-based models is they allow you to capture heterogeneity between people. In real life, it’s not realistic that everyone in a population has the same number of contacts with other people. Let’s make our contact network more realistic by adding some variation here. For this, we’ll use a Poisson distribution. The two lines below both do the same thing:\n\nnetwork = ss.RandomNet(n_contacts= ss.poisson(4))\nnetwork = ss.RandomNet(n_contacts=dict(type='poisson', lam=4))\n\nIf we use this network, our agents will have varying numbers of contacts.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#accessing-results",
    "href": "tutorials/t2_model.html#accessing-results",
    "title": "T2 - Building your model",
    "section": "Accessing results",
    "text": "Accessing results\nOnce you’ve run a model, you will want to see what the results look like! We’ve seen a few basic plotting commands above, but if you want to inspect the results for yourself, you can take a look in sim.results. This is a dictionary with keys corresponding to core components of interest. For example, the sim we created in the code block above will have the following keys: ['n_alive', 'new_deaths', 'births', 'deaths', 'sir']. Then sim.results.sir is also a dictionary and contains all the results relating to this disease over time. For example, new_infections is a kind of array showing annual new infections.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#matters-of-time",
    "href": "tutorials/t2_model.html#matters-of-time",
    "title": "T2 - Building your model",
    "section": "Matters of time",
    "text": "Matters of time\nThe default for Starsim models is the start simulations in 1995 and simulate with an annual timestep for 35 years. All of this can be easily changed within the main pars dictionary or by passing alternative values straight to the sim, e.g. \n\nsim = ss.Sim(start='2020-01-01', stop='2021-01-01', dt=ss.months(1), diseases='sis', networks=network)  # Simulate from 2020 for 1 year with a monthly timestep\nsim.run().plot()\n\nInitializing sim with 10000 agents\n  Running 2020.01.01 ( 0/13) (0.00 s)  •——————————————————— 8%\n  Running 2020.11.01 (10/13) (0.03 s)  ••••••••••••••••———— 85%\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#loading-and-saving",
    "href": "tutorials/t2_model.html#loading-and-saving",
    "title": "T2 - Building your model",
    "section": "Loading and saving",
    "text": "Loading and saving\nYou can save a sim to disk with sim.save(), and then reload it:\n\nsim.save('example.sim')\nnew_sim = ss.load('example.sim')\n\nBy default, to save space, this saves a “shrunken” version of the sim with most of the large objects (e.g. the People) removed. To save everything (for example, if you want to save a partially run sim, then reload it and continue running), you can use shrink=False:\n\nsim.save('example-big.sim', shrink=False)\n\n'/home/cliffk/idm/starsim/docs/tutorials/example-big.sim'\n\n\nAll Starsim objects can also be saved via ss.save(); this will save the entire object. This is useful for quickly storing objects for use by other Python functions, for example:\n\ndf = sim.to_df()\nss.save('example.df', df)\nnew_df = ss.load('example.df')\n\nHowever, for a human-readable format, you may want to use a different format. For example, if you’ve exported the results as a dataframe, you can then save as an Excel file:\n\ndf.to_excel('example.xlsx')",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#summary",
    "href": "tutorials/t2_model.html#summary",
    "title": "T2 - Building your model",
    "section": "Summary",
    "text": "Summary\nYou’ve now seen how to create models using the “sim” class (ss.Sim), either by defining a dictionary of parameters or by passing in sim components (demographics, people, diseases, and networks). This means you’ve got the basic skills needed to start making models to answer a range of different questions. We’ll close this tutorial with a few examples that you might like to try out for yourself.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/t2_model.html#exercises",
    "href": "tutorials/t2_model.html#exercises",
    "title": "T2 - Building your model",
    "section": "Exercises",
    "text": "Exercises\n\nHow would you model an outbreak of an SIR-like disease within a refugee camp of 20,000 people? Suppose you were interested in the cumulative number of people who got infected over 1 year - how would you find this out?\nWhether an epidemic ‘takes off’ depends to a large extent on the basic reproduction number, which is the expected number of cases that an infected individual generates. In an agent based model like the one we’ve created here, that depends largely on three things: beta (the transmissibility parameter for the disease), n_contacts (the number of contacts each person has), and dur_inf (another disease-related parameter that determines the duration of infection). Experiment with different values for each of these and compare the trajectory of sim.results.sir.n_infected with different parameter values.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T2 - Building your model"
    ]
  },
  {
    "objectID": "tutorials/solutions.html",
    "href": "tutorials/solutions.html",
    "title": "Solutions",
    "section": "",
    "text": "These are the solutions to the problems from each of the tutorials. (Note: Some solutions are still pending, but email us if you’re impatient!)\nLet’s start with the simplest version of a Starsim model. We’ll make a version of a classic SIR model. Here’s how our code would look:",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/solutions.html#t1-solutions",
    "href": "tutorials/solutions.html#t1-solutions",
    "title": "Solutions",
    "section": "T1 Solutions",
    "text": "T1 Solutions\n\nQuestion 1\nQ: To simulate a susceptible-infectious-susceptible (SIS) model instead of SIR, what would we change in the example above?\nA: We would simply change 'sir' to 'sis':\n\nimport starsim as ss\nimport sciris as sc\n\n# Define the parameters\npars = sc.objdict( # We use objdict to allow \".\" access\n    n_agents = 10_000,\n    networks = sc.objdict(\n        type = 'random',\n        n_contacts = 10,\n    ),\n    diseases = sc.objdict(\n        type = 'sis', # &lt;-- change this\n        init_prev = 0.01,\n        beta = 0.05,\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\nsim.diseases.sis.plot() # &lt;-- change this\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.18 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.21 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.25 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.28 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.31 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\n\n\nQuestion 2\nQ: How do the results change if we increase/decrease beta?\nIncreasing beta makes the curves steeper:\n\npars.diseases.type = 'sir' # Switch back to SIR\npars2 = sc.dcp(pars) # copy to new dictionary\npars2.diseases.beta = 0.10\nsim2 = ss.Sim(pars2).run()\nsim2.diseases.sir.plot()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.03 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.07 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.10 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.13 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.16 s)  •••••••••••••••••••• 100%\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nDecreasing beta makes the curves shallower:\n\npars3 = sc.dcp(pars)\npars3.diseases.beta = 0.02\nsim3 = ss.Sim(pars3).run()\nsim3.diseases.sir.plot()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.03 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.07 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.10 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.13 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.17 s)  •••••••••••••••••••• 100%\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\n\n\nQuestion 3\nQ: How do the results change if we reduce the number of agents to 200?\nWe get a similar result as before, except less smooth, since random effects are more important with small numbers of agents:\n\npars4 = sc.dcp(pars)\npars4.n_agents = 200\nsim4 = ss.Sim(pars4).run()\nsim4.diseases.sir.plot()\n\nInitializing sim with 200 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.01 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.02 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.04 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.05 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.06 s)  •••••••••••••••••••• 100%\n\nFigure(672x480)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/solutions.html#t2-solutions",
    "href": "tutorials/solutions.html#t2-solutions",
    "title": "Solutions",
    "section": "T2 Solutions",
    "text": "T2 Solutions\n\nQuestion 1\nQ: How would you model an outbreak of an SIR-like disease within a refugee camp of 2,000 people? Suppose you were interested in the cumulative number of people who got infected over 1 year - how would you find this out?\nThe answer obviously depends on the disease parameters. However, we can make some simple assumptions and use cum_infections to determine the total number of infections:\n\nimport starsim as ss\nimport sciris as sc\n\npars = sc.objdict(\n    n_agents = 2_000,\n    start = '2025-01-01',\n    dur = 365,\n    dt = 'day',\n    verbose = 1/30, # Print every month\n)\nsir = ss.SIR(\n    dur_inf = ss.days(14),\n    beta = ss.perday(0.02),\n    init_prev = 0.001,\n)\nnet = ss.RandomNet(n_contacts=4)\n\nsim = ss.Sim(pars, diseases=sir, networks=net)\nsim.init()\nsim.run()\nsim.plot()\n\nanswer = sim.results.sir.cum_infections[-1]\nprint(f'Cumulative infections over one year: {answer}')\n\nInitializing sim with 2000 agents\n  Running 2025.01.01 ( 0/366) (0.00 s)  ———————————————————— 0%\n  Running 2025.01.31 (30/366) (0.04 s)  •——————————————————— 8%\n  Running 2025.03.02 (60/366) (0.08 s)  •••————————————————— 17%\n  Running 2025.04.01 (90/366) (0.13 s)  ••••———————————————— 25%\n  Running 2025.05.01 (120/366) (0.17 s)  ••••••—————————————— 33%\n  Running 2025.05.31 (150/366) (0.21 s)  ••••••••———————————— 41%\n  Running 2025.06.30 (180/366) (0.25 s)  •••••••••——————————— 49%\n  Running 2025.07.30 (210/366) (0.28 s)  •••••••••••————————— 58%\n  Running 2025.08.29 (240/366) (0.32 s)  •••••••••••••——————— 66%\n  Running 2025.09.28 (270/366) (0.36 s)  ••••••••••••••—————— 74%\n  Running 2025.10.28 (300/366) (0.40 s)  ••••••••••••••••———— 82%\n  Running 2025.11.27 (330/366) (0.44 s)  ••••••••••••••••••—— 90%\n  Running 2025.12.27 (360/366) (0.47 s)  •••••••••••••••••••— 99%\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nCumulative infections over one year: 411.0",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/solutions.html#question-2-1",
    "href": "tutorials/solutions.html#question-2-1",
    "title": "Solutions",
    "section": "Question 2",
    "text": "Question 2\nSolution pending.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/solutions.html#t3-solutions",
    "href": "tutorials/solutions.html#t3-solutions",
    "title": "Solutions",
    "section": "T3 Solutions",
    "text": "T3 Solutions\n\nQuestion 1\nQ: In Niger, the crude birth rate is 45 and the crude death rate is 9. Assuming these rates stay constant, and starting with a total population of 24 million in 2020, how many people will there be in 2040? (You do not need to include any diseases in your model.)\nA: We can build our simple demographic model with these parameters, then run it and plot the results:\n\nimport starsim as ss\nimport sciris as sc\n\npars = sc.objdict(\n    start = 2020,\n    stop = 2040,\n    total_pop = 24e6,\n    birth_rate = 45,\n    death_rate = 9,\n)\nsim = ss.Sim(pars)\nsim.run()\nsim.plot('n_alive')\n\nanswer = sim.results.n_alive[-1]/1e6\nprint(f'Population size in year {pars.stop}: {answer} million')\n\nInitializing sim with 10000 agents\n  Running 2020.01.01 ( 0/21) (0.00 s)  ———————————————————— 5%\n  Running 2030.01.01 (10/21) (0.01 s)  ••••••••••—————————— 52%\n  Running 2040.01.01 (20/21) (0.02 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nPopulation size in year 2040: 49.7592 million",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/solutions.html#t4-solutions",
    "href": "tutorials/solutions.html#t4-solutions",
    "title": "Solutions",
    "section": "T4 Solutions",
    "text": "T4 Solutions\n\nQuestion 1\nSolution pending.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/solutions.html#t5-solutions",
    "href": "tutorials/solutions.html#t5-solutions",
    "title": "Solutions",
    "section": "T5 Solutions",
    "text": "T5 Solutions\n\nQuestion 1\nSolution pending.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/solutions.html#t6-solutions",
    "href": "tutorials/solutions.html#t6-solutions",
    "title": "Solutions",
    "section": "T6 Solutions",
    "text": "T6 Solutions\n\nQuestion 1\nQ: If we change the disease from SIR to SIS and set coverage to 100%, what minimum efficacy of vaccine is required to eradicate the disease by 2050?\nA: There are many ways we could solve this, including with formal numerical optimization packages. However, since we are only varying a single parameter, we can also just use a simple binay search or grid search. This solution illustrates both approaches.\n\nimport numpy as np\nimport sciris as sc\nimport starsim as ss\n\npars = dict(\n    n_agents = 5_000,\n    birth_rate = 20,\n    death_rate = 15,\n    networks = dict(\n        type = 'random',\n        n_contacts = 4\n    ),\n    diseases = dict(\n        type = 'sis',\n        dur_inf = 10,\n        beta = 0.1,\n    ),\n    verbose = False,\n)\n\nclass sis_vaccine(ss.Vx):\n    \"\"\" A simple vaccine against \"SIS\" \"\"\"\n    def __init__(self, efficacy=1.0, **kwargs):\n        super().__init__()\n        self.define_pars(efficacy=efficacy)\n        self.update_pars(**kwargs)\n        return\n\n    def administer(self, people, uids):\n        people.sis.rel_sus[uids] *= 1-self.pars.efficacy\n        return\n    \ndef run_sim(efficacy):\n    \"\"\" Run a simulation with a given vaccine efficacy \"\"\"\n    # Create the vaccine product\n    product = sis_vaccine(efficacy=efficacy)\n\n    # Create the intervention\n    intervention = ss.routine_vx(\n        start_year=2015, # Begin vaccination in 2015\n        prob=1.0,        # 100% coverage\n        product=product  # Use the SIS vaccine\n    )\n\n    # Now create two sims: a baseline sim and one with the intervention\n    sim = ss.Sim(pars=pars, interventions=intervention)\n    sim.run()\n    return sim\n\ndef objective(efficacy, penalty=10, boolean=False, verbose=False):\n    \"\"\" Calculate the objective from the simulation \"\"\"\n    sim = run_sim(efficacy=efficacy)\n    transmission = sim.results.sis.new_infections[-1] &gt; 0\n    if boolean:\n        return not transmission\n    else:\n        loss = efficacy + penalty*transmission\n        if verbose:\n            print(f'Trial: {efficacy=}, {transmission=}, {loss=}')\n        return loss\n\ndef grid_search(n=5, reps=2):\n    \"\"\" Perform a grid search over the objective function \"\"\"\n    sc.heading('Performing grid search ...')\n    lb = 0 # Lower bound for efficacy\n    ub = 1 # Upper bound for efficacy\n    for rep in range(reps):\n        print(f'Grid search {rep+1} of {reps}...')\n        efficacy = np.linspace(lb, ub, n)\n        transmission = sc.parallelize(objective, efficacy, boolean=True)\n        lb = efficacy[sc.findlast(transmission, False)]\n        ub = efficacy[sc.findfirst(transmission, True)]\n        print(f'  Trials: {dict(zip(efficacy, transmission))}')\n        print(f'  Results: lower={lb}, upper={ub}')\n    mid = (lb+ub)/2\n    print(sc.ansi.bold(f'Result: {mid}'))\n    return mid, lb, ub\n\ndef auto_search(efficacy=1.0):\n    \"\"\" Perform automatic search \"\"\"\n    sc.heading('Performing automatic search...')\n    out = sc.asd(objective, x=efficacy, xmin=0, xmax=1, maxiters=10, verbose=True)\n    print(sc.ansi.bold(f'Result: {out.x}'))\n    return out\n\n# Run both optimizations\nmid, lb, ub = grid_search()\nout = auto_search()\n\n\n\n——————————————————————————\nPerforming grid search ...\n——————————————————————————\n\nGrid search 1 of 2...\n  Trials: {0.0: False, 0.25: False, 0.5: True, 0.75: True, 1.0: True}\n  Results: lower=0.25, upper=0.5\nGrid search 2 of 2...\n  Trials: {0.25: False, 0.3125: False, 0.375: False, 0.4375: False, 0.5: True}\n  Results: lower=0.4375, upper=0.5\nResult: 0.46875\n\n\n——————————————————————————————\nPerforming automatic search...\n——————————————————————————————\n\n     step 1 (0.2 s) ++ (orig:array([1.]) | best:array([1.]) | new:array([0.9]) | diff:array([-0.1]))\n     step 2 (0.4 s) ++ (orig:array([1.]) | best:array([0.9]) | new:array([0.7]) | diff:array([-0.2]))\n     step 3 (0.6 s) -- (orig:array([1.]) | best:array([0.7]) | new:array([10.3]) | diff:array([9.6]))\n     step 4 (0.8 s) ++ (orig:array([1.]) | best:array([0.7]) | new:array([0.5]) | diff:array([-0.2]))\n     step 5 (1.0 s) -- (orig:array([1.]) | best:array([0.5]) | new:array([10.1]) | diff:array([9.6]))\n     step 6 (1.2 s) -- (orig:array([1.]) | best:array([0.5]) | new:array([10.3]) | diff:array([9.8]))\n     step 7 (1.4 s) -- (orig:array([1.]) | best:array([0.5]) | new:array([10.4]) | diff:array([9.9]))\n     step 8 (1.6 s) -- (orig:array([1.]) | best:array([0.5]) | new:array([0.6]) | diff:array([0.1]))\n     step 9 (1.8 s) -- (orig:array([1.]) | best:array([0.5]) | new:array([0.55]) | diff:array([0.05]))\n     step 10 (2.0 s) -- (orig:array([1.]) | best:array([0.5]) | new:array([10.45]) | diff:array([9.95]))\n===  Maximum iterations reached (10 steps, orig: 1.000 | best: 0.5000 | ratio: 0.49999999999999994) ===\nResult: 0.49999999999999994",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "Solutions"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html",
    "href": "tutorials/t5_networks.html",
    "title": "T5 - Networks",
    "section": "",
    "text": "An interactive version of this notebook is available on Google Colab or Binder.\nMany infectious diseases transmit when people come into contact with one another. In the basic SIR example that we covered in the first two tutorials, we used a ‘random’ contact network, which creates random pairings of people. Generally speaking, the structure of network that you use depends on what disease you’re modeling.\nStarsim contains two different approaches to disease transmission.\nContact network: Disease transmits on individual person-to-person relationships. These are networks in the sense that each agent (person) can be viewed as a node and each contact is an edge. Networks are undirected in the sense that an edge will allow transmission in both directions, however you can make transmission stronger one way (p1–&gt;p2) than the other (p2–&gt;p1). The framework includes several pre-built contact network algorithms, each of which manages a list of edges that can change on each simulation step. In addition to the ‘random’ network, the framework include algorithms representing basic sexual networks for modeling sexually transmitted infections (STIs) and a ‘maternal’ network for modeling mother-to-child transmission.\nMixing pools: Simulate well-mixed transmission from one group of agents to another. Each mixing pool simulates directed transmission from a group of source agents to a group of destination agents. Instead of simulating individual edges like in a contact network, mixing pools first compute the total “contagion” that is shed by the source group. This total contagion value is normalized by the number of agents in the source group to arrive at a value that represents a typical infectious source agent. Then, each destination agent is exposed to this typical (average) infectious agent, likely resulting in new infections in the destination group. Multiple mixing pools can be run simultaneously to simulate heterogeneous transmission between various source and destination groups. Mixing pools could be used with age contact matrices like those developed by Prem et al.\nNote that contact networks and mixing pools can be used together in a single simulation.\nIn this tutorial, we’ll demonstrate a couple of the built-in contact networks, and give an overview of how you might create your own for your own disease modeling work. We’ll also demonstrate how to use mixing pools.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#overview-of-starsims-contact-network-structure",
    "href": "tutorials/t5_networks.html#overview-of-starsims-contact-network-structure",
    "title": "T5 - Networks",
    "section": "Overview of Starsim’s contact network structure",
    "text": "Overview of Starsim’s contact network structure\nStarsim’s networks are stored in the networks.py file. At the top of this file you’ll see the Network class, which provides the template for all the other networks. At a high level, all you need to know is that network stores various parameters that determine how pairs of people form and dissolve, and a collection of all the edges that exist at a given point in time. Let’s look at a simple example of the random network:\n\nimport numpy as np\nimport sciris as sc\nimport starsim as ss\nimport starsim_examples as sse\nimport matplotlib.pyplot as plt\n\n# Make random network\nrandom = ss.RandomNet()\n\nThe network we just made stores two very important things: the list of contacts (found in random.edges) and the parameters (random.pars).\nIf we just make a network on its own like this, it’s not very interesting. Like all components of Starsim, it needs to be initialized within a sim before the database of contacts gets populated:\n\nnet = ss.RandomNet()\nsir = ss.SIR()\nsim = ss.Sim(n_agents=50, diseases=sir, networks=net) # Decreasing n_agents so we can plot the network below\nsim.init()\n\nInitializing sim with 50 agents\n\n\nSim(n=50; 2000—2050.0; networks=randomnet; diseases=sir)\n\n\nWe can easily take a look at the list of edges between agents. All networks are stored in sim.networks, and individual networks can be found at their class name after conversion to lower case. So for this example, sim.networks.randomnet.edges has all the information about which agents (referenced by their UID) are paired with which other agents as well as a per-edge transmission multiplier called beta and a per-edge duration, dur.\n\nsim.networks.randomnet\n\nrandomnet(n_edges=250; pars=[n_contacts, dur, beta]; states=[participant])\n\n\nNetworks provide some basic functionality, for example to identify contacts. Additionally, the edge list can be quickly converted to a pandas dataframe or networkx graph for further analysis and manipulation:\n\nnet = sim.networks.randomnet\n\n# Use the \"find_contacts\" function to find all contacts of agent with uid 0\ncontacts_of_agent_0 = net.find_contacts([0])\nprint('The following agents were identified as contacts of agent 0:', contacts_of_agent_0)\n\n# Convert to a pandas DataFrame and manually find all edges involving agent with uid 0\ndf = net.to_df()\nuid0_edges = df.loc[(df['p1']==0) | (df['p2']==0)]\nprint('\\nEdges involving UID 0 extracted from the edge list data frame:')\ndisplay(uid0_edges)\n\n# Plot the network using networkx\nnet.plot()\n\nThe following agents were identified as contacts of agent 0: [ 7  9 13 18 24 33 39 40 44 46]\n\nEdges involving UID 0 extracted from the edge list data frame:\n\n\n\n\n\n\n\n\n\np1\np2\nbeta\ndur\n\n\n\n\n0\n0\n24\n1.0\n0.0\n\n\n1\n0\n7\n1.0\n0.0\n\n\n2\n0\n44\n1.0\n0.0\n\n\n3\n0\n13\n1.0\n0.0\n\n\n4\n0\n18\n1.0\n0.0\n\n\n45\n9\n0\n1.0\n0.0\n\n\n165\n33\n0\n1.0\n0.0\n\n\n196\n39\n0\n1.0\n0.0\n\n\n204\n40\n0\n1.0\n0.0\n\n\n234\n46\n0\n1.0\n0.0\n\n\n\n\n\n\n\nFigure(672x480)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#sexual-networks",
    "href": "tutorials/t5_networks.html#sexual-networks",
    "title": "T5 - Networks",
    "section": "Sexual networks",
    "text": "Sexual networks\nStarsim contains a few basic sexual networks, including an mf network for modeling heterosexual partnerships and an msm network for men having sex with men. Modeling STIs is a straightforward extension of the SIR example we looked at previously. Here’s an example modeling syphilis:\n\n# Create the disease\nsyph = sse.Syphilis(\n    beta = {'mf': [0.25, 0.15]},    # See notes below \n)\n\n# Create a heterosexual network\nmf = ss.MFNet(\n    duration=1/24,  # Using very short relationships so that we get more transmission \n    acts=80,        # Distribution of the number of coital acts/year\n)\n\npars = dict(start=2000, dur=20, dt=1/12)\nsim = ss.Sim(pars=pars, diseases=syph, networks=mf)\n\nThe main difference here is that we’ve added the line syph.pars['beta'] = {'mf': [0.25, 0.15]}. Because STIs are generally more transmissible from males to females than vice versa, we can specify beta as a list, and we can also allow it to vary between networks. For instance, if we also had an MSM network here, we could set\nsyph.pars.update(beta = {'mf': [0.25, 0.15], 'msm': [0.4, 0.4]})\nThe sexual network itself is structurally similar to the random network that we looked at previously, and can be customized by changing the pars dictionary that’s used to construct it.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#maternal-networks",
    "href": "tutorials/t5_networks.html#maternal-networks",
    "title": "T5 - Networks",
    "section": "Maternal networks",
    "text": "Maternal networks\nMaternal networks are useful for capturing mother-to-child transmission. If you want to use them, you also need to model pregnancy. As new agents are born via pregnancy, edges are automatically added between mother and prenatal child in the maternal network. Here’s an example showing how you would do this for syphilis:\n\nsyph = sse.Syphilis(\n    beta = {'mf': [0.25, 0.15], 'maternal': [0.99, 0]}\n)\n\n# Make demographic modules\npregnancy = ss.Pregnancy(fertility_rate=20)\ndeath = ss.Deaths(death_rate=15)\n\n# Make maternal network\nmaternal = ss.MaternalNet()\n\n# Make sim\nsim = ss.Sim(pars=pars, diseases=syph, networks=[mf, maternal], demographics=[pregnancy, death], dur=10)\nsim.run().plot(show_module=False)\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/121) (0.00 s)  ———————————————————— 1%\n  Running 2000.11.01 (10/121) (0.25 s)  •——————————————————— 9%\n  Running 2001.09.01 (20/121) (0.36 s)  •••————————————————— 17%\n  Running 2002.07.02 (30/121) (0.49 s)  •••••——————————————— 26%\n  Running 2003.05.03 (40/121) (0.62 s)  ••••••—————————————— 34%\n  Running 2004.03.02 (50/121) (0.73 s)  ••••••••———————————— 42%\n  Running 2005.01.01 (60/121) (0.84 s)  ••••••••••—————————— 50%\n  Running 2005.11.01 (70/121) (0.95 s)  •••••••••••————————— 59%\n  Running 2006.09.01 (80/121) (1.06 s)  •••••••••••••——————— 67%\n  Running 2007.07.02 (90/121) (1.17 s)  •••••••••••••••————— 75%\n  Running 2008.05.02 (100/121) (1.28 s)  ••••••••••••••••———— 83%\n  Running 2009.03.03 (110/121) (1.39 s)  ••••••••••••••••••—— 92%\n  Running 2010.01.01 (120/121) (1.50 s)  •••••••••••••••••••• 100%\n\nFigure(1152x864)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#making-your-own-contact-network",
    "href": "tutorials/t5_networks.html#making-your-own-contact-network",
    "title": "T5 - Networks",
    "section": "Making your own contact network",
    "text": "Making your own contact network\nIf you want to make your own network, a good place to start is by inheriting from one of the templates in networks.py. For example, if you wanted to make an mf network that has more age structure, you could do something like this:\n\nclass age_mf(ss.MFNet):\n    def add_pairs(self, people, ti=None):\n        # Custom code to select pairs based on age\n        return \n\nThis network would operate exactly like the existing mf network, but you could control how new pairs were added.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#introduction-to-mixing-pools",
    "href": "tutorials/t5_networks.html#introduction-to-mixing-pools",
    "title": "T5 - Networks",
    "section": "Introduction to mixing pools",
    "text": "Introduction to mixing pools\nWhile contact networks model individual relationships, mixing pools model group-level transmission. This is useful for: - Large populations where individual contacts are impractical - Age-structured mixing (like school, work, household contacts) - When you have contact matrices from epidemiological studies\nHere’s a simple comparison:\n\n# Simple mixing pool example\nmp = ss.MixingPool(beta=1.0, n_contacts=ss.poisson(lam=3))\nsir_mp = ss.SIR()\nsim_mp = ss.Sim(diseases=sir_mp, networks=mp, verbose=0, label='Mixing Pool')\n\n# Equivalent contact network\nnet = ss.RandomNet(n_contacts=ss.poisson(lam=3))\nsir_net = ss.SIR(beta=ss.peryear(0.1))\nsim_net = ss.Sim(diseases=sir_net, networks=net, verbose=0, label='Contact Network')\n\nmsim = ss.MultiSim([sim_mp, sim_net]).run()\nmsim.plot()\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nBoth approaches model similar transmission patterns, but mixing pools work with groups rather than individual contacts.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#what-youve-learned",
    "href": "tutorials/t5_networks.html#what-youve-learned",
    "title": "T5 - Networks",
    "section": "What you’ve learned",
    "text": "What you’ve learned\nCongratulations! You’ve now learned how to: - Use basic contact networks for disease transmission - Model disease-specific networks (sexual, maternal) - Create custom networks with your own connection rules - Understand the difference between contact networks and mixing pools\nFor more advanced mixing pool techniques (age-structured mixing, contact matrices, multi-group models), see the Networks implementation guide.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t5_networks.html#exercises",
    "href": "tutorials/t5_networks.html#exercises",
    "title": "T5 - Networks",
    "section": "Exercises",
    "text": "Exercises\n\nMulti-network STI model: Adapt the syphilis example to include both MF and MSM transmission\nCustom network parameters: Modify the AgeMFNet to have different age bins and mixing probabilities\nNetwork comparison: Compare random vs age-structured networks - how do they affect epidemic dynamics?",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T5 - Networks"
    ]
  },
  {
    "objectID": "tutorials/t1_intro.html",
    "href": "tutorials/t1_intro.html",
    "title": "T1 - Getting started",
    "section": "",
    "text": "Starsim is a highly flexible framework for creating agent-based models. Starsim was designed by a team with expertise in infectious diseases, so many of the examples that we’ll cover throughout these tutorials are examples of infectious diseases. However, you can also use Starsim for modeling other things, like non-communicable diseases (NCDs) or family planning and maternal health.\nInstalling and getting started with Starsim is quite simple.\nTo install, just type pip install starsim. If it worked, you should be able to import Starsim with import starsim as ss.\nThe basic design philosophy of Starsim is: common tasks should be simple. Since Starsim is most commonly used for modeling infectious diseases, everything related to that should be straightforward. The most common tasks that you are likely to do are:\nThis tutorial walks you through the simplest possible version of how to do these things.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T1 - Getting started"
    ]
  },
  {
    "objectID": "tutorials/t1_intro.html#hello-world",
    "href": "tutorials/t1_intro.html#hello-world",
    "title": "T1 - Getting started",
    "section": "Hello world",
    "text": "Hello world\nLet’s start with the simplest version of a Starsim model. We’ll make a version of a classic SIR model. Here’s how our code would look:\n\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 10_000,    # Number of agents to simulate\n    networks = dict(      # *Networks* add detail on how the agents interact with each other \n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 10   # Each person has an average of 10 contacts with other people\n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model \n        type = 'sir',     # Here, we're creating an SIR disease \n        init_prev = 0.01, # Proportion of the population initially infected \n        beta = 0.05,      # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\nsim.diseases.sir.plot()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.17 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.21 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.25 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.27 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.30 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nAs the tutorials progress we’ll show how to extend this different diseases with different transmission pathways, and how to customize the model in lots of different ways.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T1 - Getting started"
    ]
  },
  {
    "objectID": "tutorials/t1_intro.html#exercises",
    "href": "tutorials/t1_intro.html#exercises",
    "title": "T1 - Getting started",
    "section": "Exercises",
    "text": "Exercises\n\nTo simulate a susceptible-infectious-susceptible (SIS) model instead of SIR, what would we change in the example above?\nHow do the results change if we increase/decrease beta?\nHow do the results change if we reduce the number of agents to 200?",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T1 - Getting started"
    ]
  },
  {
    "objectID": "conduct.html",
    "href": "conduct.html",
    "title": "Code of conduct",
    "section": "",
    "text": "In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n\n\nExamples of behavior that contributes to creating a positive environment include:\n\nUsing welcoming and inclusive language\nBeing respectful of differing viewpoints and experiences\nGracefully accepting constructive criticism\nFocusing on what is best for the community\nShowing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\nThe use of sexualized language or imagery and unwelcome sexual attention or advances\nTrolling, insulting/derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or electronic address, without explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting\n\n\n\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at info@starsim.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.\n\n\n\nThis Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html.\nFor answers to common questions about this code of conduct, see the FAQ.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#our-pledge",
    "href": "conduct.html#our-pledge",
    "title": "Code of conduct",
    "section": "",
    "text": "In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#our-standards",
    "href": "conduct.html#our-standards",
    "title": "Code of conduct",
    "section": "",
    "text": "Examples of behavior that contributes to creating a positive environment include:\n\nUsing welcoming and inclusive language\nBeing respectful of differing viewpoints and experiences\nGracefully accepting constructive criticism\nFocusing on what is best for the community\nShowing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\nThe use of sexualized language or imagery and unwelcome sexual attention or advances\nTrolling, insulting/derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others’ private information, such as a physical or electronic address, without explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#our-responsibilities",
    "href": "conduct.html#our-responsibilities",
    "title": "Code of conduct",
    "section": "",
    "text": "Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#scope",
    "href": "conduct.html#scope",
    "title": "Code of conduct",
    "section": "",
    "text": "This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#enforcement",
    "href": "conduct.html#enforcement",
    "title": "Code of conduct",
    "section": "",
    "text": "Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at info@starsim.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "conduct.html#attribution",
    "href": "conduct.html#attribution",
    "title": "Code of conduct",
    "section": "",
    "text": "This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html.\nFor answers to common questions about this code of conduct, see the FAQ.",
    "crumbs": [
      "Home",
      "**Code of conduct**"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html",
    "href": "user_guide/modules_diseases.html",
    "title": "Diseases",
    "section": "",
    "text": "Starsim has a two-tier disease class hierarchy:\n\n\n\nBase class for all diseases\nDefines step methods and basic disease structure\nDoes not include transmission logic\nUsed for non-communicable diseases (NCDs)\nKey methods: define_states(), set_prognoses()\n\n\n\n\n\nInherits from ss.Disease\nIncludes transmission logic via the infect() method\nUsed for all communicable diseases\nHandles network-based transmission automatically\nApplies network-specific betas and agent susceptibility/transmissibility\n\nImportant: Almost all diseases should inherit from ss.Infection. Do not write your own infect() method unless you have very specific requirements - the built-in method correctly handles:\n\nLooping over agents in each network\nApplying network- and disease-specific transmission probabilities\nManaging agent transmissibility and susceptibility\nMixing pool logic",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html#disease-class-architecture",
    "href": "user_guide/modules_diseases.html#disease-class-architecture",
    "title": "Diseases",
    "section": "",
    "text": "Starsim has a two-tier disease class hierarchy:\n\n\n\nBase class for all diseases\nDefines step methods and basic disease structure\nDoes not include transmission logic\nUsed for non-communicable diseases (NCDs)\nKey methods: define_states(), set_prognoses()\n\n\n\n\n\nInherits from ss.Disease\nIncludes transmission logic via the infect() method\nUsed for all communicable diseases\nHandles network-based transmission automatically\nApplies network-specific betas and agent susceptibility/transmissibility\n\nImportant: Almost all diseases should inherit from ss.Infection. Do not write your own infect() method unless you have very specific requirements - the built-in method correctly handles:\n\nLooping over agents in each network\nApplying network- and disease-specific transmission probabilities\nManaging agent transmissibility and susceptibility\nMixing pool logic",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html#key-implementation-methods",
    "href": "user_guide/modules_diseases.html#key-implementation-methods",
    "title": "Diseases",
    "section": "Key implementation methods",
    "text": "Key implementation methods\n\n\n\n\n\n\n\n\nMethod\nPurpose\nWhen to override\n\n\n\n\ndefine_states()\nInitialize disease states (S, I, R, etc.)\nAlways for custom diseases\n\n\nset_prognoses()\nSet outcomes for newly infected people\n(Almost) always for custom diseases\n\n\nstep_state()\nUpdate states each timestep\nWhen adding new state transitions\n\n\nstep_die()\nHandle deaths\nWhen disease has custom states\n\n\ninfect()\nHandle transmission\nRarely - use built-in version",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "user_guide/modules_diseases.html#implementation-patterns",
    "href": "user_guide/modules_diseases.html#implementation-patterns",
    "title": "Diseases",
    "section": "Implementation patterns",
    "text": "Implementation patterns\n\nPattern 1: Extending existing diseases\nWhen you need to modify an existing disease model, inherit from it and override specific methods:\n\nimport starsim as ss\n\nclass MyCustomSIR(ss.SIR):\n    def __init__(self, **kwargs):\n        super().__init__()\n        # Add custom parameters\n        self.define_pars(my_param=0.5)\n        self.update_pars(**kwargs)\n        \n    def set_prognoses(self, uids, sources=None):\n        # Custom progression logic\n        super().set_prognoses(uids, sources)\n        # Additional custom logic here\n\n\n\nPattern 2: Adding new states\nTo add states to an existing disease:\n\nclass MySEIR(ss.SIR):\n    def __init__(self, **kwargs):\n        super().__init__()\n        # Add new parameters\n        self.define_pars(dur_exp=ss.lognorm_ex(0.5))\n        self.update_pars(**kwargs)\n        \n        # Add new states\n        self.define_states(\n            ss.BoolState('exposed', label='Exposed'),\n            ss.FloatArr('ti_exposed', label='Time of exposure'),\n        )\n\n    @property\n    def infectious(self):\n        # Define who can transmit (both infected and exposed)\n        return self.infected | self.exposed\n\n    def step_state(self):\n        # Call parent state updates first\n        super().step_state()\n        \n        # Add custom state transitions\n        transitioning = self.exposed & (self.ti_infected &lt;= self.ti)\n        self.exposed[transitioning] = False\n        self.infected[transitioning] = True",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Diseases"
    ]
  },
  {
    "objectID": "user_guide/basics_parameters.html",
    "href": "user_guide/basics_parameters.html",
    "title": "Parameters",
    "section": "",
    "text": "When you create a module using Starsim, you have the opportunity to define the default format for parameters. Let’s look at an example from the SIR disease model:\n\nimport starsim as ss\n\nclass MySIR(ss.SIR):\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            beta = ss.peryear(0.1),\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=ss.years(6)),\n            p_death = ss.bernoulli(p=0.01),\n        )\n        self.update_pars(**kwargs)\n\n        self.define_states(\n            ss.BoolState('susceptible', default=True, label='Susceptible'),\n            ss.BoolState('infected', label='Infectious'),\n            ss.BoolState('recovered', label='Recovered'),\n            ss.FloatArr('ti_infected', label='Time of infection'),\n            ss.FloatArr('ti_recovered', label='Time of recovery'),\n            ss.FloatArr('ti_dead', label='Time of death'),\n            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),\n            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),\n            reset = True, # Do not use any existing states\n        )\n        return\n\nThe point of self.define_pars() is to set the ground truth for the format that the parameters should take. When users enter their own parameters for defining an instance of this module, the parameter values they enter will be processed within self.update_pars() and will be checked for consistency with the format provided in the original parameters (define_pars). For example, the parameter p_death in the SIR example above is specified initially as a Bernoulli distribution. It would be perfectly legitimate to create an instance of the SIR model using any of the following formats:\n\nsir1 = MySIR(p_death=0.02)\nsir2 = MySIR(p_death=ss.bernoulli(p=0.2))\n\nHowever, it would NOT be ok to create an SIR model with e.g. MySIR(p_death=ss.lognorm_ex(4)), because if a distribution is defined as a Bernoulli in the default_pars, it can’t be changed. This is only the case for Bernoulli distributions; other distributions can be changed, e.g. MySIR(dur_inf=ss.normal(4)) would be okay. This is because Bernoulli distributions have different methods than other distributions, e.g. a filter() method that returns True for agents which pass the filter.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Parameters"
    ]
  },
  {
    "objectID": "user_guide/basics_parameters.html#defining-default-parameters",
    "href": "user_guide/basics_parameters.html#defining-default-parameters",
    "title": "Parameters",
    "section": "",
    "text": "When you create a module using Starsim, you have the opportunity to define the default format for parameters. Let’s look at an example from the SIR disease model:\n\nimport starsim as ss\n\nclass MySIR(ss.SIR):\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            beta = ss.peryear(0.1),\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=ss.years(6)),\n            p_death = ss.bernoulli(p=0.01),\n        )\n        self.update_pars(**kwargs)\n\n        self.define_states(\n            ss.BoolState('susceptible', default=True, label='Susceptible'),\n            ss.BoolState('infected', label='Infectious'),\n            ss.BoolState('recovered', label='Recovered'),\n            ss.FloatArr('ti_infected', label='Time of infection'),\n            ss.FloatArr('ti_recovered', label='Time of recovery'),\n            ss.FloatArr('ti_dead', label='Time of death'),\n            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),\n            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),\n            reset = True, # Do not use any existing states\n        )\n        return\n\nThe point of self.define_pars() is to set the ground truth for the format that the parameters should take. When users enter their own parameters for defining an instance of this module, the parameter values they enter will be processed within self.update_pars() and will be checked for consistency with the format provided in the original parameters (define_pars). For example, the parameter p_death in the SIR example above is specified initially as a Bernoulli distribution. It would be perfectly legitimate to create an instance of the SIR model using any of the following formats:\n\nsir1 = MySIR(p_death=0.02)\nsir2 = MySIR(p_death=ss.bernoulli(p=0.2))\n\nHowever, it would NOT be ok to create an SIR model with e.g. MySIR(p_death=ss.lognorm_ex(4)), because if a distribution is defined as a Bernoulli in the default_pars, it can’t be changed. This is only the case for Bernoulli distributions; other distributions can be changed, e.g. MySIR(dur_inf=ss.normal(4)) would be okay. This is because Bernoulli distributions have different methods than other distributions, e.g. a filter() method that returns True for agents which pass the filter.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Parameters"
    ]
  },
  {
    "objectID": "user_guide/basics_parameters.html#using-callable-parameters",
    "href": "user_guide/basics_parameters.html#using-callable-parameters",
    "title": "Parameters",
    "section": "Using callable parameters",
    "text": "Using callable parameters\nOne of the most flexible aspects of how Starsim’s distributions are defined is that they can take callable functions as parameter values. For example, in reality the duration of infection of a disease might vary by age. We could model this as follows:\n\nimport sciris as sc\nimport matplotlib.pyplot as plt\nimport starsim as ss\n\n# Create and run the simulation\nsir = ss.SIR(dur_inf=ss.normal(loc=ss.years(10)))  # Define an SIR model with a default duration of 10 days\nsir.pars.dur_inf.set(loc = lambda self, sim, uids: sim.people.age[uids] / 10)  # Change the mean duration so it scales with age\nsim = ss.Sim(n_agents=20e3, dur=10, diseases=sir, networks='random')\nsim.run()\nsim.plot()\n\n# Show the age distribution of infections\nages = sim.people.age[:]\ninfected_ages = ages[sim.diseases.sir.infected]\n\nfig = plt.figure()\n\nplt.subplot(2,1,1)\nplt.hist(ages, bins=range(0,100,5))\nplt.title('Simulation age distribution')\nplt.xlabel('Age')\nplt.ylabel('Number of people')\n\nplt.subplot(2,1,2)\nplt.hist(infected_ages, bins=range(0,100,5))\nplt.title('Infection age distribution')\nplt.xlabel('Age')\nplt.ylabel('Number of people')\n\nsc.figlayout()\nplt.show()\n\nInitializing sim with 20000 agents\n  Running 2000.01.01 ( 0/11) (0.00 s)  •——————————————————— 9%\n  Running 2010.01.01 (10/11) (0.19 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing similar logic, any other parameter could be set to depend on anything that the sim is aware of, including time or agent properties like age, sex, or health attributes.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Parameters"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html",
    "href": "user_guide/basics_sim.html",
    "title": "The Sim object",
    "section": "",
    "text": "As noted on the Model Structure page, the Sim is the main object for doing things with Starsim. Once you’ve created your modules for diseases and interventions, you will add them to the Sim, which will ensure that everything gets run in a sensible order, and that everything is nicely accessible afterwards.\nOn this page, we explain what happens when you create a Sim, and the particular order of steps taken when a Sim is run. We then provide a few common examples of how to create and run a Sim and when/why you might choose each one.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html#creating-and-initializing-a-sim",
    "href": "user_guide/basics_sim.html#creating-and-initializing-a-sim",
    "title": "The Sim object",
    "section": "Creating and initializing a Sim",
    "text": "Creating and initializing a Sim\nWhen you first create a sim, e.g. with sim = ss.Sim(), the resulting Sim object will be mostly empty with a few pre-set defaults. Most of the initialization is done when sim.init() is called. This completes the initialization with the following steps:\n\nValidating the parameters;\nAdding a Time module to the sim (stored under sim.t), which looks after converting parameters between timesteps;\nAdding People to the Sim: if these are not supplied directly, Starsim will automatically add People with default age/sex structure;\nAdding all the parameters and results from each Module to the Sim, and adding the states from each Module to the People;\nInitializing any distributions contained anywhere within the parameters or states.\n\nA Sim is automatically initialized if sim.run() is called.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html#running-a-sim",
    "href": "user_guide/basics_sim.html#running-a-sim",
    "title": "The Sim object",
    "section": "Running a Sim",
    "text": "Running a Sim\n\nOrder of operations\nAn important function of the Sim class is that it controls the order in which the different steps of each module are executed. Starsim allows users lots of flexibility regarding the timesteps for individual modules. For example, a common usage pattern is that you may only want to update your demographic modules once a year, but you may want to update your disease modules once per month, week, or day. The Sim class stores a plan for updating each module in the right order and with the right frequency. This is stored within a specialized Loop class housed within the Sim. Users typically won’t interact with this class directly, but it is worth knowing the order in which updates are made on each timestep.\n\nModules have a start_step method which is called first. This usually just advances random number generators forward.\nAny Demographic modules have their step method called\nAny Disease modules have their step_state method called\nAny Connectors have their step method called\nAny Networks have their step method called\nAny Interventions have their step method called\nAny Disease modules have their step method called\nThe People class has its step_die method called: this updates any people who died on this time step. Deaths are handled by modules, not by People directly, but step_die method assembles all the causes of death across disease modules and demographic modules and reconciles them. This ensures that each agent’s death is uniquely attributable to a cause.\nResults are updated for the People and the Modules\nAny Analyzer modules have their step method called\nCalls are made to finish_step for the Modules, the People, and the Sim.\n\nIf you want to see more details, have a look at sim.loop.to_df() (after calling sim.init()) and it will show a dataframe of every step in the simulation. You can also use sim.loop.plot() to visualize each step.\nNote that there are two separate update calls for diseases, step_state and then step. The step_state method happens before transmission, and the step method typically handles transmission. The step_state method typically handles disease progression, as in this example from the SIR model:\n\ndef step_state(self):\n    \"\"\" Progress infectious -&gt; recovered \"\"\"\n    recovered = (self.infected & (self.ti_recovered &lt;= self.ti)).uids\n    self.infected[recovered] = False\n    self.susceptible[recovered] = True\n    self.update_immunity()\n    return\n\nTo illustrate the ordering of all these updates, let’s consider an example of a woman infected with pre-symptomatic COVID who, in the course of a single busy day, started developing COVID symptoms, took a COVID test, moved out of her parents’ house and into her husband’s house, and became pregnant. Starsim’s model update logic would order her day as follows: (1) become pregnant, (2) develop symptoms, (3) move house, (4) transmit COVID to anyone still in her contact networks, which at this point would include her husband but not her parents, (5) get COVID test.\nThere are a few principles that guide the logic about the update ordering. Updating the demographics first makes sense because we want to make sure we capture mother-to-child transmission. Suppose that during one month, a woman became pregnant and also acquired malaria; we want to ensure that the effects of malaria on her pregnancy are captured. Updating the network before disease transmission occurs is fairly arbitrary, but it means that transmission can occur with new partners, which is particularly relevant for sexually transmitted infections, especially when it’s an instantaneously-dissolving partnership.\n\n\nPrinting progress\nIt can be useful to see how the Sim is progressing, and the sim.run() method accepts a verbose argument that controls how frequently to provide updates. With verbose=1, you will see updates on progree on every timestep; with verbose=0.1 you will see updates every 10 timesteps, and so on. If you are running monthly or daily timesteps you can also use verbose=1/12 or 1/365 to avoid having too much printed output in your Python terminal. You can also use verbose=-1, which will only print output when the sim is complete.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_sim.html#starting-and-stopping-a-run",
    "href": "user_guide/basics_sim.html#starting-and-stopping-a-run",
    "title": "The Sim object",
    "section": "Starting and stopping a run",
    "text": "Starting and stopping a run\nSimulations can be partially run, stopped, and restarted using the sim.run(until=) argument. This can be useful for a few different reasons:\n\nTo inspect the state of a simulation for mid-run (although you can also use an analyzer or the Python debugger for this)\nTo modify the state of a simulation before continuing (although you can also use an intervention for this)\nTo run part of a simulation only once, before copying it and running different scenarios (although note that copying a simulation can often take almost as much time as running it!)\n\nOf these, the third use case is probably the most common. The example below illustrates how to do this.\n\nimport sciris as sc\nimport starsim as ss\n\n# Define custom intervention\nclass sis_vaccine(ss.Intervention):\n\n    def __init__(self, start=2040, eff=1.0):\n        super().__init__()\n        self.start = start\n        self.eff = eff\n        return\n\n    def step(self):\n        sis = self.sim.diseases.sis\n        if sis.now == self.start:\n            sis.rel_trans[:] *= 1-self.eff\n        return\n\n# Default parameters\npars = dict(\n    start = 2000,\n    stop = 2050,\n    diseases = 'sis',\n    networks = 'random',\n    verbose = 0,\n)\n\n# Define list of efficacies to run\neffs = [0.0, 0.2, 0.5, 0.8, 1.0]\n\n\n#%% Standard parallel run\nT = sc.timer()\nsims = []\n\nfor eff in effs:\n    s = ss.Sim(pars, label=f'Efficacy={eff}', interventions=sis_vaccine(eff=eff))\n    sims.append(s)\n\nsims = ss.parallel(sims)\nT.toc('Runtime using default')\n\n\n#%% Shortcut using \"until\"\nT = sc.timer()\nsim = ss.Sim(pars, interventions=sis_vaccine())\nsim.run(until=2039)\nsims = []\n\nfor eff in effs:\n    s = sim.copy()\n    s.label = f'Efficacy={eff}'\n    s.interventions[0].eff = eff\n    sims.append(s)\n\nsims = ss.parallel(sims)\nT.toc('Runtime using \"until\"')\n\nsims.plot()\nss.show()\n\nRuntime using default: 0.897 s\nRuntime using \"until\": 1.08 s\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nHere, there is relatively little time saved by using until; however, with a longer burn-in period, or more scenarios, the time savings may be greater.\nYou can also use this approach to modify the parameters of a simulation before continuing:\n\nimport starsim as ss\n\nbase_sim = ss.Sim(diseases='sis', networks='random', start=2000, stop=2100, verbose=False)\nbase_sim.run(until=2030)\n\nsims = []\nbetas = [0.01, 0.02, 0.05, 0.10]\nfor beta in betas:\n    sim = base_sim.copy()\n    sim.diseases.sis.pars.beta = beta\n    sim.label = f'beta={beta}'\n    sims.append(sim)\n\nmsim = ss.parallel(sims)\nmsim.plot()\n\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "The Sim object"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html",
    "href": "user_guide/basics_people.html",
    "title": "People, States, and Arrays",
    "section": "",
    "text": "Starsim is a framework for creating agent-based models, and the People class is where we store the agents, so it should come as no surprise that this class serves as the fundamental heart of any Starsim model. In this page we provide alternative pathways for creating people and some guidance on how to adapt these workflows depending on your needs.\nWe start by giving an overview on this page of Starsim’s custom Arr (array) classes, which are a separate but related Starsim class designed to neatly track data about people.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#starsim-states-and-arrays",
    "href": "user_guide/basics_people.html#starsim-states-and-arrays",
    "title": "People, States, and Arrays",
    "section": "Starsim States and Arrays",
    "text": "Starsim States and Arrays\nStarsim has a set of custom array classes for recording information about each agent in the population. The two fundamental types of array for storing such infomation are the BoolState class, which is a Boolean array, and the FloatArr class, which stores numbers (we don’t distinguish between floats and integers, so all numbers are stored in these arrays). Each of these is a subclass of the Starsim Arr class.\nThe Arr class in Starsim is optimized for three key tasks that are common to almost all Starsim models:\n\nDynamic growth: as the population grows over time, the size of the arrays dynamically update in a way that avoids costly concatenation operations;\nIndexing: over time, there are agents in the population who die. It is desirable for these agents to remain in the arrays so that we can continue to access data about them, but the indexing is set up so that dead agents are automatically excluded from most operations.\nStochastic states: we often want to set the values of a state by sampling from a random variable (e.g. sex might be drawn as a Bernoulli random variable). Starsim’s Arr class can be initialized with a random variables; we will provide examples of this below.\n\nAll agents have a uid (universal identifier), which corresponds to their position in the array. Starsim keeps track of a list of auids (active UIDs), corresponding to agents who are alive or are otherwise participating in the simulation. This way, Starsim knows to skip over dead agents (or otherwise removed, e.g. from migration) when calculating disease progression, aging, etc.\nIn most cases, you shouldn’t need to worry about uids, auids, etc. However, this example illustrates how they work:\n\nimport sciris as sc\nimport starsim as ss\n\nsim = ss.Sim(start=2000, stop=2020, n_agents=1000, diseases='sir', networks='random', demographics=True, verbose=False)\nsim.init()\n\nsc.heading('Initial state')\nppl = sim.people\nprint('Number of agents before run:', len(ppl))\nprint('Maximum UID:', ppl.uid.max())\nprint('Mean age:', ppl.age.mean())\n\nsc.heading('After running the sim')\nsim.run()\nres = sim.results\nprint('Number of agents after run:', len(ppl))\nprint('Number of agents who were born:', sim.results.births.cumulative[-1])\nprint('Number of agents who died:', sim.results.cum_deaths[-1])\nprint('Maximum UID:', ppl.uid.max())\nprint('Size of the raw arrays:', len(ppl.uid.raw))\nprint('Mean age of alive agents:', ppl.age.mean())\n\n\n\n—————————————\nInitial state\n—————————————\n\nNumber of agents before run: 1000\nMaximum UID: 999\nMean age: 30.130148\n\n\n—————————————————————\nAfter running the sim\n—————————————————————\n\nNumber of agents after run: 1230\nNumber of agents who were born: 460.0\nNumber of agents who died: 218.0\nMaximum UID: 1459\nSize of the raw arrays: 1500\nMean age of alive agents: 36.88307",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#creating-default-people",
    "href": "user_guide/basics_people.html#creating-default-people",
    "title": "People, States, and Arrays",
    "section": "Creating default people",
    "text": "Creating default people\nWhen you create a sim, it automatically creates People, and you can use the n_agents argument to control the population size:\n\nimport numpy as np\nimport pandas as pd\nimport starsim as ss \nsim = ss.Sim(n_agents=1000)  # Create a sim with default people\nsim.init()\n\nInitializing sim with 1000 agents\n\n\nSim(n=1000; 2000—2050.0)\n\n\nThe People that are added to the Sim come with the following default states and arrays:\n\nalive, a State that records whether each agent is alive\nfemale, a State that records whether each agent is female\nage, a FloatArr that records agent ages\nti_dead, a FloatArr that records the time of death, NaN by default\nscale, a FloatArr that records the number of people that each agent represents; 1 by default.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#creating-custom-people",
    "href": "user_guide/basics_people.html#creating-custom-people",
    "title": "People, States, and Arrays",
    "section": "Creating custom people",
    "text": "Creating custom people\nRather than relying on the Sim to create people, you can create your own People and add them to the Sim as a separate argument. The example below is equivalent to the one immediately above:\n\npeople = ss.People(1000)\nsim = ss.Sim(people=people)\n\nThe main reason to create custom people is if you want to specify a particular age/sex distribution. The following example creates a population with the age distribution of Nigeria:\n\nage_data = pd.read_csv('test_data/nigeria_age.csv')\nppl = ss.People(n_agents=10e3, age_data=age_data)\nsim = ss.Sim(people=ppl, copy_inputs=False).init()\nppl.plot_ages();\n\nInitializing sim with 10000 agents\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nAnother reason to create custom people is if there are additional attributes that you want to track. Let’s say we want to add a state to track urban/rural status. The example below also illustrates how you can add a stochastic state whose values are sampled from a distribution.\n\ndef urban_function(n):\n    \"\"\" Make a function to randomly assign people to urban/rural locations \"\"\" \n    return np.random.choice(a=[True, False], p=[0.5, 0.5], size=n)\n\nurban = ss.BoolState('urban', default=urban_function)\nppl = ss.People(10, extra_states=urban)  # Create 10 people with this state\nsim = ss.Sim(people=ppl)\nsim.init()  # Initialize the sim --&gt; essential step to create the people and sample states\nprint(f'Number of urban people: {np.count_nonzero(sim.people.urban)}')\n\nInitializing sim with 10 agents\nNumber of urban people: 8",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#modifying-people-with-modules",
    "href": "user_guide/basics_people.html#modifying-people-with-modules",
    "title": "People, States, and Arrays",
    "section": "Modifying People with modules",
    "text": "Modifying People with modules\nWe saw an example above of adding a custom state to people. However, a far more common way to add states to people is by adding a module to the Sim. All the states of the modules will automatically get added to the main People instance.\n\nppl = ss.People(30)\nsim = ss.Sim(people=ppl, diseases=ss.SIS(init_prev=0.1), networks=ss.RandomNet())\nsim.run()\nprint(f'Number of infected people: {sim.people.sis.infected.sum()}')\n\nInitializing sim with 30 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.01 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.02 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.03 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.04 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.05 s)  •••••••••••••••••••• 100%\n\nNumber of infected people: 15\n\n\nWhen states or arrays are added by modules, they are stored as dictionaries under the name of that module.\nNote that the Starsim Arr class can be used like a Numpy array, with all the standard arithmetic operations like sums, mean, counting, etc.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/basics_people.html#debugging-and-analyzing",
    "href": "user_guide/basics_people.html#debugging-and-analyzing",
    "title": "People, States, and Arrays",
    "section": "Debugging and analyzing",
    "text": "Debugging and analyzing\nThere are several ways to explore the People object. One way is by exporting to a dataframe:\n\ndf = sim.people.to_df()\ndf.disp()\n\n    uid  slot  alive      age  female  ti_dead  ti_removed  scale  randomnet.participant  sis.susceptible  sis.infected  sis.rel_sus  sis.rel_trans  sis.ti_infected  sis.ti_recovered  sis.immunity\n0     0     0   True  25.1524   False      NaN         NaN    1.0                  False            False          True       0.0000            1.0             46.0           56.1627        1.5163\n1     1     1   True   4.9883    True      NaN         NaN    1.0                  False            False          True       0.2294            1.0             42.0           52.0214        0.7706\n2     2     2   True  58.1494   False      NaN         NaN    1.0                  False            False          True       0.0863            1.0             42.0           52.7087        0.9137\n3     3     3   True   0.1302   False      NaN         NaN    1.0                  False            False          True       0.0000            1.0             49.0           59.3261        1.4532\n4     4     4   True  43.8199   False      NaN         NaN    1.0                  False            False          True       0.0000            1.0             43.0           53.9736        1.0737\n5     5     5   True  42.6909   False      NaN         NaN    1.0                  False             True         False       0.6862            1.0             20.0           29.6344        0.3138\n6     6     6   True  54.2923    True      NaN         NaN    1.0                  False             True         False       0.2953            1.0             37.0           47.1078        0.7047\n7     7     7   True  52.6040   False      NaN         NaN    1.0                  False             True         False       0.6314            1.0             25.0           34.3523        0.3686\n8     8     8   True   7.0769   False      NaN         NaN    1.0                  False            False          True       0.0251            1.0             41.0           51.3925        0.9749\n9     9     9   True  27.2292   False      NaN         NaN    1.0                  False             True         False       0.1064            1.0             39.0           49.1210        0.8936\n10   10    10   True   4.0500    True      NaN         NaN    1.0                  False             True         False       0.1828            1.0             34.0           45.8417        0.8172\n11   11    11   True  42.6985   False      NaN         NaN    1.0                  False            False          True       0.0000            1.0             49.0           57.8087        1.4802\n12   12    12   True  25.2828    True      NaN         NaN    1.0                  False            False          True       0.0000            1.0             48.0           57.5599        1.4279\n13   13    13   True  27.6266    True      NaN         NaN    1.0                  False             True         False       0.3926            1.0             36.0           44.9499        0.6074\n14   14    14   True  24.6072   False      NaN         NaN    1.0                  False            False          True       0.0362            1.0             42.0           51.6577        0.9638\n15   15    15   True  48.8226   False      NaN         NaN    1.0                  False             True         False       0.1770            1.0             35.0           43.8462        0.8230\n16   16    16   True  16.9486   False      NaN         NaN    1.0                  False             True         False       0.5447            1.0             28.0           37.6368        0.4553\n17   17    17   True  19.6193    True      NaN         NaN    1.0                  False             True         False       0.5025            1.0             31.0           40.2820        0.4975\n18   18    18   True  40.8453    True      NaN         NaN    1.0                  False            False          True       0.0000            1.0             43.0           51.2966        1.1735\n19   19    19   True  25.0690   False      NaN         NaN    1.0                  False             True         False       0.4052            1.0             35.0           47.0952        0.5948\n20   20    20   True  24.1976   False      NaN         NaN    1.0                  False            False          True       0.0000            1.0             41.0           50.5722        1.1485\n21   21    21   True  27.8875   False      NaN         NaN    1.0                  False            False          True       0.5276            1.0             50.0           61.8450        1.4724\n22   22    22   True   7.1277    True      NaN         NaN    1.0                  False             True         False       0.5071            1.0             32.0           42.5898        0.4929\n23   23    23   True  35.5697   False      NaN         NaN    1.0                  False             True         False       0.5034            1.0             30.0           40.4424        0.4966\n24   24    24   True  36.3433    True      NaN         NaN    1.0                  False             True         False       0.3615            1.0             37.0           46.3120        0.6385\n25   25    25   True  58.3792   False      NaN         NaN    1.0                  False             True         False       0.5156            1.0             30.0           39.2283        0.4844\n26   26    26   True   1.6279    True      NaN         NaN    1.0                  False             True         False       0.6753            1.0             22.0           31.9325        0.3247\n27   27    27   True  49.9440   False      NaN         NaN    1.0                  False            False          True       0.0966            1.0             50.0           60.1813        1.9034\n28   28    28   True  50.4779   False      NaN         NaN    1.0                  False            False          True       0.0000            1.0             40.0           51.4462        1.1485\n29   29    29   True  39.0536   False      NaN         NaN    1.0                  False            False          True       0.2576            1.0             50.0           59.1780        1.7424\n\n\nThis is usually too much information to understand directly, but can be useful for producing summary statistics; for example, let’s say we want to understand the relationship between time since recovery and immunity:\n\nimport matplotlib.pyplot as plt\nplt.scatter(df['sis.ti_recovered'], df['sis.immunity'])\nplt.xlabel('Time of recovery')\nplt.ylabel('Immunity')\nplt.show()\n\n\n\n\n\n\n\n\nSometimes we want to explore a single agent in more detail. For this, there is a person() method, which will return all the attributes of that particular agent (equivalent to a single row in the dataframe):\n\nsim.people.person(10)\n\n#0. 'uid':                   10\n#1. 'slot':                  10\n#2. 'alive':                 True\n#3. 'age':                   4.050025\n#4. 'female':                True\n#5. 'ti_dead':               nan\n#6. 'ti_removed':            nan\n#7. 'scale':                 1.0\n#8. 'randomnet.participant': False\n#9. 'sis.susceptible':       True\n#10. 'sis.infected':          False\n#11. 'sis.rel_sus':           0.18277001\n#12. 'sis.rel_trans':         1.0\n#13. 'sis.ti_infected':       34.0\n#14. 'sis.ti_recovered':      45.841686\n#15. 'sis.immunity':          0.81723",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "People, States, and Arrays"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html",
    "href": "user_guide/workflows_deploy.html",
    "title": "Deployment",
    "section": "",
    "text": "Since Starsim is implemented in pure Python, it can easily be deployed on the cloud. Here we describe some different approaches for doing this.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html#virtual-machine",
    "href": "user_guide/workflows_deploy.html#virtual-machine",
    "title": "Deployment",
    "section": "Virtual machine",
    "text": "Virtual machine\nOne of the most common approaches is to run Starsim on a single large virtual machine (VM). By default, ss.MultiSim (and ss.parallel()) will use all available cores. If your script already makes use of these, then you don’t need to make any more changes:\n\nimport sciris as sc\nimport starsim as ss\n\nbase_pars = sc.objdict(\n    n_agents = 10e3,\n    diseases = sc.objdict(\n        type = 'sis',\n        beta = 0.1,\n    ),\n    networks = 'random',\n    rand_seed = 1,\n    verbose = False,\n)\n\n# Generate sims in serial\nsims = sc.autolist() # Can also just use []\nfor i in range(10):\n    pars = base_pars.copy()\n    pars.diseases.beta *= sc.perturb()\n    pars.rand_seed = i\n    sim = ss.Sim(pars)\n    sims += sim\n\n# Run in parallel\nmsim = ss.parallel(sims)\nmsim.plot(legend=False)\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nNote that this example uses sc.objdict() rather than dict() – either work, but it means you can use pars.diseases.beta rather than pars['diseases']['beta']. You could also create full Starsim objects (e.g. diseases = ss.SIS() and then modify pars.diseases.pars.beta).\nIn some cases, creating the sim is itself a time-consuming step (especially if hundreds or thousands are being generated). In this case, you can write a make_sim() function and parallelize that too:\n\ndef make_sim(i, pars):\n    pars.diseases.beta *= sc.perturb() # Don't need to copy pars since implicitly copied via the pickling process\n    pars.rand_seed = i\n    sim = ss.Sim(pars)\n    return sim\n\nsims = sc.parallelize(make_sim, range(10), pars=base_pars, serial=False)\nmsim = ss.parallel(sims)\nmsim.plot(legend=False)\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nNote that parallelizing the build process pickles and unpickles the sims, which can be an expensive operation. make_sim() functions can often get quite complicated, so it’s often good software engineering practice to separate them out anyway. You can use the serial=True argument of Sciris’ sc.parallelize() function (which is what ss.parallel() calls under the hood) in order to run in serial, to see if it’s the same speed or faster.\n\nWhile the traditional way to run on a VM is via SSH and terminal, it is also possible to run remotely via VS Code (and Cursor etc.), PyCharm, or Spyder. You can also run a Jupyter server on the VM and access it that way (we like The Littlest JupyterHub).",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html#dask-and-coiled",
    "href": "user_guide/workflows_deploy.html#dask-and-coiled",
    "title": "Deployment",
    "section": "Dask and Coiled",
    "text": "Dask and Coiled\nAdapting the examples above, we can fairly easily make Starsim simulations run using other popular tools such as Dask and Joblib. Here’s a Dask example:\n\nimport dask\nimport dask.distributed as dd\nimport numpy as np\nimport starsim as ss\n\n\ndef run_sim(index, beta):\n    \"\"\" Run a standard simulation \"\"\"\n    label = f'Sim {index}, beta={beta:n}'\n    sis = ss.SIS(beta=beta)\n    sim = ss.Sim(label=label, networks='random', diseases=sis, rand_seed=index, verbose=False)\n    sim.run()\n    sim.shrink() # Remove People and other states to make pickling faster\n    return sim\n\n\nif __name__ == '__main__':\n\n    # Run settings\n    n = 8\n    n_workers = 4\n    betas = 0.1*np.sort(np.random.random(n))\n\n    # Create and queue the Dask jobs\n    client = dd.Client(n_workers=n_workers)\n    queued = []\n    for i,beta in enumerate(betas):\n        run = dask.delayed(run_sim)(i, beta)\n        queued.append(run)\n\n    # Run and process the simulations\n    sims = list(dask.compute(*queued))\n    msim = ss.MultiSim(sims)\n    msim.plot()\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nCoiled, which is a paid service by Dask that allows auto-scaling across clusters, has a similar syntax:\nimport sciris as sc\nimport starsim as ss\nimport coiled\nimport dask.distributed as dd\n\n# Parameters\nn_workers = 50\nn = 1000\n\ndef run_sim(seed):\n    sim = ss.Sim(n_agents=100e3, dur=100, diseases='sis', networks='random', rand_seed=seed)\n    sim.run().shrink()\n    return sim\n\n# Set up cluster\ncluster = coiled.Cluster(n_workers=n_workers, workspace=\"&lt;your_coiled_workspace&gt;\")\nclient = cluster.get_client()\n\n# Set up futures\nfutures = []\nfor seed in range(n):\n    future = client.submit(run_sim, seed)\n    futures.append(future)\n\n# Run\nsims = client.gather(futures)\n\n# Plot\nmsim = ss.MultiSim(sims)\nmsim.plot()\n(Note: You will need a Coiled subscription to run this example.)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/workflows_deploy.html#interactive-dashboards",
    "href": "user_guide/workflows_deploy.html#interactive-dashboards",
    "title": "Deployment",
    "section": "Interactive dashboards",
    "text": "Interactive dashboards\nAnother common desire is to make interactive dashboards. There are many ways to do this, including Shiny for Python, Voila, and Panel, but the simplest is probably Streamlit:\nimport streamlit as st\nimport starsim as ss\n\ndef run_sim(beta, n_agents):\n    sis = ss.SIS(beta=beta)\n    sim = ss.Sim(\n        n_agents = n_agents,\n        diseases = sis,\n        networks = 'random',\n    )\n    sim.run()\n    sim.label = f'Beta={beta:n} • Agents={n_agents:,} • Time={sim.timer.total:0.1f} s'\n    return sim\n\n# Create the Streamlit interface\nst.title('SIS Dashboard')\nbeta = st.slider('Transmission rate (beta)', 0.0, 1.0, 0.1)\nn_agents = st.slider('Number of agents', 1_000, 100_000, 10_000)\n\n# Run simulation and plot results\nsim = run_sim(beta, n_agents)\nfig = sim.diseases.sis.plot()\nfig.suptitle(sim.label)\nst.pyplot(fig)\nThis example is saved in this folder as streamlit.py, and (after pip install streamlit) can be run with streamlit run streamlit.py. This should give something like this:\n\n\n\nStreamlit example",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Deployment"
    ]
  },
  {
    "objectID": "user_guide/workflows_run.html",
    "href": "user_guide/workflows_run.html",
    "title": "Multiple runs",
    "section": "",
    "text": "Let’s be honest, there isn’t much you can do with a single sim run. So 99.9% of the time, you’ll be wanting to run multiple simulations and compare them.\nThe easiest way to do this is with ss.parallel(), which, as the name suggests, runs the sim in parallel on your computer using all available cores. Let’s say we want to see what difference swapping the network makes:\nimport starsim as ss\nss.options(jupyter=True) # Improve plot resolution\n\nsim1 = ss.Sim(label='random', diseases='sis', networks='random')\nsim2 = ss.Sim(label='randomsafe', diseases='sis', networks='randomsafe')\nmsim = ss.parallel(sim1, sim2)\nmsim.plot()\n\nInitializing sim \"randomsafe\" with 10000 agents\nInitializing sim \"random\" with 10000 agents\n  Running \"randomsafe\": 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running \"random\": 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running \"random\": 2010.01.01 (10/51) (0.17 s)  ••••———————————————— 22%\n  Running \"randomsafe\": 2010.01.01 (10/51) (0.19 s)  ••••———————————————— 22%\n  Running \"random\": 2020.01.01 (20/51) (0.20 s)  ••••••••———————————— 41%\n  Running \"randomsafe\": 2020.01.01 (20/51) (0.24 s)  ••••••••———————————— 41%  Running \"random\": 2030.01.01 (30/51) (0.24 s)  ••••••••••••———————— 61%\n\n  Running \"random\": 2040.01.01 (40/51) (0.27 s)  ••••••••••••••••———— 80%\n  Running \"randomsafe\": 2030.01.01 (30/51) (0.29 s)  ••••••••••••———————— 61%\n  Running \"random\": 2050.01.01 (50/51) (0.30 s)  •••••••••••••••••••• 100%\n\n  Running \"randomsafe\": 2040.01.01 (40/51) (0.34 s)  ••••••••••••••••———— 80%\n  Running \"randomsafe\": 2050.01.01 (50/51) (0.39 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\nss.parallel() is just a wrapper for ss.MultiSim().run() (and note how we can pass arguments to all of the sims, e.g. verbose=0 here):\nsim1 = ss.Sim(diseases='sis', networks='random')\nsim2 = ss.Sim(diseases='sis', networks='randomsafe')\nmsim = ss.MultiSim(sims=[sim1, sim2]).run(verbose=0)\nmsim.plot()\n\nInitializing sim \"Sim 0\" with 10000 agents\nInitializing sim \"Sim 1\" with 10000 agents\nFigure(768x576)\nIn most cases, this is the most efficient workflow: make some sims (potentially via a loop), and then run them. But there are some other common workflows as well. One is to run the same simulation with different random seeds. This is what happens by default if you call ss.MultiSim() with a single sim:\nsim = ss.Sim(n_agents=2000, diseases='sir', networks='random', verbose=0)\nmsim = ss.MultiSim(sim).run()\nmsim.plot()\n\nFigure(768x576)\nIn addition to plotting the individual sims, we can quickly compute stats on the sim by calling msim.mean() or msim.median() (or more generally, msim.reduce() if we want to specify e.g. quantiles):\nmsim.mean()\nmsim.plot()\n\nFigure(768x576)\nThis looks a little wonky because the error bounds shown are ±2 standard deviations, but we know things like deaths can’t go negative. In cases like this, we get more reasonable results with median(), which by default shows the 10th and 90th quantiles:\nmsim.median()\nmsim.plot()\n\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Multiple runs"
    ]
  },
  {
    "objectID": "user_guide/workflows_run.html#copies",
    "href": "user_guide/workflows_run.html#copies",
    "title": "Multiple runs",
    "section": "Copies",
    "text": "Copies\nBoth ss.Sim and ss.MultiSim objects let you control whether or not the objects passed into them are copied. By default, sims do copy inputs and multisims don’t. Let’s look at a few examples.\nSims copy inputs by default because it’s common to want to reuse a module between sims, which wouldn’t be allowed if it wasn’t copied (since it’s modified in place during run). For example:\n\nsis = ss.SIS(beta=0.1)\n\ns1 = ss.Sim(label='Low contacts', diseases=sis, networks=ss.RandomNet(n_contacts=5))\ns2 = ss.Sim(label='High contacts', diseases=sis, networks=ss.RandomNet(n_contacts=10))\nss.parallel(s1, s2).plot()\n\nInitializing sim \"Low contacts\" with 10000 agentsInitializing sim \"High contacts\" with 10000 agents\n\n  Running \"High contacts\": 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%  Running \"Low contacts\": 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n\n  Running \"Low contacts\": 2010.01.01 (10/51) (0.17 s)  ••••———————————————— 22%\n  Running \"High contacts\": 2010.01.01 (10/51) (0.17 s)  ••••———————————————— 22%\n  Running \"Low contacts\": 2020.01.01 (20/51) (0.20 s)  ••••••••———————————— 41%\n  Running \"High contacts\": 2020.01.01 (20/51) (0.21 s)  ••••••••———————————— 41%\n  Running \"Low contacts\": 2030.01.01 (30/51) (0.22 s)  ••••••••••••———————— 61%\n  Running \"High contacts\": 2030.01.01 (30/51) (0.25 s)  ••••••••••••———————— 61%  Running \"Low contacts\": 2040.01.01 (40/51) (0.25 s)  ••••••••••••••••———— 80%\n\n  Running \"Low contacts\": 2050.01.01 (50/51) (0.28 s)  •••••••••••••••••••• 100%\n\n  Running \"High contacts\": 2040.01.01 (40/51) (0.30 s)  ••••••••••••••••———— 80%\n  Running \"High contacts\": 2050.01.01 (50/51) (0.33 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nBut this can be confusing, because it means the sis in the simulation is a different object than the sis you created. If you want to keep it the same, set copy_inputs=False, for example, to use it directly afterwards:\n\nsir = ss.SIR(beta=0.035)\nsim = ss.Sim(diseases=sir, networks='random', copy_inputs=False)\nsim.run()\nsir.plot() # This wouldn't work without copy_inputs=False\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.17 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.21 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.24 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.28 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.31 s)  •••••••••••••••••••• 100%\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nConversely, ss.MultiSim() by default does not copy the input sims, so they are modified in place:\n\ns1 = ss.Sim(diseases='sis', networks='random')\ns2 = ss.Sim(diseases='sir', networks='random')\nss.parallel(s1, s2, verbose=0)\n\ns1.plot() # This also works, because it was run in place\n\nInitializing sim \"Sim 0\" with 10000 agentsInitializing sim \"Sim 1\" with 10000 agents\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nIf you want to copy the sims before run, then set inplace=False:\n\ns1 = ss.Sim(diseases='sis', networks='random')\ns2 = ss.Sim(diseases='sir', networks='random')\nss.parallel(s1, s2, verbose=0, inplace=False)\n\ns1.run().plot() # This now works, because the sim was *not* run in place\n\nInitializing sim \"Sim 0\" with 10000 agents\nInitializing sim \"Sim 1\" with 10000 agents\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.03 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.06 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.09 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.12 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.15 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Multiple runs"
    ]
  },
  {
    "objectID": "user_guide/workflows_run.html#advanced-workflows",
    "href": "user_guide/workflows_run.html#advanced-workflows",
    "title": "Multiple runs",
    "section": "Advanced workflows",
    "text": "Advanced workflows\nA common pattern for more complex workflows is to write make_sim(). The example below, based on an STIsim application, shows how complex a make_sim() function can get (this is, after all, where most of the science happens!):\ndef make_sim(seed=1, n_agents=None, start=1990, stop=2030, debug=False, add_stis=True, scenario='treat'):\n\n    total_pop = {1970: 5.203e6, 1980: 7.05e6, 1985: 8.691e6, 1990: 9980999, 2000: 11.83e6}[start]\n    if n_agents is None: n_agents = [int(10e3), int(5e2)][debug]\n    if dt is None: dt = [1/12, 1][debug]\n\n    # Demographic modules\n    fertility_data = pd.read_csv(f'data/asfr.csv')\n    pregnancy = ss.Pregnancy(dt='month', fertility_rate=fertility_data)\n    death_data = pd.read_csv(f'data/deaths.csv')\n    death = ss.Deaths(death_rate=death_data, rate_units=1)\n\n    # People and networks\n    ppl = ss.People(n_agents, age_data=pd.read_csv(f'data/age_dist_{start}.csv', index_col='age')['value'])\n    sexual = sti.FastStructuredSexual(\n        prop_f0=0.79,\n        prop_m0=0.83,\n        f1_conc=0.16,\n        m1_conc=0.11,\n        p_pair_form=0.58,\n        condom_data=pd.read_csv(f'data/condom_use.csv'),\n    )\n    maternal = ss.MaternalNet(dt='month')\n\n    # Diseases\n    hiv = make_hiv()\n    diseases = [hiv]\n    if add_stis:\n        ng, ct, tv, bv = make_stis()\n        stis = [ng, ct, tv, bv]\n        diseases += stis  # Add the STIs to the list of diseases\n\n    # Interventions and analyzers\n    intvs = make_hiv_intvs()\n    if add_stis:\n        intvs += make_testing(ng, ct, tv, bv, scenario=scenario, poc=poc, stop=stop)\n        connectors = [sti.hiv_ng(hiv, ng), sti.hiv_ct(hiv, ct), sti.hiv_tv(hiv, tv)]\n    else:\n        connectors = []\n\n    if analyzers is None:\n        analyzers = [sti.sw_stats(diseases=['ng', 'ct', 'tv']), ts()]\n\n    # Actually create the sim\n    sim = ss.Sim(\n        dt=dt,\n        rand_seed=seed,\n        total_pop=total_pop,\n        start=start,\n        stop=stop,\n        people=ppl,\n        diseases=diseases,\n        networks=[sexual, maternal],\n        demographics=[pregnancy, death],\n        interventions=intvs,\n        analyzers=analyzers,\n        connectors=connectors,\n    )\n\n    # Store scenario\n    sim.scenario = scenario\n    return sim\nIf your make_sim() function is computationally expensive, you can parallelize it using sc.parallelize(), e.g.\n# Make the arguments\niterkwargs = []\nfor seed in range(100):\n    for n_agents in [1e3, 2e3, 5e3, 10e3]:\n        iterkwargs.append(dict(seed=seed, n_agents=n_agents))\n\n# Make the sims\nsims = sc.parallelize(make_sim, iterkwargs=iterkwargs)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Multiple runs"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html",
    "href": "user_guide/workflows_samples.html",
    "title": "Samples",
    "section": "",
    "text": "As Starsim models are usually stochastic, for a single scenario it is often desirable to run the model multiple times with different random seeds. The role of the Samples class is to facilitate working with large numbers of simulations and scenarios, to ease:\nEssentially, if we think of the processed results of a model run as being\nthen the classes Dataset and Samples manage collections of these results. In particular, the Samples class manages different random samples of the same parameters, and the Dataset class manages a collection of Samples.\nimport starsim as ss\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport sciris as sc",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#obtaining-simulation-output",
    "href": "user_guide/workflows_samples.html#obtaining-simulation-output",
    "title": "Samples",
    "section": "Obtaining simulation output",
    "text": "Obtaining simulation output\nTo demonstrate usage of this class, we will first consider constructing the kinds of output that the Samples class stores. We begin by running a basic simulation using the SIR model:\n\nppl = ss.People(5000)\nnet = ss.ndict(ss.RandomNet(n_contacts=ss.poisson(5)))\nsir = ss.SIR()\nsim = ss.Sim(people=ppl, networks=net, diseases=sir, rand_seed=0)\nsim.run();\n\nInitializing sim with 5000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.16 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.19 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.21 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.23 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.25 s)  •••••••••••••••••••• 100%\n\n\n\n\nDataframe output\nA Sim instance is (in general) too large and complex to efficiently store on disk - the file size and loading time make it prohibitive to work with tens of thousands of simulations. Therefore, rather than storing entire Sim instances, we instead store dataframes containing just the simulation results and any other pre-processed calculated quantities. There are broadly speaking two types of outputs:\n\nScalar outputs at each timepoint (e.g., daily new cases)\nScalar outputs for each simulation (e.g., total number of deaths)\n\nThese outputs can each be produced from a Sim - the former has a tabular structure, and the latter has a dictionary structure (which can later be assembled into a table where the rows correspond to each simulation). The export_df method is a quick way to obtain a dataframe with the appropriate structure retaining all results from the Sim.\n\nIn real-world use, it is often helpful to write your own function to extract a dataframe of simulation outputs, because typically some of the outputs need to be extracted from custom Analyzers.\n\n\nsim.to_df()\n\n\n\n\n\n\n\n\ntimevec\nrandomnet_n_edges\nsir_n_susceptible\nsir_n_infected\nsir_n_recovered\nsir_prevalence\nsir_new_infections\nsir_cum_infections\nn_alive\nn_female\nnew_deaths\nnew_emigrants\ncum_deaths\n\n\n\n\n0\n2000-01-01\n12616.0\n4937.0\n63.0\n0.0\n0.012600\n15.0\n15.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n1\n2001-01-01\n12598.0\n4905.0\n95.0\n0.0\n0.019000\n32.0\n47.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n2\n2002-01-01\n12436.0\n4862.0\n138.0\n0.0\n0.027600\n43.0\n90.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n3\n2003-01-01\n12570.0\n4795.0\n205.0\n0.0\n0.041000\n67.0\n157.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n4\n2004-01-01\n12525.0\n4699.0\n301.0\n0.0\n0.060200\n96.0\n253.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n5\n2005-01-01\n12456.0\n4555.0\n434.0\n11.0\n0.086800\n144.0\n397.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n6\n2006-01-01\n12662.0\n4373.0\n587.0\n40.0\n0.117400\n182.0\n579.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n7\n2007-01-01\n12486.0\n4142.0\n777.0\n80.0\n0.155400\n231.0\n810.0\n4999.0\n0.0\n1.0\n0.0\n0.0\n\n\n8\n2008-01-01\n12516.0\n3843.0\n1034.0\n122.0\n0.206841\n299.0\n1109.0\n4999.0\n0.0\n0.0\n0.0\n1.0\n\n\n9\n2009-01-01\n12412.0\n3524.0\n1290.0\n184.0\n0.258052\n319.0\n1428.0\n4998.0\n0.0\n1.0\n0.0\n1.0\n\n\n10\n2010-01-01\n12658.0\n3128.0\n1597.0\n272.0\n0.319528\n396.0\n1824.0\n4997.0\n0.0\n1.0\n0.0\n2.0\n\n\n11\n2011-01-01\n12534.0\n2682.0\n1921.0\n393.0\n0.384431\n446.0\n2270.0\n4996.0\n0.0\n1.0\n0.0\n3.0\n\n\n12\n2012-01-01\n12634.0\n2276.0\n2159.0\n559.0\n0.432146\n406.0\n2676.0\n4994.0\n0.0\n2.0\n0.0\n4.0\n\n\n13\n2013-01-01\n12498.0\n1882.0\n2346.0\n766.0\n0.469764\n394.0\n3070.0\n4994.0\n0.0\n0.0\n0.0\n6.0\n\n\n14\n2014-01-01\n12401.0\n1523.0\n2456.0\n1014.0\n0.491790\n359.0\n3429.0\n4993.0\n0.0\n1.0\n0.0\n6.0\n\n\n15\n2015-01-01\n12482.0\n1250.0\n2421.0\n1319.0\n0.484879\n273.0\n3702.0\n4990.0\n0.0\n3.0\n0.0\n7.0\n\n\n16\n2016-01-01\n12532.0\n1035.0\n2275.0\n1679.0\n0.455912\n215.0\n3917.0\n4989.0\n0.0\n1.0\n0.0\n10.0\n\n\n17\n2017-01-01\n12585.0\n880.0\n2030.0\n2076.0\n0.406895\n155.0\n4072.0\n4986.0\n0.0\n3.0\n0.0\n11.0\n\n\n18\n2018-01-01\n12364.0\n746.0\n1749.0\n2489.0\n0.350782\n134.0\n4206.0\n4984.0\n0.0\n2.0\n0.0\n14.0\n\n\n19\n2019-01-01\n12565.0\n649.0\n1449.0\n2877.0\n0.290730\n97.0\n4303.0\n4975.0\n0.0\n9.0\n0.0\n16.0\n\n\n20\n2020-01-01\n12442.0\n573.0\n1159.0\n3241.0\n0.232965\n76.0\n4379.0\n4973.0\n0.0\n2.0\n0.0\n25.0\n\n\n21\n2021-01-01\n12325.0\n540.0\n868.0\n3559.0\n0.174543\n33.0\n4412.0\n4967.0\n0.0\n6.0\n0.0\n27.0\n\n\n22\n2022-01-01\n12465.0\n505.0\n667.0\n3793.0\n0.134286\n35.0\n4447.0\n4965.0\n0.0\n2.0\n0.0\n33.0\n\n\n23\n2023-01-01\n12490.0\n485.0\n500.0\n3979.0\n0.100705\n20.0\n4467.0\n4964.0\n0.0\n1.0\n0.0\n35.0\n\n\n24\n2024-01-01\n12396.0\n479.0\n347.0\n4138.0\n0.069903\n6.0\n4473.0\n4964.0\n0.0\n0.0\n0.0\n36.0\n\n\n25\n2025-01-01\n12400.0\n468.0\n246.0\n4248.0\n0.049557\n11.0\n4484.0\n4962.0\n0.0\n2.0\n0.0\n36.0\n\n\n26\n2026-01-01\n12420.0\n460.0\n175.0\n4326.0\n0.035268\n8.0\n4492.0\n4961.0\n0.0\n1.0\n0.0\n38.0\n\n\n27\n2027-01-01\n12511.0\n453.0\n116.0\n4392.0\n0.023382\n7.0\n4499.0\n4961.0\n0.0\n0.0\n0.0\n39.0\n\n\n28\n2028-01-01\n12410.0\n448.0\n82.0\n4431.0\n0.016529\n5.0\n4504.0\n4961.0\n0.0\n0.0\n0.0\n39.0\n\n\n29\n2029-01-01\n12492.0\n447.0\n56.0\n4458.0\n0.011288\n1.0\n4505.0\n4961.0\n0.0\n0.0\n0.0\n39.0\n\n\n30\n2030-01-01\n12537.0\n445.0\n40.0\n4474.0\n0.008063\n2.0\n4507.0\n4959.0\n0.0\n2.0\n0.0\n39.0\n\n\n31\n2031-01-01\n12199.0\n443.0\n31.0\n4484.0\n0.006251\n2.0\n4509.0\n4958.0\n0.0\n1.0\n0.0\n41.0\n\n\n32\n2032-01-01\n12290.0\n440.0\n24.0\n4494.0\n0.004841\n3.0\n4512.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n33\n2033-01-01\n12387.0\n439.0\n20.0\n4499.0\n0.004034\n1.0\n4513.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n34\n2034-01-01\n12299.0\n438.0\n16.0\n4504.0\n0.003227\n1.0\n4514.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n35\n2035-01-01\n12533.0\n438.0\n11.0\n4509.0\n0.002219\n0.0\n4514.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n36\n2036-01-01\n12577.0\n437.0\n9.0\n4512.0\n0.001815\n1.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n37\n2037-01-01\n12405.0\n437.0\n6.0\n4515.0\n0.001210\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n38\n2038-01-01\n12471.0\n437.0\n3.0\n4518.0\n0.000605\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n39\n2039-01-01\n12483.0\n437.0\n3.0\n4518.0\n0.000605\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n40\n2040-01-01\n12359.0\n437.0\n1.0\n4520.0\n0.000202\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n41\n2041-01-01\n12419.0\n437.0\n1.0\n4520.0\n0.000202\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n42\n2042-01-01\n12242.0\n437.0\n1.0\n4520.0\n0.000202\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n43\n2043-01-01\n12449.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n44\n2044-01-01\n12400.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n45\n2045-01-01\n12324.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n46\n2046-01-01\n12445.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n47\n2047-01-01\n12368.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n48\n2048-01-01\n12479.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n49\n2049-01-01\n12304.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n50\n2050-01-01\n12485.0\n437.0\n0.0\n4521.0\n0.000000\n0.0\n4515.0\n4958.0\n0.0\n0.0\n0.0\n42.0\n\n\n\n\n\n\n\n\n\nScalar/summary outputs\nWe can also consider extracting a summary dictionary of scalar values. For example:\n\nsummary = {}\nsummary['seed'] = sim.pars['rand_seed']\nsummary['p_death'] = sim.diseases[0].pars.p_death.pars.p\nsummary['cum_infections'] = sum(sim.results.sir.new_infections)\nsummary['cum_deaths'] = sum(sim.results.new_deaths)\nsummary\n\n{'seed': 0, 'p_death': 0.01, 'cum_infections': 4515.0, 'cum_deaths': 42.0}\n\n\n\nNotice how in the example above, the summary contains both simulation inputs (seed, probability of death) as well as simulation outputs (total infections, total deaths). The simulation summary should contain sufficient information about the simulation inputs to identify the simulation. The seed should generally be present. The other inputs normally correspond to variables that scenarios are being run over. In this example, we will run scenarios comparing simulations with different probabilities of death. Therefore, we need to include the death probability in the simulation summary.\n\n\n\nRunning the model\nFor usage at scale, the steps of creating a simulation, running it and producing these outputs are usually encapsulated in functions:\n\ndef get_sim(seed, p_death):\n    ppl = ss.People(5000)\n    net = ss.RandomNet(n_contacts=ss.poisson(5))\n    sir = ss.SIR(p_death=p_death)\n    sim = ss.Sim(people=ppl, networks=net, diseases=sir, rand_seed=seed)\n    sim.init(verbose=0)\n    return sim\n    \ndef run_sim(seed, p_death):\n    sim = get_sim(seed, p_death)\n    sim.run(verbose=0)\n    df = sim.to_df()\n    \n    summary = {}\n    summary['seed'] = sim.pars['rand_seed']\n    summary['p_death']= sim.diseases[0].pars.p_death.pars.p\n    summary['cum_infections'] = sum(sim.results.sir.new_infections)\n    summary['cum_deaths'] = sum(sim.results.new_deaths)\n    \n    return df, summary\n\n\nThe functions above could be combined into a single function. However, in real world usage it is often convenient to be able to construct a simulation independently of running it (e.g., for diagnostic purposes or to allow running the sim in a range of different ways). The suggested structure above, with a get_sim() function and a run_sim() function are recommended as standard practice.\n\nNow running a simulation for a given beta/seed value and returning the processed outputs can be done in a single step:\n\n# Scalar output\ndf, summary = run_sim(0, 0.2);\nsummary\n\n{'seed': 0, 'p_death': 0.2, 'cum_infections': 4628.0, 'cum_deaths': 934.0}\n\n\nWe can produce all of the samples associated with a scenario by iterating over the input seed values. This is being done in a basic loop here, but could be done in more sophistical ways to leverage parallel computing (e.g., with sc.parallelize for single host parallelization, or with celery for distributed computation).\n\n# Run a collection of sims\nn = 20\nseeds = np.arange(n)\noutputs = [run_sim(seed, 0.2) for seed in seeds]",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#saving-and-loading-the-samples",
    "href": "user_guide/workflows_samples.html#saving-and-loading-the-samples",
    "title": "Samples",
    "section": "Saving and loading the samples",
    "text": "Saving and loading the samples\nWe have now produced simulation outputs (dataframes and summary statistics) for 20 simulation runs. The outputs here are a list of tuples, containing the dataframe and dictionary outputs for each sample. This list can be passed to the cvv.Samples class to produce a single compressed file on disk:\n\nresultsdir = Path('results')\nresultsdir.mkdir(exist_ok=True, parents=True)\nss.Samples.new(resultsdir, outputs, identifiers=[\"p_death\"])\nlist(resultsdir.iterdir())\n\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.2.zip\"\n\n\n[PosixPath('results/0.2.zip')]\n\n\nNotice that a list of identifiers should be passed to the Samples constructor. This is a list of keys in the simulation summary dictionaries that identifies the scenario. These would be model inputs rather than model outputs, and they should be the same for all of the outputs passed into the Samples object. If no file name is explicitly provided, the file will automatically be assigned a name based on the identifiers.\n\nThe Samples file internally contains metadata recording the identifiers. When Samples are accessed using the Dataset class, they can be accessed via the internal metadata. Therefore for a typical workflow, the file name largely doesn’t matter, and it usually doesn’t need to be manually specified.\n\nThe saved file can be loaded and accessed via the Samples class. Importantly, individual files can be extracted from a .zip file without decompressing the entire archive. This means that loading the summary dataframe and using it to selectively load the full outputs for individual runs can be done efficiently. For example, loading retrieving a single result from a Samples file would take a similar amount of time regardless of whether the file contained 10 samples or 100000 samples.\n\n# Load the samples\nres = ss.Samples('results/0.2.zip')\nres.summary\n\n\n\n\n\n\n\n\n\ncum_infections\ncum_deaths\n\n\nseed\np_death\n\n\n\n\n\n\n0\n0.2\n4628.0\n934.0\n\n\n1\n0.2\n4600.0\n909.0\n\n\n2\n0.2\n4618.0\n926.0\n\n\n3\n0.2\n4625.0\n992.0\n\n\n4\n0.2\n4564.0\n915.0\n\n\n5\n0.2\n4656.0\n971.0\n\n\n6\n0.2\n4633.0\n979.0\n\n\n7\n0.2\n4672.0\n966.0\n\n\n8\n0.2\n4613.0\n873.0\n\n\n9\n0.2\n4645.0\n960.0\n\n\n10\n0.2\n4569.0\n940.0\n\n\n11\n0.2\n4639.0\n920.0\n\n\n12\n0.2\n4605.0\n939.0\n\n\n13\n0.2\n4619.0\n926.0\n\n\n14\n0.2\n4664.0\n978.0\n\n\n15\n0.2\n4599.0\n910.0\n\n\n16\n0.2\n4622.0\n900.0\n\n\n17\n0.2\n4603.0\n942.0\n\n\n18\n0.2\n4645.0\n901.0\n\n\n19\n0.2\n4623.0\n884.0\n\n\n\n\n\n\n\nWhen the Samples file was created, a dictionary of scalars was provided for each result. These are automatically used to populate a ‘summary’ dataframe, where each identifier (and the seed) are used as the index, and the remaining keys appear as columns, as shown above. As a shortcut, columns of the summary dataframe can be accessed by indexing the Samples object directly, without having to access the .summary attribute e.g.,\n\nres['cum_infections']\n\nseed  p_death\n0     0.2        4628.0\n1     0.2        4600.0\n2     0.2        4618.0\n3     0.2        4625.0\n4     0.2        4564.0\n5     0.2        4656.0\n6     0.2        4633.0\n7     0.2        4672.0\n8     0.2        4613.0\n9     0.2        4645.0\n10    0.2        4569.0\n11    0.2        4639.0\n12    0.2        4605.0\n13    0.2        4619.0\n14    0.2        4664.0\n15    0.2        4599.0\n16    0.2        4622.0\n17    0.2        4603.0\n18    0.2        4645.0\n19    0.2        4623.0\nName: cum_infections, dtype: float64\n\n\nEach simulation is uniquely identified by its seed, and the time series dataframe for each simulation can be accessed by indexing the Samples object with the seed:\n\nres[0]\n\n\n\n\n\n\n\n\nUnnamed: 0\nrandomnet_n_edges\nsir_n_susceptible\nsir_n_infected\nsir_n_recovered\nsir_prevalence\nsir_new_infections\nsir_cum_infections\nn_alive\nn_female\nnew_deaths\nnew_emigrants\ncum_deaths\n\n\ntimevec\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2000-01-01\n0\n12616.0\n4937.0\n63.0\n0.0\n0.012600\n15.0\n15.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n2001-01-01\n1\n12598.0\n4905.0\n95.0\n0.0\n0.019000\n32.0\n47.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n2002-01-01\n2\n12436.0\n4862.0\n138.0\n0.0\n0.027600\n43.0\n90.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n2003-01-01\n3\n12570.0\n4795.0\n205.0\n0.0\n0.041000\n67.0\n157.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n2004-01-01\n4\n12525.0\n4699.0\n301.0\n0.0\n0.060200\n96.0\n253.0\n5000.0\n0.0\n0.0\n0.0\n0.0\n\n\n2005-01-01\n5\n12456.0\n4554.0\n435.0\n9.0\n0.087000\n145.0\n398.0\n4998.0\n0.0\n2.0\n0.0\n0.0\n\n\n2006-01-01\n6\n12660.0\n4405.0\n555.0\n33.0\n0.111044\n149.0\n547.0\n4993.0\n0.0\n5.0\n0.0\n2.0\n\n\n2007-01-01\n7\n12466.0\n4195.0\n724.0\n67.0\n0.145003\n210.0\n757.0\n4986.0\n0.0\n7.0\n0.0\n7.0\n\n\n2008-01-01\n8\n12502.0\n3916.0\n961.0\n105.0\n0.192740\n279.0\n1036.0\n4982.0\n0.0\n4.0\n0.0\n14.0\n\n\n2009-01-01\n9\n12389.0\n3587.0\n1227.0\n155.0\n0.246287\n329.0\n1365.0\n4969.0\n0.0\n13.0\n0.0\n18.0\n\n\n2010-01-01\n10\n12544.0\n3203.0\n1521.0\n227.0\n0.306098\n384.0\n1749.0\n4951.0\n0.0\n18.0\n0.0\n31.0\n\n\n2011-01-01\n11\n12437.0\n2776.0\n1832.0\n312.0\n0.370026\n427.0\n2176.0\n4920.0\n0.0\n31.0\n0.0\n49.0\n\n\n2012-01-01\n12\n12381.0\n2358.0\n2101.0\n428.0\n0.427033\n418.0\n2594.0\n4887.0\n0.0\n33.0\n0.0\n80.0\n\n\n2013-01-01\n13\n12178.0\n1954.0\n2305.0\n588.0\n0.471660\n404.0\n2998.0\n4847.0\n0.0\n40.0\n0.0\n113.0\n\n\n2014-01-01\n14\n12053.0\n1567.0\n2454.0\n784.0\n0.506293\n387.0\n3385.0\n4805.0\n0.0\n42.0\n0.0\n153.0\n\n\n2015-01-01\n15\n12043.0\n1236.0\n2487.0\n1030.0\n0.517586\n331.0\n3716.0\n4753.0\n0.0\n52.0\n0.0\n195.0\n\n\n2016-01-01\n16\n11899.0\n975.0\n2388.0\n1318.0\n0.502420\n261.0\n3977.0\n4681.0\n0.0\n72.0\n0.0\n247.0\n\n\n2017-01-01\n17\n11815.0\n796.0\n2165.0\n1628.0\n0.462508\n179.0\n4156.0\n4589.0\n0.0\n92.0\n0.0\n319.0\n\n\n2018-01-01\n18\n11372.0\n685.0\n1868.0\n1951.0\n0.407060\n111.0\n4267.0\n4504.0\n0.0\n85.0\n0.0\n411.0\n\n\n2019-01-01\n19\n11297.0\n576.0\n1587.0\n2265.0\n0.352353\n109.0\n4376.0\n4428.0\n0.0\n76.0\n0.0\n496.0\n\n\n2020-01-01\n20\n11069.0\n507.0\n1252.0\n2602.0\n0.282746\n69.0\n4445.0\n4361.0\n0.0\n67.0\n0.0\n572.0\n\n\n2021-01-01\n21\n10853.0\n450.0\n972.0\n2869.0\n0.222885\n57.0\n4502.0\n4291.0\n0.0\n70.0\n0.0\n639.0\n\n\n2022-01-01\n22\n10761.0\n411.0\n732.0\n3097.0\n0.170590\n39.0\n4541.0\n4240.0\n0.0\n51.0\n0.0\n709.0\n\n\n2023-01-01\n23\n10648.0\n385.0\n526.0\n3276.0\n0.124057\n26.0\n4567.0\n4187.0\n0.0\n53.0\n0.0\n760.0\n\n\n2024-01-01\n24\n10417.0\n362.0\n388.0\n3404.0\n0.092668\n23.0\n4590.0\n4154.0\n0.0\n33.0\n0.0\n813.0\n\n\n2025-01-01\n25\n10348.0\n350.0\n281.0\n3495.0\n0.067646\n12.0\n4602.0\n4126.0\n0.0\n28.0\n0.0\n846.0\n\n\n2026-01-01\n26\n10319.0\n340.0\n206.0\n3561.0\n0.049927\n10.0\n4612.0\n4107.0\n0.0\n19.0\n0.0\n874.0\n\n\n2027-01-01\n27\n10292.0\n333.0\n148.0\n3616.0\n0.036036\n7.0\n4619.0\n4097.0\n0.0\n10.0\n0.0\n893.0\n\n\n2028-01-01\n28\n10198.0\n332.0\n103.0\n3653.0\n0.025140\n1.0\n4620.0\n4088.0\n0.0\n9.0\n0.0\n903.0\n\n\n2029-01-01\n29\n10251.0\n330.0\n67.0\n3687.0\n0.016389\n2.0\n4622.0\n4084.0\n0.0\n4.0\n0.0\n912.0\n\n\n2030-01-01\n30\n10323.0\n327.0\n48.0\n3699.0\n0.011753\n3.0\n4625.0\n4074.0\n0.0\n10.0\n0.0\n916.0\n\n\n2031-01-01\n31\n10084.0\n325.0\n34.0\n3712.0\n0.008346\n2.0\n4627.0\n4071.0\n0.0\n3.0\n0.0\n926.0\n\n\n2032-01-01\n32\n10072.0\n325.0\n19.0\n3726.0\n0.004667\n0.0\n4627.0\n4070.0\n0.0\n1.0\n0.0\n929.0\n\n\n2033-01-01\n33\n10177.0\n324.0\n12.0\n3732.0\n0.002948\n1.0\n4628.0\n4068.0\n0.0\n2.0\n0.0\n930.0\n\n\n2034-01-01\n34\n10122.0\n324.0\n10.0\n3734.0\n0.002458\n0.0\n4628.0\n4068.0\n0.0\n0.0\n0.0\n932.0\n\n\n2035-01-01\n35\n10260.0\n324.0\n7.0\n3737.0\n0.001721\n0.0\n4628.0\n4068.0\n0.0\n0.0\n0.0\n932.0\n\n\n2036-01-01\n36\n10318.0\n324.0\n6.0\n3737.0\n0.001475\n0.0\n4628.0\n4067.0\n0.0\n1.0\n0.0\n932.0\n\n\n2037-01-01\n37\n10182.0\n324.0\n3.0\n3739.0\n0.000738\n0.0\n4628.0\n4066.0\n0.0\n1.0\n0.0\n933.0\n\n\n2038-01-01\n38\n10212.0\n324.0\n1.0\n3741.0\n0.000246\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2039-01-01\n39\n10319.0\n324.0\n1.0\n3741.0\n0.000246\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2040-01-01\n40\n10139.0\n324.0\n1.0\n3741.0\n0.000246\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2041-01-01\n41\n10179.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2042-01-01\n42\n10023.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2043-01-01\n43\n10143.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2044-01-01\n44\n10176.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2045-01-01\n45\n10190.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2046-01-01\n46\n10213.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2047-01-01\n47\n10090.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2048-01-01\n48\n10242.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2049-01-01\n49\n10172.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n2050-01-01\n50\n10206.0\n324.0\n0.0\n3742.0\n0.000000\n0.0\n4628.0\n4066.0\n0.0\n0.0\n0.0\n934.0\n\n\n\n\n\n\n\nThe dataframes in the Samples object are cached, so that the dataframes don’t all need to be loaded in order to start working with the file. The first time a dataframe is accessed, it will be loaded from disk. Subsequent requests for the dataframe will return a cached version instead. The cached dataframe is copied each time it is retrieved, to prevent accidentally modifying the original data.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#common-analysis-operations",
    "href": "user_guide/workflows_samples.html#common-analysis-operations",
    "title": "Samples",
    "section": "Common analysis operations",
    "text": "Common analysis operations\nHere are some examples of common analyses that can be performed using functionality in the Samples class\n\nPlotting summary quantities\nOften it’s useful to be able plot distributions of summary quantities, such as the total infections. This can be performed by directly indexing the Samples object and then using the appropriate plotting command:\n\nplt.hist(res['cum_infections'], density=True)\n\nplt.xlabel('Total infections')\nplt.ylabel('Probability density')\n\nText(0, 0.5, 'Probability density')\n\n\n\n\n\n\n\n\n\n\n\nPlotting time series\nTime series plots can be obtained by accessing the dataframes associated with each seed, and then plotting quantities from those. For convenience, iterating over the Samples object will automatically iterate over all of the dataframes associated with each seed. For example:\n\nfor df in res:\n    plt.plot(df['sir_new_infections'], color='b', alpha=0.1)\n\n\n\n\n\n\n\n\n\n\nOther ways to access content\nWe have seen so far that we can use\n\nres.summary - retrieve dataframe of summary outputs\nres[summary_column] - retrieve a column of the summary dataframe\nres[seed] - retrieve the time series dataframe associated with one of the simulations\nfor df in res - iterate over time series dataframes\n\nSometimes it is useful to have access to both the summary dictionary and the time series dataframe associated with a single sample. These can be accessed using the get method, which takes in a seed, and returns both outputs for that seed together:\n\nres.get(0) # Retrieve both summary quantities and dataframes\n\n(#0. 'p_death':        0.2\n #1. 'cum_infections': 4628.0\n #2. 'cum_deaths':     934.0,\n             Unnamed: 0  randomnet_n_edges  sir_n_susceptible  sir_n_infected  \\\n timevec                                                                        \n 2000-01-01           0            12616.0             4937.0            63.0   \n 2001-01-01           1            12598.0             4905.0            95.0   \n 2002-01-01           2            12436.0             4862.0           138.0   \n 2003-01-01           3            12570.0             4795.0           205.0   \n 2004-01-01           4            12525.0             4699.0           301.0   \n 2005-01-01           5            12456.0             4554.0           435.0   \n 2006-01-01           6            12660.0             4405.0           555.0   \n 2007-01-01           7            12466.0             4195.0           724.0   \n 2008-01-01           8            12502.0             3916.0           961.0   \n 2009-01-01           9            12389.0             3587.0          1227.0   \n 2010-01-01          10            12544.0             3203.0          1521.0   \n 2011-01-01          11            12437.0             2776.0          1832.0   \n 2012-01-01          12            12381.0             2358.0          2101.0   \n 2013-01-01          13            12178.0             1954.0          2305.0   \n 2014-01-01          14            12053.0             1567.0          2454.0   \n 2015-01-01          15            12043.0             1236.0          2487.0   \n 2016-01-01          16            11899.0              975.0          2388.0   \n 2017-01-01          17            11815.0              796.0          2165.0   \n 2018-01-01          18            11372.0              685.0          1868.0   \n 2019-01-01          19            11297.0              576.0          1587.0   \n 2020-01-01          20            11069.0              507.0          1252.0   \n 2021-01-01          21            10853.0              450.0           972.0   \n 2022-01-01          22            10761.0              411.0           732.0   \n 2023-01-01          23            10648.0              385.0           526.0   \n 2024-01-01          24            10417.0              362.0           388.0   \n 2025-01-01          25            10348.0              350.0           281.0   \n 2026-01-01          26            10319.0              340.0           206.0   \n 2027-01-01          27            10292.0              333.0           148.0   \n 2028-01-01          28            10198.0              332.0           103.0   \n 2029-01-01          29            10251.0              330.0            67.0   \n 2030-01-01          30            10323.0              327.0            48.0   \n 2031-01-01          31            10084.0              325.0            34.0   \n 2032-01-01          32            10072.0              325.0            19.0   \n 2033-01-01          33            10177.0              324.0            12.0   \n 2034-01-01          34            10122.0              324.0            10.0   \n 2035-01-01          35            10260.0              324.0             7.0   \n 2036-01-01          36            10318.0              324.0             6.0   \n 2037-01-01          37            10182.0              324.0             3.0   \n 2038-01-01          38            10212.0              324.0             1.0   \n 2039-01-01          39            10319.0              324.0             1.0   \n 2040-01-01          40            10139.0              324.0             1.0   \n 2041-01-01          41            10179.0              324.0             0.0   \n 2042-01-01          42            10023.0              324.0             0.0   \n 2043-01-01          43            10143.0              324.0             0.0   \n 2044-01-01          44            10176.0              324.0             0.0   \n 2045-01-01          45            10190.0              324.0             0.0   \n 2046-01-01          46            10213.0              324.0             0.0   \n 2047-01-01          47            10090.0              324.0             0.0   \n 2048-01-01          48            10242.0              324.0             0.0   \n 2049-01-01          49            10172.0              324.0             0.0   \n 2050-01-01          50            10206.0              324.0             0.0   \n \n             sir_n_recovered  sir_prevalence  sir_new_infections  \\\n timevec                                                           \n 2000-01-01              0.0        0.012600                15.0   \n 2001-01-01              0.0        0.019000                32.0   \n 2002-01-01              0.0        0.027600                43.0   \n 2003-01-01              0.0        0.041000                67.0   \n 2004-01-01              0.0        0.060200                96.0   \n 2005-01-01              9.0        0.087000               145.0   \n 2006-01-01             33.0        0.111044               149.0   \n 2007-01-01             67.0        0.145003               210.0   \n 2008-01-01            105.0        0.192740               279.0   \n 2009-01-01            155.0        0.246287               329.0   \n 2010-01-01            227.0        0.306098               384.0   \n 2011-01-01            312.0        0.370026               427.0   \n 2012-01-01            428.0        0.427033               418.0   \n 2013-01-01            588.0        0.471660               404.0   \n 2014-01-01            784.0        0.506293               387.0   \n 2015-01-01           1030.0        0.517586               331.0   \n 2016-01-01           1318.0        0.502420               261.0   \n 2017-01-01           1628.0        0.462508               179.0   \n 2018-01-01           1951.0        0.407060               111.0   \n 2019-01-01           2265.0        0.352353               109.0   \n 2020-01-01           2602.0        0.282746                69.0   \n 2021-01-01           2869.0        0.222885                57.0   \n 2022-01-01           3097.0        0.170590                39.0   \n 2023-01-01           3276.0        0.124057                26.0   \n 2024-01-01           3404.0        0.092668                23.0   \n 2025-01-01           3495.0        0.067646                12.0   \n 2026-01-01           3561.0        0.049927                10.0   \n 2027-01-01           3616.0        0.036036                 7.0   \n 2028-01-01           3653.0        0.025140                 1.0   \n 2029-01-01           3687.0        0.016389                 2.0   \n 2030-01-01           3699.0        0.011753                 3.0   \n 2031-01-01           3712.0        0.008346                 2.0   \n 2032-01-01           3726.0        0.004667                 0.0   \n 2033-01-01           3732.0        0.002948                 1.0   \n 2034-01-01           3734.0        0.002458                 0.0   \n 2035-01-01           3737.0        0.001721                 0.0   \n 2036-01-01           3737.0        0.001475                 0.0   \n 2037-01-01           3739.0        0.000738                 0.0   \n 2038-01-01           3741.0        0.000246                 0.0   \n 2039-01-01           3741.0        0.000246                 0.0   \n 2040-01-01           3741.0        0.000246                 0.0   \n 2041-01-01           3742.0        0.000000                 0.0   \n 2042-01-01           3742.0        0.000000                 0.0   \n 2043-01-01           3742.0        0.000000                 0.0   \n 2044-01-01           3742.0        0.000000                 0.0   \n 2045-01-01           3742.0        0.000000                 0.0   \n 2046-01-01           3742.0        0.000000                 0.0   \n 2047-01-01           3742.0        0.000000                 0.0   \n 2048-01-01           3742.0        0.000000                 0.0   \n 2049-01-01           3742.0        0.000000                 0.0   \n 2050-01-01           3742.0        0.000000                 0.0   \n \n             sir_cum_infections  n_alive  n_female  new_deaths  new_emigrants  \\\n timevec                                                                        \n 2000-01-01                15.0   5000.0       0.0         0.0            0.0   \n 2001-01-01                47.0   5000.0       0.0         0.0            0.0   \n 2002-01-01                90.0   5000.0       0.0         0.0            0.0   \n 2003-01-01               157.0   5000.0       0.0         0.0            0.0   \n 2004-01-01               253.0   5000.0       0.0         0.0            0.0   \n 2005-01-01               398.0   4998.0       0.0         2.0            0.0   \n 2006-01-01               547.0   4993.0       0.0         5.0            0.0   \n 2007-01-01               757.0   4986.0       0.0         7.0            0.0   \n 2008-01-01              1036.0   4982.0       0.0         4.0            0.0   \n 2009-01-01              1365.0   4969.0       0.0        13.0            0.0   \n 2010-01-01              1749.0   4951.0       0.0        18.0            0.0   \n 2011-01-01              2176.0   4920.0       0.0        31.0            0.0   \n 2012-01-01              2594.0   4887.0       0.0        33.0            0.0   \n 2013-01-01              2998.0   4847.0       0.0        40.0            0.0   \n 2014-01-01              3385.0   4805.0       0.0        42.0            0.0   \n 2015-01-01              3716.0   4753.0       0.0        52.0            0.0   \n 2016-01-01              3977.0   4681.0       0.0        72.0            0.0   \n 2017-01-01              4156.0   4589.0       0.0        92.0            0.0   \n 2018-01-01              4267.0   4504.0       0.0        85.0            0.0   \n 2019-01-01              4376.0   4428.0       0.0        76.0            0.0   \n 2020-01-01              4445.0   4361.0       0.0        67.0            0.0   \n 2021-01-01              4502.0   4291.0       0.0        70.0            0.0   \n 2022-01-01              4541.0   4240.0       0.0        51.0            0.0   \n 2023-01-01              4567.0   4187.0       0.0        53.0            0.0   \n 2024-01-01              4590.0   4154.0       0.0        33.0            0.0   \n 2025-01-01              4602.0   4126.0       0.0        28.0            0.0   \n 2026-01-01              4612.0   4107.0       0.0        19.0            0.0   \n 2027-01-01              4619.0   4097.0       0.0        10.0            0.0   \n 2028-01-01              4620.0   4088.0       0.0         9.0            0.0   \n 2029-01-01              4622.0   4084.0       0.0         4.0            0.0   \n 2030-01-01              4625.0   4074.0       0.0        10.0            0.0   \n 2031-01-01              4627.0   4071.0       0.0         3.0            0.0   \n 2032-01-01              4627.0   4070.0       0.0         1.0            0.0   \n 2033-01-01              4628.0   4068.0       0.0         2.0            0.0   \n 2034-01-01              4628.0   4068.0       0.0         0.0            0.0   \n 2035-01-01              4628.0   4068.0       0.0         0.0            0.0   \n 2036-01-01              4628.0   4067.0       0.0         1.0            0.0   \n 2037-01-01              4628.0   4066.0       0.0         1.0            0.0   \n 2038-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2039-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2040-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2041-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2042-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2043-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2044-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2045-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2046-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2047-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2048-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2049-01-01              4628.0   4066.0       0.0         0.0            0.0   \n 2050-01-01              4628.0   4066.0       0.0         0.0            0.0   \n \n             cum_deaths  \n timevec                 \n 2000-01-01         0.0  \n 2001-01-01         0.0  \n 2002-01-01         0.0  \n 2003-01-01         0.0  \n 2004-01-01         0.0  \n 2005-01-01         0.0  \n 2006-01-01         2.0  \n 2007-01-01         7.0  \n 2008-01-01        14.0  \n 2009-01-01        18.0  \n 2010-01-01        31.0  \n 2011-01-01        49.0  \n 2012-01-01        80.0  \n 2013-01-01       113.0  \n 2014-01-01       153.0  \n 2015-01-01       195.0  \n 2016-01-01       247.0  \n 2017-01-01       319.0  \n 2018-01-01       411.0  \n 2019-01-01       496.0  \n 2020-01-01       572.0  \n 2021-01-01       639.0  \n 2022-01-01       709.0  \n 2023-01-01       760.0  \n 2024-01-01       813.0  \n 2025-01-01       846.0  \n 2026-01-01       874.0  \n 2027-01-01       893.0  \n 2028-01-01       903.0  \n 2029-01-01       912.0  \n 2030-01-01       916.0  \n 2031-01-01       926.0  \n 2032-01-01       929.0  \n 2033-01-01       930.0  \n 2034-01-01       932.0  \n 2035-01-01       932.0  \n 2036-01-01       932.0  \n 2037-01-01       933.0  \n 2038-01-01       934.0  \n 2039-01-01       934.0  \n 2040-01-01       934.0  \n 2041-01-01       934.0  \n 2042-01-01       934.0  \n 2043-01-01       934.0  \n 2044-01-01       934.0  \n 2045-01-01       934.0  \n 2046-01-01       934.0  \n 2047-01-01       934.0  \n 2048-01-01       934.0  \n 2049-01-01       934.0  \n 2050-01-01       934.0  )\n\n\nIn the same way that it is possible to index the Samples object directly in order to retrieve columns from the summary dataframe, it is also possible to directly index the Samples object to get a column of the time series dataframe. In this case, pass a tuple of items to the Samples object, where the first item is the seed, and the second is a column from the time series dataframe. For example:\n\nres[0,'sir_n_infected'] # Equivalent to `res[0]['sir.n_infected']`\n\ntimevec\n2000-01-01      63.0\n2001-01-01      95.0\n2002-01-01     138.0\n2003-01-01     205.0\n2004-01-01     301.0\n2005-01-01     435.0\n2006-01-01     555.0\n2007-01-01     724.0\n2008-01-01     961.0\n2009-01-01    1227.0\n2010-01-01    1521.0\n2011-01-01    1832.0\n2012-01-01    2101.0\n2013-01-01    2305.0\n2014-01-01    2454.0\n2015-01-01    2487.0\n2016-01-01    2388.0\n2017-01-01    2165.0\n2018-01-01    1868.0\n2019-01-01    1587.0\n2020-01-01    1252.0\n2021-01-01     972.0\n2022-01-01     732.0\n2023-01-01     526.0\n2024-01-01     388.0\n2025-01-01     281.0\n2026-01-01     206.0\n2027-01-01     148.0\n2028-01-01     103.0\n2029-01-01      67.0\n2030-01-01      48.0\n2031-01-01      34.0\n2032-01-01      19.0\n2033-01-01      12.0\n2034-01-01      10.0\n2035-01-01       7.0\n2036-01-01       6.0\n2037-01-01       3.0\n2038-01-01       1.0\n2039-01-01       1.0\n2040-01-01       1.0\n2041-01-01       0.0\n2042-01-01       0.0\n2043-01-01       0.0\n2044-01-01       0.0\n2045-01-01       0.0\n2046-01-01       0.0\n2047-01-01       0.0\n2048-01-01       0.0\n2049-01-01       0.0\n2050-01-01       0.0\nName: sir_n_infected, dtype: float64\n\n\n\n\nFiltering results\nThe .seeds attribute contains a listing of seeds, which can be helpful for iteration:\n\nres.seeds\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19])\n\n\nThe seeds are drawn from the summary dataframe, which defines which seeds are accessible via the Samples object. Therefore, you can drop rows from the summary dataframe to filter the results. For example, suppose we only wanted to analyze simulations with over 4900 deaths. We could retrieve a copy of the summary dataframe that only contains matching simulations:\n\nres.summary.loc[res['cum_infections']&gt;4900]\n\n\n\n\n\n\n\n\n\ncum_infections\ncum_deaths\n\n\nseed\np_death\n\n\n\n\n\n\n\n\n\n\n\nWe can then make a copy of the results and write the reduced summary dataframe back to that object:\n\nres2 = res.copy()\nres2.summary = res.summary.loc[res['cum_infections']&gt;4900]\n\n\nUnlike sc.dcp(), copying using the .copy() method only deep copies the summary dataframe. It does not duplicate the time series dataframes or the cache. For Samples objects, it is therefore generally preferable to use .copy().\n\nNow notice that there are fewer samples, and the seeds have been filtered:\n\nlen(res)\n\n20\n\n\n\nlen(res2)\n\n0\n\n\n\nres2.seeds\n\narray([], dtype=int64)\n\n\n\nplt.hist(res2['cum_infections'], density=True)\nplt.xlabel('Total infections')\nplt.ylabel('Probability density')\n\n/software/conda/lib/python3.13/site-packages/numpy/lib/_histograms_impl.py:897: RuntimeWarning: invalid value encountered in divide\n  return n / db / n.sum(), bin_edges\n\n\nText(0, 0.5, 'Probability density')\n\n\n\n\n\n\n\n\n\n\n\nApplying functions and transformations\nSometimes it might be necessary to calculate quantities that are derived from the time series dataframes. These could be simple scalar values, such as totals or averages that had not been computed ahead of time, or extracting values from each simulation at a particular point in time. As an alternative to writing a loop that iterates over the seeds, the .apply() method takes in a function and maps it to every dataframe. This makes it quick to construct lists or arrays with scalar values extracted from the time series. For example, suppose we wanted to extract the peak number of people infected from each simulation:\n\npeak_infections = lambda df: df['sir_n_infected'].max()\nres.apply(peak_infections)\n\n[2487.0,\n 2502.0,\n 2524.0,\n 2437.0,\n 2391.0,\n 2471.0,\n 2526.0,\n 2459.0,\n 2397.0,\n 2483.0,\n 2436.0,\n 2443.0,\n 2449.0,\n 2338.0,\n 2506.0,\n 2401.0,\n 2509.0,\n 2365.0,\n 2438.0,\n 2476.0]",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#options-when-loading",
    "href": "user_guide/workflows_samples.html#options-when-loading",
    "title": "Samples",
    "section": "Options when loading",
    "text": "Options when loading\nThere are two options available when loading that can change how the Samples class interacts with the file on disk:\n\nmemory_buffer - copy the entire file into memory. This prevents the file from being locked on disk and allows scripts to be re-run and results regenerated while still running the analysis notebook. This defaults to True for convenience, but loading the entire file into memory can be problematic if the file is large (e.g., &gt;1GB) in which case setting memory_buffer=False may be preferable\npreload - Populate the cache in one step. This facilitates interactive usage of the analysis notebook by making the runtime of analysis functions predictable (since all results will be retrieved from the cache) at the expense of a long initial load time\n\n\nImplementation details\nIf the file is loaded from a memory buffer, the ._zipfile attribute will be populated. A helper property .zipfile is used to access the buffer, so if caching is not used, .zipfile returns the actual file on disk rather than the buffer:\n\nres = ss.Samples('results/0.2.zip', memory_buffer=True) # Copy the entire file into memory\nprint(res._zipfile)\nprint(res.zipfile)\n\n&lt;zipfile.ZipFile file=&lt;_io.BytesIO object at 0x75163c733880&gt; mode='r'&gt;\n&lt;zipfile.ZipFile file=&lt;_io.BytesIO object at 0x75163c733880&gt; mode='r'&gt;\n\n\n\nres = ss.Samples('results/0.2.zip', memory_buffer=False) # Copy the entire file into memory\nprint(res._zipfile)\nprint(res.zipfile)\n\nNone\n&lt;zipfile.ZipFile filename='results/0.2.zip' mode='r'&gt;\n\n\nThe dataframes associated with the individual dataframes are cached on access, so pd.read_csv() only needs to be called once. The cache starts out empty:\n\nres._cache\n\n{}\n\n\nWhen a dataframe is accessed, it is automatically stored in the cache:\n\nres[0]\nres._cache.keys()\n\ndict_keys([0])\n\n\nThis means that iterating through the dataframes the first time can be slow (but in general, iterating over all dataframes is avoided in favour of either only using summary outputs, or accessing a subset of the runs):\n\nwith sc.Timer():\n    for df in res:\n        continue\n\nElapsed time: 19.9 ms\n\n\n\nwith sc.Timer():\n    for df in res:\n        continue\n\nElapsed time: 2.62 ms\n\n\nThe preload option populates the entire cache in advance. This makes creating the Samples object slower, but operating on the dataframes afterwards will be consistently fast. This type of usage can be useful when wanting to load large files in the background and then interactively work with them afterwards.\n\nwith sc.Timer():\n    res = ss.Samples('results/0.2.zip', preload=True)\n\nElapsed time: 19.5 ms\n\n\n\nwith sc.Timer():\n    for df in res:\n        continue\n\nElapsed time: 2.57 ms\n\n\n\nwith sc.Timer():\n    for df in res:\n        continue\n\nElapsed time: 2.79 ms\n\n\nTogether, these options provide some flexibility in terms of memory and time demands to suit analyses at various different scales.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Samples"
    ]
  },
  {
    "objectID": "user_guide/workflows_samples.html#running-scenarios",
    "href": "user_guide/workflows_samples.html#running-scenarios",
    "title": "Samples",
    "section": "Running scenarios",
    "text": "Running scenarios\nSuppose we wanted to compare a range of different p_death values and initial values (initial number of infections). We might define these runs as:\n\ninitials = np.arange(1,4)\np_deaths = np.arange(0,1,0.25)\n\nRecall that our run_sim() function had an argument for p_death. We can extend this to include the initial parameter too. We can actually generalize this further by passing the parameters as keyword arguments to avoid needing to hard-code all of them. Note that we also need to add the initial value to the summary outputs:\n\ndef get_sim(seed, **kwargs):\n    ppl = ss.People(1000)\n    net = ss.RandomNet(n_contacts=ss.poisson(5))\n    sir = ss.SIR(pars=kwargs)\n    sim = ss.Sim(people=ppl, networks=net, diseases=sir, rand_seed=seed, dur=ss.years(10))\n    sim.init(verbose=0)\n    return sim\n    \ndef run_sim(seed, **kwargs):\n    sim = get_sim(seed, **kwargs)\n    sim.run(verbose=0)\n    df = sim.to_df()\n    sir = sim.diseases.sir\n    \n    summary = {}\n    summary['seed'] = sim.pars.rand_seed\n    summary['p_death']= sir.pars.p_death.pars.p\n    summary['initial']= sir.pars.init_prev.pars.p\n    summary['cum_infections'] = sum(sim.results.sir.new_infections)\n    summary['cum_deaths'] = sum(sim.results.new_deaths)\n    \n    return df, summary\n\nWe can now easily run a set of scenarios with different values of p_death and save each one to a separate Samples object. Note that when we create the Samples objects now, we also want to specify that 'init_prev' is one of the identifiers for the scenarios:\n\n# Clear the existing results\nfor file_path in resultsdir.glob('*'):\n    file_path.unlink()\n\n\n# Run the sweep over initial and p_death\nn = 10\nseeds = np.arange(n)\nfor init_prev in initials:\n    for p_death in p_deaths:\n        outputs = [run_sim(seed, init_prev=init_prev, p_death=p_death) for seed in seeds]\n        ss.Samples.new(resultsdir, outputs, [\"p_death\", \"initial\"])\n\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.0-1.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.25-1.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.5-1.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.75-1.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.0-2.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.25-2.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.5-2.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.75-2.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.0-3.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.25-3.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.5-3.zip\"\nZip file saved to \"/home/cliffk/idm/starsim/docs/user_guide/results/0.75-3.zip\"\n\n\nThe results folder now contains a collection of saved Samples objects. Notice how the automatically selected file names now contain both the p_death value and the initial value, because they were both specified as identifiers. We can load one of these objects in to see how these identifiers are stored and accessed inside the Samples class:\n\nlist(resultsdir.iterdir())\n\n[PosixPath('results/0.0-3.zip'),\n PosixPath('results/0.0-1.zip'),\n PosixPath('results/0.25-3.zip'),\n PosixPath('results/0.5-3.zip'),\n PosixPath('results/0.75-3.zip'),\n PosixPath('results/0.0-2.zip'),\n PosixPath('results/0.75-1.zip'),\n PosixPath('results/0.25-2.zip'),\n PosixPath('results/0.25-1.zip'),\n PosixPath('results/0.75-2.zip'),\n PosixPath('results/0.5-2.zip'),\n PosixPath('results/0.5-1.zip')]\n\n\n\nres = ss.Samples('results/0.25-2.zip')\n\nThe ‘id’ of a Samples object is a dictionary of the identifiers, which makes it easy to access the input parameters associated with a set of scenario runs:\n\nres.id\n\n{'p_death': 0.25, 'initial': 2}\n\n\nThe ‘identifier’ is a tuple of these values, which is suitable for use as a dictionary key. This can be useful for accumulating and comparing variables across scenarios:\n\nres.identifier\n\n(0.25, 2)\n\n\n\nLoading multiple scenarios\nWe saw above that we now have a directory full of .zip files corresponding to the various scenario runs. These can be accessed using the Dataset class, which facilitates accessing multiple instances of Samples. We can pass the folder containing the results to the Dataset constructor to load them all:\n\nresults = ss.Dataset(resultsdir)\nresults\n\n&lt;Dataset:\n    'p_death':[0.0, 0.25, 0.5, 0.75]\n    'initial':[1, 2, 3]\n&gt;\n\n\nThe .ids attribute lists all of the values available across scenarios in the results folder:\n\nresults.ids\n\n{'p_death': [0.0, 0.25, 0.5, 0.75], 'initial': [1, 2, 3]}\n\n\nThe individual results can be accessed by indexing the Dataset instance using the values of the identifiers. For example:\n\nresults[0.25,2]\n\n&lt;Samples 0.25-2, 10 seeds&gt;\n\n\nThis indexing operation is sensitive to the order in which the identifiers are specified. The .get() method allows you to specify them as key-value pairs:\n\nresults.get(initial=2, p_death=0.25)\n\n&lt;Samples 0.25-2, 10 seeds&gt;\n\n\nIterating over the Dataset will iterate over the Samples instances contained within it:\n\nfor res in results:\n    print(res)\n\n&lt;Samples 0.0-1, 10 seeds&gt;\n&lt;Samples 0.0-2, 10 seeds&gt;\n&lt;Samples 0.0-3, 10 seeds&gt;\n&lt;Samples 0.25-1, 10 seeds&gt;\n&lt;Samples 0.25-2, 10 seeds&gt;\n&lt;Samples 0.25-3, 10 seeds&gt;\n&lt;Samples 0.5-1, 10 seeds&gt;\n&lt;Samples 0.5-2, 10 seeds&gt;\n&lt;Samples 0.5-3, 10 seeds&gt;\n&lt;Samples 0.75-1, 10 seeds&gt;\n&lt;Samples 0.75-2, 10 seeds&gt;\n&lt;Samples 0.75-3, 10 seeds&gt;\n\n\nThis can be used to extract and compare values across scenarios. For example, we could consider the use case of making a plot that compares total deaths across scenarios:\n\nlabels = []\ny = []\nyerr = []\n\nfor res in results:\n    labels.append(res.id)\n    y.append(res['cum_deaths'].median())\n\nplt.barh(np.arange(len(results)),y, tick_label=labels)\nplt.xlabel('Median total deaths');\nplt.ylabel('Scenario')\n\nText(0, 0.5, 'Scenario')\n\n\n\n\n\n\n\n\n\n\n\nFiltering scenarios\nOften plots need to be generated for a subset of scenarios e.g., for sensitivity analysis or to otherwise compare specific scenarios. Dataset.filter returns a new Dataset containing a subset of the results:\n\nfor res in results.filter(initial=2):\n    print(res)\n\n&lt;Samples 0.0-2, 10 seeds&gt;\n&lt;Samples 0.25-2, 10 seeds&gt;\n&lt;Samples 0.5-2, 10 seeds&gt;\n&lt;Samples 0.75-2, 10 seeds&gt;\n\n\n\nfor res in results.filter(p_death=0.25):\n    print(res)\n\n&lt;Samples 0.25-1, 10 seeds&gt;\n&lt;Samples 0.25-2, 10 seeds&gt;\n&lt;Samples 0.25-3, 10 seeds&gt;\n\n\nThis is also a quick and efficient operation, so you can easily embed filtering commands inside the analysis to select subsets of the scenarios for plotting and other output generation. For instance:\n\nfor res, color in zip(results.filter(initial=2), sc.gridcolors(4)):\n    plt.plot(res[0].index, np.median([df['new_deaths'] for df in res], axis=0), color=color, label=f'p_death = {res.id[\"p_death\"]}')\nplt.legend()\nplt.title('Sensitivity to p_death (initial = 2)')\nplt.xlabel('Year')\nplt.ylabel('New deaths')\n\nText(0, 0.5, 'New deaths')\n\n\n\n\n\n\n\n\n\n\nfor res, color in zip(results.filter(p_death=0.25), sc.gridcolors(3)):\n    plt.plot(res[0].index, np.median([df['new_deaths'] for df in res], axis=0), color=color, label=f'initial = {res.id[\"initial\"]}')\nplt.legend()\nplt.title('Sensitivity to initial infections (p_death = 0.25)')\nplt.xlabel('Year')\nplt.ylabel('New deaths')\nsc.dateformatter()\n\n/software/conda/lib/python3.13/site-packages/matplotlib/axis.py:1282: RuntimeWarning: Axes data not recognizable as dates: Matplotlib converted them to days starting in 1970, which seems wrong. Please convert to actual dates first, using e.g. sc.date().\nRaw values: [0.00000000e+00 2.31481481e-11 4.62962963e-11 6.94444444e-11\n 9.25925926e-11 1.15740741e-10]\n  major_labels = self.major.formatter.format_ticks(major_locs)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Samples"
    ]
  },
  {
    "objectID": "user_guide/intro_models.html",
    "href": "user_guide/intro_models.html",
    "title": "Starsim models",
    "section": "",
    "text": "The Starsim framework serves as a centralized “hub” for storing anything that is typically required to model the spread of diseases among agents. This includes representations of networks, diseases, populations, demographics, interventions, and products, and logic for connecting all of these things together and simulating their interactions over time.\nSpecific models that have been created using the Starsim framework are kept in their own separate repositories. As of May 2025, Starsim’s models include the following models:\n\n\n\nModel\nStatus\nDescription\n\n\n\n\nHPVsim\nStable\nHuman papillomavirus (HPV) and cervical cancer\n\n\nFPsim\nStable\nFamily planning and reproductive health\n\n\nSTIsim\nBeta\nSexually transmitted infections, including HIV, bacterial vaginosis, chlamydia, gonorrhea, syphilis, and trichomoniasis\n\n\nRotasim\nPre-release\nRotavirus, with a focus on genetic diversity\n\n\nPHCsim\nPre-release\nPrimary health care and health systems\n\n\nMIGHTI\nPre-release\nModel of Inter-Generational Health, Transmission, and Interventions (HIV and other comorbidities)\n\n\nTBsim\nPre-release\nTuberculosis, including malnutrition\n\n\nRVFsim\nPre-release\nRift valley fever in cattle\n\n\nTyphoidsim\nPre-release\nTyphoid, including environmental transmission\n\n\n\nIf you’ve developed a model and want it included in this list, please get in touch.\nOne of the strengths of Starsim is that all of these models are inter-compatible. For example, an HIV-TB coinfection model can be created by combining the HIV module from STIsim and the TB module from TBsim.\nNote: the Starsim suite also includes Covasim (for modeling COVID-19). Covasim is built on the same principles as Starsim, but unlike the above tools, it is a separate codebase and is not inter-operable with the other models.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "Starsim models"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html",
    "href": "user_guide/modules_interventions.html",
    "title": "Interventions",
    "section": "",
    "text": "This guide describes how to implementing interventions in Starsim. Interventions represent actions that affect disease transmission, such as screening, treatment, and vaccination programs.\nFor learning-oriented content on interventions, see Tutorial 6 - Interventions.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html#comparison-of-intervention-classes",
    "href": "user_guide/modules_interventions.html#comparison-of-intervention-classes",
    "title": "Interventions",
    "section": "Comparison of intervention classes",
    "text": "Comparison of intervention classes\n\nBase classes\n\n\n\nClass\nPurpose\nKey features\n\n\n\n\nIntervention\nBase intervention class\nEligibility checking, product integration, step() method\n\n\nRoutineDelivery\nContinuous delivery over time\nInterpolated probabilities, annual/timestep rates\n\n\nCampaignDelivery\nOne-off or discrete campaigns\nSpecific years, optional interpolation\n\n\nBaseTest\nBase for screening/triage\nProduct administration, outcome tracking\n\n\nBaseScreening\nScreening programs\nPopulation-level eligibility checking\n\n\nBaseTriage\nTriage/follow-up testing\nTargeted eligibility (e.g., screen positives)\n\n\nBaseTreatment\nTreatment interventions\nQueue management, eligibility validation\n\n\nBaseVaccination\nVaccination programs\nDose tracking, vaccination state management\n\n\n\n\n\nScreening interventions\n\n\n\nClass\nDelivery pattern\nUse case\n\n\n\n\nroutine_screening\nContinuous\nRegular screening programs (e.g., annual STI screening)\n\n\ncampaign_screening\nDiscrete\nMass screening events (e.g., outbreak response)\n\n\nroutine_triage\nContinuous\nFollow-up testing for positives\n\n\ncampaign_triage\nDiscrete\nCampaign-based confirmatory testing\n\n\n\n\n\nTreatment interventions\n\n\n\nClass\nCapacity Model\nUse Case\n\n\n\n\ntreat_num\nFixed capacity per timestep\nResource-constrained treatment programs\n\n\n\n\n\nVaccination interventions\n\n\n\nClass\nDelivery Pattern\nUse Case\n\n\n\n\nroutine_vx\nContinuous\nRoutine immunization programs\n\n\ncampaign_vx\nDiscrete\nMass vaccination campaigns",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html#implementation-patterns",
    "href": "user_guide/modules_interventions.html#implementation-patterns",
    "title": "Interventions",
    "section": "Implementation patterns",
    "text": "Implementation patterns\n\nEligibility functions\nInterventions use eligibility functions to determine who can receive the intervention:\n\nimport starsim as ss\n\n# Lambda functions for simple eligibility\neligible_adults = lambda sim: (sim.people.age &gt;= 18).uids\n\n# More complex eligibility combining multiple conditions  \ndef high_risk_eligibility(sim):\n    adults = sim.people.age &gt;= 18\n    sexually_active = sim.networks.mfnet.participant\n    return (adults & sexually_active).uids\n\n# Using intervention outcomes for triage\nscreen_positives = lambda sim: sim.interventions.screening.outcomes['positive']\n\n\n\nProduct integration\nInterventions work with products that define the actual medical intervention:\n\nimport sciris as sc\nimport starsim as ss\n\n# Define parameters\npars = sc.objdict(\n    n_agents = 5e3,\n    start = 2000,\n    stop = 2020,\n    diseases = 'sis',\n    networks = 'random',\n)\n\n# Define the product data\ndx_data = sc.dataframe(\n    columns =\n        ['disease', 'state', 'result', 'probability'],\n    data = [\n        ['sis', 'susceptible', 'positive', 0.01],\n        ['sis', 'susceptible', 'negative', 0.99],\n        ['sis', 'infected', 'positive', 0.95],\n        ['sis', 'infected', 'negative', 0.05],\n    ]\n)\n\n# Using built-in products\nvx_start = 2005\nmy_vaccine = ss.simple_vx(efficacy=0.9)\nvaccination = ss.routine_vx(\n    product = my_vaccine,  # Product object\n    prob = 0.8,\n    start_year = vx_start,\n)\n\n# Using custom products\ndx_start = 2010\nscreening = ss.routine_screening(\n    product = ss.Dx(df=dx_data),\n    prob = 0.9,\n    start_year = dx_start,\n)\n\n# Run the sim\nsim = ss.Sim(pars, interventions=[screening, vaccination])\nsim.run()\nsim.plot()\n\nInitializing sim with 5000 agents\n  Running 2000.01.01 ( 0/21) (0.00 s)  ———————————————————— 5%\n  Running 2010.01.01 (10/21) (0.17 s)  ••••••••••—————————— 52%\n  Running 2020.01.01 (20/21) (0.24 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/modules_interventions.html#adding-multiple-interventions",
    "href": "user_guide/modules_interventions.html#adding-multiple-interventions",
    "title": "Interventions",
    "section": "Adding multiple interventions",
    "text": "Adding multiple interventions\nIf you want to add multiple of the same intervention, you need to give them different names. (This also applies to diseases and other modules.) This example compares simulations with 0, 1, or 2 vaccines:\n\nimport starsim as ss\n\n# Create the product - a vaccine with 80% efficacy\nvx = ss.simple_vx(efficacy=0.8)\n\n# Create the interventions -- low and high coverage\nintv_low  = ss.routine_vx(name='intv_low', start_year=2010, prob=0.2, product=vx)\nintv_high = ss.routine_vx(name='intv_high', start_year=2020, prob=0.6, product=vx)\n\n# Create the sims\npars = dict(n_agents=5000, networks='random', diseases='sis', verbose=0)\ns0 = ss.Sim(pars, label='Baseline')\ns1 = ss.Sim(pars, label='Low vaccine coverage', interventions=intv_low)\ns2 = ss.Sim(pars, label='Low + high vaccine coverage', interventions=[intv_low, intv_high])\n\n# Run & plot\nmsim = ss.parallel(s0, s1, s2)\nmsim.plot('sis_new_infections')\n\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Interventions"
    ]
  },
  {
    "objectID": "user_guide/advanced_profiling.html",
    "href": "user_guide/advanced_profiling.html",
    "title": "Profiling and debugging",
    "section": "",
    "text": "One of the main reasons people don’t use ABMs is because they can be very slow. While “vanilla Starsim” is quite fast (10,000 agents running for 100 timesteps should take about a second), custom modules, if not properly written, can be quite slow.\nThe first step of fixing a slow module is to identify the problem. To do this, Starsim includes some built-in profiling tools.\nLet’s look at a simple simulation:\n\nimport sciris as sc\nimport starsim as ss\nsc.options(jupyter=True)\n\npars = dict(\n    start = '2000-01-01',\n    stop = '2020-01-01',\n    diseases = 'sis',\n    networks = 'random'\n)\n\n# Profile sim\nsim = ss.Sim(pars)\nprof = sim.profile()\n\nInitializing sim with 10000 agents\nProfiling 15 function(s):\n &lt;bound method Sim.run of Sim(n=10000; 2000.01.01—2020.01.01; networks=randomnet; diseases=sis)&gt;\n&lt;bound method Sim.start_step of Sim(n=10000; 2000.01.01—2020.01.01; networks=randomnet; diseases=sis [...]\n&lt;function Module.start_step at 0x7dd03f47eb60&gt;\n&lt;function Module.start_step at 0x7dd03f47eb60&gt;\n&lt;bound method SIS.step_state of sis(pars=[init_prev, beta, dur_inf, waning, imm_boost, _n_initial_ca [...]\n&lt;bound method DynamicNetwork.step of randomnet(n_edges=50000; pars=[n_contacts, dur, beta]; states=[ [...]\n&lt;bound method Infection.step of sis(pars=[init_prev, beta, dur_inf, waning, imm_boost, _n_initial_ca [...]\n&lt;bound method People.step_die of People(n=10000; age=30.0±17.3)&gt;\n&lt;bound method People.update_results of People(n=10000; age=30.0±17.3)&gt;\n&lt;bound method Network.update_results of randomnet(n_edges=50000; pars=[n_contacts, dur, beta]; state [...]\n&lt;function SIS.update_results at 0x7dd03ee7d3a0&gt;\n&lt;function Module.finish_step at 0x7dd03f47ed40&gt;\n&lt;function Module.finish_step at 0x7dd03f47ed40&gt;\n&lt;bound method People.finish_step of People(n=10000; age=30.0±17.3)&gt;\n&lt;bound method Sim.finish_step of Sim(n=10000; 2000.01.01—2020.01.01; networks=randomnet; diseases=si [...] \n\n  Running 2000.01.01 ( 0/21) (0.00 s)  ———————————————————— 5%\n  Running 2010.01.01 (10/21) (0.49 s)  ••••••••••—————————— 52%\n  Running 2020.01.01 (20/21) (0.54 s)  •••••••••••••••••••• 100%\n\nElapsed time: 0.556 s\n\n\n——————————————————————————————————————————————————————————————————————\nProfile of networks.Network.update_results: 0.000370856 s (0.0667428%)\n——————————————————————————————————————————————————————————————————————\n\nTotal time: 0.000370856 s\nFile: /home/cliffk/idm/starsim/starsim/networks.py\nFunction: Network.update_results at line 254\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   254                                               def update_results(self):\n   255                                                   \"\"\" Store the number of edges in the network \"\"\"\n   256        21      99548.0   4740.4     26.8          super().update_results()\n   257        21     261994.0  12475.9     70.6          self.results['n_edges'][self.ti] = len(self)\n   258        21       9314.0    443.5      2.5          return\n\n\n\n————————————————————————————————————————————————————————————————\nProfile of people.People.finish_step: 0.000542667 s (0.0976635%)\n————————————————————————————————————————————————————————————————\n\nTotal time: 0.000542667 s\nFile: /home/cliffk/idm/starsim/starsim/people.py\nFunction: People.finish_step at line 475\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   475                                               def finish_step(self):\n   476        21     361739.0  17225.7     66.7          self.remove_dead()\n   477        21     171654.0   8174.0     31.6          self.update_post()\n   478        21       9274.0    441.6      1.7          return\n\n\n\n———————————————————————————————————————————————————————————\nProfile of people.People.step_die: 0.00143625 s (0.258481%)\n———————————————————————————————————————————————————————————\n\nTotal time: 0.00143625 s\nFile: /home/cliffk/idm/starsim/starsim/people.py\nFunction: People.step_die at line 437\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   437                                               def step_die(self):\n   438                                                   \"\"\" Carry out any deaths or removals that took place this timestep \"\"\"\n   439        21    1203757.0  57321.8     83.8          death_uids = ((self.ti_dead &lt;= self.sim.ti) | (self.ti_removed &lt;= self.sim.ti)).uids\n   440        21      54355.0   2588.3      3.8          self.alive[death_uids] = False  # Whilst not dead, removed agents should not be included in alive totals\n   441                                           \n   442                                                   # Execute deaths that took place this timestep (i.e., changing the `alive` state of the agents). This is executed\n   443                                                   # before analyzers have run so that analyzers are able to inspect and record outcomes for agents that died this timestep\n   444        42     117468.0   2796.9      8.2          for disease in self.sim.diseases():\n   445        21      17513.0    834.0      1.2              if isinstance(disease, ss.Disease):\n   446        21      28388.0   1351.8      2.0                  disease.step_die(death_uids)\n   447                                           \n   448        21      14769.0    703.3      1.0          return death_uids\n\n\n\n—————————————————————————————————————————————————————————————————\nProfile of people.People.update_results: 0.00214351 s (0.385766%)\n—————————————————————————————————————————————————————————————————\n\nTotal time: 0.00214351 s\nFile: /home/cliffk/idm/starsim/starsim/people.py\nFunction: People.update_results at line 466\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   466                                               def update_results(self):\n   467        21      18901.0    900.0      0.9          ti = self.sim.ti\n   468        21       7392.0    352.0      0.3          res = self.sim.results\n   469        21     508266.0  24203.1     23.7          res.n_alive[ti] = np.count_nonzero(self.alive)\n   470        21     541601.0  25790.5     25.3          res.new_deaths[ti] = np.count_nonzero(self.ti_dead == ti)\n   471        21     442591.0  21075.8     20.6          res.new_emigrants[ti] = np.count_nonzero(self.ti_removed == ti)\n   472        21     607162.0  28912.5     28.3          res.cum_deaths[ti] = np.sum(res.new_deaths[:ti]) # TODO: inefficient to compute the cumulative sum on every timestep!\n   473        21      17599.0    838.0      0.8          return\n\n\n\n————————————————————————————————————————————————————\nProfile of diseases.py:670: 0.00230529 s (0.414882%)\n————————————————————————————————————————————————————\n\nTotal time: 0.00230529 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: SIS.update_results at line 670\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   670                                               @ss.required()\n   671                                               def update_results(self):\n   672                                                   \"\"\" Store the population immunity (susceptibility) \"\"\"\n   673        21    1596974.0  76046.4     69.3          super().update_results()\n   674        21     697955.0  33236.0     30.3          self.results['rel_sus'][self.ti] = self.rel_sus.mean()\n   675        21      10357.0    493.2      0.4          return\n\n\n\n———————————————————————————————————————————————————————\nProfile of sim.Sim.start_step: 0.00368424 s (0.663051%)\n———————————————————————————————————————————————————————\n\nTotal time: 0.00368424 s\nFile: /home/cliffk/idm/starsim/starsim/sim.py\nFunction: Sim.start_step at line 306\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   306                                               def start_step(self):\n   307                                                   \"\"\" Start the step -- only print progress; all actual changes happen in the modules \"\"\"\n   308                                           \n   309                                                   # Set the time and if we have reached the end of the simulation, then do nothing\n   310        21       7642.0    363.9      0.2          if self.complete:\n   311                                                       errormsg = 'Simulation already complete (call sim.init() to re-run)'\n   312                                                       raise AlreadyRunError(errormsg)\n   313                                           \n   314                                                   # Print out progress if needed\n   315        21    2504678.0 119270.4     68.0          self.elapsed = self.timer.toc(output=True)\n   316        21      11508.0    548.0      0.3          if self.verbose: # Print progress\n   317        21       6123.0    291.6      0.2              t = self.t\n   318        21     148133.0   7054.0      4.0              simlabel = f'\"{self.label}\": ' if self.label else ''\n   319        21     683401.0  32542.9     18.5              string = f'  Running {simlabel}{t.now(\"str\")} ({t.ti:2.0f}/{t.npts}) ({self.elapsed:0.2f} s) '\n   320        21       9644.0    459.2      0.3              if self.verbose &gt;= 1:\n   321                                                           sc.heading(string)\n   322        21       7289.0    347.1      0.2              elif self.verbose &gt; 0:\n   323        21      15407.0    733.7      0.4                  if not (t.ti % int(1.0 / self.verbose)):\n   324         3     269323.0  89774.3      7.3                      sc.progressbar(t.ti + 1, t.npts, label=string, length=20, newline=True)\n   325        21      21096.0   1004.6      0.6          return\n\n\n\n————————————————————————————————————————————————————————————\nProfile of diseases.SIS.step_state: 0.00393148 s (0.707546%)\n————————————————————————————————————————————————————————————\n\nTotal time: 0.00393148 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: SIS.step_state at line 631\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   631                                               def step_state(self):\n   632                                                   \"\"\" Progress infectious -&gt; recovered \"\"\"\n   633        21    1222804.0  58228.8     31.1          recovered = (self.infected & (self.ti_recovered &lt;= self.ti)).uids\n   634        21      67807.0   3228.9      1.7          self.infected[recovered] = False\n   635        21      39496.0   1880.8      1.0          self.susceptible[recovered] = True\n   636        21    2587513.0 123214.9     65.8          self.update_immunity()\n   637        21      13862.0    660.1      0.4          return\n\n\n\n——————————————————————————————————————————————————\nProfile of modules.py:673: 0.00672401 s (1.21012%)\n——————————————————————————————————————————————————\n\nTotal time: 0.00672401 s\nFile: /home/cliffk/idm/starsim/starsim/modules.py\nFunction: Module.start_step at line 673\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   673                                               @required()\n   674                                               def start_step(self):\n   675                                                   \"\"\" Tasks to perform at the beginning of the step \"\"\"\n   676        42      24797.0    590.4      0.4          if self.finalized:\n   677                                                       errormsg = f'The module {self._debug_name} has already been run. Did you mean to copy it before running it?'\n   678                                                       raise RuntimeError(errormsg)\n   679        42      19795.0    471.3      0.3          if self.dists is not None: # Will be None if no distributions are defined\n   680        42    6654161.0 158432.4     99.0              self.dists.jump_dt() # Advance random number generators forward for calls on this step\n   681        42      25259.0    601.4      0.4          return\n\n\n\n———————————————————————————————————————————————————————————————\nProfile of networks.DynamicNetwork.step: 0.0355001 s (6.38893%)\n———————————————————————————————————————————————————————————————\n\nTotal time: 0.0355001 s\nFile: /home/cliffk/idm/starsim/starsim/networks.py\nFunction: DynamicNetwork.step at line 412\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   412                                               def step(self):\n   413        21   10101223.0 481010.6     28.5          self.end_pairs()\n   414        21   25384704.0 1.21e+06     71.5          self.add_pairs()\n   415        21      14157.0    674.1      0.0          return\n\n\n\n————————————————————————————————————————————————————————\nProfile of diseases.Infection.step: 0.483204 s (86.962%)\n————————————————————————————————————————————————————————\n\nTotal time: 0.483204 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.step at line 208\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   208                                               def step(self):\n   209                                                   \"\"\"\n   210                                                   Perform key infection updates, including infection and setting prognoses\n   211                                                   \"\"\"\n   212                                                   # Create new cases\n   213        21  472348159.0 2.25e+07     97.8          new_cases, sources, networks = self.infect() # TODO: store outputs in self or use objdict rather than 3 returns\n   214                                           \n   215                                                   # Set prognoses\n   216        21      18036.0    858.9      0.0          if len(new_cases):\n   217        21   10821773.0 515322.5      2.2              self.set_outcomes(new_cases, sources)\n   218                                           \n   219        21      15765.0    750.7      0.0          return new_cases, sources, networks\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nThis graph (which is a shortcut to sim.loop.plot_cpu()) shows us how much time each step in the integration loop takes. We can get line-by-line detail of where each function is taking time, though:\n\nprof.disp(maxentries=5)\n\n\n\n———————————————————————————————————————————————————————\nProfile of sim.Sim.start_step: 0.00368424 s (0.663051%)\n———————————————————————————————————————————————————————\n\nTotal time: 0.00368424 s\nFile: /home/cliffk/idm/starsim/starsim/sim.py\nFunction: Sim.start_step at line 306\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   306                                               def start_step(self):\n   307                                                   \"\"\" Start the step -- only print progress; all actual changes happen in the modules \"\"\"\n   308                                           \n   309                                                   # Set the time and if we have reached the end of the simulation, then do nothing\n   310        21       7642.0    363.9      0.2          if self.complete:\n   311                                                       errormsg = 'Simulation already complete (call sim.init() to re-run)'\n   312                                                       raise AlreadyRunError(errormsg)\n   313                                           \n   314                                                   # Print out progress if needed\n   315        21    2504678.0 119270.4     68.0          self.elapsed = self.timer.toc(output=True)\n   316        21      11508.0    548.0      0.3          if self.verbose: # Print progress\n   317        21       6123.0    291.6      0.2              t = self.t\n   318        21     148133.0   7054.0      4.0              simlabel = f'\"{self.label}\": ' if self.label else ''\n   319        21     683401.0  32542.9     18.5              string = f'  Running {simlabel}{t.now(\"str\")} ({t.ti:2.0f}/{t.npts}) ({self.elapsed:0.2f} s) '\n   320        21       9644.0    459.2      0.3              if self.verbose &gt;= 1:\n   321                                                           sc.heading(string)\n   322        21       7289.0    347.1      0.2              elif self.verbose &gt; 0:\n   323        21      15407.0    733.7      0.4                  if not (t.ti % int(1.0 / self.verbose)):\n   324         3     269323.0  89774.3      7.3                      sc.progressbar(t.ti + 1, t.npts, label=string, length=20, newline=True)\n   325        21      21096.0   1004.6      0.6          return\n\n\n\n————————————————————————————————————————————————————————————\nProfile of diseases.SIS.step_state: 0.00393148 s (0.707546%)\n————————————————————————————————————————————————————————————\n\nTotal time: 0.00393148 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: SIS.step_state at line 631\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   631                                               def step_state(self):\n   632                                                   \"\"\" Progress infectious -&gt; recovered \"\"\"\n   633        21    1222804.0  58228.8     31.1          recovered = (self.infected & (self.ti_recovered &lt;= self.ti)).uids\n   634        21      67807.0   3228.9      1.7          self.infected[recovered] = False\n   635        21      39496.0   1880.8      1.0          self.susceptible[recovered] = True\n   636        21    2587513.0 123214.9     65.8          self.update_immunity()\n   637        21      13862.0    660.1      0.4          return\n\n\n\n——————————————————————————————————————————————————\nProfile of modules.py:673: 0.00672401 s (1.21012%)\n——————————————————————————————————————————————————\n\nTotal time: 0.00672401 s\nFile: /home/cliffk/idm/starsim/starsim/modules.py\nFunction: Module.start_step at line 673\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   673                                               @required()\n   674                                               def start_step(self):\n   675                                                   \"\"\" Tasks to perform at the beginning of the step \"\"\"\n   676        42      24797.0    590.4      0.4          if self.finalized:\n   677                                                       errormsg = f'The module {self._debug_name} has already been run. Did you mean to copy it before running it?'\n   678                                                       raise RuntimeError(errormsg)\n   679        42      19795.0    471.3      0.3          if self.dists is not None: # Will be None if no distributions are defined\n   680        42    6654161.0 158432.4     99.0              self.dists.jump_dt() # Advance random number generators forward for calls on this step\n   681        42      25259.0    601.4      0.4          return\n\n\n\n———————————————————————————————————————————————————————————————\nProfile of networks.DynamicNetwork.step: 0.0355001 s (6.38893%)\n———————————————————————————————————————————————————————————————\n\nTotal time: 0.0355001 s\nFile: /home/cliffk/idm/starsim/starsim/networks.py\nFunction: DynamicNetwork.step at line 412\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   412                                               def step(self):\n   413        21   10101223.0 481010.6     28.5          self.end_pairs()\n   414        21   25384704.0 1.21e+06     71.5          self.add_pairs()\n   415        21      14157.0    674.1      0.0          return\n\n\n\n————————————————————————————————————————————————————————\nProfile of diseases.Infection.step: 0.483204 s (86.962%)\n————————————————————————————————————————————————————————\n\nTotal time: 0.483204 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.step at line 208\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   208                                               def step(self):\n   209                                                   \"\"\"\n   210                                                   Perform key infection updates, including infection and setting prognoses\n   211                                                   \"\"\"\n   212                                                   # Create new cases\n   213        21  472348159.0 2.25e+07     97.8          new_cases, sources, networks = self.infect() # TODO: store outputs in self or use objdict rather than 3 returns\n   214                                           \n   215                                                   # Set prognoses\n   216        21      18036.0    858.9      0.0          if len(new_cases):\n   217        21   10821773.0 515322.5      2.2              self.set_outcomes(new_cases, sources)\n   218                                           \n   219        21      15765.0    750.7      0.0          return new_cases, sources, networks\n\n\n\n(Note that the names of the functions here refer to the actual functions called, which may not match the graph above. That’s because, for example, ss.SIS does not define its own step() method, but instead inherits step() from Infection. In the graph, this is shown as sis.step(), but is listed in the table as Infection.step(). This is because it’s referring to the actual code being run, so refers to where those lines of code exist in the codebase; there is no code corresponding to SIS.step() since it’s just inherited from Infection.step().)\nIf you want more detail, you can also define custom functions to follow. For example, we can see that ss.SIS.infect() takes the most time in ss.SIS.step(), so let’s profile that:\n\nprof = sim.profile(follow=ss.SIS.infect, plot=False)\nprof.disp()\n\nInitializing sim with 10000 agents\nProfiling 1 function(s):\n &lt;function Infection.infect at 0x7dd03ee63f60&gt; \n\n  Running 2000.01.01 ( 0/21) (0.00 s)  ———————————————————— 5%\n  Running 2010.01.01 (10/21) (0.05 s)  ••••••••••—————————— 52%\n  Running 2020.01.01 (20/21) (0.10 s)  •••••••••••••••••••• 100%\n\nElapsed time: 0.113 s\n\n\n———————————————————————————————————————————————————————————\nProfile of diseases.Infection.infect: 0.042982 s (37.9613%)\n———————————————————————————————————————————————————————————\n\nTotal time: 0.042982 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.infect at line 230\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   230                                               def infect(self):\n   231                                                   \"\"\" Determine who gets infected on this timestep via transmission on the network \"\"\"\n   232        21      12402.0    590.6      0.0          new_cases = []\n   233        21       7146.0    340.3      0.0          sources = []\n   234        21       4669.0    222.3      0.0          networks = []\n   235        21     389916.0  18567.4      0.9          betamap = self.validate_beta()\n   236                                           \n   237        21     852127.0  40577.5      2.0          rel_trans = self.rel_trans.asnew(self.infectious * self.rel_trans)\n   238        21     553232.0  26344.4      1.3          rel_sus   = self.rel_sus.asnew(self.susceptible * self.rel_sus)\n   239                                           \n   240        42      97080.0   2311.4      0.2          for i, (nkey,route) in enumerate(self.sim.networks.items()):\n   241        21      21190.0   1009.0      0.0              nk = ss.standardize_netkey(nkey)\n   242                                           \n   243                                                       # Main use case: networks\n   244        21      10084.0    480.2      0.0              if isinstance(route, ss.Network):\n   245        21     134554.0   6407.3      0.3                  if len(route): # Skip networks with no edges\n   246        21       7615.0    362.6      0.0                      edges = route.edges\n   247        21     188632.0   8982.5      0.4                      p1p2b0 = [edges.p1, edges.p2, betamap[nk][0]] # Person 1, person 2, beta 0\n   248        21     180462.0   8593.4      0.4                      p2p1b1 = [edges.p2, edges.p1, betamap[nk][1]] # Person 2, person 1, beta 1\n   249        63      34038.0    540.3      0.1                      for src, trg, beta in [p1p2b0, p2p1b1]:\n   250        42      50539.0   1203.3      0.1                          if beta: # Skip networks with no transmission\n   251        42     763187.0  18171.1      1.8                              disease_beta = beta.to_prob(self.t.dt) if isinstance(beta, ss.Rate) else beta\n   252        42    1335047.0  31786.8      3.1                              beta_per_dt = route.net_beta(disease_beta=disease_beta, disease=self) # Compute beta for this network and timestep\n   253        42   30330721.0 722160.0     70.6                              randvals = self.trans_rng.rvs(src, trg) # Generate a new random number based on the two other random numbers\n   254        42      33662.0    801.5      0.1                              args = (src, trg, rel_trans, rel_sus, beta_per_dt, randvals) # Set up the arguments to calculate transmission\n   255        42    6247050.0 148739.3     14.5                              target_uids, source_uids = self.compute_transmission(*args) # Actually calculate it\n   256        42      18655.0    444.2      0.0                              new_cases.append(target_uids)\n   257        42      14189.0    337.8      0.0                              sources.append(source_uids)\n   258        42     314183.0   7480.5      0.7                              networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   259                                           \n   260                                                       # Handle everything else: mixing pools, environmental transmission, etc.\n   261                                                       elif isinstance(route, ss.Route):\n   262                                                           # Mixing pools are unidirectional, only use the first beta value\n   263                                                           disease_beta = betamap[nk][0].to_prob(self.t.dt) if isinstance(betamap[nk][0], ss.Rate) else betamap[nk][0]\n   264                                                           target_uids = route.compute_transmission(rel_sus, rel_trans, disease_beta, disease=self)\n   265                                                           new_cases.append(target_uids)\n   266                                                           sources.append(np.full(len(target_uids), dtype=ss_float, fill_value=np.nan))\n   267                                                           networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   268                                                       else:\n   269                                                           errormsg = f'Cannot compute transmission via route {type(route)}; please subclass ss.Route and define a compute_transmission() method'\n   270                                                           raise TypeError(errormsg)\n   271                                           \n   272                                                   # Finalize\n   273        21      12564.0    598.3      0.0          if len(new_cases) and len(sources):\n   274        21     158220.0   7534.3      0.4              new_cases = ss.uids.cat(new_cases)\n   275        21     977391.0  46542.4      2.3              new_cases, inds = new_cases.unique(return_index=True)\n   276        21     119650.0   5697.6      0.3              sources = ss.uids.cat(sources)[inds]\n   277        21      63468.0   3022.3      0.1              networks = np.concatenate(networks)[inds]\n   278                                                   else:\n   279                                                       new_cases = ss.uids()\n   280                                                       sources = ss.uids()\n   281                                                       networks = np.empty(0, dtype=ss_int)\n   282                                           \n   283        21      50344.0   2397.3      0.1          return new_cases, sources, networks\n\n\n\n———————————————————————————————————————————————————————————\nProfile of diseases.Infection.infect: 0.042982 s (37.9613%)\n———————————————————————————————————————————————————————————\n\nTotal time: 0.042982 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.infect at line 230\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   230                                               def infect(self):\n   231                                                   \"\"\" Determine who gets infected on this timestep via transmission on the network \"\"\"\n   232        21      12402.0    590.6      0.0          new_cases = []\n   233        21       7146.0    340.3      0.0          sources = []\n   234        21       4669.0    222.3      0.0          networks = []\n   235        21     389916.0  18567.4      0.9          betamap = self.validate_beta()\n   236                                           \n   237        21     852127.0  40577.5      2.0          rel_trans = self.rel_trans.asnew(self.infectious * self.rel_trans)\n   238        21     553232.0  26344.4      1.3          rel_sus   = self.rel_sus.asnew(self.susceptible * self.rel_sus)\n   239                                           \n   240        42      97080.0   2311.4      0.2          for i, (nkey,route) in enumerate(self.sim.networks.items()):\n   241        21      21190.0   1009.0      0.0              nk = ss.standardize_netkey(nkey)\n   242                                           \n   243                                                       # Main use case: networks\n   244        21      10084.0    480.2      0.0              if isinstance(route, ss.Network):\n   245        21     134554.0   6407.3      0.3                  if len(route): # Skip networks with no edges\n   246        21       7615.0    362.6      0.0                      edges = route.edges\n   247        21     188632.0   8982.5      0.4                      p1p2b0 = [edges.p1, edges.p2, betamap[nk][0]] # Person 1, person 2, beta 0\n   248        21     180462.0   8593.4      0.4                      p2p1b1 = [edges.p2, edges.p1, betamap[nk][1]] # Person 2, person 1, beta 1\n   249        63      34038.0    540.3      0.1                      for src, trg, beta in [p1p2b0, p2p1b1]:\n   250        42      50539.0   1203.3      0.1                          if beta: # Skip networks with no transmission\n   251        42     763187.0  18171.1      1.8                              disease_beta = beta.to_prob(self.t.dt) if isinstance(beta, ss.Rate) else beta\n   252        42    1335047.0  31786.8      3.1                              beta_per_dt = route.net_beta(disease_beta=disease_beta, disease=self) # Compute beta for this network and timestep\n   253        42   30330721.0 722160.0     70.6                              randvals = self.trans_rng.rvs(src, trg) # Generate a new random number based on the two other random numbers\n   254        42      33662.0    801.5      0.1                              args = (src, trg, rel_trans, rel_sus, beta_per_dt, randvals) # Set up the arguments to calculate transmission\n   255        42    6247050.0 148739.3     14.5                              target_uids, source_uids = self.compute_transmission(*args) # Actually calculate it\n   256        42      18655.0    444.2      0.0                              new_cases.append(target_uids)\n   257        42      14189.0    337.8      0.0                              sources.append(source_uids)\n   258        42     314183.0   7480.5      0.7                              networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   259                                           \n   260                                                       # Handle everything else: mixing pools, environmental transmission, etc.\n   261                                                       elif isinstance(route, ss.Route):\n   262                                                           # Mixing pools are unidirectional, only use the first beta value\n   263                                                           disease_beta = betamap[nk][0].to_prob(self.t.dt) if isinstance(betamap[nk][0], ss.Rate) else betamap[nk][0]\n   264                                                           target_uids = route.compute_transmission(rel_sus, rel_trans, disease_beta, disease=self)\n   265                                                           new_cases.append(target_uids)\n   266                                                           sources.append(np.full(len(target_uids), dtype=ss_float, fill_value=np.nan))\n   267                                                           networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   268                                                       else:\n   269                                                           errormsg = f'Cannot compute transmission via route {type(route)}; please subclass ss.Route and define a compute_transmission() method'\n   270                                                           raise TypeError(errormsg)\n   271                                           \n   272                                                   # Finalize\n   273        21      12564.0    598.3      0.0          if len(new_cases) and len(sources):\n   274        21     158220.0   7534.3      0.4              new_cases = ss.uids.cat(new_cases)\n   275        21     977391.0  46542.4      2.3              new_cases, inds = new_cases.unique(return_index=True)\n   276        21     119650.0   5697.6      0.3              sources = ss.uids.cat(sources)[inds]\n   277        21      63468.0   3022.3      0.1              networks = np.concatenate(networks)[inds]\n   278                                                   else:\n   279                                                       new_cases = ss.uids()\n   280                                                       sources = ss.uids()\n   281                                                       networks = np.empty(0, dtype=ss_int)\n   282                                           \n   283        21      50344.0   2397.3      0.1          return new_cases, sources, networks\n\n\n\n(Note: you can only follow functions that are called as part of sim.run() this way. To follow other functions, such as those run by sim.init(), you can use sc.profile() directly.)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Profiling and debugging"
    ]
  },
  {
    "objectID": "user_guide/advanced_profiling.html#profiling",
    "href": "user_guide/advanced_profiling.html#profiling",
    "title": "Profiling and debugging",
    "section": "",
    "text": "One of the main reasons people don’t use ABMs is because they can be very slow. While “vanilla Starsim” is quite fast (10,000 agents running for 100 timesteps should take about a second), custom modules, if not properly written, can be quite slow.\nThe first step of fixing a slow module is to identify the problem. To do this, Starsim includes some built-in profiling tools.\nLet’s look at a simple simulation:\n\nimport sciris as sc\nimport starsim as ss\nsc.options(jupyter=True)\n\npars = dict(\n    start = '2000-01-01',\n    stop = '2020-01-01',\n    diseases = 'sis',\n    networks = 'random'\n)\n\n# Profile sim\nsim = ss.Sim(pars)\nprof = sim.profile()\n\nInitializing sim with 10000 agents\nProfiling 15 function(s):\n &lt;bound method Sim.run of Sim(n=10000; 2000.01.01—2020.01.01; networks=randomnet; diseases=sis)&gt;\n&lt;bound method Sim.start_step of Sim(n=10000; 2000.01.01—2020.01.01; networks=randomnet; diseases=sis [...]\n&lt;function Module.start_step at 0x7dd03f47eb60&gt;\n&lt;function Module.start_step at 0x7dd03f47eb60&gt;\n&lt;bound method SIS.step_state of sis(pars=[init_prev, beta, dur_inf, waning, imm_boost, _n_initial_ca [...]\n&lt;bound method DynamicNetwork.step of randomnet(n_edges=50000; pars=[n_contacts, dur, beta]; states=[ [...]\n&lt;bound method Infection.step of sis(pars=[init_prev, beta, dur_inf, waning, imm_boost, _n_initial_ca [...]\n&lt;bound method People.step_die of People(n=10000; age=30.0±17.3)&gt;\n&lt;bound method People.update_results of People(n=10000; age=30.0±17.3)&gt;\n&lt;bound method Network.update_results of randomnet(n_edges=50000; pars=[n_contacts, dur, beta]; state [...]\n&lt;function SIS.update_results at 0x7dd03ee7d3a0&gt;\n&lt;function Module.finish_step at 0x7dd03f47ed40&gt;\n&lt;function Module.finish_step at 0x7dd03f47ed40&gt;\n&lt;bound method People.finish_step of People(n=10000; age=30.0±17.3)&gt;\n&lt;bound method Sim.finish_step of Sim(n=10000; 2000.01.01—2020.01.01; networks=randomnet; diseases=si [...] \n\n  Running 2000.01.01 ( 0/21) (0.00 s)  ———————————————————— 5%\n  Running 2010.01.01 (10/21) (0.49 s)  ••••••••••—————————— 52%\n  Running 2020.01.01 (20/21) (0.54 s)  •••••••••••••••••••• 100%\n\nElapsed time: 0.556 s\n\n\n——————————————————————————————————————————————————————————————————————\nProfile of networks.Network.update_results: 0.000370856 s (0.0667428%)\n——————————————————————————————————————————————————————————————————————\n\nTotal time: 0.000370856 s\nFile: /home/cliffk/idm/starsim/starsim/networks.py\nFunction: Network.update_results at line 254\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   254                                               def update_results(self):\n   255                                                   \"\"\" Store the number of edges in the network \"\"\"\n   256        21      99548.0   4740.4     26.8          super().update_results()\n   257        21     261994.0  12475.9     70.6          self.results['n_edges'][self.ti] = len(self)\n   258        21       9314.0    443.5      2.5          return\n\n\n\n————————————————————————————————————————————————————————————————\nProfile of people.People.finish_step: 0.000542667 s (0.0976635%)\n————————————————————————————————————————————————————————————————\n\nTotal time: 0.000542667 s\nFile: /home/cliffk/idm/starsim/starsim/people.py\nFunction: People.finish_step at line 475\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   475                                               def finish_step(self):\n   476        21     361739.0  17225.7     66.7          self.remove_dead()\n   477        21     171654.0   8174.0     31.6          self.update_post()\n   478        21       9274.0    441.6      1.7          return\n\n\n\n———————————————————————————————————————————————————————————\nProfile of people.People.step_die: 0.00143625 s (0.258481%)\n———————————————————————————————————————————————————————————\n\nTotal time: 0.00143625 s\nFile: /home/cliffk/idm/starsim/starsim/people.py\nFunction: People.step_die at line 437\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   437                                               def step_die(self):\n   438                                                   \"\"\" Carry out any deaths or removals that took place this timestep \"\"\"\n   439        21    1203757.0  57321.8     83.8          death_uids = ((self.ti_dead &lt;= self.sim.ti) | (self.ti_removed &lt;= self.sim.ti)).uids\n   440        21      54355.0   2588.3      3.8          self.alive[death_uids] = False  # Whilst not dead, removed agents should not be included in alive totals\n   441                                           \n   442                                                   # Execute deaths that took place this timestep (i.e., changing the `alive` state of the agents). This is executed\n   443                                                   # before analyzers have run so that analyzers are able to inspect and record outcomes for agents that died this timestep\n   444        42     117468.0   2796.9      8.2          for disease in self.sim.diseases():\n   445        21      17513.0    834.0      1.2              if isinstance(disease, ss.Disease):\n   446        21      28388.0   1351.8      2.0                  disease.step_die(death_uids)\n   447                                           \n   448        21      14769.0    703.3      1.0          return death_uids\n\n\n\n—————————————————————————————————————————————————————————————————\nProfile of people.People.update_results: 0.00214351 s (0.385766%)\n—————————————————————————————————————————————————————————————————\n\nTotal time: 0.00214351 s\nFile: /home/cliffk/idm/starsim/starsim/people.py\nFunction: People.update_results at line 466\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   466                                               def update_results(self):\n   467        21      18901.0    900.0      0.9          ti = self.sim.ti\n   468        21       7392.0    352.0      0.3          res = self.sim.results\n   469        21     508266.0  24203.1     23.7          res.n_alive[ti] = np.count_nonzero(self.alive)\n   470        21     541601.0  25790.5     25.3          res.new_deaths[ti] = np.count_nonzero(self.ti_dead == ti)\n   471        21     442591.0  21075.8     20.6          res.new_emigrants[ti] = np.count_nonzero(self.ti_removed == ti)\n   472        21     607162.0  28912.5     28.3          res.cum_deaths[ti] = np.sum(res.new_deaths[:ti]) # TODO: inefficient to compute the cumulative sum on every timestep!\n   473        21      17599.0    838.0      0.8          return\n\n\n\n————————————————————————————————————————————————————\nProfile of diseases.py:670: 0.00230529 s (0.414882%)\n————————————————————————————————————————————————————\n\nTotal time: 0.00230529 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: SIS.update_results at line 670\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   670                                               @ss.required()\n   671                                               def update_results(self):\n   672                                                   \"\"\" Store the population immunity (susceptibility) \"\"\"\n   673        21    1596974.0  76046.4     69.3          super().update_results()\n   674        21     697955.0  33236.0     30.3          self.results['rel_sus'][self.ti] = self.rel_sus.mean()\n   675        21      10357.0    493.2      0.4          return\n\n\n\n———————————————————————————————————————————————————————\nProfile of sim.Sim.start_step: 0.00368424 s (0.663051%)\n———————————————————————————————————————————————————————\n\nTotal time: 0.00368424 s\nFile: /home/cliffk/idm/starsim/starsim/sim.py\nFunction: Sim.start_step at line 306\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   306                                               def start_step(self):\n   307                                                   \"\"\" Start the step -- only print progress; all actual changes happen in the modules \"\"\"\n   308                                           \n   309                                                   # Set the time and if we have reached the end of the simulation, then do nothing\n   310        21       7642.0    363.9      0.2          if self.complete:\n   311                                                       errormsg = 'Simulation already complete (call sim.init() to re-run)'\n   312                                                       raise AlreadyRunError(errormsg)\n   313                                           \n   314                                                   # Print out progress if needed\n   315        21    2504678.0 119270.4     68.0          self.elapsed = self.timer.toc(output=True)\n   316        21      11508.0    548.0      0.3          if self.verbose: # Print progress\n   317        21       6123.0    291.6      0.2              t = self.t\n   318        21     148133.0   7054.0      4.0              simlabel = f'\"{self.label}\": ' if self.label else ''\n   319        21     683401.0  32542.9     18.5              string = f'  Running {simlabel}{t.now(\"str\")} ({t.ti:2.0f}/{t.npts}) ({self.elapsed:0.2f} s) '\n   320        21       9644.0    459.2      0.3              if self.verbose &gt;= 1:\n   321                                                           sc.heading(string)\n   322        21       7289.0    347.1      0.2              elif self.verbose &gt; 0:\n   323        21      15407.0    733.7      0.4                  if not (t.ti % int(1.0 / self.verbose)):\n   324         3     269323.0  89774.3      7.3                      sc.progressbar(t.ti + 1, t.npts, label=string, length=20, newline=True)\n   325        21      21096.0   1004.6      0.6          return\n\n\n\n————————————————————————————————————————————————————————————\nProfile of diseases.SIS.step_state: 0.00393148 s (0.707546%)\n————————————————————————————————————————————————————————————\n\nTotal time: 0.00393148 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: SIS.step_state at line 631\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   631                                               def step_state(self):\n   632                                                   \"\"\" Progress infectious -&gt; recovered \"\"\"\n   633        21    1222804.0  58228.8     31.1          recovered = (self.infected & (self.ti_recovered &lt;= self.ti)).uids\n   634        21      67807.0   3228.9      1.7          self.infected[recovered] = False\n   635        21      39496.0   1880.8      1.0          self.susceptible[recovered] = True\n   636        21    2587513.0 123214.9     65.8          self.update_immunity()\n   637        21      13862.0    660.1      0.4          return\n\n\n\n——————————————————————————————————————————————————\nProfile of modules.py:673: 0.00672401 s (1.21012%)\n——————————————————————————————————————————————————\n\nTotal time: 0.00672401 s\nFile: /home/cliffk/idm/starsim/starsim/modules.py\nFunction: Module.start_step at line 673\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   673                                               @required()\n   674                                               def start_step(self):\n   675                                                   \"\"\" Tasks to perform at the beginning of the step \"\"\"\n   676        42      24797.0    590.4      0.4          if self.finalized:\n   677                                                       errormsg = f'The module {self._debug_name} has already been run. Did you mean to copy it before running it?'\n   678                                                       raise RuntimeError(errormsg)\n   679        42      19795.0    471.3      0.3          if self.dists is not None: # Will be None if no distributions are defined\n   680        42    6654161.0 158432.4     99.0              self.dists.jump_dt() # Advance random number generators forward for calls on this step\n   681        42      25259.0    601.4      0.4          return\n\n\n\n———————————————————————————————————————————————————————————————\nProfile of networks.DynamicNetwork.step: 0.0355001 s (6.38893%)\n———————————————————————————————————————————————————————————————\n\nTotal time: 0.0355001 s\nFile: /home/cliffk/idm/starsim/starsim/networks.py\nFunction: DynamicNetwork.step at line 412\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   412                                               def step(self):\n   413        21   10101223.0 481010.6     28.5          self.end_pairs()\n   414        21   25384704.0 1.21e+06     71.5          self.add_pairs()\n   415        21      14157.0    674.1      0.0          return\n\n\n\n————————————————————————————————————————————————————————\nProfile of diseases.Infection.step: 0.483204 s (86.962%)\n————————————————————————————————————————————————————————\n\nTotal time: 0.483204 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.step at line 208\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   208                                               def step(self):\n   209                                                   \"\"\"\n   210                                                   Perform key infection updates, including infection and setting prognoses\n   211                                                   \"\"\"\n   212                                                   # Create new cases\n   213        21  472348159.0 2.25e+07     97.8          new_cases, sources, networks = self.infect() # TODO: store outputs in self or use objdict rather than 3 returns\n   214                                           \n   215                                                   # Set prognoses\n   216        21      18036.0    858.9      0.0          if len(new_cases):\n   217        21   10821773.0 515322.5      2.2              self.set_outcomes(new_cases, sources)\n   218                                           \n   219        21      15765.0    750.7      0.0          return new_cases, sources, networks\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nThis graph (which is a shortcut to sim.loop.plot_cpu()) shows us how much time each step in the integration loop takes. We can get line-by-line detail of where each function is taking time, though:\n\nprof.disp(maxentries=5)\n\n\n\n———————————————————————————————————————————————————————\nProfile of sim.Sim.start_step: 0.00368424 s (0.663051%)\n———————————————————————————————————————————————————————\n\nTotal time: 0.00368424 s\nFile: /home/cliffk/idm/starsim/starsim/sim.py\nFunction: Sim.start_step at line 306\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   306                                               def start_step(self):\n   307                                                   \"\"\" Start the step -- only print progress; all actual changes happen in the modules \"\"\"\n   308                                           \n   309                                                   # Set the time and if we have reached the end of the simulation, then do nothing\n   310        21       7642.0    363.9      0.2          if self.complete:\n   311                                                       errormsg = 'Simulation already complete (call sim.init() to re-run)'\n   312                                                       raise AlreadyRunError(errormsg)\n   313                                           \n   314                                                   # Print out progress if needed\n   315        21    2504678.0 119270.4     68.0          self.elapsed = self.timer.toc(output=True)\n   316        21      11508.0    548.0      0.3          if self.verbose: # Print progress\n   317        21       6123.0    291.6      0.2              t = self.t\n   318        21     148133.0   7054.0      4.0              simlabel = f'\"{self.label}\": ' if self.label else ''\n   319        21     683401.0  32542.9     18.5              string = f'  Running {simlabel}{t.now(\"str\")} ({t.ti:2.0f}/{t.npts}) ({self.elapsed:0.2f} s) '\n   320        21       9644.0    459.2      0.3              if self.verbose &gt;= 1:\n   321                                                           sc.heading(string)\n   322        21       7289.0    347.1      0.2              elif self.verbose &gt; 0:\n   323        21      15407.0    733.7      0.4                  if not (t.ti % int(1.0 / self.verbose)):\n   324         3     269323.0  89774.3      7.3                      sc.progressbar(t.ti + 1, t.npts, label=string, length=20, newline=True)\n   325        21      21096.0   1004.6      0.6          return\n\n\n\n————————————————————————————————————————————————————————————\nProfile of diseases.SIS.step_state: 0.00393148 s (0.707546%)\n————————————————————————————————————————————————————————————\n\nTotal time: 0.00393148 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: SIS.step_state at line 631\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   631                                               def step_state(self):\n   632                                                   \"\"\" Progress infectious -&gt; recovered \"\"\"\n   633        21    1222804.0  58228.8     31.1          recovered = (self.infected & (self.ti_recovered &lt;= self.ti)).uids\n   634        21      67807.0   3228.9      1.7          self.infected[recovered] = False\n   635        21      39496.0   1880.8      1.0          self.susceptible[recovered] = True\n   636        21    2587513.0 123214.9     65.8          self.update_immunity()\n   637        21      13862.0    660.1      0.4          return\n\n\n\n——————————————————————————————————————————————————\nProfile of modules.py:673: 0.00672401 s (1.21012%)\n——————————————————————————————————————————————————\n\nTotal time: 0.00672401 s\nFile: /home/cliffk/idm/starsim/starsim/modules.py\nFunction: Module.start_step at line 673\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   673                                               @required()\n   674                                               def start_step(self):\n   675                                                   \"\"\" Tasks to perform at the beginning of the step \"\"\"\n   676        42      24797.0    590.4      0.4          if self.finalized:\n   677                                                       errormsg = f'The module {self._debug_name} has already been run. Did you mean to copy it before running it?'\n   678                                                       raise RuntimeError(errormsg)\n   679        42      19795.0    471.3      0.3          if self.dists is not None: # Will be None if no distributions are defined\n   680        42    6654161.0 158432.4     99.0              self.dists.jump_dt() # Advance random number generators forward for calls on this step\n   681        42      25259.0    601.4      0.4          return\n\n\n\n———————————————————————————————————————————————————————————————\nProfile of networks.DynamicNetwork.step: 0.0355001 s (6.38893%)\n———————————————————————————————————————————————————————————————\n\nTotal time: 0.0355001 s\nFile: /home/cliffk/idm/starsim/starsim/networks.py\nFunction: DynamicNetwork.step at line 412\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   412                                               def step(self):\n   413        21   10101223.0 481010.6     28.5          self.end_pairs()\n   414        21   25384704.0 1.21e+06     71.5          self.add_pairs()\n   415        21      14157.0    674.1      0.0          return\n\n\n\n————————————————————————————————————————————————————————\nProfile of diseases.Infection.step: 0.483204 s (86.962%)\n————————————————————————————————————————————————————————\n\nTotal time: 0.483204 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.step at line 208\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   208                                               def step(self):\n   209                                                   \"\"\"\n   210                                                   Perform key infection updates, including infection and setting prognoses\n   211                                                   \"\"\"\n   212                                                   # Create new cases\n   213        21  472348159.0 2.25e+07     97.8          new_cases, sources, networks = self.infect() # TODO: store outputs in self or use objdict rather than 3 returns\n   214                                           \n   215                                                   # Set prognoses\n   216        21      18036.0    858.9      0.0          if len(new_cases):\n   217        21   10821773.0 515322.5      2.2              self.set_outcomes(new_cases, sources)\n   218                                           \n   219        21      15765.0    750.7      0.0          return new_cases, sources, networks\n\n\n\n(Note that the names of the functions here refer to the actual functions called, which may not match the graph above. That’s because, for example, ss.SIS does not define its own step() method, but instead inherits step() from Infection. In the graph, this is shown as sis.step(), but is listed in the table as Infection.step(). This is because it’s referring to the actual code being run, so refers to where those lines of code exist in the codebase; there is no code corresponding to SIS.step() since it’s just inherited from Infection.step().)\nIf you want more detail, you can also define custom functions to follow. For example, we can see that ss.SIS.infect() takes the most time in ss.SIS.step(), so let’s profile that:\n\nprof = sim.profile(follow=ss.SIS.infect, plot=False)\nprof.disp()\n\nInitializing sim with 10000 agents\nProfiling 1 function(s):\n &lt;function Infection.infect at 0x7dd03ee63f60&gt; \n\n  Running 2000.01.01 ( 0/21) (0.00 s)  ———————————————————— 5%\n  Running 2010.01.01 (10/21) (0.05 s)  ••••••••••—————————— 52%\n  Running 2020.01.01 (20/21) (0.10 s)  •••••••••••••••••••• 100%\n\nElapsed time: 0.113 s\n\n\n———————————————————————————————————————————————————————————\nProfile of diseases.Infection.infect: 0.042982 s (37.9613%)\n———————————————————————————————————————————————————————————\n\nTotal time: 0.042982 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.infect at line 230\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   230                                               def infect(self):\n   231                                                   \"\"\" Determine who gets infected on this timestep via transmission on the network \"\"\"\n   232        21      12402.0    590.6      0.0          new_cases = []\n   233        21       7146.0    340.3      0.0          sources = []\n   234        21       4669.0    222.3      0.0          networks = []\n   235        21     389916.0  18567.4      0.9          betamap = self.validate_beta()\n   236                                           \n   237        21     852127.0  40577.5      2.0          rel_trans = self.rel_trans.asnew(self.infectious * self.rel_trans)\n   238        21     553232.0  26344.4      1.3          rel_sus   = self.rel_sus.asnew(self.susceptible * self.rel_sus)\n   239                                           \n   240        42      97080.0   2311.4      0.2          for i, (nkey,route) in enumerate(self.sim.networks.items()):\n   241        21      21190.0   1009.0      0.0              nk = ss.standardize_netkey(nkey)\n   242                                           \n   243                                                       # Main use case: networks\n   244        21      10084.0    480.2      0.0              if isinstance(route, ss.Network):\n   245        21     134554.0   6407.3      0.3                  if len(route): # Skip networks with no edges\n   246        21       7615.0    362.6      0.0                      edges = route.edges\n   247        21     188632.0   8982.5      0.4                      p1p2b0 = [edges.p1, edges.p2, betamap[nk][0]] # Person 1, person 2, beta 0\n   248        21     180462.0   8593.4      0.4                      p2p1b1 = [edges.p2, edges.p1, betamap[nk][1]] # Person 2, person 1, beta 1\n   249        63      34038.0    540.3      0.1                      for src, trg, beta in [p1p2b0, p2p1b1]:\n   250        42      50539.0   1203.3      0.1                          if beta: # Skip networks with no transmission\n   251        42     763187.0  18171.1      1.8                              disease_beta = beta.to_prob(self.t.dt) if isinstance(beta, ss.Rate) else beta\n   252        42    1335047.0  31786.8      3.1                              beta_per_dt = route.net_beta(disease_beta=disease_beta, disease=self) # Compute beta for this network and timestep\n   253        42   30330721.0 722160.0     70.6                              randvals = self.trans_rng.rvs(src, trg) # Generate a new random number based on the two other random numbers\n   254        42      33662.0    801.5      0.1                              args = (src, trg, rel_trans, rel_sus, beta_per_dt, randvals) # Set up the arguments to calculate transmission\n   255        42    6247050.0 148739.3     14.5                              target_uids, source_uids = self.compute_transmission(*args) # Actually calculate it\n   256        42      18655.0    444.2      0.0                              new_cases.append(target_uids)\n   257        42      14189.0    337.8      0.0                              sources.append(source_uids)\n   258        42     314183.0   7480.5      0.7                              networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   259                                           \n   260                                                       # Handle everything else: mixing pools, environmental transmission, etc.\n   261                                                       elif isinstance(route, ss.Route):\n   262                                                           # Mixing pools are unidirectional, only use the first beta value\n   263                                                           disease_beta = betamap[nk][0].to_prob(self.t.dt) if isinstance(betamap[nk][0], ss.Rate) else betamap[nk][0]\n   264                                                           target_uids = route.compute_transmission(rel_sus, rel_trans, disease_beta, disease=self)\n   265                                                           new_cases.append(target_uids)\n   266                                                           sources.append(np.full(len(target_uids), dtype=ss_float, fill_value=np.nan))\n   267                                                           networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   268                                                       else:\n   269                                                           errormsg = f'Cannot compute transmission via route {type(route)}; please subclass ss.Route and define a compute_transmission() method'\n   270                                                           raise TypeError(errormsg)\n   271                                           \n   272                                                   # Finalize\n   273        21      12564.0    598.3      0.0          if len(new_cases) and len(sources):\n   274        21     158220.0   7534.3      0.4              new_cases = ss.uids.cat(new_cases)\n   275        21     977391.0  46542.4      2.3              new_cases, inds = new_cases.unique(return_index=True)\n   276        21     119650.0   5697.6      0.3              sources = ss.uids.cat(sources)[inds]\n   277        21      63468.0   3022.3      0.1              networks = np.concatenate(networks)[inds]\n   278                                                   else:\n   279                                                       new_cases = ss.uids()\n   280                                                       sources = ss.uids()\n   281                                                       networks = np.empty(0, dtype=ss_int)\n   282                                           \n   283        21      50344.0   2397.3      0.1          return new_cases, sources, networks\n\n\n\n———————————————————————————————————————————————————————————\nProfile of diseases.Infection.infect: 0.042982 s (37.9613%)\n———————————————————————————————————————————————————————————\n\nTotal time: 0.042982 s\nFile: /home/cliffk/idm/starsim/starsim/diseases.py\nFunction: Infection.infect at line 230\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   230                                               def infect(self):\n   231                                                   \"\"\" Determine who gets infected on this timestep via transmission on the network \"\"\"\n   232        21      12402.0    590.6      0.0          new_cases = []\n   233        21       7146.0    340.3      0.0          sources = []\n   234        21       4669.0    222.3      0.0          networks = []\n   235        21     389916.0  18567.4      0.9          betamap = self.validate_beta()\n   236                                           \n   237        21     852127.0  40577.5      2.0          rel_trans = self.rel_trans.asnew(self.infectious * self.rel_trans)\n   238        21     553232.0  26344.4      1.3          rel_sus   = self.rel_sus.asnew(self.susceptible * self.rel_sus)\n   239                                           \n   240        42      97080.0   2311.4      0.2          for i, (nkey,route) in enumerate(self.sim.networks.items()):\n   241        21      21190.0   1009.0      0.0              nk = ss.standardize_netkey(nkey)\n   242                                           \n   243                                                       # Main use case: networks\n   244        21      10084.0    480.2      0.0              if isinstance(route, ss.Network):\n   245        21     134554.0   6407.3      0.3                  if len(route): # Skip networks with no edges\n   246        21       7615.0    362.6      0.0                      edges = route.edges\n   247        21     188632.0   8982.5      0.4                      p1p2b0 = [edges.p1, edges.p2, betamap[nk][0]] # Person 1, person 2, beta 0\n   248        21     180462.0   8593.4      0.4                      p2p1b1 = [edges.p2, edges.p1, betamap[nk][1]] # Person 2, person 1, beta 1\n   249        63      34038.0    540.3      0.1                      for src, trg, beta in [p1p2b0, p2p1b1]:\n   250        42      50539.0   1203.3      0.1                          if beta: # Skip networks with no transmission\n   251        42     763187.0  18171.1      1.8                              disease_beta = beta.to_prob(self.t.dt) if isinstance(beta, ss.Rate) else beta\n   252        42    1335047.0  31786.8      3.1                              beta_per_dt = route.net_beta(disease_beta=disease_beta, disease=self) # Compute beta for this network and timestep\n   253        42   30330721.0 722160.0     70.6                              randvals = self.trans_rng.rvs(src, trg) # Generate a new random number based on the two other random numbers\n   254        42      33662.0    801.5      0.1                              args = (src, trg, rel_trans, rel_sus, beta_per_dt, randvals) # Set up the arguments to calculate transmission\n   255        42    6247050.0 148739.3     14.5                              target_uids, source_uids = self.compute_transmission(*args) # Actually calculate it\n   256        42      18655.0    444.2      0.0                              new_cases.append(target_uids)\n   257        42      14189.0    337.8      0.0                              sources.append(source_uids)\n   258        42     314183.0   7480.5      0.7                              networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   259                                           \n   260                                                       # Handle everything else: mixing pools, environmental transmission, etc.\n   261                                                       elif isinstance(route, ss.Route):\n   262                                                           # Mixing pools are unidirectional, only use the first beta value\n   263                                                           disease_beta = betamap[nk][0].to_prob(self.t.dt) if isinstance(betamap[nk][0], ss.Rate) else betamap[nk][0]\n   264                                                           target_uids = route.compute_transmission(rel_sus, rel_trans, disease_beta, disease=self)\n   265                                                           new_cases.append(target_uids)\n   266                                                           sources.append(np.full(len(target_uids), dtype=ss_float, fill_value=np.nan))\n   267                                                           networks.append(np.full(len(target_uids), dtype=ss_int, fill_value=i))\n   268                                                       else:\n   269                                                           errormsg = f'Cannot compute transmission via route {type(route)}; please subclass ss.Route and define a compute_transmission() method'\n   270                                                           raise TypeError(errormsg)\n   271                                           \n   272                                                   # Finalize\n   273        21      12564.0    598.3      0.0          if len(new_cases) and len(sources):\n   274        21     158220.0   7534.3      0.4              new_cases = ss.uids.cat(new_cases)\n   275        21     977391.0  46542.4      2.3              new_cases, inds = new_cases.unique(return_index=True)\n   276        21     119650.0   5697.6      0.3              sources = ss.uids.cat(sources)[inds]\n   277        21      63468.0   3022.3      0.1              networks = np.concatenate(networks)[inds]\n   278                                                   else:\n   279                                                       new_cases = ss.uids()\n   280                                                       sources = ss.uids()\n   281                                                       networks = np.empty(0, dtype=ss_int)\n   282                                           \n   283        21      50344.0   2397.3      0.1          return new_cases, sources, networks\n\n\n\n(Note: you can only follow functions that are called as part of sim.run() this way. To follow other functions, such as those run by sim.init(), you can use sc.profile() directly.)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Profiling and debugging"
    ]
  },
  {
    "objectID": "user_guide/advanced_profiling.html#debugging",
    "href": "user_guide/advanced_profiling.html#debugging",
    "title": "Profiling and debugging",
    "section": "Debugging",
    "text": "Debugging\nWhen figuring out what your sim is doing – whether it’s doing something it shouldn’t be, or not doing something it should – sim.loop is your friend. It shows everything that will happen in the sim, and in what order:\n\nimport starsim as ss\n\nsim = ss.Sim(\n    start = 2000,\n    stop = 2002,\n    diseases = 'sis',\n    networks = 'random',\n    verbose = 0,\n)\nsim.run()\nsim.loop.df.disp()\n# %%\n\n    time  ti  func_order                     label     module       func_name    cpu_time\n0   2000   0           0            sim.start_step        sim      start_step  2.0854e-04\n1   2000   0           1      randomnet.start_step  randomnet      start_step  1.1106e-04\n2   2000   0           2            sis.start_step        sis      start_step  1.0002e-04\n3   2000   0           3            sis.step_state        sis      step_state  8.1091e-05\n4   2000   0           4            randomnet.step  randomnet            step  1.1102e-03\n5   2000   0           5                  sis.step        sis            step  2.2622e-03\n6   2000   0           6           people.step_die     people        step_die  3.7400e-05\n7   2000   0           7     people.update_results     people  update_results  4.4885e-05\n8   2000   0           8  randomnet.update_results  randomnet  update_results  8.6730e-06\n9   2000   0           9        sis.update_results        sis  update_results  6.2612e-05\n10  2000   0          10     randomnet.finish_step  randomnet     finish_step  3.3670e-06\n11  2000   0          11           sis.finish_step        sis     finish_step  1.7570e-06\n12  2000   0          12        people.finish_step     people     finish_step  1.1204e-05\n13  2000   0          13           sim.finish_step        sim     finish_step  1.6490e-06\n14  2001   1           0            sim.start_step        sim      start_step  5.3382e-05\n15  2001   1           1      randomnet.start_step  randomnet      start_step  8.2708e-05\n16  2001   1           2            sis.start_step        sis      start_step  9.3020e-05\n17  2001   1           3            sis.step_state        sis      step_state  5.9762e-05\n18  2001   1           4            randomnet.step  randomnet            step  1.0267e-03\n19  2001   1           5                  sis.step        sis            step  1.6051e-03\n20  2001   1           6           people.step_die     people        step_die  3.1857e-05\n21  2001   1           7     people.update_results     people  update_results  4.1163e-05\n22  2001   1           8  randomnet.update_results  randomnet  update_results  7.0070e-06\n23  2001   1           9        sis.update_results        sis  update_results  5.4160e-05\n24  2001   1          10     randomnet.finish_step  randomnet     finish_step  3.3090e-06\n25  2001   1          11           sis.finish_step        sis     finish_step  1.6930e-06\n26  2001   1          12        people.finish_step     people     finish_step  1.0562e-05\n27  2001   1          13           sim.finish_step        sim     finish_step  1.4910e-06\n28  2002   2           0            sim.start_step        sim      start_step  5.0586e-05\n29  2002   2           1      randomnet.start_step  randomnet      start_step  7.7721e-05\n30  2002   2           2            sis.start_step        sis      start_step  8.9695e-05\n31  2002   2           3            sis.step_state        sis      step_state  5.2579e-05\n32  2002   2           4            randomnet.step  randomnet            step  9.9232e-04\n33  2002   2           5                  sis.step        sis            step  1.5362e-03\n34  2002   2           6           people.step_die     people        step_die  3.0093e-05\n35  2002   2           7     people.update_results     people  update_results  3.8311e-05\n36  2002   2           8  randomnet.update_results  randomnet  update_results  6.4450e-06\n37  2002   2           9        sis.update_results        sis  update_results  4.9012e-05\n38  2002   2          10     randomnet.finish_step  randomnet     finish_step  2.7030e-06\n39  2002   2          11           sis.finish_step        sis     finish_step  1.3510e-06\n40  2002   2          12        people.finish_step     people     finish_step  9.6950e-06\n41  2002   2          13           sim.finish_step        sim     finish_step  1.2550e-06\n\n\nAs you can see, it’s a lot – this is only three timesteps and two modules, and it’s already 41 steps.\nThe typical way to do debugging is to insert breakpoints or print statements into your modules for custom debugging (e.g., to print a value), or to use analyzers for heavier-lift debugging. Starsim also lets you manually modify the loop by inserting “probes” or other arbitrary functions. For example, if you wanted to check the population size after each time the People object is updated:\n\ndef check_pop_size(sim):\n    print(f'Population size is {len(sim.people)}')\n\nsim = ss.Sim(diseases='sir', networks='random', demographics=True, dur=10)\nsim.init()\nsim.loop.insert(check_pop_size, label='people.finish_step')\nsim.run()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/11) (0.00 s)  •——————————————————— 9%\nPopulation size is 10191\nPopulation size is 10264\nPopulation size is 10357\nPopulation size is 10447\nPopulation size is 10557\nPopulation size is 10664\nPopulation size is 10739\nPopulation size is 10817\nPopulation size is 10917\nPopulation size is 11033\n  Running 2010.01.01 (10/11) (0.05 s)  •••••••••••••••••••• 100%\n\nPopulation size is 11124\n\n\nSim(n=10000; 2000—2010.0; demographics=births, deaths; networks=randomnet; diseases=sir)\n\n\nIn this case, you get the same output as using an analyzer:\n\ndef check_pop_size(sim):\n    print(f'Population size is {len(sim.people)}')\n\nsim = ss.Sim(diseases='sir', networks='random', demographics=True, dur=10, analyzers=check_pop_size)\nsim.run()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/11) (0.00 s)  •——————————————————— 9%\nPopulation size is 10191\nPopulation size is 10264\nPopulation size is 10357\nPopulation size is 10447\nPopulation size is 10557\nPopulation size is 10664\nPopulation size is 10739\nPopulation size is 10817\nPopulation size is 10917\nPopulation size is 11033\n  Running 2010.01.01 (10/11) (0.06 s)  •••••••••••••••••••• 100%\n\nPopulation size is 11124\n\n\nSim(n=10000; 2000—2010.0; demographics=births, deaths; networks=randomnet; diseases=sir; analyzers=check_pop_size)\n\n\nHowever, inserting functions directly in the loop gives you more control over their exact placement, whereas analyzers are always executed last in the timestep.\nThe loop also has methods for visualizing itself. You can get a simple representation of the loop with loop.plot():\n\nsim.loop.plot()\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nOr a slightly more detailed one with loop.plot_step_order():\n\nsim.loop.plot_step_order()\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nThis is especially useful if your simulation has modules with different timesteps, e.g.:\n\nsis = ss.SIS(dt=0.1)\nnet = ss.RandomNet(dt=0.5)\nbirths = ss.Births(dt=1)\nsim = ss.Sim(dt=0.1, dur=5, diseases=sis, networks=net, demographics=births)\nsim.init()\nsim.loop.plot_step_order()\n\nInitializing sim with 10000 agents\nFigure(672x480)\n\n\n\n\n\n\n\n\n\n(Note: this is a 3D plot, so it helps if you can plot it in a separate window interactively to be able to move it around, rather than just in a notebook.)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Profiling and debugging"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html",
    "href": "user_guide/advanced_nonstandard.html",
    "title": "Nonstandard usage",
    "section": "",
    "text": "Although Starsim is primarily intended as an agent-based disease model, due to its modular structure, it can be used for other applications as well. This tutorial describes how Starsim can be used (1) as a compartmental disease model, and (2) as a general-purpose agent-based model.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html#compartmental-modeling",
    "href": "user_guide/advanced_nonstandard.html#compartmental-modeling",
    "title": "Nonstandard usage",
    "section": "Compartmental modeling",
    "text": "Compartmental modeling\nMuch of Starsim’s power comes from how it handles agents. However, agent-based modeling may be too slow or too complex for some problems. While in many cases it probably makes more sense to do compartmental disease modeling in another framework (such as Atomica), it is also possible to do it within Starsim, taking advantage of features such as demographics, time units, etc. This is especially useful for a multi-disease simulation where some diseases need the detail and flexibility of an ABM, while others can be modeled more simply (and faster) as compartmental models.\n\nSetting up the model\nHere we will define a simple compartmental susceptible-infectious-susceptible (SIS) model. The model definition here is quite similar to the agent-based implementation in Starsim’s SIR module; differences are noted in comments. Note that the model runs extremely fast, since a three-state compartmental model (susceptible, infecious, and immunity) runs as fast as an agent-based model with three agents!\n\n\"\"\"\nExample compartmental SIS model for Starsim\n\"\"\"\nimport starsim as ss\nimport sciris as sc\nimport matplotlib.pyplot as plt\n\nclass CompSIS(ss.Module): # We don't need the extra functionality of the Infection class, so just inherit from Module\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            beta = ss.peryear(0.8), # Leverage Starsim's automatic time unit handling\n            init_prev = 0.01, # NB: this is a scalar, rather than a distribution for an ABM\n            recovery = ss.peryear(0.1), # Also not a distribution\n            waning = ss.peryear(0.05),\n            imm_boost = 1.0,\n        )\n        self.update_pars(**kwargs)\n        \n        # Don't need to define states; just use scalars\n        self.N = 0\n        self.S = 0\n        self.I = 0\n        self.immunity = 0\n        return\n    \n    def init_post(self):\n        \"\"\" Finish initialization \"\"\"\n        super().init_post()\n        self.N = len(self.sim.people) # Assumes a static population; could also use a dynamic population size\n        i0 = self.pars.init_prev\n        self.S = self.N*(1-i0)\n        self.I = self.N*i0\n        self.immunity = i0\n        return\n\n    @property\n    def rel_sus(self):\n        return 1 - self.immunity\n    \n    def step(self):\n        \"\"\" Carry out disease transmission logic \"\"\"\n        self.immunity *= (1 - self.pars.waning.to_prob()) # Update immunity from waning\n        infected = (self.S*self.I/self.N)*(self.pars.beta.to_prob())*self.rel_sus # Replaces Infection.infect()\n        recovered = self.I*self.pars.recovery.to_prob() # Replaces setting a time to recovery and checking that time\n        net = infected - recovered # Net change in number infectious\n        self.S -= net\n        self.I += net\n        self.immunity += infected/self.N*self.pars.imm_boost # Update immunity from new infections\n        return\n    \n    def init_results(self):\n        \"\"\" Initialize results \"\"\"\n        super().init_results()\n        self.define_results(\n            ss.Result('S', label='Susceptible'),\n            ss.Result('I', label='Infectious'),\n        )\n        return\n\n    def update_results(self):\n        \"\"\" Store the current state \"\"\"\n        super().update_results()\n        self.results['S'][self.ti] = self.S\n        self.results['I'][self.ti] = self.I\n        return \n\n    def plot(self):\n        \"\"\" Default plot for SIS model \"\"\"\n        fig = plt.figure()\n        res = self.results\n        kw = dict(lw=2, alpha=0.7)\n        for rkey in ['S', 'I']:\n            plt.plot(res.timevec, res[rkey], label=res[rkey].label, **kw)\n        plt.legend(frameon=False)\n        plt.xlabel('Time')\n        plt.ylabel('Number of people')\n        plt.ylim(bottom=0)\n        sc.boxoff()\n        sc.commaticks() \n        plt.show()      \n        return fig\n    \n\n# Run the compartmental simulation (csim)\ncsim = ss.Sim(diseases=CompSIS(), dur=100, dt=0.1, verbose=0.01)\ncsim.run()\n\n# Plot the results\ncsim.diseases.compsis.plot();\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/1001) (0.00 s)  ———————————————————— 0%\n  Running 2010.01.01 (100/1001) (0.01 s)  ••—————————————————— 10%\n  Running 2020.01.01 (200/1001) (0.02 s)  ••••———————————————— 20%\n  Running 2030.01.01 (300/1001) (0.03 s)  ••••••—————————————— 30%\n  Running 2040.01.01 (400/1001) (0.04 s)  ••••••••———————————— 40%\n  Running 2050.01.01 (500/1001) (0.05 s)  ••••••••••—————————— 50%\n  Running 2060.01.01 (600/1001) (0.06 s)  ••••••••••••———————— 60%\n  Running 2070.01.01 (700/1001) (0.06 s)  ••••••••••••••—————— 70%\n  Running 2080.01.01 (800/1001) (0.07 s)  ••••••••••••••••———— 80%\n  Running 2090.01.01 (900/1001) (0.08 s)  ••••••••••••••••••—— 90%\n  Running 2100.01.01 (1000/1001) (0.09 s)  •••••••••••••••••••• 100%\n\n\n\n\n\n\n\n\n\n\nLet’s compare to our standard agent-based SIS model with similar parameters:\n\nimport starsim as ss\n\n# Run the model\nabm = ss.Sim(diseases=ss.SIS(beta=0.03), networks='random', dur=100, dt=0.1, verbose=0.01)\nabm.run()\n\n# Plot the results\nabm.diseases.sis.plot()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/1001) (0.00 s)  ———————————————————— 0%\n  Running 2010.01.01 (100/1001) (0.57 s)  ••—————————————————— 10%\n  Running 2020.01.01 (200/1001) (0.88 s)  ••••———————————————— 20%\n  Running 2030.01.01 (300/1001) (1.21 s)  ••••••—————————————— 30%\n  Running 2040.01.01 (400/1001) (1.54 s)  ••••••••———————————— 40%\n  Running 2050.01.01 (500/1001) (1.85 s)  ••••••••••—————————— 50%\n  Running 2060.01.01 (600/1001) (2.21 s)  ••••••••••••———————— 60%\n  Running 2070.01.01 (700/1001) (2.58 s)  ••••••••••••••—————— 70%\n  Running 2080.01.01 (800/1001) (2.96 s)  ••••••••••••••••———— 80%\n  Running 2090.01.01 (900/1001) (3.36 s)  ••••••••••••••••••—— 90%\n  Running 2100.01.01 (1000/1001) (3.64 s)  •••••••••••••••••••• 100%\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nThe results are broadly similar, although there are differences due to the network transmission, duration of infection, etc. Note that the compartmental version runs 20 times faster than the agent-based version. Does this mean that compartmental models are better than agent-based models? If all you want to simulate is a simple SIS model, then … the answer is probably yes!",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html#epiverse-epidemics-school-closure-model",
    "href": "user_guide/advanced_nonstandard.html#epiverse-epidemics-school-closure-model",
    "title": "Nonstandard usage",
    "section": "Epiverse Epidemics: School closure model",
    "text": "Epiverse Epidemics: School closure model\nThis example adapts the example from the Epidemics v0.4.0 R package:\nhttps://epiverse-trace.github.io/epidemics/\nNote that it does not use the same level of detail as the original in terms of the population or contact matrices, but produces similar results.\n\nimport numpy as np\nimport pandas as pd\nimport sciris as sc\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Intervention\nclass close_schools(ss.Intervention):\n    \"\"\" Approximate closing schools by reducing susceptibility and transmissibility of children \"\"\"\n    def __init__(self, start=50, stop=80, reduction=0.5):\n        super().__init__()\n        self.start = start\n        self.stop = stop\n        self.reduction = reduction\n        return\n\n    def step(self):\n        disease = self.sim.diseases[0]\n        children = self.sim.people.age &lt; 20\n        if self.now == self.start:\n            disease.rel_sus[children] *= 1-self.reduction\n            disease.rel_trans[children] *= 1-self.reduction\n        elif self.now == self.stop:\n            disease.rel_sus[children] = 1.0\n            disease.rel_trans[children] = 1.0\n        return\n\n# Analyzer\nclass infections_by_age(ss.Analyzer):\n    \"\"\" Count infections by age \"\"\"\n    def __init__(self, age_bins=(0, 20, 40, 100)):\n        super().__init__()\n        self.age_bins = age_bins\n        self.mins = age_bins[:-1]\n        self.maxes = age_bins[1:]\n        self.hist = {k:[] for k in self.mins}\n        return\n\n    def init_pre(self, sim):\n        super().init_pre(sim)\n        self.infections = np.zeros(len(self.sim.people.age))\n        return\n\n    def step(self):\n        age = self.sim.people.age\n        disease = self.sim.diseases[0]\n        for min, max in zip(self.mins, self.maxes):\n            mask = (age &gt;= min) & (age &lt; max)\n            self.hist[min].append(disease.infected[mask].sum())\n        return\n\n    def plot(self):\n        plt.figure()\n        x = self.sim.t.tvec\n        for min, max in zip(self.mins, self.maxes):\n            plt.plot(x, self.hist[min], label=f'Age {min}-{max}')\n        intv = self.sim.interventions[0]\n        for day in [intv.start, intv.stop]:\n            plt.axvline(day, linestyle=':')\n        plt.legend(frameon=False)\n        plt.xlabel('Model time (days)')\n        plt.ylabel('Individuals infected')\n        plt.ylim(bottom=0)\n        sc.boxoff()\n        plt.show()\n        return\n\n# Run the model\nsim = ss.Sim(\n    people = ss.People(n_agents=20e3, age_data=pd.read_csv('test_data/nigeria_age.csv')),\n    diseases = dict(\n        type = 'sir',\n        init_prev = 0.001,\n        beta = ss.perday(1/100),\n        dur_inf = ss.days(20.0),\n    ),\n    networks = 'random',\n    interventions = close_schools(),\n    analyzers = infections_by_age(),\n    start = ss.days(0),\n    dur = ss.days(300),\n    dt = ss.days(1.0),\n    verbose = False,\n)\n\nsim.run()\nsim.analyzers.infections_by_age.plot()\n\n\n\n\n\n\n\n\nWhile the Starsim version is longer than the Epidemics version, note that Epidemics has built-in contacts interventions and automatically reports infections by age. These have to be manually added to Starsim, but in turn Starsim provides much more control.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide/advanced_nonstandard.html#mesa-wealth-model",
    "href": "user_guide/advanced_nonstandard.html#mesa-wealth-model",
    "title": "Nonstandard usage",
    "section": "Mesa: Wealth model",
    "text": "Mesa: Wealth model\nThis example illustrates a simple “weath model”, in which each agent starts with a single unit of wealth, and on each timestep, every agent with more than zero wealth gives one unit of wealth to another agent.\nThis tutorial is adapted from the following example:\nhttps://mesa.readthedocs.io/en/stable/tutorials/intro_tutorial.html\n\nSetting up the model\nWe could define the wealth model as any type of module, since they all can store states and update them. Here we will define wealth as a subclass of ss.Intervention (though it could equally well be a subclass of ss.Demographics or even ss.Disease, if you are so inclined). All we need to do is update the wealth state (which we can store inside the “intervention”), and we can also use this class to track the wealth distribution over time and plot it. The full model looks like this:\n\n\"\"\"\nDefine the classic agent-based \"wealth model\" in Starsim\n\"\"\"\n\n# Imports\nimport numpy as np\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Define the model\nclass WealthModel(ss.Module):\n    \"\"\" A simple wealth transfer model\"\"\"\n    \n    def init_post(self, bins=10):\n        \"\"\" Define custom model attributes \"\"\"\n        super().init_post()\n        self.npts = len(self.sim) # Number of timepoints\n        self.n_agents = len(sim.people) # Number of agents\n        self.wealth = np.ones(self.n_agents) # Initial wealth of each agent\n        self.bins = np.arange(bins+1) # Bins used for plotting\n        self.wealth_dist = np.zeros((self.npts, len(self.bins)-1)) # Wealth distribution over time\n        return\n        \n    def step(self):\n        \"\"\" Transfer wealth between agents -- core model logic \"\"\"\n        self.wealth_hist() # Store the wealth at this time point\n        givers = self.wealth &gt; 0 # People need wealth to be givers\n        receivers = np.random.choice(self.sim.people.uid, size=givers.sum()) # Anyone can be a receiver\n        self.wealth[givers] -= 1 # Givers are unique, so can use vectorized version\n        for receive in receivers: # Vectorized version is: np.add.at(sim.people.wealth.raw, receivers, 1)\n            self.wealth[receive] += 1\n        return\n    \n    def wealth_hist(self):\n        \"\"\" Calculate the wealth histogram \"\"\"\n        ti = self.sim.ti # Current timestep\n        self.wealth_dist[ti,:], _ = np.histogram(self.wealth, bins=self.bins)\n        return\n    \n    def plot(self):\n        \"\"\" Plot a 2D histogram of the final wealth distribution \"\"\"\n        plt.figure()\n        plt.bar(self.bins[:-1], self.wealth_dist[-1,:])\n        plt.title('Wealth distribution at final time point')\n        plt.xlabel('Wealth')\n        plt.ylabel('Number of agents')\n        plt.show()\n        return\n    \n    def plot3d(self):\n        \"\"\" Plot a 3D heatmap of the wealth distribution over time \"\"\"\n        plt.figure()\n        plt.pcolor(self.wealth_dist.T, cmap='turbo')\n        plt.title('Wealth distribution over time')\n        plt.xlabel('Time')\n        plt.ylabel('Wealth')\n        plt.colorbar().set_label('Number of agents', rotation=270)\n        plt.show()\n        return\n\n# Create sim inputs, including the wealth model\nwealth = WealthModel()\npars = dict(\n    n_agents = 100, # Number of agents\n    start = 0,\n    stop = 100,\n    demographics = wealth,\n)\n\n# Run the model\nsim = ss.Sim(pars, copy_inputs=False) # copy_inputs=False lets us reuse the \"wealth\" object from above\nsim.run()\n\n# Plot the results\nwealth.plot()\nwealth.plot3d()\n\nInitializing sim with 100 agents\n  Running 0.0 ( 0/101) (0.00 s)  ———————————————————— 1%\n  Running 10.0 (10/101) (0.00 s)  ••—————————————————— 11%\n  Running 20.0 (20/101) (0.00 s)  ••••———————————————— 21%\n  Running 30.0 (30/101) (0.00 s)  ••••••—————————————— 31%\n  Running 40.0 (40/101) (0.01 s)  ••••••••———————————— 41%\n  Running 50.0 (50/101) (0.01 s)  ••••••••••—————————— 50%\n  Running 60.0 (60/101) (0.01 s)  ••••••••••••———————— 60%\n  Running 70.0 (70/101) (0.01 s)  ••••••••••••••—————— 70%\n  Running 80.0 (80/101) (0.01 s)  ••••••••••••••••———— 80%\n  Running 90.0 (90/101) (0.01 s)  ••••••••••••••••••—— 90%\n  Running 100.0 (100/101) (0.01 s)  •••••••••••••••••••• 100%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparison with Mesa\nWhile the implementation in Starsim is similar to Mesa, there are a couple key differences:\n\nBecause Starsim’s people object is vectorized, the wealth definition and update is vectorized as well.\nBoth Mesa and Starsim versions of the model are quite simple, but there is a little less boilerplate in the Starsim version.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Nonstandard usage"
    ]
  },
  {
    "objectID": "user_guide.html",
    "href": "user_guide.html",
    "title": "User guide",
    "section": "",
    "text": "These user guides provide a more in-depth look at each topic compared to the corresponding tutorials.\n\n\n\n\n\n\nNote\n\n\n\nYou can download these tutorials as Jupyter notebooks to run them locally. Look for the download button at the top of each tutorial.\n\n\n\n\n\n\n\n\nRunning tutorials locally\n\n\n\nTo run these tutorials locally:\n\nClone the Starsim repository\nInstall Starsim and its dependencies\nNavigate to the docs/user_guide folder\nLaunch Jupyter: jupyter lab\n\n\n\n\n\n\nIntroduction to Starsim\nStarsim models\n\n\n\n\n\nUnderstanding the model\nThe Sim object\nParameter configuration\n\n\n\n\n\nDiseases\nNetworks\nDemographics\nInterventions\nAnalyzers\nConnectors\n\n\n\n\n\nRunning simulations\nSIR Calibration\nCalibration\nDeployment\nWorking with samples\n\n\n\n\n\nTime handling\nIndexing and arrays\nProbability distributions\nRandom number generation\nProfiling and optimization\nNonstandard usage"
  },
  {
    "objectID": "user_guide.html#introduction",
    "href": "user_guide.html#introduction",
    "title": "User guide",
    "section": "",
    "text": "Introduction to Starsim\nStarsim models"
  },
  {
    "objectID": "user_guide.html#basics",
    "href": "user_guide.html#basics",
    "title": "User guide",
    "section": "",
    "text": "Understanding the model\nThe Sim object\nParameter configuration"
  },
  {
    "objectID": "user_guide.html#modules",
    "href": "user_guide.html#modules",
    "title": "User guide",
    "section": "",
    "text": "Diseases\nNetworks\nDemographics\nInterventions\nAnalyzers\nConnectors"
  },
  {
    "objectID": "user_guide.html#workflows",
    "href": "user_guide.html#workflows",
    "title": "User guide",
    "section": "",
    "text": "Running simulations\nSIR Calibration\nCalibration\nDeployment\nWorking with samples"
  },
  {
    "objectID": "user_guide.html#advanced-topics",
    "href": "user_guide.html#advanced-topics",
    "title": "User guide",
    "section": "",
    "text": "Time handling\nIndexing and arrays\nProbability distributions\nRandom number generation\nProfiling and optimization\nNonstandard usage"
  },
  {
    "objectID": "whatsnew.html",
    "href": "whatsnew.html",
    "title": "What’s new",
    "section": "",
    "text": "All notable changes to the codebase are documented in this file. Changes that may result in differences in model output, or are required in order to run an old parameter set with the current version, are flagged with the terms “Migration” or “Regression”.\n\n\n\nTBC\n\n\n\n\n\nRegression information: See docs/migration/v3.0_v3.1.md for a detailed, LLM-friendly migration guide.\nAdded new functionality to the Pregnancy module:\n\nRenamed make_p_fertility() -&gt; make_p_conceive()\nAdded variable durations of pregnancies and tracking of pre-term birth outcomes\nAdded variable breastfeeding durations\nRefactored the logic of how pregnancies and births are handled with new helper methods for better extensibility\nAdded results on age-specific fertility rates and total fertility rates\n\nPreviously People.(module_name).(state_name) could be used to access module states (e.g., people.sir.infected). However, this mechanism fails to pass on property attributes that are dynamically computed (e.g., SIR.infectious). Now People.(module_name) simply contains a reference to the module, so all attributes can be accessed.\nAdd support for operating on ss.BaseArr with time parameters (e.g., multiplying a state by a duration)\nAdd support for creating an ss.dur from an ss.BaseArr\nChanged date plotting to convert ss.date and ss.DateArray values to years internally. This facilitates adding extra data to plots when the data is in years.\nAdded ss.parse_age_range utility function to standardize formats for age ranges in data/input files.\nImplemented __bool__ for ss.bernoulli which returns False if there is no possibility of returning any True values.\nAdded automatic result creation for ss.BoolState instances in People, matching the behavior already present in modules. People now has auto_state_list property and init_results() method.\nImplemented operators for ss.BoolArr and ss.uids where the latter is treated as a BoolArr. This makes operations like people.sir.infected & people.female and people.sir.infected & people.female.uids equivalent.\nImplemented in-place operators for ss.BoolArr and ss.uids. The former are true in-place operations that reuse existing memory and preserve references, and thus they can be safely used with BoolState instances in modules directly.\nFixed/added operators + and - for ss.DateArray when operating on ss.date and ss.dur instances\nFixed bug when multiplying an ss.prob by an array of durations\nRenamed arguments to MaternalNet.add_pairs() from mother_inds to mother_uids and unborn_inds to unborn_uids to clarify that these inputs should be agent UIDs.\nRemoved dur argument to MaternalNet.add_pairs() as the edge lifespan is now managed by the Pregnancy module with edges being removed upon delivery.\nRemoved Network.prenatal and Network.postnatal attributes as these are now tracked by type (ss.PrenatalNet and ss.PostnatalNet)\nGitHub info: PR 1065\n\n\n\n\n\nFixed bug in sim.loop.plot_cpu() when using pandas v3\n\n\n\n\n\nFixed bugs with products being added/stepped multiple times.\nFixed bug that prevented Result.resample(output_form='series') from being used.\n\n\n\n\n\nAdded additional calibration examples for workflows to re-identify known parameters.\nRemoved p_death from the parameters for the ss.Deaths module, as Deaths.make_p_death() always overrides this value and is therefore the means by which the death probability should be set or changed.\nGitHub info: PR 1055\n\n\n\n\n\nSwapped order of age and female states in People to allow female dist to use age state during population initialization.\n\n\n\n\n\nAdditional minor updates following the v3 release.\nCleans up some of the logic for converting rates to probabilities in the demographic modules\nAdds a request_removal method to People, which can be used to remove people from the population for reasons other than death (e.g. migration)\nFixes a bug that prevented ss.prob from accepting arrays\nAdds a year property to Timelines, so sim.t.now('year') can be rewritten as sim.t.year\nGitHub info: PR 1032\n\n\n\n\n\nMinor updates following the v3 release.\nThe logic for initializing ss.Timeline has been changed. Now, start and stop will not be converted to dates unless at least one argument is a date (e.g. start=ss.years(2000) will remain ss.years()). ss.Timeline is also now much more robust about handling different types of input, and choosing sensible defaults for missing inputs (e.g. with stop=ss.days(20), the new default is start=ss.days(0)).\nSubtracting dates now yields a relativedelta, e.g. ss.date(2025) - ss.date(2015) now gives ss.datedur(years=10) (previously it converted to days).\nss.DateArray now has a unit attribute, allowing more reliable conversion to years.\nTimepars now have a disp() method.\nGitHub info: PR 1029\n\n\n\n\n\n\nStarsim v3 includes a reimplementation of how time is handled, an extensive new suite of debugging tools, and smaller changes, including an extensive user guide in addition to the tutorials. Please also see docs/migration_v2v3 for a detailed (and LLM-friendly) migration guide for porting existing Starsim code over to the new version. If a point below says “See the migration guide”, that indicates that additional information (and a conversion script where possible) is provided in that guide. Otherwise, it is (generally) a non-breaking change.\n\n\n\nTime is now based on precise datetime stamps (specifically, pd.Timestamp). In Starsim v3.0, the supported time units are days, weeks, months, and years. Days or years are always handled exactly and weeks and months are defined in terms of them, i.e. a week is exactly 7 days and a month is exactly 1/12th of a year. The following changes have been made to the API:\n\nWhile durations work similarly as in Starsim v2, rates work differently. The base class, ss.Rate, cannot be used directly. Instead, you must use one of the three derived classes. ss.freq() is the closest to ss.rate() in Starsim v2, and is a simple inverse of ss.dur(). ss.per() is the equivalent of ss.rate_prob() in Starsim v2, but is the primary probability-based rate that should be used (e.g. for beta, birth rates, death rates, etc.). Finally, ss.prob() is the equivalent to ss.time_prob() in Starsim v2, but whereas time_prob was preferred in v2, per (equivalent to rate_prob in v2) is preferred in v3.\nIn addition to these base classes, each of them is available for each time unit. For durations, singletons are available (ss.day), as well as e.g. ss.days(), ss.years() etc. For rates, ss.peryear() is derived from ss.per, while ss.probperyear() is the equivalent for ss.prob and ss.freqperyear() is the equivalent for ss.freq. ss.prob can also be unitless (ss.per and ss.freq cannot be).\nss.beta() has been removed; use ss.prob() instead for a literal equivalent, although in most cases ss.per() is preferable, e.g. ss.peryear().\nss.rate() has been removed; use ss.freq() instead for a literal equivalent, although in most cases ss.per() is preferable, e.g. ss.peryear().\nunit has been removed as an argument; use dt instead, e.g. ss.Sim(dt=1, unit='years') is now ss.Sim(dt=ss.year) (or ss.Sim(dt='years') or ss.Sim(dt=ss.years(1))).\nAlthough ss.dur() still exists in Starsim v3.0, it is preferable to use named classes instead, e.g. ss.years(3) instead of ss.dur(3, 'years').\nss.Time() is now called ss.Timeline() and its internal calculations are handled differently.\nss.time_ratio() has been removed; time unit ratio calculations (e.g. months to years) are now handled internally by timepars.\nt.abstvec has been removed; in most cases, t.tvec should be used instead (although t.yearvec, t.datevec, or t.timevec may be preferable in some cases).\nMultiplication by dt no longer happens automatically; call to_prob() to convert from a timepar to a unitless probability (or to_events() to convert to a number of events instead).\n\nFor full details, see the migration guide.\n\n\n\n\nDistributions now have a scale_type attribute, which determines how they scale with time: some distributions, like ss.normal(), can be scaled either before or after random numbers are drawn; others, like ss.poisson(), can only be scaled before. See ss.scale_types for details.\nDistributions that can be scaled post-draw now take an unit argument, e.g. ss.normal(mean=5, std=2, unit=ss.years(1)). This is equivalent to ss.years(ss.normal(mean=5, std=2)) or ss.normal(mean=ss.years(5), std=ss.years(2)). Note that not all distributions can be scaled this way (you will get an error if you try to scale a non-scalable distribution.)\nDistributions now have a random-number-safe randround() method\nThere are two new distributions, ss.beta_dist() and ss.beta_mean() (not called ss.beta() to distinguish from the beta transmissibility parameter).\n\n\n\n\n\nSims now take an optional modules argument. These are run first, before anything else in the integration loop. If you want, you can supply everything directly as a module, e.g. ss.Sim(modules=[ss.Births(), ss.RandomNet(), ss.SIR()]) is equivalent to ss.Sim(demographics=ss.Births(), networks=ss.RandomNet(), diseases=ss.SIR()). You can also add your own custom modules, not based on an existing Starsim module type, and specify the order they are called in.\nsim.modules has been renamed sim.module_list.\nss.People has a new filter() method, which lets you chain operations, e.g.: ppl = sim.people; f = ppl.filter(ppl.female & (ppl.age&gt;5) & ~ppl.sir.infected)\nss.People has new methods plot() (all variables) and plot_ages() (age pyramid by sex).\n\n\n\n\n\n\n\nModule methods have a new decorator, @ss.required(), which flag that it is an error for the method not to be called. This is used to prevent the user from accidentally forgetting to call super().method().\nModules can now be used like dictionaries for accessing user-defined states, e.g. module['my_custom_state'] is an alias for module.my_custom_state.\nmodule.states has been renamed module.state_list. module.statesdict has been renamed module.state_dict. There is also a module.auto_state_list property, referring specifically to ss.BoolState attributes.\nBuilt-in modules now have function signatures that look like this example for ss.Births(): def __init__(self, pars=None, rel_death=_, death_rate=_, rate_units=_, **kwargs):. Although _ is simply None, this notation is short-hand for indicating that (a) the named arguments are the available parameters for the module, (b) their actual values are set by the define_pars() method.\nModules now have a much briefer __repr__, typically one line. The full module information can still be obtained via module.disp().\n\n\n\n\n\nkey_dict has been removed from ss.Network(); modify the network.meta dictionary directly instead, e.g. ss.DynamicNetwork has self.meta.dur = ss_float in its __init__() method, while ss.SexualNetwork has self.meta.acts = ss_int.\nss.Network() now has plot() and to_edgelist() methods.\nss.RandomNet() now only adds “missing” edges, fixing a bug in which the longer the edge duration, the more edges the network had.\nThere is a new network, ss.RandomSafe(), whch is similar to ss.Random() but random-number safe (at the cost of being slightly slower).\nFor ss.MixingPool, the argument contacts has been renamed n_contacts.\n\n\n\n\n\nThere is a new built-in analyzer ss.dynamics_by_age().\nThere is a new built-in connector ss.seasonality().\nss.Births() is now random-number safe.\nss.Deaths() now has a default rate of 10 per 1000 people per year (instead of 20). Births is still 20. This means that with demographics=True, the population grows at roughly the correct global average rate.\nss.sir_vaccine() has been renamed ss.simple_vx().\n\n\n\n\n\nStarsim v3 comes with a new set of tools for debugging (in debugtools.py): both understanding simulations and what is happening at different points in time, and understanding and profiling code performance to find possible improvements to efficiency. These include: - sim.profile(): profiles a run of a sim, showing module by module (and optionally line by line) where most of the time is being spent. See ss.Profile() for details. - ss.Debugger(): steps through one or more simulations, and raises an exception when a particular condition is met (e.g., if the results from two sims start to diverge). - ss.check_requires(): use this function to check if a sim contains a required module (e.g., an HIV-syphilis connector would require both HIV and syphilis modules to be present in the sim). - ss.check_version(): for checking which version of Starsim is installed.\n\n\n\nss.Loop now has an insert() method that lets you manually insert functions at an arbitrary point in the simulation loop.\nss.Loop now has a plot_step_order() method that lets you validate that the steps are being called in the expected order.\n\n\n\n\n\nIn the tests folder, there is a benchmark_tests.py script for benchmarking the performance of the tests. Each test is also now timed (via the @sc.timer decorator).\nThere are also various profiling scripts, e.g. profile_sim.py.\nBaseline and performance benchmark files have been converted from JSON to YAML.\n\n\n\n\nStarsim components are intended to work together as part of an ss.Sim object, which handles initialization and coordination across modules, distributions, time parameters, etc. But sometimes, it’s useful to build a very simple example to test a component in isolation. Starsim v3 comes with “mock” components, which allow you to work with e.g. a module without incorporating it into a full sim. These have the essential structure of the real thing (e.g., sim.t.dt), but without the complexity of the full object. These mock objects are:\n\nss.mock_sim(): generates a mock sim; useful for testing modules\nss.mock_module(): generates a mock module; useful for testing distributions\nss.mock_people(): generates a mock ss.People object; used by ss.mock_sim()\nss.mock_time(): generates a mock ss.Timeline object; used by ss.mock_sim() and ss.mock_module()\n\nDistributions now have a mock() method, that allows you to immediately start using them to generate random numbers, e.g. ss.normal(5,2).mock().rvs(10).\n\n\n\n\n\n\n\nAll diseases except for SIR, SIS, and NCD have been moved to a separate starsim_examples folder. This is installed together with Starsim, but must be imported separately, e.g. import starsim_examples as sse; hiv = sse.HIV() instead of import starsim as ss; hiv = ss.HIV(). See the migration guide for details.\nss.register_modules() lets you register external modules as Starsim modules, to allow calling by string; e.g. ss.register_modules(sse) (from above) will let you do ss.Sim(diseases='hiv'), since sse.HIV is registered as a known Starsim module.\nFiles have been reorganized:\n\nanalyzers.py and connectors.py have been created (split out from modules.py);\ncalibration.py and calib_components.py have been combined into calibration.py;\ndisease.py has been renamed diseases.py and diseases/sir.py and diseases/ncd.py have been incorporated into it;\ntimeline.py has been split out from time.py.\n\n\n\n\n\n\nPlotting defaults have been updated; you can use these defaults via with ``ss.style().\nResult plotting has been improved, in terms of module labels and correct x-axis labels.\nss.MultiSim() plotting has been improved to display legends correctly.\nPlotting arguments are now handled by ss.plot_args(), which will parse different arguments among figure, plot, scatter, and other functions, e.g. ss.plot_args(dpi=150, linewidth=3) will set the figure DPI and the plot line width.\nSim results are now automatically skipped during plotting if they were never updated (e.g., n_deaths if there were no deaths).\n\n\n\n\n\nArray indexing has been reimplemented, using Numba instead of NumPy for large operations; this should be about 30% faster. An unnecessary array copy operation was also removed, for a further ~50% efficiency gain. (Note that although array indexing is now much faster, it was not typically the slowest step, so “real world” performance gains are closer to 10-20%.)\nThere is a new class, ss.IntArr, although in most cases ss.FloatArr is still preferred due to better handling of NaNs.\nss.State has been renamed to ss.BoolState. See the migration guide for details.\nss.options._centralized has been renamed ss.options.single_rng. Although there is a very small performance benefit, use of this option is not recommended.\nss.set_seed() has been removed; the seed should be set automatically by the distributions. If you want to set the seed for a custom (not random-number-safe) non-distribution random number, call np.random.seed() manually.\nDistributions and modules now define their own shrink() methods (for saving small files). Note that if you define a custom module that stores a lot of data, you may want to define your own shrink() method to remove this data.\nss.Result() objects now have disp() and to_str() methods, and they can also be treated as dicts (e.g. res['low'] instead of res.low).\nYou can now create an ss.MultiSim comprised of sims of different lengths; however, the sims will be truncated to be of the same length, and they are not temporally aligned. In general, it is still inadvisable to use msim.reduce() with sims of different lengths.\n\n\n\n\nStarsim v3 comes with several new options, set via ss.options:\n\nss.options.check_method_calls: whether to check that required module methods are called (default True)\nss.options.install_fonts: whether to install custom fonts for plotting (default True)\nss.options.numba_indexing: threshold at which to switch from NumPy to Numba indexing (default 5000 indices)\nss.options.style: plotting style to use; options are “starsim”, “fancy”, “simple”, or any Matplotlib style\nss.options.warn_convert: whether to warn when automatically converting time parameters\n\nss.options also now has a help method that will print detailed help on a given option or all options, e.g. ss.options.help(detailed=True).\n\n\n\n\nAn agentic LLM such as Cursor or Claude Code should be able to perform most of the migrations from v2 to v3 automatically. Tell it to read llms.txt, then docs/migration/v2_v3/README.md. However, there will still be a few things to manually double check, especially around time conversions (such as whether you want ss.beta() ported literally to ss.probperyear(), or “upgraded” to ss.peryear()).\nGitHub info: PR 1008\n\n\n\n\n\n\n\nFix argument passing in Infection.infect. This will be the final Starsim v2.x release.\nGitHub info: PR 1008\n\n\n\n\n\nUpdated ss.Sim.shrink() to remove additional objects, resulting in a smaller sim size.\nss.Calibration.save_csv() has been replaced by ss.Calibration.to_df() (to save to a CSV, use ss.Calibration.to_df().to_csv().\nss.Result.shape has been renamed ss.Result._shape, so ss.Result.shape now correctly returns the actual size of the array.\nResults by default convert all result keys to lowercase; use keep_case=True to turn off this behavior.\nFixed a bug with an ss.date object converting to a pd.Timestamp upon copy.\nGitHub info: PR 865\n\n\n\n\n\nThe calibration class has been completely redesigned. Calibration now relies on “components”, which capture mismatch with a particular data type (e.g., new infections). The new approach also adds additional statistical rigor for calculating mismatches.\nss.MixingPool has been updated to be more modular, and behave more like ss.Network; in particular, compute_transmission() rather than step() is called to determine new infections.\nss.Result now has a summarize_by argument, which determines how a result should be summarized as a scalar (e.g., mean for a prevalence, sum for a count, last entry for a cumulative count).\nFixed a bug with time parameters incorrectly pulling the parent unit from the Sim, rather than the parent module.\nGitHub info: PR 831\n\n\n\n\n\nStarsim is now available for R! See https://r.starsim.org for details.\nThe Calibration class has been completely rewritten. See the calibration tutorial for more information.\nA negative binomial distribution is now available as ss.nbinom().\nss.Births() now uses a binomial draw of births per timestep, rather than the expected value.\nAdded ss.load() and ss.save() functions, and removed ss.Sim.load().\nGitHub info: PR 778\n\n\n\n\n\nAdds improved Jupyter support for plotting (to prevent plots from appearing twice); you can disable this by setting ss.options.set(jupyter=False).\nAdds auto_plot to Result objects, to indicate if it should appear in sim.plot() by default.\nAdds copy() to the Sim and modules.\nNetworks now store their length on each timestep as a result.\nImproves sim.shrink(), with typical size reductions of &gt;99%.\nAdds additional plotting options show_module (include the module name in the plot title), show_label (use the simulation label as the figure title), and show_skipped (shows results even if auto_plot=False).\nGitHub info: PR 745\n\n\n\n\n\n\n\nTime in simulations is now handled by an ss.Time() class, which unifies how time is represented between the Sim and each module.\nIn addition to networks, there is now a new way of implementing disease transmission via mixing pools.\n\n\n\n\n\nTime handling now performed by the ss.Time() class. This has inputs similar to before (start, stop, unit, dt, with dur still available as a sim input). However, instead of the previous timevec and abs_tvec arrays, there are now multiple ways of representing time (including datevec and yearvec), regardless of what the inputs were.\nDates are now represented in a native format, ss.date, that is based on pd.Timestamp.\n\n\n\n\n\nAdds a new approach to disease transmission called mixing pools. A mixing pool is a “mean field” coupling wherein susceptible agents are exposed to the average infectious agent. The user can create a single mixing pool using the ss.MixingPool class, or create many pools using MixingPools. Such mixing pools could be used to simulate contact matrices, for example as published by Prem et al.\nThere is a new ss.Route class, which is the base class for ss.Network and ss.MixingPool.\n\n\n\n\n\nDemographic modules have been updated to fix various bugs around different time units.\nThe method for hashing distribution trace strings into seeds has changed, meaning that results will be stochastically different compared to Starsim v2.0.\nFixed a bug with how timepars were updated in parameters.\nThere is a new ss.Base class, which both ss.Sim and ss.Module inherit from.\nResults now print as a single line rather than the full array. The latter is available as result.disp().\nsim.to_df() now works even if different modules have different numbers of timepoints.\nThe timepars module has been renamed to time.\nIn demographics modules, units has been renamed rate_units.\nThere are two new options, ss.options.date_sep and ss.options.license. The former sets the date separator (default ., e.g. 2024.04.0.4), and the latter sets if the license prints when Starsim is imported.\nGitHub info: PR 724\n\n\n\n\n\n\n\nVersion 2.0 contains several major changes. These include: module-specific timesteps and time-aware parameters (including a day/year unit flag for modules, and ss.dur() and ss.rate() classes for parameters), and changes to module types and integration (e.g. renaming update() and apply() methods to step();).\n\n\n\n\nAdded ss.dur(), ss.rate(), and ss.time_prob() classes, for automatic handling of time units in simulations. There are also convenience classes ss.days(), ss.years(), ss.perday(), ss.peryear(), and ss.beta() for special cases of these.\nss.dur() and ss.rate(), along with modules and the sim itself, have a unit parameter which can be 'day', 'week', 'month', or 'year' (default). Modules now also have their own timestep dt. Different units and timesteps can be mixed and matched. Time parameters have a to() method, e.g. ss.dur(1, 'year').to('day') will return ss.dur(365, unit='day').\nThe ss.Sim parameter n_years has been renamed dur; sim.yearvec is now sim.timevec, which can have units of days (usually starting at 0), dates (e.g. '2020-01-01'), or years (e.g. 2020). sim.abs_tvec is the translation of sim.timevec as a numeric array starting at 0, using the sim’s units (usually 'day' or 'year'). For example, if sim.timevec is a list of daily dates from '2022-01-01' to '2022-12-31', sim.abs_tvec will be np.arange(365).\nEach module also has its own mod.timevec; this can be different from the sim if it defines its own time unit and/or timestep. mod.abs_tvec always starts at 0 and always uses the sim’s unit.\nThere is a new Loop class which handles the integration loop. You can view the integration plan via sim.loop.to_df() or sim.loop.plot(). You can see how long each part of the sim took with sim.loop.plot_cpu().\nThere are more advanced debugging tools. You can run a single sim timestep with sim.run_one_step() (which in turn calls multiple functions), and you can run a single function from the integration loop with sim.loop.run_one_step().\n\n\n\n\n\nFunctionality has been moved from ss.Plugin to ss.Module, and the former has been removed.\nss.Connector functionality has been moved to ss.Module. ss.Module objects can be placed anywhere in the list of modules (e.g., in demographics, networks, diseases, interventions), depending on when you want them to execute. However, ss.Connector objects are applied after Disease.step_state() and before Network.step().\nMany of the module methods have been renamed; in particular, all modules now have a step() method, which replaces update() (for demographics and networks), apply() (for interventions and analyzers), and make_new_cases() (for diseases). For both the sim and modules, initialize() has been renamed init().\nAll modules are treated the same in the integration loop, except for diseases, which have step_state() and step_die() methods.\nThe Starsim module states.py has been moved to arrays.py, and network.py has been moved to networks.py.\n\n\n\n\n\nss.Arr, ss.TimePar, and ss.Result all inherit from the new class ss.BaseArr, which provides functionality similar to a NumPy array, except all values are stored in arr.values (like a pd.Series).\nWhereas before, computations on an ss.Arr usually returned a NumPy array, calculations now usually return the same type. To access the NumPy array, use arr.values.\nThere is a new ss.State class, which is a subtype of ss.BoolArr. Typically, ss.State is used for boolean disease states, such as infected, susceptible, etc., where you want to automatically generate results (e.g. n_infected). You can continue using ss.BoolArr for other agent attributes that you don’t necessarily want to automatically generate results for, e.g. ever_vaccinated.\n\n\n\n\n\nResults are now defined differently. They should be defined in ss.Module.init_results(), not ss.Module.init_pre(). They now take the module name, number of points, and time vector from the parent module. As a result, they are usually initialized via ss.Module.define_results(res1, res2) (as opposed to mod.results += [res1, res2] previously). define_results() automatically adds these properties from the parent module; they can still be defined explicitly if needed however.\nBecause results now store their own time information, they can be plotted in a self-contained way. Both ss.Result and ss.Results objects now have plot() and to_df() methods.\n\n\n\n\n\nFixed a bug in how results were defined for ss.Births and ss.Deaths.\nThe ss.Pregnancy module has been significantly rewritten, including: (1) Agents now have a parent which indicates the UID of the parent; (2) Women now track child_uid; (3) On neonatal death, the pregnancy state of the mother is corrected; (4) Pregnancy rates now adjusted for infecund rather than pregnant; (4) Pregnancy now has a burn-in, which defaults to True; (5) Pregnancy has a p_neonatal_death parameter to capture fetal and neonatal death if the mother dies.\nSlots now has a minimum, default of 100, to account for small initial population sizes that grow dramatically over time.\n\n\n\n\n\nThere have been several performance improvements. The default float type is now np.float32. Transmission is now handled by a specialized Infection.compute_transmission() method. Several additional functions now use Numba, including fastmath=True, which leverages Intel’s short vector math library.\nA new ss.multi_random() distribution class has been added, that allows random numbers to be generated by two (or more) agents. It largely replaces ss.combine_rands() and is 5-10x faster.\nA new ss.gamma() distribution has also been added.\nDistributions have a new jump_dt method that jumps by much more than a single state update.\nss.parallel() and ss.MultiSim.run() now modify simulations in place by default. Instead of sims = ss.parallel(sim1, sim2).sims; sims[0].plot(), you can now simply do ss.parallel(sim1, sim2); sim1.plot().\n\n\n\n\n\nData can now be supplied to a simulation; it will be automatically plotted by sim.plot().\nss.Calibration has been significantly reworked, and now includes more flexible parameter setting, plus plotting (calib.plot_sims() and calib.plot_trend()). It also has a debug argument (which runs in serial rather than paralell), which can be helpful for troubleshooting issues.\nMultiSim now has display methods brief() (minimal), show() (moderate), and disp (verbose).\nsim.export_df() has been renamed sim.to_df().\nMost classes now have to_json() methods (which can also export to a dict).\nFixed a bug in how the InfectionLog is added to disease modules.\nSim.gitinfo has been replaced with Sim.metadata (which includes git info).\nInfection.validate_beta() is now applied on every timestep, so changes to beta during the simulation are now honored.\nsim.get_intervention() and sim.get_analyzer() have been removed; use built-in ndict operations (e.g., the label) to find the object you’re after.\nrequires has been removed from modules, but ss.check_requires() is still available if needed. Call it manually from init_pre() if desired, e.g. a PMTCT intervention might call ss.check_requires(self.sim, ['hiv', 'maternalnet']).\nFor networks, contacts has been renamed edges except in cases where it refers to an agent’s contacts. For example, network.contacts has been renamed network.edges, but ss.find_contacts() remains the same.\nNetworks now have a to_graph() method that exports to NetworkX.\nss.diff_sims() can now handle MultiSim objects.\nSim._orig_pars has been removed.\nss.unique() has been removed.\n\n\n\n\n\nNote: the list here covers major changes only; in general, Starsim v1.0 scripts will not be compatible with Starsim v2.0.\nResults from Starsim v2.0 will be stochastically (but not statistically) different from Starsim v1.0.\nAll duration and rate parameters should now be wrapped with ss.dur() and ss.rate(). Events that represent probabilities over time (i.e. hazard rates) can also be wrapped with ss.time_prob(), although this is similar to ss.rate() unless the value is relatively large.\nss.Plugin has been removed. Use ss.Module instead.\ninit_results() is now called by init_pre(), and does not need to be called explicitly.\ndefault_pars() has been renamed define_pars().\nadd_states() has been renamed define_states()\ninitialize() has been renamed init().\nDemographics.update() has been renamed Demographics.step().\nNetwork.update() has been renamed Network.step().\nDisease.update_pre() has been renamed Disease.step_state().\nDisease.make_new_cases() has been renamed Disease.step().\nDisease.update_death() has been renamed Disease.step_die() (which is now called by People.step_die()).\nInfection._set_cases() has been renamed Infection.set_outcomes().\nIntervention.apply(sim) has been renamed Intervention.step(); ditto for Analyzer.\nModule.step() no longer takes sim as an argument (e.g., replace intervention.apply(sim) with intervention.step()).\nAll modules now have methods for start_step(), finish_step(), init_results(), and update_results().\nNetwork.contacts has been renamed Network.edges.\nsim.get_intervention() and sim.get_analyzer() have been removed; simply call directly instead (e.g. replace sim.get_intervention('vaccine') with sim.interventions['vaccine']).\nrequires is no longer an attribute of modules; call the ss.check_requires() function directly if needed.\nPeople.resolve_deaths() has been renamed People.check_deaths()\nss.unique() has been removed.\nGitHub info: PR 626\n\n\n\n\n\n\nFixes a bug in which some intervention parameters (e.g. eligibility) do not get set properly.\nGitHub info: PR 639\n\n\n\n\n\nFixes a bug in which random numbers drawn from auto-jumped distributions would overlap with random numbers drawn from subsequent timesteps.\nGitHub info: PR 639\n\n\n\n\n\nAdds a new distribution, ss.rand_raw(), that samples raw integers from the random number bit generator, for use with calculating transmission. This version is roughly 20-30% faster than the previous implementation.\nAdds interpolation to age-standardized fertility rate (ASFR) data.\nAdds flexibility to ART initiation.\nGitHub info: PR 593\n\n\n\n\n\nOfficial release of Starsim!\nAdds a Calibration class, based on Optuna, to facilitate the calibration of Starsim models.\nAdds mean(), median(), and plot() methods to MultiSim.\nAdds low and high attributes to Result objects.\nAdds a flatten() method to Results, allowing nested Results objects to be turned into flat dictionaries.\nRemoves duplicate UIDs among new infections, and adds a unique() method to ss.uids.\nFixes a bug that prevented ss.lognorm_im() from using callable parameters.\nUpdates the default Sim string representation to be a single line; the more verbose version is available via sim.disp().\nGitHub info: PR 581\n\n\n\n\n\nAdds two new common-random-number-safe networks. The first is an Erdős-Rényi network that is similar to RandomNet but parameterized differently. The second is a 2D spatial network with connectivity between agents within a given radius; these agents can also optionally move.\nGitHub info: PR 575\n\n\n\n\n\nAdded a ss.histogram() distribution, which allows generating new random values from an empirical histogram.\nWhen binned age data is provided to specify the initial ages for new agents, the ages are now distributed throughout the year/bin rather than new agents being assigned integer ages\nInitial age data is now accepted as a pd.Series rather than a pd.DataFrame where the index corresponds to the age values, thereby avoiding the need for specific dataframe column names to be used to specify the age and value\nGitHub info: PR 572\n\n\n\n\n\nRevert to making infection logging disabled by default. However, the infection log will now always be created so disease subclasses can override logging behaviour where required (e.g., to capture additional metadata)\nBackwards-compatibility notes: Logging has been moved from an argument to Disease to pars. Existing code such as Disease(log=True) should be changed to Disease(pars={'log':True}). The ‘log’ option can be added to the pars passed to any subclass e.g., ss.HIV(pars={...,log=True}).\nGitHub info: PR 573\n\n\n\n\n\nImplemented a new ss.combine_rands() function based on a bitwise-XOR, since the previous modulo-based approach could introduce correlations between pairs of agents.\nGitHub info: PR 546\n\n\n\n\n\nss.Infection.make_new_cases() now returns the index of the network associated with each transmission event\nIf a People object is provided to the Arr constructor, the arrays will be pre-initialized to index the current UIDs in the People object. This enables construction of temporary Arr instances that can be used to perform intermediate calculations (e.g., inside Intervention.apply() or within a module update step)\nDeprecated Arr(raw=...) argument to simplify initialization, as in practice the raw variable is not directly set, and this update also introduces a new pathway for initializating the raw attribute\nss.uids.to_numpy() now returns a view rather than a copy\nss.bernoulli.filter() now supports ss.BoolArr as an input, where the filtering will operate on the uids returned by ss.BoolArr.uids\nss.uids() supports construction from set objects (via np.fromiter())\nGitHub info: PR 565\n\n\n\n\n\nAdded labels to Result and state (Arr) objects.\nAdded Numba decorator to find_contacts to significantly increase performance.\nFixed bug when comparing uids and BoolArr objects.\nGitHub info: PR 562\n\n\n\n\n\nAdjusted RandomNet to avoid connections to unborn agents and use random rounding for half edges\nAdds get_analyzers and get_analyzer\nRefactor how data is pre-processed for births/pregnancy/death rates, giving about a 10% decrease in run time for the STIsim HIV model\nBoolArr.uids is automatically called when doing set operations on uids with a BoolArr\nGitHub info: PR 555\n\n\n\n\n\nss.uids class implements set operators to facilitate combining or otherwise operating on collections of UIDs\nFloatArr.isnan and FloatArr.notnan return BoolArr instances rather than UIDs (so as to facilitate logical operations with other BoolArr instances, and to align more closely with np.isnan)\nArr.true() and Arr.false() are supported for all Arr subclasses\nBoolArr.isnan and Boolarr.notnan are also implemented (although since BoolArr cannot store NaN values, these always return False and True, respectively)\nGitHub info: PR 544\n\n\n\n\n\nRenames network.contacts to network.edges.\nFor modules (including diseases, networks, etc.), renames initialize() to init_pre() and init_vals() to init_post().\nRenames ss.delta() to ss.constant().\nAllows Arr objects to be indexed by integer (which are assumed to be UIDs).\nFixes bug when using callable parameters with ss.lognorm_ex() and ss.lognorm_im().\nFixes bug when initializing ss.StaticNet().\nUpdates default birth rate from 0 to 30 (so demographics=True is meaningful).\nAdds min_age and max_age parameters to the Pregnancy module (with defaults 15 and 50 years).\nAdds an option for the sir_vaccine to be all-or-nothing instead of leaky.\nUpdates baseline test from HIV to SIR + SIS.\nFixes issue with infection log not being populated.\nGitHub info: PR 527\n\n\n\n\n\nSeparates maternal transmission into prenatal and postnatal modules.\nGitHub info: PR 509\n\n\n\n\n\n\nAll inputs to the sim and modules now use a ss.Pars() class, which handles updating and validation. It is now not necessary to ever use pars= (although you still can if you want), so what was previously:\nsim = ss.Sim(pars=dict(diseases='sir', networks='random'))\nis now just:\nsim = ss.Sim(diseases='sir', networks='random')\nUpdates happen recursively, so distributions etc. can be flexibly updated.\nThis has significantly changed how modules are initialized; what was previously:\ndef __init__(self, pars=None, **kwargs):\n\n    pars = ss.omergeleft(pars,\n        dur_inf = 6,\n        init_prev = 0.01,\n        p_death = 0.01,\n        beta = 0.5,\n    )\n\n    par_dists = ss.omergeleft(par_dists,\n        dur_inf = ss.lognorm_ex,\n        init_prev = ss.bernoulli,\n        p_death = ss.bernoulli,\n    )\n\n    super().__init__(pars=pars, par_dists=par_dists, *args, **kwargs)\nis now:\ndef __init__(self, pars=None, **kwargs):\n    super().__init__()\n    self.default_pars(\n        beta = 0.5,\n        init_prev = ss.bernoulli(0.01),\n        dur_inf = ss.lognorm_ex(6),\n        p_death = ss.bernoulli(0.01),\n    )\n    self.update_pars(pars, **kwargs)\n\n\n\n\nAdded a ss.Pars class (and a ss.SimPars subclass) that handles parameter creation, updates, and validation.\nInitialization has been moved from sim.py to parameters.py; ss.Sim.convert_plugins() has been replaced by ss.SimPars.convert_modules().\nThe key method is ss.Pars.update(), which performs all necessary validation on the parameters being updated.\n\n\n\n\n\nPreviously, the people were initialized first, then the states were initialized and the values populated, then the modules were initialized, and finally the distributions are initialized. This led to circular logic with the states being initialized based on uninitialized distributions. Now, states and modules are linked to the People and Sim objects, but further initialization is not done at this step. This ensures all distributions are created but not yet used. Next, distributions are initialized. Finally, the initial values are populated, and everything is initialized.\nNew methods supporting these changes include ss.link_dists(), dist.link_sim(), dist.link_module(), sim.init_vals(), people.init_vals(), module.init_vals(),\n\n\n\n\n\nWhereas modules previously initialized a dict of parameters and then called super().__init__(pars, **kwargs), they now call super().__init__() first, then self.default_pars(par1=x, par2=y), then finally self.update_pars(pars, **kwargs).\nWhat was previously e.g. ss.Module(pars=dict(par=x)) is now ss.Module(par=x).\npar_dists has been removed; instead, distributions are specified in the default parameters, and are updated via the Pars object.\nModules now contain a link back to the Sim object. This means that all methods that used to have sim as an argument now do not, e.g. self.update() instead of self.update(sim).\nss.module_map() maps different module types to their location in the sim.\nss.find_modules() finds all available modules (including subclasses) in Starsim.\nRemoved ss.dictmerge() and ss.dictmergeleft (now handled by ss.Pars.update()).\nRemoved ss.get_subclasses() and ss.all_subclasses() (now handled by ss.find_modules()).\nModules can no longer be initialized with a name key; it must be type (e.g. dict(type='sir') rather than dict(name='sir').\nAdded to_json() and plot() methods to Module.\nRemoved connectors.py; connectors still exist but as an empty subclass of Module.\n\n\n\n\n\nBasePeople has been removed and merged with People.\nTime parameters (ti, dt, etc.) have been removed from People. Use sim.ti, sim.dt etc. instead. One consequence of this is that people.request_death() now requires a sim argument. Another is that network methods (e.g. add_pairs()) now take sim arguments instead of people arguments.\nSexualNetwork is now a subclass of DynamicNetwork.\nRemoved ss.Networks (now just an ss.ndict).\nNetwork connectors have been removed.\nPerson has been implemented as a slice of sim.people[i].\nThere is a new parameter use_aging; this defaults to True if demographic modules are supplied, and False otherwise.\n\n\n\n\n\nBoolean arrays have new methods true(), false(), and split(), which return the UIDs for the True values (alias to arr.uids), False values, and both sets of values, respectively. ss.bernoulli.split() has been added as an alias of ss.bernoulli.filter(both=True).\nAll inputs to a sim are now copied by default. To disable, use ss.Sim(..., copy_inputs=False).\nThere is a new Plugin class, which contains shared logic for Interventions and Analyzers. It has a from_func(), which will generate an intervention/analyzer from a function.\nDiseases no longer have a default value of beta=1 assigned; beta must be defined explicitly if being used.\nIndividual diseases can now be plotted via either e.g. sim.plot('hiv') or sim.diseases.hiv.plot().\nDistributions can be created from dicts via ss.make_dist().\nA new function ss.check_sims_match() will check if the results of two or more simulations match.\nndict values can be accessed through a call; e.g. sim.diseases() is equivalent to sim.diseases.values().\nMerged test_dcp.py and test_base.py into test_other.py.\nRenamed test_simple.py to test_sim.py.\nRenamed test_dists.py to test_randomness.py.\nGitHub info: PR 488\n\n\n\n\n\n\nReplace UIDArray, ArrayView, and State with Arr, which has different subclasses for different data types (e.g. FloatArr, BoolArr, and IndexArr). States are usually represented by BoolArr (e.g. sir.infected), while other agent properties are represented by FloatArr (e.g. sir.rel_trans).\nArrays that had previously been represented using an integer data type (e.g. sir.ti_infected) are now also FloatArr, to allow the use of np.nan. Integer arrays are supported via IndexArr, but these are only intended for use for slots and UIDs.\nArr objects automatically skip over dead (or otherwise removed) agents; the “active” UIDs are stored in sim.people.auids, which is updated when agents are born or die. This array is linked to each Arr, so that e.g. sim.people.age.mean() will only calculate the mean over alive agents. To access the underlying Numpy array, use sim.people.age.raw.\nFloatArr has isnan, notnan, and notnanvals properties. BoolArr has logical operations defined. For example, ~people.female works, but ~people.ti_dead does not; people.ti_dead.notnan works, but people.female.notnan does not.\nUIDs used to be NumPy integer arrays; they are now ss.uids objects (which is a class, but is lowercase for consistency with np.array(), which it is functionally similar to). Indexing a state by an integer array rather than ss.uids() now raises an exception, due to the ambiguity involved. To index the underlying array with an integer array, use Arr.raw[int_arr]; to index only the active/alive agents, use Arr.values[int_arr].\nDead agents are no longer removed, so uid always corresponds to the position in the array. This means that no remapping is necessary, which has a significant performance benefit (roughly 2x faster for large numbers of agents).\nRenamed omerge to dictmerge and omergeleft to dictmergeleft.\nGitHub info: PR 456\n\n\n\n\n\nDefault duration of edges in ss.RandomNet changed from 1 to 0; this does not matter if dt=1, but does matter with smaller dt values.\nRemoved ss.HPVNet.\nnew_deaths now counted for cholera.\nCrude birth and death rates now take dt into account.\nThe ability to use a centralized random number generator has been restored via ss.options(_centralized=True); this option not advised, but can be used for testing.\nGitHub info: PR 473\n\n\n\n\n\nChanged Ebola model transmission logic.\nFixed bug with module names not being preserved with multiple initialization.\nGitHub info: PR 463\n\n\n\n\n\nChange to syphilis model to permit latent transmission.\nGitHub info: PR 450\n\n\n\n\n\nAdded SIS model.\nFixes distribution initialization.\nAllows interventions and analyzers to be functions.\nTidies up tests.\nPerformance improvements in UIDArray (~3x faster for large numbers of agents).\nGitHub info: PR 428\n\n\n\n\n\n\n\nReplaces ss.SingleRNG(), ss.MultiRNG(), ss.ScipyDistribution(), and ss.ScipyHistogram() with a single ss.Dist() class. The starsim.random and starsim.distributions submodules have been removed, and starsim.dists has been added.\nThe ss.Dist class uses np.random.default_rng() rather than scipy.stats by default, although a scipy.stats distribution can be supplied as an alternative. This is up to 4x faster (including, critically, for Bernoulli distributions).\nAlso removes ss.options.multirng (the new version is equivalent to it being always on).\nRemoves duplicate logic for transmission (make_new_cases())\nAdds new custom distributions such as ss.choice() and ss.delta().\nThese distributions can be called directly, e.g. dist = ss.weibull(c=2); dist(5) will return 5 random variates from a Weibull distribution.\nInstead of being manually initialized based on the name, the Sim object is parsed and all distributions will be initialized with a unique identifier based on their place in the object (e.g. sim.diseases.sir.pars.dur_inf), which is used to set their unique seed.\n\n\n\n\n\nThis PR also fixes bugs with lognormal parameters, and makes it clear whether the parameters are for the implicit normal distribution (ss.lognorm_im(), the NumPy/SciPy default, equivalent to ss.lognorm_mean() previously) or the “explicit” lognormal distribution (ss.lognorm_ex(), equivalent to ss.lognorm() previously).\nRenames ss.dx, ss.tx, ss.vx toss.Dx, ss.Tx, ss.Vx.\nRemoved set_numba_seed() as a duplicate of set_seed().\nGitHub info: PR 392\n\n\n\n\n\n\nSIR duration of infection now accounts for dt\nReworked sir_vaccine to modify rel_sus instead of moving agents from susceptible to recovered.\nn_years no longer necessarily an integer\nGitHub info: PR 389\n\n\n\n\n\nRenames and extends the multirng option in settings, now called ‘rng’, which set how random numbers are handled in Starsim with three options:\n\n“centralized” uses the centralized numpy random number generator for all distributions.\n“single” uses a separate (SingleRNG) random number generator for each distribution.\n“multi” uses a separate (MultiRNG) random number generator for each distribution.\n\nGitHub info: PR 349\n\n\n\n\n\nAdd ss.demo() to quickly create a default simulation.\nGitHub info: PR 380\n\n\n\n\n\nUpdate StaticNet with defaults and correct argument passing\nGitHub info: PR 339\n\n\n\n\n\nMake random number streams independent for SIR\nGitHub info: PR 307\n\n\n\n\n\nImprove logic for making new cases with multi-RNG\nGitHub info: PR 337\n\n\n\n\n\nImprove sim.summarize()\nImprove sim.plot()\nImprove SIR model defaults\nGitHub info: PR 320\n\n\n\n\n\nRemoves STI class\nChanges default death rate from units of per person to per thousand people\nAllows ss.Sim(demographics=True) to enable births and deaths\nFix pickling of State objects\nRename networks.py to network.py, and fix HIV mortality\nGitHub info: PRs 305, 308, 317\n\n\n\n\n\nAdd the Samples class\nGitHub info: PR 311\n\n\n\n\n\nOnly remove dead agents on certain timesteps\nGitHub info: PR 294\n\n\n\n\n\nCode reorganization, including making networks.py and disease.py to the top level\nNetworks moved from People to Sim\nVarious classes renamed (e.g. FusedArray to UIDArray, STI to Infection)\nBetter type checking\nAdded MultiSim\nAdded cholera, measles, and Ebola\nAdded vaccination\nMore flexible inputs\nGitHub info: PR 235\n\n\n\n\n\nTransmission based on number of contacts\nGitHub info: PR 220\n\n\n\n\n\nPerformance enhancement for disease transmission, leading to a 10% decrease in runtime.\nGitHub info: PR 217\n\n\n\n\n\nAdds template interventions and products for diagnostics and treatment\nAdds syphilis screening & treatment interventions\nGitHub info: PR 210\n\n\n\n\n\nRenamed stisim to starsim.\nGitHub info: PR 200\n\n\n\n\n\nAdds a syphilis module\nGitHub info: PR 206\n\n\n\n\n\nRead in age distributions for people initializations\nGitHub info: PR 205\n\n\n\n\n\nFunctionality for converting birth & fertility data to a callable parameter within SciPy distributions\nGitHub info: PR 203\n\n\n\n\n\nImproving performance of MultiRNG\nNow factoring the timestep, dt, into transmission calculations\nGitHub info: PRs 204\n\n\n\n\n\nAllows SciPy distributions to be used as parameters\nOptionally use multiple random number streams and other tricks to maintain coherence between simulations\nAdding functionality to convert death rate data to a callable parameter within a SciPy distribution\nGitHub info: PRs 170 and 202\n\n\n\n\n\nEnable removing people from simulations following death\nGitHub info: PR 121\n\n\n\n\n\nRefactor distributions to use new Distribution class\nGitHub info: PR 112\n\n\n\n\n\nChanges agent IDs from index-based to UID-based\nAllows states to store their own data and live within modules\nGitHub info: PR 88\n\n\n\n\n\nRefactor file structure\nGitHub info: PRs 77 and 86\n\n\n\n\n\nAdds in basic Starsim functionality\nGitHub info: PR 17\n\n\n\n\n\nInitial version.",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.1.1-2026-02-16",
    "href": "whatsnew.html#version-3.1.1-2026-02-16",
    "title": "What’s new",
    "section": "",
    "text": "TBC",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.1.0-2026-02-12",
    "href": "whatsnew.html#version-3.1.0-2026-02-12",
    "title": "What’s new",
    "section": "",
    "text": "Regression information: See docs/migration/v3.0_v3.1.md for a detailed, LLM-friendly migration guide.\nAdded new functionality to the Pregnancy module:\n\nRenamed make_p_fertility() -&gt; make_p_conceive()\nAdded variable durations of pregnancies and tracking of pre-term birth outcomes\nAdded variable breastfeeding durations\nRefactored the logic of how pregnancies and births are handled with new helper methods for better extensibility\nAdded results on age-specific fertility rates and total fertility rates\n\nPreviously People.(module_name).(state_name) could be used to access module states (e.g., people.sir.infected). However, this mechanism fails to pass on property attributes that are dynamically computed (e.g., SIR.infectious). Now People.(module_name) simply contains a reference to the module, so all attributes can be accessed.\nAdd support for operating on ss.BaseArr with time parameters (e.g., multiplying a state by a duration)\nAdd support for creating an ss.dur from an ss.BaseArr\nChanged date plotting to convert ss.date and ss.DateArray values to years internally. This facilitates adding extra data to plots when the data is in years.\nAdded ss.parse_age_range utility function to standardize formats for age ranges in data/input files.\nImplemented __bool__ for ss.bernoulli which returns False if there is no possibility of returning any True values.\nAdded automatic result creation for ss.BoolState instances in People, matching the behavior already present in modules. People now has auto_state_list property and init_results() method.\nImplemented operators for ss.BoolArr and ss.uids where the latter is treated as a BoolArr. This makes operations like people.sir.infected & people.female and people.sir.infected & people.female.uids equivalent.\nImplemented in-place operators for ss.BoolArr and ss.uids. The former are true in-place operations that reuse existing memory and preserve references, and thus they can be safely used with BoolState instances in modules directly.\nFixed/added operators + and - for ss.DateArray when operating on ss.date and ss.dur instances\nFixed bug when multiplying an ss.prob by an array of durations\nRenamed arguments to MaternalNet.add_pairs() from mother_inds to mother_uids and unborn_inds to unborn_uids to clarify that these inputs should be agent UIDs.\nRemoved dur argument to MaternalNet.add_pairs() as the edge lifespan is now managed by the Pregnancy module with edges being removed upon delivery.\nRemoved Network.prenatal and Network.postnatal attributes as these are now tracked by type (ss.PrenatalNet and ss.PostnatalNet)\nGitHub info: PR 1065",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.0.6-2026-01-28",
    "href": "whatsnew.html#version-3.0.6-2026-01-28",
    "title": "What’s new",
    "section": "",
    "text": "Fixed bug in sim.loop.plot_cpu() when using pandas v3",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.0.5-2025-10-22.",
    "href": "whatsnew.html#version-3.0.5-2025-10-22.",
    "title": "What’s new",
    "section": "",
    "text": "Fixed bugs with products being added/stepped multiple times.\nFixed bug that prevented Result.resample(output_form='series') from being used.",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.0.4-2025-10-22",
    "href": "whatsnew.html#version-3.0.4-2025-10-22",
    "title": "What’s new",
    "section": "",
    "text": "Added additional calibration examples for workflows to re-identify known parameters.\nRemoved p_death from the parameters for the ss.Deaths module, as Deaths.make_p_death() always overrides this value and is therefore the means by which the death probability should be set or changed.\nGitHub info: PR 1055",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.0.3-2025-10-07",
    "href": "whatsnew.html#version-3.0.3-2025-10-07",
    "title": "What’s new",
    "section": "",
    "text": "Swapped order of age and female states in People to allow female dist to use age state during population initialization.",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.0.2-2025-08-25",
    "href": "whatsnew.html#version-3.0.2-2025-08-25",
    "title": "What’s new",
    "section": "",
    "text": "Additional minor updates following the v3 release.\nCleans up some of the logic for converting rates to probabilities in the demographic modules\nAdds a request_removal method to People, which can be used to remove people from the population for reasons other than death (e.g. migration)\nFixes a bug that prevented ss.prob from accepting arrays\nAdds a year property to Timelines, so sim.t.now('year') can be rewritten as sim.t.year\nGitHub info: PR 1032",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.0.1-2025-08-04",
    "href": "whatsnew.html#version-3.0.1-2025-08-04",
    "title": "What’s new",
    "section": "",
    "text": "Minor updates following the v3 release.\nThe logic for initializing ss.Timeline has been changed. Now, start and stop will not be converted to dates unless at least one argument is a date (e.g. start=ss.years(2000) will remain ss.years()). ss.Timeline is also now much more robust about handling different types of input, and choosing sensible defaults for missing inputs (e.g. with stop=ss.days(20), the new default is start=ss.days(0)).\nSubtracting dates now yields a relativedelta, e.g. ss.date(2025) - ss.date(2015) now gives ss.datedur(years=10) (previously it converted to days).\nss.DateArray now has a unit attribute, allowing more reliable conversion to years.\nTimepars now have a disp() method.\nGitHub info: PR 1029",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-3.0.0-2025-08-02",
    "href": "whatsnew.html#version-3.0.0-2025-08-02",
    "title": "What’s new",
    "section": "",
    "text": "Starsim v3 includes a reimplementation of how time is handled, an extensive new suite of debugging tools, and smaller changes, including an extensive user guide in addition to the tutorials. Please also see docs/migration_v2v3 for a detailed (and LLM-friendly) migration guide for porting existing Starsim code over to the new version. If a point below says “See the migration guide”, that indicates that additional information (and a conversion script where possible) is provided in that guide. Otherwise, it is (generally) a non-breaking change.\n\n\n\nTime is now based on precise datetime stamps (specifically, pd.Timestamp). In Starsim v3.0, the supported time units are days, weeks, months, and years. Days or years are always handled exactly and weeks and months are defined in terms of them, i.e. a week is exactly 7 days and a month is exactly 1/12th of a year. The following changes have been made to the API:\n\nWhile durations work similarly as in Starsim v2, rates work differently. The base class, ss.Rate, cannot be used directly. Instead, you must use one of the three derived classes. ss.freq() is the closest to ss.rate() in Starsim v2, and is a simple inverse of ss.dur(). ss.per() is the equivalent of ss.rate_prob() in Starsim v2, but is the primary probability-based rate that should be used (e.g. for beta, birth rates, death rates, etc.). Finally, ss.prob() is the equivalent to ss.time_prob() in Starsim v2, but whereas time_prob was preferred in v2, per (equivalent to rate_prob in v2) is preferred in v3.\nIn addition to these base classes, each of them is available for each time unit. For durations, singletons are available (ss.day), as well as e.g. ss.days(), ss.years() etc. For rates, ss.peryear() is derived from ss.per, while ss.probperyear() is the equivalent for ss.prob and ss.freqperyear() is the equivalent for ss.freq. ss.prob can also be unitless (ss.per and ss.freq cannot be).\nss.beta() has been removed; use ss.prob() instead for a literal equivalent, although in most cases ss.per() is preferable, e.g. ss.peryear().\nss.rate() has been removed; use ss.freq() instead for a literal equivalent, although in most cases ss.per() is preferable, e.g. ss.peryear().\nunit has been removed as an argument; use dt instead, e.g. ss.Sim(dt=1, unit='years') is now ss.Sim(dt=ss.year) (or ss.Sim(dt='years') or ss.Sim(dt=ss.years(1))).\nAlthough ss.dur() still exists in Starsim v3.0, it is preferable to use named classes instead, e.g. ss.years(3) instead of ss.dur(3, 'years').\nss.Time() is now called ss.Timeline() and its internal calculations are handled differently.\nss.time_ratio() has been removed; time unit ratio calculations (e.g. months to years) are now handled internally by timepars.\nt.abstvec has been removed; in most cases, t.tvec should be used instead (although t.yearvec, t.datevec, or t.timevec may be preferable in some cases).\nMultiplication by dt no longer happens automatically; call to_prob() to convert from a timepar to a unitless probability (or to_events() to convert to a number of events instead).\n\nFor full details, see the migration guide.\n\n\n\n\nDistributions now have a scale_type attribute, which determines how they scale with time: some distributions, like ss.normal(), can be scaled either before or after random numbers are drawn; others, like ss.poisson(), can only be scaled before. See ss.scale_types for details.\nDistributions that can be scaled post-draw now take an unit argument, e.g. ss.normal(mean=5, std=2, unit=ss.years(1)). This is equivalent to ss.years(ss.normal(mean=5, std=2)) or ss.normal(mean=ss.years(5), std=ss.years(2)). Note that not all distributions can be scaled this way (you will get an error if you try to scale a non-scalable distribution.)\nDistributions now have a random-number-safe randround() method\nThere are two new distributions, ss.beta_dist() and ss.beta_mean() (not called ss.beta() to distinguish from the beta transmissibility parameter).\n\n\n\n\n\nSims now take an optional modules argument. These are run first, before anything else in the integration loop. If you want, you can supply everything directly as a module, e.g. ss.Sim(modules=[ss.Births(), ss.RandomNet(), ss.SIR()]) is equivalent to ss.Sim(demographics=ss.Births(), networks=ss.RandomNet(), diseases=ss.SIR()). You can also add your own custom modules, not based on an existing Starsim module type, and specify the order they are called in.\nsim.modules has been renamed sim.module_list.\nss.People has a new filter() method, which lets you chain operations, e.g.: ppl = sim.people; f = ppl.filter(ppl.female & (ppl.age&gt;5) & ~ppl.sir.infected)\nss.People has new methods plot() (all variables) and plot_ages() (age pyramid by sex).\n\n\n\n\n\n\n\nModule methods have a new decorator, @ss.required(), which flag that it is an error for the method not to be called. This is used to prevent the user from accidentally forgetting to call super().method().\nModules can now be used like dictionaries for accessing user-defined states, e.g. module['my_custom_state'] is an alias for module.my_custom_state.\nmodule.states has been renamed module.state_list. module.statesdict has been renamed module.state_dict. There is also a module.auto_state_list property, referring specifically to ss.BoolState attributes.\nBuilt-in modules now have function signatures that look like this example for ss.Births(): def __init__(self, pars=None, rel_death=_, death_rate=_, rate_units=_, **kwargs):. Although _ is simply None, this notation is short-hand for indicating that (a) the named arguments are the available parameters for the module, (b) their actual values are set by the define_pars() method.\nModules now have a much briefer __repr__, typically one line. The full module information can still be obtained via module.disp().\n\n\n\n\n\nkey_dict has been removed from ss.Network(); modify the network.meta dictionary directly instead, e.g. ss.DynamicNetwork has self.meta.dur = ss_float in its __init__() method, while ss.SexualNetwork has self.meta.acts = ss_int.\nss.Network() now has plot() and to_edgelist() methods.\nss.RandomNet() now only adds “missing” edges, fixing a bug in which the longer the edge duration, the more edges the network had.\nThere is a new network, ss.RandomSafe(), whch is similar to ss.Random() but random-number safe (at the cost of being slightly slower).\nFor ss.MixingPool, the argument contacts has been renamed n_contacts.\n\n\n\n\n\nThere is a new built-in analyzer ss.dynamics_by_age().\nThere is a new built-in connector ss.seasonality().\nss.Births() is now random-number safe.\nss.Deaths() now has a default rate of 10 per 1000 people per year (instead of 20). Births is still 20. This means that with demographics=True, the population grows at roughly the correct global average rate.\nss.sir_vaccine() has been renamed ss.simple_vx().\n\n\n\n\n\nStarsim v3 comes with a new set of tools for debugging (in debugtools.py): both understanding simulations and what is happening at different points in time, and understanding and profiling code performance to find possible improvements to efficiency. These include: - sim.profile(): profiles a run of a sim, showing module by module (and optionally line by line) where most of the time is being spent. See ss.Profile() for details. - ss.Debugger(): steps through one or more simulations, and raises an exception when a particular condition is met (e.g., if the results from two sims start to diverge). - ss.check_requires(): use this function to check if a sim contains a required module (e.g., an HIV-syphilis connector would require both HIV and syphilis modules to be present in the sim). - ss.check_version(): for checking which version of Starsim is installed.\n\n\n\nss.Loop now has an insert() method that lets you manually insert functions at an arbitrary point in the simulation loop.\nss.Loop now has a plot_step_order() method that lets you validate that the steps are being called in the expected order.\n\n\n\n\n\nIn the tests folder, there is a benchmark_tests.py script for benchmarking the performance of the tests. Each test is also now timed (via the @sc.timer decorator).\nThere are also various profiling scripts, e.g. profile_sim.py.\nBaseline and performance benchmark files have been converted from JSON to YAML.\n\n\n\n\nStarsim components are intended to work together as part of an ss.Sim object, which handles initialization and coordination across modules, distributions, time parameters, etc. But sometimes, it’s useful to build a very simple example to test a component in isolation. Starsim v3 comes with “mock” components, which allow you to work with e.g. a module without incorporating it into a full sim. These have the essential structure of the real thing (e.g., sim.t.dt), but without the complexity of the full object. These mock objects are:\n\nss.mock_sim(): generates a mock sim; useful for testing modules\nss.mock_module(): generates a mock module; useful for testing distributions\nss.mock_people(): generates a mock ss.People object; used by ss.mock_sim()\nss.mock_time(): generates a mock ss.Timeline object; used by ss.mock_sim() and ss.mock_module()\n\nDistributions now have a mock() method, that allows you to immediately start using them to generate random numbers, e.g. ss.normal(5,2).mock().rvs(10).\n\n\n\n\n\n\n\nAll diseases except for SIR, SIS, and NCD have been moved to a separate starsim_examples folder. This is installed together with Starsim, but must be imported separately, e.g. import starsim_examples as sse; hiv = sse.HIV() instead of import starsim as ss; hiv = ss.HIV(). See the migration guide for details.\nss.register_modules() lets you register external modules as Starsim modules, to allow calling by string; e.g. ss.register_modules(sse) (from above) will let you do ss.Sim(diseases='hiv'), since sse.HIV is registered as a known Starsim module.\nFiles have been reorganized:\n\nanalyzers.py and connectors.py have been created (split out from modules.py);\ncalibration.py and calib_components.py have been combined into calibration.py;\ndisease.py has been renamed diseases.py and diseases/sir.py and diseases/ncd.py have been incorporated into it;\ntimeline.py has been split out from time.py.\n\n\n\n\n\n\nPlotting defaults have been updated; you can use these defaults via with ``ss.style().\nResult plotting has been improved, in terms of module labels and correct x-axis labels.\nss.MultiSim() plotting has been improved to display legends correctly.\nPlotting arguments are now handled by ss.plot_args(), which will parse different arguments among figure, plot, scatter, and other functions, e.g. ss.plot_args(dpi=150, linewidth=3) will set the figure DPI and the plot line width.\nSim results are now automatically skipped during plotting if they were never updated (e.g., n_deaths if there were no deaths).\n\n\n\n\n\nArray indexing has been reimplemented, using Numba instead of NumPy for large operations; this should be about 30% faster. An unnecessary array copy operation was also removed, for a further ~50% efficiency gain. (Note that although array indexing is now much faster, it was not typically the slowest step, so “real world” performance gains are closer to 10-20%.)\nThere is a new class, ss.IntArr, although in most cases ss.FloatArr is still preferred due to better handling of NaNs.\nss.State has been renamed to ss.BoolState. See the migration guide for details.\nss.options._centralized has been renamed ss.options.single_rng. Although there is a very small performance benefit, use of this option is not recommended.\nss.set_seed() has been removed; the seed should be set automatically by the distributions. If you want to set the seed for a custom (not random-number-safe) non-distribution random number, call np.random.seed() manually.\nDistributions and modules now define their own shrink() methods (for saving small files). Note that if you define a custom module that stores a lot of data, you may want to define your own shrink() method to remove this data.\nss.Result() objects now have disp() and to_str() methods, and they can also be treated as dicts (e.g. res['low'] instead of res.low).\nYou can now create an ss.MultiSim comprised of sims of different lengths; however, the sims will be truncated to be of the same length, and they are not temporally aligned. In general, it is still inadvisable to use msim.reduce() with sims of different lengths.\n\n\n\n\nStarsim v3 comes with several new options, set via ss.options:\n\nss.options.check_method_calls: whether to check that required module methods are called (default True)\nss.options.install_fonts: whether to install custom fonts for plotting (default True)\nss.options.numba_indexing: threshold at which to switch from NumPy to Numba indexing (default 5000 indices)\nss.options.style: plotting style to use; options are “starsim”, “fancy”, “simple”, or any Matplotlib style\nss.options.warn_convert: whether to warn when automatically converting time parameters\n\nss.options also now has a help method that will print detailed help on a given option or all options, e.g. ss.options.help(detailed=True).\n\n\n\n\nAn agentic LLM such as Cursor or Claude Code should be able to perform most of the migrations from v2 to v3 automatically. Tell it to read llms.txt, then docs/migration/v2_v3/README.md. However, there will still be a few things to manually double check, especially around time conversions (such as whether you want ss.beta() ported literally to ss.probperyear(), or “upgraded” to ss.peryear()).\nGitHub info: PR 1008",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.3.2-2025-07-16",
    "href": "whatsnew.html#version-2.3.2-2025-07-16",
    "title": "What’s new",
    "section": "",
    "text": "Fix argument passing in Infection.infect. This will be the final Starsim v2.x release.\nGitHub info: PR 1008",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.3.1-2025-02-25",
    "href": "whatsnew.html#version-2.3.1-2025-02-25",
    "title": "What’s new",
    "section": "",
    "text": "Updated ss.Sim.shrink() to remove additional objects, resulting in a smaller sim size.\nss.Calibration.save_csv() has been replaced by ss.Calibration.to_df() (to save to a CSV, use ss.Calibration.to_df().to_csv().\nss.Result.shape has been renamed ss.Result._shape, so ss.Result.shape now correctly returns the actual size of the array.\nResults by default convert all result keys to lowercase; use keep_case=True to turn off this behavior.\nFixed a bug with an ss.date object converting to a pd.Timestamp upon copy.\nGitHub info: PR 865",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.3.0-2025-02-14",
    "href": "whatsnew.html#version-2.3.0-2025-02-14",
    "title": "What’s new",
    "section": "",
    "text": "The calibration class has been completely redesigned. Calibration now relies on “components”, which capture mismatch with a particular data type (e.g., new infections). The new approach also adds additional statistical rigor for calculating mismatches.\nss.MixingPool has been updated to be more modular, and behave more like ss.Network; in particular, compute_transmission() rather than step() is called to determine new infections.\nss.Result now has a summarize_by argument, which determines how a result should be summarized as a scalar (e.g., mean for a prevalence, sum for a count, last entry for a cumulative count).\nFixed a bug with time parameters incorrectly pulling the parent unit from the Sim, rather than the parent module.\nGitHub info: PR 831",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.2.0-2024-11-18",
    "href": "whatsnew.html#version-2.2.0-2024-11-18",
    "title": "What’s new",
    "section": "",
    "text": "Starsim is now available for R! See https://r.starsim.org for details.\nThe Calibration class has been completely rewritten. See the calibration tutorial for more information.\nA negative binomial distribution is now available as ss.nbinom().\nss.Births() now uses a binomial draw of births per timestep, rather than the expected value.\nAdded ss.load() and ss.save() functions, and removed ss.Sim.load().\nGitHub info: PR 778",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.1.1-2024-11-08",
    "href": "whatsnew.html#version-2.1.1-2024-11-08",
    "title": "What’s new",
    "section": "",
    "text": "Adds improved Jupyter support for plotting (to prevent plots from appearing twice); you can disable this by setting ss.options.set(jupyter=False).\nAdds auto_plot to Result objects, to indicate if it should appear in sim.plot() by default.\nAdds copy() to the Sim and modules.\nNetworks now store their length on each timestep as a result.\nImproves sim.shrink(), with typical size reductions of &gt;99%.\nAdds additional plotting options show_module (include the module name in the plot title), show_label (use the simulation label as the figure title), and show_skipped (shows results even if auto_plot=False).\nGitHub info: PR 745",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.1.0-2024-11-07",
    "href": "whatsnew.html#version-2.1.0-2024-11-07",
    "title": "What’s new",
    "section": "",
    "text": "Time in simulations is now handled by an ss.Time() class, which unifies how time is represented between the Sim and each module.\nIn addition to networks, there is now a new way of implementing disease transmission via mixing pools.\n\n\n\n\n\nTime handling now performed by the ss.Time() class. This has inputs similar to before (start, stop, unit, dt, with dur still available as a sim input). However, instead of the previous timevec and abs_tvec arrays, there are now multiple ways of representing time (including datevec and yearvec), regardless of what the inputs were.\nDates are now represented in a native format, ss.date, that is based on pd.Timestamp.\n\n\n\n\n\nAdds a new approach to disease transmission called mixing pools. A mixing pool is a “mean field” coupling wherein susceptible agents are exposed to the average infectious agent. The user can create a single mixing pool using the ss.MixingPool class, or create many pools using MixingPools. Such mixing pools could be used to simulate contact matrices, for example as published by Prem et al.\nThere is a new ss.Route class, which is the base class for ss.Network and ss.MixingPool.\n\n\n\n\n\nDemographic modules have been updated to fix various bugs around different time units.\nThe method for hashing distribution trace strings into seeds has changed, meaning that results will be stochastically different compared to Starsim v2.0.\nFixed a bug with how timepars were updated in parameters.\nThere is a new ss.Base class, which both ss.Sim and ss.Module inherit from.\nResults now print as a single line rather than the full array. The latter is available as result.disp().\nsim.to_df() now works even if different modules have different numbers of timepoints.\nThe timepars module has been renamed to time.\nIn demographics modules, units has been renamed rate_units.\nThere are two new options, ss.options.date_sep and ss.options.license. The former sets the date separator (default ., e.g. 2024.04.0.4), and the latter sets if the license prints when Starsim is imported.\nGitHub info: PR 724",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-2.0.0-2024-10-01",
    "href": "whatsnew.html#version-2.0.0-2024-10-01",
    "title": "What’s new",
    "section": "",
    "text": "Version 2.0 contains several major changes. These include: module-specific timesteps and time-aware parameters (including a day/year unit flag for modules, and ss.dur() and ss.rate() classes for parameters), and changes to module types and integration (e.g. renaming update() and apply() methods to step();).\n\n\n\n\nAdded ss.dur(), ss.rate(), and ss.time_prob() classes, for automatic handling of time units in simulations. There are also convenience classes ss.days(), ss.years(), ss.perday(), ss.peryear(), and ss.beta() for special cases of these.\nss.dur() and ss.rate(), along with modules and the sim itself, have a unit parameter which can be 'day', 'week', 'month', or 'year' (default). Modules now also have their own timestep dt. Different units and timesteps can be mixed and matched. Time parameters have a to() method, e.g. ss.dur(1, 'year').to('day') will return ss.dur(365, unit='day').\nThe ss.Sim parameter n_years has been renamed dur; sim.yearvec is now sim.timevec, which can have units of days (usually starting at 0), dates (e.g. '2020-01-01'), or years (e.g. 2020). sim.abs_tvec is the translation of sim.timevec as a numeric array starting at 0, using the sim’s units (usually 'day' or 'year'). For example, if sim.timevec is a list of daily dates from '2022-01-01' to '2022-12-31', sim.abs_tvec will be np.arange(365).\nEach module also has its own mod.timevec; this can be different from the sim if it defines its own time unit and/or timestep. mod.abs_tvec always starts at 0 and always uses the sim’s unit.\nThere is a new Loop class which handles the integration loop. You can view the integration plan via sim.loop.to_df() or sim.loop.plot(). You can see how long each part of the sim took with sim.loop.plot_cpu().\nThere are more advanced debugging tools. You can run a single sim timestep with sim.run_one_step() (which in turn calls multiple functions), and you can run a single function from the integration loop with sim.loop.run_one_step().\n\n\n\n\n\nFunctionality has been moved from ss.Plugin to ss.Module, and the former has been removed.\nss.Connector functionality has been moved to ss.Module. ss.Module objects can be placed anywhere in the list of modules (e.g., in demographics, networks, diseases, interventions), depending on when you want them to execute. However, ss.Connector objects are applied after Disease.step_state() and before Network.step().\nMany of the module methods have been renamed; in particular, all modules now have a step() method, which replaces update() (for demographics and networks), apply() (for interventions and analyzers), and make_new_cases() (for diseases). For both the sim and modules, initialize() has been renamed init().\nAll modules are treated the same in the integration loop, except for diseases, which have step_state() and step_die() methods.\nThe Starsim module states.py has been moved to arrays.py, and network.py has been moved to networks.py.\n\n\n\n\n\nss.Arr, ss.TimePar, and ss.Result all inherit from the new class ss.BaseArr, which provides functionality similar to a NumPy array, except all values are stored in arr.values (like a pd.Series).\nWhereas before, computations on an ss.Arr usually returned a NumPy array, calculations now usually return the same type. To access the NumPy array, use arr.values.\nThere is a new ss.State class, which is a subtype of ss.BoolArr. Typically, ss.State is used for boolean disease states, such as infected, susceptible, etc., where you want to automatically generate results (e.g. n_infected). You can continue using ss.BoolArr for other agent attributes that you don’t necessarily want to automatically generate results for, e.g. ever_vaccinated.\n\n\n\n\n\nResults are now defined differently. They should be defined in ss.Module.init_results(), not ss.Module.init_pre(). They now take the module name, number of points, and time vector from the parent module. As a result, they are usually initialized via ss.Module.define_results(res1, res2) (as opposed to mod.results += [res1, res2] previously). define_results() automatically adds these properties from the parent module; they can still be defined explicitly if needed however.\nBecause results now store their own time information, they can be plotted in a self-contained way. Both ss.Result and ss.Results objects now have plot() and to_df() methods.\n\n\n\n\n\nFixed a bug in how results were defined for ss.Births and ss.Deaths.\nThe ss.Pregnancy module has been significantly rewritten, including: (1) Agents now have a parent which indicates the UID of the parent; (2) Women now track child_uid; (3) On neonatal death, the pregnancy state of the mother is corrected; (4) Pregnancy rates now adjusted for infecund rather than pregnant; (4) Pregnancy now has a burn-in, which defaults to True; (5) Pregnancy has a p_neonatal_death parameter to capture fetal and neonatal death if the mother dies.\nSlots now has a minimum, default of 100, to account for small initial population sizes that grow dramatically over time.\n\n\n\n\n\nThere have been several performance improvements. The default float type is now np.float32. Transmission is now handled by a specialized Infection.compute_transmission() method. Several additional functions now use Numba, including fastmath=True, which leverages Intel’s short vector math library.\nA new ss.multi_random() distribution class has been added, that allows random numbers to be generated by two (or more) agents. It largely replaces ss.combine_rands() and is 5-10x faster.\nA new ss.gamma() distribution has also been added.\nDistributions have a new jump_dt method that jumps by much more than a single state update.\nss.parallel() and ss.MultiSim.run() now modify simulations in place by default. Instead of sims = ss.parallel(sim1, sim2).sims; sims[0].plot(), you can now simply do ss.parallel(sim1, sim2); sim1.plot().\n\n\n\n\n\nData can now be supplied to a simulation; it will be automatically plotted by sim.plot().\nss.Calibration has been significantly reworked, and now includes more flexible parameter setting, plus plotting (calib.plot_sims() and calib.plot_trend()). It also has a debug argument (which runs in serial rather than paralell), which can be helpful for troubleshooting issues.\nMultiSim now has display methods brief() (minimal), show() (moderate), and disp (verbose).\nsim.export_df() has been renamed sim.to_df().\nMost classes now have to_json() methods (which can also export to a dict).\nFixed a bug in how the InfectionLog is added to disease modules.\nSim.gitinfo has been replaced with Sim.metadata (which includes git info).\nInfection.validate_beta() is now applied on every timestep, so changes to beta during the simulation are now honored.\nsim.get_intervention() and sim.get_analyzer() have been removed; use built-in ndict operations (e.g., the label) to find the object you’re after.\nrequires has been removed from modules, but ss.check_requires() is still available if needed. Call it manually from init_pre() if desired, e.g. a PMTCT intervention might call ss.check_requires(self.sim, ['hiv', 'maternalnet']).\nFor networks, contacts has been renamed edges except in cases where it refers to an agent’s contacts. For example, network.contacts has been renamed network.edges, but ss.find_contacts() remains the same.\nNetworks now have a to_graph() method that exports to NetworkX.\nss.diff_sims() can now handle MultiSim objects.\nSim._orig_pars has been removed.\nss.unique() has been removed.\n\n\n\n\n\nNote: the list here covers major changes only; in general, Starsim v1.0 scripts will not be compatible with Starsim v2.0.\nResults from Starsim v2.0 will be stochastically (but not statistically) different from Starsim v1.0.\nAll duration and rate parameters should now be wrapped with ss.dur() and ss.rate(). Events that represent probabilities over time (i.e. hazard rates) can also be wrapped with ss.time_prob(), although this is similar to ss.rate() unless the value is relatively large.\nss.Plugin has been removed. Use ss.Module instead.\ninit_results() is now called by init_pre(), and does not need to be called explicitly.\ndefault_pars() has been renamed define_pars().\nadd_states() has been renamed define_states()\ninitialize() has been renamed init().\nDemographics.update() has been renamed Demographics.step().\nNetwork.update() has been renamed Network.step().\nDisease.update_pre() has been renamed Disease.step_state().\nDisease.make_new_cases() has been renamed Disease.step().\nDisease.update_death() has been renamed Disease.step_die() (which is now called by People.step_die()).\nInfection._set_cases() has been renamed Infection.set_outcomes().\nIntervention.apply(sim) has been renamed Intervention.step(); ditto for Analyzer.\nModule.step() no longer takes sim as an argument (e.g., replace intervention.apply(sim) with intervention.step()).\nAll modules now have methods for start_step(), finish_step(), init_results(), and update_results().\nNetwork.contacts has been renamed Network.edges.\nsim.get_intervention() and sim.get_analyzer() have been removed; simply call directly instead (e.g. replace sim.get_intervention('vaccine') with sim.interventions['vaccine']).\nrequires is no longer an attribute of modules; call the ss.check_requires() function directly if needed.\nPeople.resolve_deaths() has been renamed People.check_deaths()\nss.unique() has been removed.\nGitHub info: PR 626",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.3-2024-09-26",
    "href": "whatsnew.html#version-1.0.3-2024-09-26",
    "title": "What’s new",
    "section": "",
    "text": "Fixes a bug in which some intervention parameters (e.g. eligibility) do not get set properly.\nGitHub info: PR 639",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.2-2024-09-25",
    "href": "whatsnew.html#version-1.0.2-2024-09-25",
    "title": "What’s new",
    "section": "",
    "text": "Fixes a bug in which random numbers drawn from auto-jumped distributions would overlap with random numbers drawn from subsequent timesteps.\nGitHub info: PR 639",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.1-2024-07-22",
    "href": "whatsnew.html#version-1.0.1-2024-07-22",
    "title": "What’s new",
    "section": "",
    "text": "Adds a new distribution, ss.rand_raw(), that samples raw integers from the random number bit generator, for use with calculating transmission. This version is roughly 20-30% faster than the previous implementation.\nAdds interpolation to age-standardized fertility rate (ASFR) data.\nAdds flexibility to ART initiation.\nGitHub info: PR 593",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-1.0.0-2024-07-10",
    "href": "whatsnew.html#version-1.0.0-2024-07-10",
    "title": "What’s new",
    "section": "",
    "text": "Official release of Starsim!\nAdds a Calibration class, based on Optuna, to facilitate the calibration of Starsim models.\nAdds mean(), median(), and plot() methods to MultiSim.\nAdds low and high attributes to Result objects.\nAdds a flatten() method to Results, allowing nested Results objects to be turned into flat dictionaries.\nRemoves duplicate UIDs among new infections, and adds a unique() method to ss.uids.\nFixes a bug that prevented ss.lognorm_im() from using callable parameters.\nUpdates the default Sim string representation to be a single line; the more verbose version is available via sim.disp().\nGitHub info: PR 581",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.10-2024-07-03",
    "href": "whatsnew.html#version-0.5.10-2024-07-03",
    "title": "What’s new",
    "section": "",
    "text": "Adds two new common-random-number-safe networks. The first is an Erdős-Rényi network that is similar to RandomNet but parameterized differently. The second is a 2D spatial network with connectivity between agents within a given radius; these agents can also optionally move.\nGitHub info: PR 575",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.9-2024-06-30",
    "href": "whatsnew.html#version-0.5.9-2024-06-30",
    "title": "What’s new",
    "section": "",
    "text": "Added a ss.histogram() distribution, which allows generating new random values from an empirical histogram.\nWhen binned age data is provided to specify the initial ages for new agents, the ages are now distributed throughout the year/bin rather than new agents being assigned integer ages\nInitial age data is now accepted as a pd.Series rather than a pd.DataFrame where the index corresponds to the age values, thereby avoiding the need for specific dataframe column names to be used to specify the age and value\nGitHub info: PR 572",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.8-2024-06-30",
    "href": "whatsnew.html#version-0.5.8-2024-06-30",
    "title": "What’s new",
    "section": "",
    "text": "Revert to making infection logging disabled by default. However, the infection log will now always be created so disease subclasses can override logging behaviour where required (e.g., to capture additional metadata)\nBackwards-compatibility notes: Logging has been moved from an argument to Disease to pars. Existing code such as Disease(log=True) should be changed to Disease(pars={'log':True}). The ‘log’ option can be added to the pars passed to any subclass e.g., ss.HIV(pars={...,log=True}).\nGitHub info: PR 573",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.7-2024-06-27",
    "href": "whatsnew.html#version-0.5.7-2024-06-27",
    "title": "What’s new",
    "section": "",
    "text": "Implemented a new ss.combine_rands() function based on a bitwise-XOR, since the previous modulo-based approach could introduce correlations between pairs of agents.\nGitHub info: PR 546",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.6-2024-06-22",
    "href": "whatsnew.html#version-0.5.6-2024-06-22",
    "title": "What’s new",
    "section": "",
    "text": "ss.Infection.make_new_cases() now returns the index of the network associated with each transmission event\nIf a People object is provided to the Arr constructor, the arrays will be pre-initialized to index the current UIDs in the People object. This enables construction of temporary Arr instances that can be used to perform intermediate calculations (e.g., inside Intervention.apply() or within a module update step)\nDeprecated Arr(raw=...) argument to simplify initialization, as in practice the raw variable is not directly set, and this update also introduces a new pathway for initializating the raw attribute\nss.uids.to_numpy() now returns a view rather than a copy\nss.bernoulli.filter() now supports ss.BoolArr as an input, where the filtering will operate on the uids returned by ss.BoolArr.uids\nss.uids() supports construction from set objects (via np.fromiter())\nGitHub info: PR 565",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.5-2024-06-19",
    "href": "whatsnew.html#version-0.5.5-2024-06-19",
    "title": "What’s new",
    "section": "",
    "text": "Added labels to Result and state (Arr) objects.\nAdded Numba decorator to find_contacts to significantly increase performance.\nFixed bug when comparing uids and BoolArr objects.\nGitHub info: PR 562",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.4-2024-06-18",
    "href": "whatsnew.html#version-0.5.4-2024-06-18",
    "title": "What’s new",
    "section": "",
    "text": "Adjusted RandomNet to avoid connections to unborn agents and use random rounding for half edges\nAdds get_analyzers and get_analyzer\nRefactor how data is pre-processed for births/pregnancy/death rates, giving about a 10% decrease in run time for the STIsim HIV model\nBoolArr.uids is automatically called when doing set operations on uids with a BoolArr\nGitHub info: PR 555",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.3-2024-06-10",
    "href": "whatsnew.html#version-0.5.3-2024-06-10",
    "title": "What’s new",
    "section": "",
    "text": "ss.uids class implements set operators to facilitate combining or otherwise operating on collections of UIDs\nFloatArr.isnan and FloatArr.notnan return BoolArr instances rather than UIDs (so as to facilitate logical operations with other BoolArr instances, and to align more closely with np.isnan)\nArr.true() and Arr.false() are supported for all Arr subclasses\nBoolArr.isnan and Boolarr.notnan are also implemented (although since BoolArr cannot store NaN values, these always return False and True, respectively)\nGitHub info: PR 544",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.2-2024-06-04",
    "href": "whatsnew.html#version-0.5.2-2024-06-04",
    "title": "What’s new",
    "section": "",
    "text": "Renames network.contacts to network.edges.\nFor modules (including diseases, networks, etc.), renames initialize() to init_pre() and init_vals() to init_post().\nRenames ss.delta() to ss.constant().\nAllows Arr objects to be indexed by integer (which are assumed to be UIDs).\nFixes bug when using callable parameters with ss.lognorm_ex() and ss.lognorm_im().\nFixes bug when initializing ss.StaticNet().\nUpdates default birth rate from 0 to 30 (so demographics=True is meaningful).\nAdds min_age and max_age parameters to the Pregnancy module (with defaults 15 and 50 years).\nAdds an option for the sir_vaccine to be all-or-nothing instead of leaky.\nUpdates baseline test from HIV to SIR + SIS.\nFixes issue with infection log not being populated.\nGitHub info: PR 527",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.1-2024-05-15",
    "href": "whatsnew.html#version-0.5.1-2024-05-15",
    "title": "What’s new",
    "section": "",
    "text": "Separates maternal transmission into prenatal and postnatal modules.\nGitHub info: PR 509",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.5.0-2024-05-14",
    "href": "whatsnew.html#version-0.5.0-2024-05-14",
    "title": "What’s new",
    "section": "",
    "text": "All inputs to the sim and modules now use a ss.Pars() class, which handles updating and validation. It is now not necessary to ever use pars= (although you still can if you want), so what was previously:\nsim = ss.Sim(pars=dict(diseases='sir', networks='random'))\nis now just:\nsim = ss.Sim(diseases='sir', networks='random')\nUpdates happen recursively, so distributions etc. can be flexibly updated.\nThis has significantly changed how modules are initialized; what was previously:\ndef __init__(self, pars=None, **kwargs):\n\n    pars = ss.omergeleft(pars,\n        dur_inf = 6,\n        init_prev = 0.01,\n        p_death = 0.01,\n        beta = 0.5,\n    )\n\n    par_dists = ss.omergeleft(par_dists,\n        dur_inf = ss.lognorm_ex,\n        init_prev = ss.bernoulli,\n        p_death = ss.bernoulli,\n    )\n\n    super().__init__(pars=pars, par_dists=par_dists, *args, **kwargs)\nis now:\ndef __init__(self, pars=None, **kwargs):\n    super().__init__()\n    self.default_pars(\n        beta = 0.5,\n        init_prev = ss.bernoulli(0.01),\n        dur_inf = ss.lognorm_ex(6),\n        p_death = ss.bernoulli(0.01),\n    )\n    self.update_pars(pars, **kwargs)\n\n\n\n\nAdded a ss.Pars class (and a ss.SimPars subclass) that handles parameter creation, updates, and validation.\nInitialization has been moved from sim.py to parameters.py; ss.Sim.convert_plugins() has been replaced by ss.SimPars.convert_modules().\nThe key method is ss.Pars.update(), which performs all necessary validation on the parameters being updated.\n\n\n\n\n\nPreviously, the people were initialized first, then the states were initialized and the values populated, then the modules were initialized, and finally the distributions are initialized. This led to circular logic with the states being initialized based on uninitialized distributions. Now, states and modules are linked to the People and Sim objects, but further initialization is not done at this step. This ensures all distributions are created but not yet used. Next, distributions are initialized. Finally, the initial values are populated, and everything is initialized.\nNew methods supporting these changes include ss.link_dists(), dist.link_sim(), dist.link_module(), sim.init_vals(), people.init_vals(), module.init_vals(),\n\n\n\n\n\nWhereas modules previously initialized a dict of parameters and then called super().__init__(pars, **kwargs), they now call super().__init__() first, then self.default_pars(par1=x, par2=y), then finally self.update_pars(pars, **kwargs).\nWhat was previously e.g. ss.Module(pars=dict(par=x)) is now ss.Module(par=x).\npar_dists has been removed; instead, distributions are specified in the default parameters, and are updated via the Pars object.\nModules now contain a link back to the Sim object. This means that all methods that used to have sim as an argument now do not, e.g. self.update() instead of self.update(sim).\nss.module_map() maps different module types to their location in the sim.\nss.find_modules() finds all available modules (including subclasses) in Starsim.\nRemoved ss.dictmerge() and ss.dictmergeleft (now handled by ss.Pars.update()).\nRemoved ss.get_subclasses() and ss.all_subclasses() (now handled by ss.find_modules()).\nModules can no longer be initialized with a name key; it must be type (e.g. dict(type='sir') rather than dict(name='sir').\nAdded to_json() and plot() methods to Module.\nRemoved connectors.py; connectors still exist but as an empty subclass of Module.\n\n\n\n\n\nBasePeople has been removed and merged with People.\nTime parameters (ti, dt, etc.) have been removed from People. Use sim.ti, sim.dt etc. instead. One consequence of this is that people.request_death() now requires a sim argument. Another is that network methods (e.g. add_pairs()) now take sim arguments instead of people arguments.\nSexualNetwork is now a subclass of DynamicNetwork.\nRemoved ss.Networks (now just an ss.ndict).\nNetwork connectors have been removed.\nPerson has been implemented as a slice of sim.people[i].\nThere is a new parameter use_aging; this defaults to True if demographic modules are supplied, and False otherwise.\n\n\n\n\n\nBoolean arrays have new methods true(), false(), and split(), which return the UIDs for the True values (alias to arr.uids), False values, and both sets of values, respectively. ss.bernoulli.split() has been added as an alias of ss.bernoulli.filter(both=True).\nAll inputs to a sim are now copied by default. To disable, use ss.Sim(..., copy_inputs=False).\nThere is a new Plugin class, which contains shared logic for Interventions and Analyzers. It has a from_func(), which will generate an intervention/analyzer from a function.\nDiseases no longer have a default value of beta=1 assigned; beta must be defined explicitly if being used.\nIndividual diseases can now be plotted via either e.g. sim.plot('hiv') or sim.diseases.hiv.plot().\nDistributions can be created from dicts via ss.make_dist().\nA new function ss.check_sims_match() will check if the results of two or more simulations match.\nndict values can be accessed through a call; e.g. sim.diseases() is equivalent to sim.diseases.values().\nMerged test_dcp.py and test_base.py into test_other.py.\nRenamed test_simple.py to test_sim.py.\nRenamed test_dists.py to test_randomness.py.\nGitHub info: PR 488",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.4.0-2024-04-24",
    "href": "whatsnew.html#version-0.4.0-2024-04-24",
    "title": "What’s new",
    "section": "",
    "text": "Replace UIDArray, ArrayView, and State with Arr, which has different subclasses for different data types (e.g. FloatArr, BoolArr, and IndexArr). States are usually represented by BoolArr (e.g. sir.infected), while other agent properties are represented by FloatArr (e.g. sir.rel_trans).\nArrays that had previously been represented using an integer data type (e.g. sir.ti_infected) are now also FloatArr, to allow the use of np.nan. Integer arrays are supported via IndexArr, but these are only intended for use for slots and UIDs.\nArr objects automatically skip over dead (or otherwise removed) agents; the “active” UIDs are stored in sim.people.auids, which is updated when agents are born or die. This array is linked to each Arr, so that e.g. sim.people.age.mean() will only calculate the mean over alive agents. To access the underlying Numpy array, use sim.people.age.raw.\nFloatArr has isnan, notnan, and notnanvals properties. BoolArr has logical operations defined. For example, ~people.female works, but ~people.ti_dead does not; people.ti_dead.notnan works, but people.female.notnan does not.\nUIDs used to be NumPy integer arrays; they are now ss.uids objects (which is a class, but is lowercase for consistency with np.array(), which it is functionally similar to). Indexing a state by an integer array rather than ss.uids() now raises an exception, due to the ambiguity involved. To index the underlying array with an integer array, use Arr.raw[int_arr]; to index only the active/alive agents, use Arr.values[int_arr].\nDead agents are no longer removed, so uid always corresponds to the position in the array. This means that no remapping is necessary, which has a significant performance benefit (roughly 2x faster for large numbers of agents).\nRenamed omerge to dictmerge and omergeleft to dictmergeleft.\nGitHub info: PR 456",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.4-2024-04-18",
    "href": "whatsnew.html#version-0.3.4-2024-04-18",
    "title": "What’s new",
    "section": "",
    "text": "Default duration of edges in ss.RandomNet changed from 1 to 0; this does not matter if dt=1, but does matter with smaller dt values.\nRemoved ss.HPVNet.\nnew_deaths now counted for cholera.\nCrude birth and death rates now take dt into account.\nThe ability to use a centralized random number generator has been restored via ss.options(_centralized=True); this option not advised, but can be used for testing.\nGitHub info: PR 473",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.3-2024-04-16",
    "href": "whatsnew.html#version-0.3.3-2024-04-16",
    "title": "What’s new",
    "section": "",
    "text": "Changed Ebola model transmission logic.\nFixed bug with module names not being preserved with multiple initialization.\nGitHub info: PR 463",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.2-2024-04-08",
    "href": "whatsnew.html#version-0.3.2-2024-04-08",
    "title": "What’s new",
    "section": "",
    "text": "Change to syphilis model to permit latent transmission.\nGitHub info: PR 450",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.1-2024-03-31",
    "href": "whatsnew.html#version-0.3.1-2024-03-31",
    "title": "What’s new",
    "section": "",
    "text": "Added SIS model.\nFixes distribution initialization.\nAllows interventions and analyzers to be functions.\nTidies up tests.\nPerformance improvements in UIDArray (~3x faster for large numbers of agents).\nGitHub info: PR 428",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.3.0-2024-03-30",
    "href": "whatsnew.html#version-0.3.0-2024-03-30",
    "title": "What’s new",
    "section": "",
    "text": "Replaces ss.SingleRNG(), ss.MultiRNG(), ss.ScipyDistribution(), and ss.ScipyHistogram() with a single ss.Dist() class. The starsim.random and starsim.distributions submodules have been removed, and starsim.dists has been added.\nThe ss.Dist class uses np.random.default_rng() rather than scipy.stats by default, although a scipy.stats distribution can be supplied as an alternative. This is up to 4x faster (including, critically, for Bernoulli distributions).\nAlso removes ss.options.multirng (the new version is equivalent to it being always on).\nRemoves duplicate logic for transmission (make_new_cases())\nAdds new custom distributions such as ss.choice() and ss.delta().\nThese distributions can be called directly, e.g. dist = ss.weibull(c=2); dist(5) will return 5 random variates from a Weibull distribution.\nInstead of being manually initialized based on the name, the Sim object is parsed and all distributions will be initialized with a unique identifier based on their place in the object (e.g. sim.diseases.sir.pars.dur_inf), which is used to set their unique seed.\n\n\n\n\n\nThis PR also fixes bugs with lognormal parameters, and makes it clear whether the parameters are for the implicit normal distribution (ss.lognorm_im(), the NumPy/SciPy default, equivalent to ss.lognorm_mean() previously) or the “explicit” lognormal distribution (ss.lognorm_ex(), equivalent to ss.lognorm() previously).\nRenames ss.dx, ss.tx, ss.vx toss.Dx, ss.Tx, ss.Vx.\nRemoved set_numba_seed() as a duplicate of set_seed().\nGitHub info: PR 392",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.10-2024-03-18",
    "href": "whatsnew.html#version-0.2.10-2024-03-18",
    "title": "What’s new",
    "section": "",
    "text": "SIR duration of infection now accounts for dt\nReworked sir_vaccine to modify rel_sus instead of moving agents from susceptible to recovered.\nn_years no longer necessarily an integer\nGitHub info: PR 389",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.9-2024-03-18",
    "href": "whatsnew.html#version-0.2.9-2024-03-18",
    "title": "What’s new",
    "section": "",
    "text": "Renames and extends the multirng option in settings, now called ‘rng’, which set how random numbers are handled in Starsim with three options:\n\n“centralized” uses the centralized numpy random number generator for all distributions.\n“single” uses a separate (SingleRNG) random number generator for each distribution.\n“multi” uses a separate (MultiRNG) random number generator for each distribution.\n\nGitHub info: PR 349",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.8-2024-03-13",
    "href": "whatsnew.html#version-0.2.8-2024-03-13",
    "title": "What’s new",
    "section": "",
    "text": "Add ss.demo() to quickly create a default simulation.\nGitHub info: PR 380",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.7-2024-03-09",
    "href": "whatsnew.html#version-0.2.7-2024-03-09",
    "title": "What’s new",
    "section": "",
    "text": "Update StaticNet with defaults and correct argument passing\nGitHub info: PR 339",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.6-2024-02-29",
    "href": "whatsnew.html#version-0.2.6-2024-02-29",
    "title": "What’s new",
    "section": "",
    "text": "Make random number streams independent for SIR\nGitHub info: PR 307",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.5-2024-02-29",
    "href": "whatsnew.html#version-0.2.5-2024-02-29",
    "title": "What’s new",
    "section": "",
    "text": "Improve logic for making new cases with multi-RNG\nGitHub info: PR 337",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.4-2024-02-27",
    "href": "whatsnew.html#version-0.2.4-2024-02-27",
    "title": "What’s new",
    "section": "",
    "text": "Improve sim.summarize()\nImprove sim.plot()\nImprove SIR model defaults\nGitHub info: PR 320",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.3-2024-02-26",
    "href": "whatsnew.html#version-0.2.3-2024-02-26",
    "title": "What’s new",
    "section": "",
    "text": "Removes STI class\nChanges default death rate from units of per person to per thousand people\nAllows ss.Sim(demographics=True) to enable births and deaths\nFix pickling of State objects\nRename networks.py to network.py, and fix HIV mortality\nGitHub info: PRs 305, 308, 317",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.2-2024-02-26",
    "href": "whatsnew.html#version-0.2.2-2024-02-26",
    "title": "What’s new",
    "section": "",
    "text": "Add the Samples class\nGitHub info: PR 311",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.1-2024-02-22",
    "href": "whatsnew.html#version-0.2.1-2024-02-22",
    "title": "What’s new",
    "section": "",
    "text": "Only remove dead agents on certain timesteps\nGitHub info: PR 294",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.2.0-2024-02-15",
    "href": "whatsnew.html#version-0.2.0-2024-02-15",
    "title": "What’s new",
    "section": "",
    "text": "Code reorganization, including making networks.py and disease.py to the top level\nNetworks moved from People to Sim\nVarious classes renamed (e.g. FusedArray to UIDArray, STI to Infection)\nBetter type checking\nAdded MultiSim\nAdded cholera, measles, and Ebola\nAdded vaccination\nMore flexible inputs\nGitHub info: PR 235",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.8-2024-01-30",
    "href": "whatsnew.html#version-0.1.8-2024-01-30",
    "title": "What’s new",
    "section": "",
    "text": "Transmission based on number of contacts\nGitHub info: PR 220",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.7-2024-01-27",
    "href": "whatsnew.html#version-0.1.7-2024-01-27",
    "title": "What’s new",
    "section": "",
    "text": "Performance enhancement for disease transmission, leading to a 10% decrease in runtime.\nGitHub info: PR 217",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.6-2024-01-23",
    "href": "whatsnew.html#version-0.1.6-2024-01-23",
    "title": "What’s new",
    "section": "",
    "text": "Adds template interventions and products for diagnostics and treatment\nAdds syphilis screening & treatment interventions\nGitHub info: PR 210",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.5-2024-01-23",
    "href": "whatsnew.html#version-0.1.5-2024-01-23",
    "title": "What’s new",
    "section": "",
    "text": "Renamed stisim to starsim.\nGitHub info: PR 200",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.4-2024-01-23",
    "href": "whatsnew.html#version-0.1.4-2024-01-23",
    "title": "What’s new",
    "section": "",
    "text": "Adds a syphilis module\nGitHub info: PR 206",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.3-2024-01-22",
    "href": "whatsnew.html#version-0.1.3-2024-01-22",
    "title": "What’s new",
    "section": "",
    "text": "Read in age distributions for people initializations\nGitHub info: PR 205",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.2-2024-01-19",
    "href": "whatsnew.html#version-0.1.2-2024-01-19",
    "title": "What’s new",
    "section": "",
    "text": "Functionality for converting birth & fertility data to a callable parameter within SciPy distributions\nGitHub info: PR 203",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.1-2024-01-12",
    "href": "whatsnew.html#version-0.1.1-2024-01-12",
    "title": "What’s new",
    "section": "",
    "text": "Improving performance of MultiRNG\nNow factoring the timestep, dt, into transmission calculations\nGitHub info: PRs 204",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.1.0-2023-12-10",
    "href": "whatsnew.html#version-0.1.0-2023-12-10",
    "title": "What’s new",
    "section": "",
    "text": "Allows SciPy distributions to be used as parameters\nOptionally use multiple random number streams and other tricks to maintain coherence between simulations\nAdding functionality to convert death rate data to a callable parameter within a SciPy distribution\nGitHub info: PRs 170 and 202",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.8-2023-10-04",
    "href": "whatsnew.html#version-0.0.8-2023-10-04",
    "title": "What’s new",
    "section": "",
    "text": "Enable removing people from simulations following death\nGitHub info: PR 121",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.7-2023-09-08",
    "href": "whatsnew.html#version-0.0.7-2023-09-08",
    "title": "What’s new",
    "section": "",
    "text": "Refactor distributions to use new Distribution class\nGitHub info: PR 112",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.6-2023-08-30",
    "href": "whatsnew.html#version-0.0.6-2023-08-30",
    "title": "What’s new",
    "section": "",
    "text": "Changes agent IDs from index-based to UID-based\nAllows states to store their own data and live within modules\nGitHub info: PR 88",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.5-2023-08-29",
    "href": "whatsnew.html#version-0.0.5-2023-08-29",
    "title": "What’s new",
    "section": "",
    "text": "Refactor file structure\nGitHub info: PRs 77 and 86",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.2-2023-06-29",
    "href": "whatsnew.html#version-0.0.2-2023-06-29",
    "title": "What’s new",
    "section": "",
    "text": "Adds in basic Starsim functionality\nGitHub info: PR 17",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "whatsnew.html#version-0.0.1-2023-06-22",
    "href": "whatsnew.html#version-0.0.1-2023-06-22",
    "title": "What’s new",
    "section": "",
    "text": "Initial version.",
    "crumbs": [
      "Home",
      "**What's new**"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Starsim",
    "section": "",
    "text": "Starsim is an agent-based modeling framework designed for simulating the spread of diseases among agents via dynamic transmission networks. Starsim supports the co-transmission of multiple diseases at once, capturing how they interact biologically and behaviorally. Additionally, users can also include non-infectious diseases either on their own or as factors affecting infectious diseases. To enable the study of birth-related diseases, Starsim allows detailed modeling of mother-child relationships starting from conception. Finally, Starsim lets users compare different intervention strategies, such as vaccines or treatments, to examine their impact through various delivery methods such as mass campaigns or targeted outreach.\nExamples of systems that have already been implemented in Starsim include sexually transmitted infections (HIV, HPV, and syphilis, including co-transmission), respiratory infections (tuberculosis and RSV), other infectious diseases (Ebola and cholera), and underlying determinants of health (such as malnutrition).\nNote: Starsim is a general-purpose, multi-disease framework that builds on our previous suite of disease-specific models, which included Covasim, HPVsim, and FPsim. In cases where a distinction needs to be made, Starsim is also known as “the Starsim framework” or “Starsim Core,” while this collection of other models is known as the “Starsim suite.”\nFor more information about Starsim, please see the documentation. Information about Starsim for R is available at r.starsim.org.\n\n\nPython 3.10-3.13 or R.\nWe recommend, but do not require, installing Starsim in a virtual environment, such as Miniconda.\n\n\n\n\n\nStarsim is most easily installed via PyPI:\npip install starsim\nOr with uv:\nuv init example\ncd example\nuv add starsim\nStarsim can also be installed locally (including optional dependencies for testing and documentation). To do this, clone first this repository, then run:\npip install -e .[dev]\n(Note: if after doing this, Starsim works, but you see “Import could not be resolved” in your editor, use pip install -e . --config-settings editable_mode=strict instead; more info here.)\n\n\n\nR-Starsim is still under development. You can install it with:\n# install.packages(\"devtools\")\ndevtools::install_github(\"starsimhub/rstarsim\")\nlibrary(starsim)\ninit_starsim()\nSee r.starsim.org for more information.\n\n\n\n\nFull documentation, including tutorials and an API reference, is available at docs.starsim.org.\nYou can run a simple demo via:\nimport starsim as ss\nss.demo()\nHere is a slightly more realistic example of an SIR model with random connections between agents:\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 5_000,     # Number of agents to simulate\n    networks = dict(      # Networks define how agents interact w/ each other\n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 10   # Each person has 10 contacts with other people  \n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model\n        type = 'sir',     # Here, we're creating an SIR disease\n        init_prev = 0.01, # Proportion of the population initially infected\n        beta = 0.05,      # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot() # Plot all the sim results\nsim.diseases.sir.plot() # Plot the standard SIR curves\nMore usage examples are available in the tutorials, as well as the tests folder.\n\n\n\nStarsim includes a model context protocol (MCP) server that ensures your favorite AI-enabled editor/tool is Starsim-aware. For details, see the Starsim AI project.\n\n\n\nAll core model code is located in the starsim subfolder; standard usage is import starsim as ss.\nThe model consists of core classes including Sim, People, Disease, Network, Intervention, and more. These classes contain methods for running, building simple or dynamic networks, generating random numbers, calculating results, plotting, etc.\nThe submodules of the Starsim folder are as follows:\n\nanalyzers.py: The Analyzers class (for performing analyses on the sim while it’s running), and other classes and functions for analyzing simulations.\narrays.py: Classes to handle, store, and update states for people in networks in the simulation including living, mother, child, susceptible, infected, inoculated, recovered, etc.\ncalibration.py: Class to handle automated calibration of the model to data.\nconnectors.py: Classes for modulating interactions between modules (e.g. between two diseases).\ndebugtools.py: Helper functions and classes to aid with debugging model results and performance.\ndemographics.py: Classes to transform initial condition input parameters for use in building and utilizing networks.\ndiseases.py: Classes to manage infection rate of spread, prevalence, waning effects, and other parameters for specific diseases.\ndistributions.py: Classes that handle statistical distributions used throughout Starsim to produce random numbers.\ninterventions.py: The Intervention class, for adding interventions and dynamically modifying parameters, and classes for each of the specific interventions derived from it.\nloop.py: The logic for the main simulation integration loop.\nmodules.py: Class to handle “module” logic, such as updates (diseases, networks, etc).\nnetworks.py: Classes for creating simple and dynamic networks of people based on input parameters.\nparameters.py: Classes for creating the simulation parameters.\npeople.py: The People class, for handling updates of state for each person.\nproducts.py: Classes to manage the deployment of vaccines and treatments.\nresults.py: Classes to analyze and save results from simulations.\nrun.py: Classes for running simulations (e.g. parallel runs and the Scenarios and MultiSim classes).\nsamples.py: Class to store data from a large number of simulations.\nsettings.py: User-customizable options for Starsim (e.g. default font size).\nsim.py: The Sim class, which performs most of the heavy lifting: initializing the model, running, and plotting.\ntime.py: Time classes, such as dates, durations, probabilities, and frequencies.\ntimeline.py: The Timeline class, which coordinates time between the Sim and different modules.\nutils.py: Helper functions.\nversion.py: Version, date, and license information.\n\nStarsim also includes a starsim_examples folder, which contains definitions of different examples of diseases, including STIs, Ebola, and cholera. Note: these are illustrative examples only for demonstrating Starsim usage and functionality; for actual scientific research, please see other Starsim models, e.g. STIsim.\n\n\n\nQuestions or comments can be directed to info@starsim.org , or on this project’s GitHub page. Full information about Starsim is provided in the documentation.\n\n\n\nThe code in this repository was developed by IDM, the Burnet Institute, and other collaborators to support our joint research on flexible agent-based modeling. We’ve made it publicly available under the MIT License to provide others with a better understanding of our research and an opportunity to build upon it for their own work. We make no representations that the code works as intended or that we will provide support, address issues that are found, or accept pull requests. You are welcome to create your own fork and modify the code to suit your own modeling needs as permitted under the MIT License.\n\n\n\n\n\nTutorials\nAn interactive tour of Starsim’s key features.\n\n\nAPI reference\nFull details on all classes and functions.\n\n\nWhat’s new\nSee what’s in the latest Starsim releases.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#requirements",
    "href": "index.html#requirements",
    "title": "Starsim",
    "section": "",
    "text": "Python 3.10-3.13 or R.\nWe recommend, but do not require, installing Starsim in a virtual environment, such as Miniconda.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Starsim",
    "section": "",
    "text": "Starsim is most easily installed via PyPI:\npip install starsim\nOr with uv:\nuv init example\ncd example\nuv add starsim\nStarsim can also be installed locally (including optional dependencies for testing and documentation). To do this, clone first this repository, then run:\npip install -e .[dev]\n(Note: if after doing this, Starsim works, but you see “Import could not be resolved” in your editor, use pip install -e . --config-settings editable_mode=strict instead; more info here.)\n\n\n\nR-Starsim is still under development. You can install it with:\n# install.packages(\"devtools\")\ndevtools::install_github(\"starsimhub/rstarsim\")\nlibrary(starsim)\ninit_starsim()\nSee r.starsim.org for more information.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#usage-and-documentation",
    "href": "index.html#usage-and-documentation",
    "title": "Starsim",
    "section": "",
    "text": "Full documentation, including tutorials and an API reference, is available at docs.starsim.org.\nYou can run a simple demo via:\nimport starsim as ss\nss.demo()\nHere is a slightly more realistic example of an SIR model with random connections between agents:\nimport starsim as ss\n\n# Define the parameters\npars = dict(\n    n_agents = 5_000,     # Number of agents to simulate\n    networks = dict(      # Networks define how agents interact w/ each other\n        type = 'random',  # Here, we use a 'random' network\n        n_contacts = 10   # Each person has 10 contacts with other people  \n    ),\n    diseases = dict(      # *Diseases* add detail on what diseases to model\n        type = 'sir',     # Here, we're creating an SIR disease\n        init_prev = 0.01, # Proportion of the population initially infected\n        beta = 0.05,      # Probability of transmission between contacts\n    )\n)\n\n# Make the sim, run and plot\nsim = ss.Sim(pars)\nsim.run()\nsim.plot() # Plot all the sim results\nsim.diseases.sir.plot() # Plot the standard SIR curves\nMore usage examples are available in the tutorials, as well as the tests folder.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#ai-integration",
    "href": "index.html#ai-integration",
    "title": "Starsim",
    "section": "",
    "text": "Starsim includes a model context protocol (MCP) server that ensures your favorite AI-enabled editor/tool is Starsim-aware. For details, see the Starsim AI project.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#starsim-structure",
    "href": "index.html#starsim-structure",
    "title": "Starsim",
    "section": "",
    "text": "All core model code is located in the starsim subfolder; standard usage is import starsim as ss.\nThe model consists of core classes including Sim, People, Disease, Network, Intervention, and more. These classes contain methods for running, building simple or dynamic networks, generating random numbers, calculating results, plotting, etc.\nThe submodules of the Starsim folder are as follows:\n\nanalyzers.py: The Analyzers class (for performing analyses on the sim while it’s running), and other classes and functions for analyzing simulations.\narrays.py: Classes to handle, store, and update states for people in networks in the simulation including living, mother, child, susceptible, infected, inoculated, recovered, etc.\ncalibration.py: Class to handle automated calibration of the model to data.\nconnectors.py: Classes for modulating interactions between modules (e.g. between two diseases).\ndebugtools.py: Helper functions and classes to aid with debugging model results and performance.\ndemographics.py: Classes to transform initial condition input parameters for use in building and utilizing networks.\ndiseases.py: Classes to manage infection rate of spread, prevalence, waning effects, and other parameters for specific diseases.\ndistributions.py: Classes that handle statistical distributions used throughout Starsim to produce random numbers.\ninterventions.py: The Intervention class, for adding interventions and dynamically modifying parameters, and classes for each of the specific interventions derived from it.\nloop.py: The logic for the main simulation integration loop.\nmodules.py: Class to handle “module” logic, such as updates (diseases, networks, etc).\nnetworks.py: Classes for creating simple and dynamic networks of people based on input parameters.\nparameters.py: Classes for creating the simulation parameters.\npeople.py: The People class, for handling updates of state for each person.\nproducts.py: Classes to manage the deployment of vaccines and treatments.\nresults.py: Classes to analyze and save results from simulations.\nrun.py: Classes for running simulations (e.g. parallel runs and the Scenarios and MultiSim classes).\nsamples.py: Class to store data from a large number of simulations.\nsettings.py: User-customizable options for Starsim (e.g. default font size).\nsim.py: The Sim class, which performs most of the heavy lifting: initializing the model, running, and plotting.\ntime.py: Time classes, such as dates, durations, probabilities, and frequencies.\ntimeline.py: The Timeline class, which coordinates time between the Sim and different modules.\nutils.py: Helper functions.\nversion.py: Version, date, and license information.\n\nStarsim also includes a starsim_examples folder, which contains definitions of different examples of diseases, including STIs, Ebola, and cholera. Note: these are illustrative examples only for demonstrating Starsim usage and functionality; for actual scientific research, please see other Starsim models, e.g. STIsim.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "Starsim",
    "section": "",
    "text": "Questions or comments can be directed to info@starsim.org , or on this project’s GitHub page. Full information about Starsim is provided in the documentation.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#disclaimer",
    "href": "index.html#disclaimer",
    "title": "Starsim",
    "section": "",
    "text": "The code in this repository was developed by IDM, the Burnet Institute, and other collaborators to support our joint research on flexible agent-based modeling. We’ve made it publicly available under the MIT License to provide others with a better understanding of our research and an opportunity to build upon it for their own work. We make no representations that the code works as intended or that we will provide support, address issues that are found, or accept pull requests. You are welcome to create your own fork and modify the code to suit your own modeling needs as permitted under the MIT License.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "index.html#learn-more",
    "href": "index.html#learn-more",
    "title": "Starsim",
    "section": "",
    "text": "Tutorials\nAn interactive tour of Starsim’s key features.\n\n\nAPI reference\nFull details on all classes and functions.\n\n\nWhat’s new\nSee what’s in the latest Starsim releases.",
    "crumbs": [
      "Home",
      "**Home**"
    ]
  },
  {
    "objectID": "user_guide/workflows_sir_calibration.html",
    "href": "user_guide/workflows_sir_calibration.html",
    "title": "Parameter identification",
    "section": "",
    "text": "The Starsim framework includes a built-in susceptible-infected-recovered (SIR) within-host progression module that can be used as a building block to developing more realistic agent-based models. Here, we use that SIR within-host module in combination with mixing pool transmission to create a simple SIR disease model.\nHere, we use that SIR disease model to test two calibration workflows. The goal is to assess if they able to re-identify a known “true” set of parameters and explore the resulting latent trajectories. The two workflows demonstrated are: 1. Likelihood maximization using the optuna package as integrated with Starsim 2. Posterior sampling using a Bayesian workflow\nRe-identifying the known parameter values from synthetic data provides reassurance that the calibration workflow is functioning as expected. For a more realistic Starsim calibration example, please see Calibration.\n\n# Configure notebook autoreloading and inline plotting\n%load_ext autoreload\n%autoreload 2\n%matplotlib inline\n\n##%% Imports and settings\nimport optuna\noptuna.logging.set_verbosity(optuna.logging.CRITICAL)\nimport starsim as ss\nimport numpy as np\nimport pandas as pd\nimport sciris as sc\nimport matplotlib.dates as mdates\nimport seaborn as sns\nfrom IPython.display import display\nimport matplotlib.pyplot as plt\nfrom scipy.special import betaln, gammaln\n\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\nwarnings.filterwarnings('ignore', category=optuna.exceptions.ExperimentalWarning)\n\n\nSIR model setup\nFirst, we create a simple agent-based SIR simulation using Starsim.\n\ndef make_sim():\n    \"\"\"\n    Make a simple SIR simulation using Starsim.\n\n    Returns\n    -------\n    Sim\n        A single simulation that has been configured, but not initialized or run.\n    \"\"\"\n    sir_pars = dict(\n        init_prev = 0.01, # Initial prevalence\n        p_death = 0,      # No deaths\n    )\n    sir = ss.SIR(pars=sir_pars)\n\n    net = ss.MixingPool(\n        beta = 1,       # This is a multiplier on the disease beta\n        n_contacts = 2, # Poisson lambda\n    )\n\n    sim_pars = dict(\n        n_agents = 500,      # Number of agents in the simulation\n        dt = ss.days(1),      # One-day time step\n        start = '2025-01-01', # Start date of the simulation\n        dur = 100,            # Duration of the simulation\n        verbose = 0,          # Level of detail printed to the console\n    )\n    sim = ss.Sim(pars=sim_pars, diseases=sir, networks=net)\n    return sim\n\ndef modify_sim(sim, calib_pars, rand_seed=0):\n    \"\"\"\n    Modify the given simulation with the calibration parameters and random seed.\n    \n    Parameters\n    ----------\n    sim : Sim\n        The simulation to modify.\n    calib_pars : dict\n        The calibration parameters to apply; note that the parameter values to use are stored in \"value.\"\n    rand_seed : int\n        The random seed to use for the simulation.\n\n    Returns\n    -------\n    Sim\n        The modified simulation.\n    \"\"\"\n\n    # Explicitly look for each of the calibration parameters and set the appropriate values\n    if 'beta' in calib_pars:\n        β = ss.perday(calib_pars['beta']['value']) # Use per-day for the transmission rate\n        sim.pars.diseases.pars['beta'] = β\n\n    if 'gamma' in calib_pars:\n        γ = calib_pars['gamma']['value']\n        sim.pars.diseases.pars['dur_inf'].set(1/γ)\n\n    sim.pars['rand_seed'] = rand_seed\n\n    return sim\n\ndef run_starsim(pars, rand_seed=0):\n    \"\"\"\n    Run a Starsim SIR model with given parameters and random seed, returning results.\n\n    Parameters\n    ----------\n    pars : dict\n        The parameters dictionary with Optuna a values stored in \"value.\"\n    rand_seed : int\n        The random seed to use for the simulation.\n\n    Returns\n    -------\n    dataframe\n        The results of the SIR model with columns of S, I, and R and index of Time.\n    \"\"\"\n    # Make and modify the simulation\n    sim = make_sim()\n    sim = modify_sim(sim, pars, rand_seed)\n\n    sim.run() # Run the simulation\n\n    # Extract the results\n    results = pd.DataFrame(dict(\n        S = sim.results.sir.n_susceptible,\n        I = sim.results.sir.n_infected,\n        R = sim.results.sir.n_recovered,\n    ), index=pd.Index(sim.results.timevec, name='Time'))\n    results['rand_seed'] = rand_seed # Store the random seed for later reference\n\n    return results\n\n\n\nCalibration setup\nWe will calibrate two parameters, beta and gamma, each allowed to take on values between 0 and 1.\n\n# Define the calibration parameters in a simple dictionary\ncalib_pars = dict(\n    beta = {'low': 0, 'high': 0.15},\n    gamma = {'low': 0, 'high': 0.08},\n)\n\nIf using the optimization-based approach in Starsim, likelihood functions are defined and available for use. However, for the sampling-based approach, we will need to create our own likelihood.\n\ndef beta_binomial_likelihood(results, calib_data,\n    kappa       = 10.0,\n    prior_alpha = 1.0,\n    prior_beta  = 1.0\n):\n    \"\"\"\n    Likelihood for Beta-Binomial observation model:\n        s_obs ~ BetaBinomial(n_obs, alpha=kappa*p_hat, beta=kappa*(1-p_hat))\n        p_hat is computed as (sim_x + prior_alpha) / (sim_n + prior_alpha + prior_beta).\n\n    Parameters\n    ----------\n    results: DataFrame\n        The results of a simulation.\n    calib_data: DataFrame\n        The calibration data to compare against.\n    kappa: float\n        Concentration parameter: larger values imply less over-dispersion.\n    prior_alpha: float\n        Prior alpha used to smooth the estimate of p_hat.\n    prior_beta: float\n        Prior beta used to smooth the estimate of p_hat.\n\n    Returns\n    -------\n    float\n        The likelihood of the observed data given the simulation results.\n    \"\"\"\n\n    obs_x = calib_data['x'].values\n    obs_n = calib_data['n'].values\n\n    sim_x = results['I']\n    sim_n = results.sum(axis=1)\n\n    denom = np.maximum(sim_n + prior_alpha + prior_beta, 1e-12)  # guard\n    p_hat = (sim_x + prior_alpha) / denom\n\n    p_hat = np.clip(p_hat, 1e-9, 1 - 1e-9)\n    alpha = kappa * p_hat\n    beta  = kappa * (1.0 - p_hat)\n\n    # log binomial coefficient: log C(n, x)\n    logC = gammaln(obs_n + 1) - gammaln(obs_x + 1) - gammaln(obs_n - obs_x + 1)\n    loglik = logC + betaln(obs_x + alpha, obs_n - obs_x + beta) - betaln(alpha, beta)\n    return np.exp(np.sum(loglik)) # Exponentiated sum of logs\n\nBayesian calibration requires a prior distribution over the parameters. Here, we define a simple uniform prior over beta and gamma.\n\ndef sample_from_prior(size=1):\n    \"\"\"\n    Sample beta and gamma from a uniform prior.\n\n    Parameters\n    ----------\n    size : int\n        Number of samples to draw.\n\n    Returns\n    -------\n    Pandas DataFrame\n        DataFrame of shape (size, 2) with columns [beta, gamma].\n    \"\"\"\n    beta = np.random.uniform(calib_pars['beta']['low'], calib_pars['beta']['high'], size)\n    gamma = np.random.uniform(calib_pars['gamma']['low'], calib_pars['gamma']['high'], size)\n\n    return pd.DataFrame({'beta': beta, 'gamma': gamma})\n\n\n\nGenerate synthetic data for reidentification\nThat set the basic machinery of the SIR simulation model. Next, we’ll create some synthetic data to use as calibration targets. Because the model is stochastic, we’ll average over several replicates.\n\nn_reps = 25 # Average over 25 repetitions to reduce stochastic noise\n\n# These are the true parameters the optimizer will later try to identify\ntrue_pars = dict(\n    beta = dict(value=0.05),\n    gamma = dict(value=0.03),\n)\n\n# Run the starsim SIR simulations in parallel.\n# If you need to run in serial, for example when debugging, simply set serial=True\nresults_list = sc.parallelize(run_starsim, pars=true_pars, iterkwargs=dict(rand_seed=np.arange(n_reps)), serial=False)\nresults = pd.concat(results_list) # Combine the results into a single DataFrame\nave = results.groupby('Time').mean().drop(columns='rand_seed') # Average the results over the repetitions\n\n# Extract synthetic data for calibration\nobservation_times = np.array([pd.Timestamp('2025-01-01')+pd.DateOffset(days=d) for d in [20, 40, 80]])\nstarsim_data = pd.DataFrame({\n    'x': ave.loc[observation_times, 'I'].astype(int),\n    'n': ave.loc[observation_times].sum(axis=1).astype(int),\n    'Prevalence': ave.loc[observation_times, 'I'] / ave.loc[observation_times].sum(axis=1)\n}, index=pd.Index(observation_times, name='t'))\n\nprint('Here is the data extracted from the average simulation to be used during calibration:\\n')\ndisplay(starsim_data)\n\n# Plot the results, vertical dashed lines indicate the observation times where prevalence is measured\ndf = results.reset_index().melt(id_vars=['Time', 'rand_seed'], value_vars=['S', 'I', 'R'], var_name='State', value_name='Count')\nax = sns.lineplot(data=df, hue='State', x='Time', y='Count', units='rand_seed', estimator=None, alpha=0.5, lw=0.5, legend=False)\nsns.lineplot(data=df, hue='State', x='Time', y='Count', errorbar=('pi', 50), ax=ax, legend=True)\nax.xaxis.set_major_formatter(mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\nfor ot in observation_times:\n    ax.axvline(ot, ls='--', color='black')\nax.scatter(starsim_data.index, starsim_data['x'], marker='o', color='black', label='Observed data', zorder=10);\n\nHere is the data extracted from the average simulation to be used during calibration:\n\n\n\n\n\n\n\n\n\n\nx\nn\nPrevalence\n\n\nt\n\n\n\n\n\n\n\n2025-01-21\n29\n500\n0.05832\n\n\n2025-02-10\n118\n500\n0.23720\n\n\n2025-03-22\n246\n500\n0.49352\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLikelihood maximization using the optuna package as integrated with Starsim\n\nStarsim provides built-in integration with Optuna to make advanced model calibration easier. We demonstrate that linkage below using a Beta-binomial likelihood function.\n\nsim = make_sim() # Begin by making a single \"base\" simulation with default parameters\n\n# This example will use a single calibration component. We choose a\n# Beta-binomial functional form to represent the \"prevalence survey\" data,\n# taking advantage of both the numerator (x) and denominator (n) data.\nprevalence_component = ss.BetaBinomial(\n    name = 'SIR Disease Prevalence',\n\n    # The starsim_data data has a date for each observation. The\n    # \"step_containing\" conform method will extract simulation results on the\n    # time step containing the observation date.\n    conform = 'step_containing',\n\n    # Here is the data we are trying to match, using the \"x\" and \"n\" columns\n    # from the starsim_data DataFrame.\n    expected = starsim_data[['x', 'n']],\n\n    # And here is how we will extract the relevant data from the simulation results\n    extract_fn = lambda sim: pd.DataFrame({\n        'x': sim.results.sir.n_infected, # Numerator\n        'n': sim.results.n_alive,        # Denominator\n    }, index=pd.Index(sim.results.timevec, name='t')),\n)\n\n# Now make the calibration\ncalib = ss.Calibration(\n    sim          = sim,                    # The base simulation\n    calib_pars   = calib_pars,             # The calibration parameters\n    build_fn     = modify_sim,             # The function to modify the base simulation with the calibration parameters\n    reseed       = True,                   # Reseed the simulation for each calibration trial\n    components   = [prevalence_component], # The calibration components\n    total_trials = 100,                    # Total number of trials to run\n    verbose      = False,                  # Shh...\n\n    # Select and configure the sampler (optional)\n    sampler = optuna.samplers.TPESampler(n_startup_trials=50)\n)\n\ncalib.calibrate() # Let's go!\n\n# Print out a summary\nsc.colorize(color='blue', string=f'The best parameters identified by the optimization are:\\n\\\n    * {calib.best_pars}\\n\\\n    These parameters should be close to the true parameters:\\n\\\n    * {true_pars}\\n\\\n    The best parameters resulted in a loss of {calib.study.best_value}.')\n\nThe best parameters identified by the optimization are:\n    * {'beta': 0.0632120323704147, 'gamma': 0.03260109138334929, 'rand_seed': 41802}\n    These parameters should be close to the true parameters:\n    * {'beta': {'value': 0.05}, 'gamma': {'value': 0.03}}\n    The best parameters resulted in a loss of 3.71360251126859.\n\n\nIt seems like the best parameter values are pretty close to the right values, so that’s good. We can look at all the results and easily create a DataFrame containing the top K runs.\n\ndf = calib.to_df(top_k=10)\ndisplay(df)\n\n\n\n\n\n\n\n\nvalue\ndatetime_start\ndatetime_complete\nduration\nparams_beta\nparams_gamma\nparams_rand_seed\nstate\n\n\nnumber\n\n\n\n\n\n\n\n\n\n\n\n\n83\n3.713603\n2026-02-13 23:23:48.889812\n2026-02-13 23:23:49.409839\n0 days 00:00:00.520027\n0.063212\n0.032601\n41802\nCOMPLETE\n\n\n78\n3.761700\n2026-02-13 23:23:48.828736\n2026-02-13 23:23:49.288364\n0 days 00:00:00.459628\n0.062957\n0.032999\n131811\nCOMPLETE\n\n\n80\n3.769859\n2026-02-13 23:23:48.888945\n2026-02-13 23:23:49.250507\n0 days 00:00:00.361562\n0.061501\n0.032714\n132531\nCOMPLETE\n\n\n89\n3.786013\n2026-02-13 23:23:49.142138\n2026-02-13 23:23:49.568695\n0 days 00:00:00.426557\n0.061217\n0.033471\n149744\nCOMPLETE\n\n\n82\n3.799132\n2026-02-13 23:23:48.949156\n2026-02-13 23:23:49.373515\n0 days 00:00:00.424359\n0.060890\n0.033478\n124973\nCOMPLETE\n\n\n85\n3.817062\n2026-02-13 23:23:49.026231\n2026-02-13 23:23:49.256838\n0 days 00:00:00.230607\n0.060755\n0.033794\n141432\nCOMPLETE\n\n\n88\n3.825704\n2026-02-13 23:23:49.128587\n2026-02-13 23:23:49.446739\n0 days 00:00:00.318152\n0.061037\n0.033811\n142797\nCOMPLETE\n\n\n72\n3.841721\n2026-02-13 23:23:48.664321\n2026-02-13 23:23:49.121829\n0 days 00:00:00.457508\n0.061450\n0.032218\n144634\nCOMPLETE\n\n\n90\n3.873609\n2026-02-13 23:23:49.143004\n2026-02-13 23:23:49.363857\n0 days 00:00:00.220853\n0.060985\n0.034179\n150398\nCOMPLETE\n\n\n91\n3.887816\n2026-02-13 23:23:49.169115\n2026-02-13 23:23:49.399879\n0 days 00:00:00.230764\n0.061777\n0.034210\n166763\nCOMPLETE\n\n\n\n\n\n\n\n\n# Plot the results\nfigs = calib.plot_optuna(['plot_optimization_history', 'plot_contour'])\nfigs[0].axes.set_yscale('log')\n\nfigs[1].axvline(true_pars['beta']['value'], ls='--', color='black')\nfigs[1].axhline(true_pars['gamma']['value'], ls='--', color='black')\nfigs[1].scatter(calib.study.best_params['beta'], calib.study.best_params['gamma'], 100, marker='x', color='red', zorder=10);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, let’s run some simulations with the best parameters and compare to the calibration data. From a mathemtatical perspective, this is not the right thing to do. We have found the maximum-likelihood estimate (MLE) parameters, \\(\\theta\\), and are now running simulations \\(X \\mid \\theta\\). These latent state trajectories represent the intrinsic noise in the model, but do not represent uncertainty. For that, additional methods are required or use a Bayesian approach, as illustrated below.\n\nn_reps = 10 # Number of repetitions to run\n\n# These are the best parameters found, the MLE estimate\nbest_pars = dict(\n    beta = dict(value=calib.study.best_params['beta']),\n    gamma = dict(value=calib.study.best_params['gamma']),\n)\n\n# Run the starsim SIR simulations in parallel, cool! If you need to run in\n# serial, for example when debugging, simply set serial=True\nresults_list = sc.parallelize(run_starsim, pars=best_pars, iterkwargs=dict(rand_seed=np.arange(n_reps)), serial=False)\nresults = pd.concat(results_list) # Combine the results into a single DataFrame\n\n# Plot the results, vertical dashed lines indicate the observation times where prevalence is measured\ndf = results.reset_index().melt(id_vars=['Time', 'rand_seed'], value_vars=['S', 'I', 'R'], var_name='State', value_name='Count')\nax = sns.lineplot(data=df, hue='State', x='Time', y='Count', units='rand_seed', estimator=None, alpha=0.5, lw=0.5, legend=False)\nsns.lineplot(data=df, hue='State', x='Time', y='Count', errorbar=('pi', 50), ax=ax, legend=True)\nax.xaxis.set_major_formatter(mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\nfor ot in observation_times:\n    ax.axvline(ot, ls='--', color='black')\nax.scatter(starsim_data.index, starsim_data['x'], marker='o', color='black', label='Observed data');\n\n\n\n\n\n\n\n\n\n\nBayesian calibration using sampling-importance resampling (SIR)\n\nNow let’s use a Bayesian calibration approach to see if the results are any different. We’ll use a simple ABC rejection sampling with a beta-binomial likelihood. A key difference is that we’re learning a posterior distribution over both parameters and trajectories rather than just a point estimate of the parameters.\n\nN = 100  # Number of prior samples (more is better, but slower)\n# For Beta-Binomial, the concentration parameter. Lower kappa --&gt; broader\n# posterior and higher effective sample size (ESS) for the same N. But not a\n# free parameter, kappa comes from the over-dispersion in the observed data.\nkappa = 10 \n\n# Sample from the prior\nprior_samples = sample_from_prior(size=N)\n\nrand_seeds = np.random.randint(0, 1e6, size=2*N)\nrand_seeds = np.unique(rand_seeds)[:N]\n\n# Prepare parameter dicts for each sample\nsample_pars_list = [\n    {\n        'pars': {'beta': {'value': row['beta']}, 'gamma': {'value': row['gamma']}},\n        'rand_seed': rand_seeds[idx]  # Random seed for each simulation\n    }\n    for idx, row in prior_samples.iterrows()\n]\n\n# Run simulations in parallel and collect trajectories\nsim_results_list = sc.parallelize(run_starsim, iterkwargs=sample_pars_list, serial=False)\n\n# Store latent state trajectories for each sample\ntrajectories = pd.concat(sim_results_list) \\\n    .reset_index() \\\n    .set_index(['rand_seed', 'Time'])\n\n\n# Compute likelihoods for each sample\nlikelihoods = []\nfor rand_seed, sim_result in trajectories.groupby('rand_seed'):\n    sim_sir = sim_result.loc[rand_seed].loc[observation_times, ['S', 'I', 'R']]\n    likelihood = beta_binomial_likelihood(sim_sir, starsim_data, kappa=kappa)\n    likelihoods.append((rand_seed, likelihood))\n\nresults = pd.DataFrame(likelihoods, columns=['rand_seed', 'likelihood'])\nresults = pd.concat([prior_samples, results], axis=1).set_index('rand_seed')\n\nWithin a Bayesian workflow, there are two ways to proceed from this point. 1. Use all samples, weighted by their likelihood. For this approach, there is no resampling step. 2. Resample \\(K \\leq N\\) samples with probability proportional to their likelihood (with replacement). This is sampling-importance resampling (SIR), not to be confused with the susceptible-infected-recovered (SIR) model. Ideally, we would choose \\(K=N\\) resamples, but if using these samples for further analysis, it may be useful to choose \\(K &lt; N\\) to reduce computational cost. It’s generally recommended to choose \\(K\\) as one to two times the effective sample size (ESS).\n\nresults['weight'] = results['likelihood'] / np.sum(results['likelihood'])\n\n# Importance resampling\nESS = 1 / np.sum(results['weight']**2)\nprint('='*60)\nprint(f'Effective Sample Size (ESS) = {ESS:.1f} out of {N}')\nif ESS &lt; 30:\n    print('WARNING: ESS is below 30, consider increasing N')\nprint('='*60)\n\n\nK = np.ceil(1.5 * ESS).astype(int)  # Number of samples to draw\nprint('Resampling K =', K, 'samples from the weighted ensemble of N =', N, 'samples')\nresample_seeds = np.random.choice(results.index, size=K, replace=True, p=results['weight'])\n\n# Merge results into combined (all) and selected (K&lt;N subset)\ncombined = trajectories.reset_index().merge(results, on='rand_seed').set_index(['rand_seed', 'Time'])\nselected = combined.loc[resample_seeds]\n\n# Show posterior samples as a DataFrame\nposterior_pars = results.loc[resample_seeds, ['beta', 'gamma']]\ndisplay(posterior_pars.head())\n\n============================================================\nEffective Sample Size (ESS) = 3.3 out of 100\nWARNING: ESS is below 30, consider increasing N\n============================================================\nResampling K = 5 samples from the weighted ensemble of N = 100 samples\n\n\n\n\n\n\n\n\n\nbeta\ngamma\n\n\nrand_seed\n\n\n\n\n\n\n125163\n0.038818\n0.018583\n\n\n285394\n0.020521\n0.022068\n\n\n95034\n0.047554\n0.031171\n\n\n95034\n0.047554\n0.031171\n\n\n521971\n0.034000\n0.035225\n\n\n\n\n\n\n\nLet’s look at the parameters, full (weighted) posterior mean, and posterior mean from the resample.\n\nfig, ax = plt.subplots(figsize=(7, 6))\n\n# Scatter all prior samples, colored by likelihood\nscat = ax.scatter(\n    results['beta'], results['gamma'],\n    c=results['weight'], cmap='viridis', s=15, edgecolor='none', alpha=0.8\n)\n\n# Overlay red rings for the K resampled posterior samples\nax.scatter(\n    results.loc[resample_seeds, 'beta'], results.loc[resample_seeds, 'gamma'],\n    facecolors='none', edgecolors='red', s=25, linewidths=1, label='Resampled'\n)\n\n# Overlay the true parameter values and best posterior sample\nax.axvline(true_pars['beta']['value'], ls='--', color='black', label='True parameters')\nax.axhline(true_pars['gamma']['value'], ls='--', color='black')\n\n# Mark the full and resampled posterior means\nfull_posterior_mean = results[['beta', 'gamma']].T.dot(results['weight'])\nax.scatter(full_posterior_mean.beta, full_posterior_mean.gamma, 100, marker='x', color='red', lw=2, zorder=10, label='Posterior mean (full)')\nposterior_mean = results.loc[resample_seeds, ['beta', 'gamma']].mean(axis=0)\nax.scatter(posterior_mean.beta, posterior_mean.gamma, 100, marker='x', color='blue', lw=2, zorder=11, label='Posterior mean (resampled)')\n\nax.set_xlabel('beta')\nax.set_ylabel('gamma')\nax.set_title('Posterior parameter samples (red rings) and prior samples (colored by likelihood)')\nplt.colorbar(scat, ax=ax, label='Normalized likelihood')\n# Move the legend outside the figure to the right\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nView latent trajectories based on all \\(N\\) samples, weighted by their likelihood. Takes some code to incorporate the weights into the plotting…\n\n# Use ALL samples, with weights, to compute mean and quantiles\ndf = combined \\\n    .reset_index() \\\n    .melt(\n        id_vars=['Time', 'rand_seed'],\n        value_vars=['S', 'I', 'R'],\n        var_name='State',\n        value_name='Count'\n    )\ndf['Weight'] = df['rand_seed'].map(results['weight']) # Add weights to the DataFrame\n\ndef weighted_quantile(values, quantiles, weights):\n    v = np.asarray(values, float)\n    q = np.atleast_1d(quantiles).astype(float)\n    w = np.asarray(weights, float)\n    order = np.argsort(v)\n    v, w = v[order], w[order]\n    cw = np.cumsum(w)\n    cw /= cw[-1] if cw[-1] &gt; 0 else 1.0\n    return np.interp(q, cw, v)\n\ndef summarize(group):\n    vals = group['Count'].to_numpy()\n    wts  = group['Weight'].to_numpy()\n    mean = np.average(vals, weights=wts)\n    q05, q25, q75, q95 = weighted_quantile(vals, [0.05, 0.25, 0.75, 0.95], wts)\n    return pd.Series({'mean': mean, 'q05': q05, 'q25': q25, 'q75': q75, 'q95': q95})\n\nsummary = (\n    df.groupby(['Time','State'], sort=True, as_index=False)\n      .apply(summarize)\n      .reset_index(drop=True)\n)\n\nfig, ax = plt.subplots(figsize=(9,5))\nlines = sns.lineplot(data=summary, x='Time', y='mean', hue='State', hue_order=['S', 'I', 'R'],\n                     estimator=None, errorbar=None, ax=ax, zorder=5)\n\n# Get the colors used by seaborn for each state\nstate_colors = {line.get_label(): line.get_color() for line in ax.lines}\n\nfor state, g in summary.groupby('State'):\n    color = state_colors.get(state, None)\n    ax.fill_between(g['Time'], g['q05'], g['q95'], alpha=0.12, linewidth=0, color=color)  # 90% band\n    ax.fill_between(g['Time'], g['q25'], g['q75'], alpha=0.25, linewidth=0, color=color)  # 50% band\n\nfor ot in observation_times:\n    ax.axvline(ot, ls='--', color='black')\nax.scatter(starsim_data.index, starsim_data['x'], marker='o', color='black', label='Observed data', zorder=10);\n\nax.set_ylabel('Count')\nax.set_title('Weighted posterior trajectories')\nax.legend(title='State')\nax.xaxis.set_major_formatter(mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\n# Plot the resampled trajectories. Should be similar to the weighted posterior over latent trajectories shown above.\ndf = selected \\\n    .reset_index() \\\n    .melt(\n        id_vars=['Time', 'rand_seed'],\n        value_vars=['S', 'I', 'R'],\n        var_name='State',\n        value_name='Count'\n    )\n\nfig, ax = plt.subplots(figsize=(9,5))\nsns.lineplot(data=df, hue='State', x='Time', y='Count', units='rand_seed', estimator=None, alpha=0.5, lw=0.2, legend=False, ax=ax)\nsns.lineplot(data=df, hue='State', x='Time', y='Count', errorbar=('pi', 50), alpha=0.5, ax=ax, legend=True, zorder=5)\nsns.lineplot(data=df, hue='State', x='Time', y='Count', errorbar=('pi', 90), alpha=0.25, ax=ax, legend=False, zorder=6)\nax.xaxis.set_major_formatter(mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\nfor ot in observation_times:\n    ax.axvline(ot, ls='--', color='black')\nax.scatter(starsim_data.index, starsim_data['x'], marker='o', color='black', label='Observed data', zorder=10);\nax.legend(title='State')\nax.set_title('Resampled posterior trajectories')\nplt.tight_layout()\n\n\n\n\n\n\n\n\nThe next step would be scenario analysis using these \\(K\\) resamples parameters and latent trajectories. Each of these \\(K\\) samples represents a different possible future trajectory of the epidemic, and the ensemble of these \\(K\\) trajectories can be used to quantify uncertainty in future projections. Each of these \\(K\\) trajectories should be simulated forward \\(M\\) times for each scenario, using common random numbers, to produce final results.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Parameter identification"
    ]
  },
  {
    "objectID": "user_guide/advanced_time.html",
    "href": "user_guide/advanced_time.html",
    "title": "Time",
    "section": "",
    "text": "Starsim’s implementation of time is complex, because, well, time is complex. Some questions we’ve had to wrestle with:\n\nIf you run a simulation from 2000 to 2020 with monthly timesteps, would you expect the same average result (say, number of infections) in 2004 (leap year) and 2005 (not a leap year)? What about February 2012 vs. March 2012?\nIs a year 365 days, 365.25 days, or either 365 or 366 days depending on the year?\nUsually years and dates are interchangeable, e.g. float(2000) == ss.date('2000-01-01'). So start=2000, stop=2020 is equivalent to start='2000-01-01', stop='2020-01-01'. But what if someone wants to simply run for a number of years, e.g. start=0, stop=20, given that there is no year 0?\nIf the user has scheduled an event to happen at fractional year 2025.7, do they mean the nearest day (2025-09-12) or do they mean that exact timestamp (2025-09-11 16:48:00)? Will users ever want to worry about hours and minutes? What about microseconds and nanoseconds?\nShould units be strict, e.g. ss.days(5) != 5, or permissive, e.g. ss.days(5) == 5?\nIf a mortality rate is specified as “100 deaths per 1000 people per year”, at the end of a year, should 100 people die (“100 deaths per 1000 people counted from the beginning to the end of a year”), or should 95 die (“100 deaths per 1000 person-years”, since people stop accruing person-years after they die)?\nWhat does it mean to multiply a probability? Is ss.prob(0.1)*2 == ss.prob(0.2)? If so, what is ss.prob(0.5)*2 or ss.prob(0.9)*2?\n\nWhy are we telling you all this? Because although time seems intuitive, there are many corner cases where intuition breaks down (and, worse, it might not seem like it has broken down, leading you astray!). Thus, perhaps more than any other part of Starsim, be sure to check your assumptions about time. For example, in answer to the questions above (which are some but not all of the thorny issues we encountered!), we’ve made the following decisions – but we recognize that different decisions would also be valid:\n\nA month is defined as exactly 1/12th of a year, so there are the same number of infections in 2004 and 2005, and in February vs. March.\nA year is equal to 365 days (although some stretching happens to make integer years and calendar dates line up where needed).\nBecause there is no way to represent year 0 with a date object (e.g. ss.date(), which is based on pd.Timestamp), for this (important) special case we need to switch to a different object, ss.datedur() (more on that below).\nWe assume the user means integer days, unless they have explicitly requested otherwise (e.g. dt=ss.days(0.1)).\nUnits are loose when comparing to unitless quantities (ss.days(5) == 5), but are strict when comparing with other units (e.g. ss.years(1) == ss.days(365)).\nIn Starsim v2, we chose the former by default. In Starsim v3, we decided we were wrong to do that and now choose the latter.\nProbabilities are always constrained to [0, 1], so ss.prob(0.5)*2 == ss.prob(0.75), but this also means that ss.prob(0.1)*2 ≈ ss.prob(0.19).\n\nMore information about the philosophy of time is available here.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Time"
    ]
  },
  {
    "objectID": "user_guide/advanced_time.html#on-the-philosophy-of-time",
    "href": "user_guide/advanced_time.html#on-the-philosophy-of-time",
    "title": "Time",
    "section": "",
    "text": "Starsim’s implementation of time is complex, because, well, time is complex. Some questions we’ve had to wrestle with:\n\nIf you run a simulation from 2000 to 2020 with monthly timesteps, would you expect the same average result (say, number of infections) in 2004 (leap year) and 2005 (not a leap year)? What about February 2012 vs. March 2012?\nIs a year 365 days, 365.25 days, or either 365 or 366 days depending on the year?\nUsually years and dates are interchangeable, e.g. float(2000) == ss.date('2000-01-01'). So start=2000, stop=2020 is equivalent to start='2000-01-01', stop='2020-01-01'. But what if someone wants to simply run for a number of years, e.g. start=0, stop=20, given that there is no year 0?\nIf the user has scheduled an event to happen at fractional year 2025.7, do they mean the nearest day (2025-09-12) or do they mean that exact timestamp (2025-09-11 16:48:00)? Will users ever want to worry about hours and minutes? What about microseconds and nanoseconds?\nShould units be strict, e.g. ss.days(5) != 5, or permissive, e.g. ss.days(5) == 5?\nIf a mortality rate is specified as “100 deaths per 1000 people per year”, at the end of a year, should 100 people die (“100 deaths per 1000 people counted from the beginning to the end of a year”), or should 95 die (“100 deaths per 1000 person-years”, since people stop accruing person-years after they die)?\nWhat does it mean to multiply a probability? Is ss.prob(0.1)*2 == ss.prob(0.2)? If so, what is ss.prob(0.5)*2 or ss.prob(0.9)*2?\n\nWhy are we telling you all this? Because although time seems intuitive, there are many corner cases where intuition breaks down (and, worse, it might not seem like it has broken down, leading you astray!). Thus, perhaps more than any other part of Starsim, be sure to check your assumptions about time. For example, in answer to the questions above (which are some but not all of the thorny issues we encountered!), we’ve made the following decisions – but we recognize that different decisions would also be valid:\n\nA month is defined as exactly 1/12th of a year, so there are the same number of infections in 2004 and 2005, and in February vs. March.\nA year is equal to 365 days (although some stretching happens to make integer years and calendar dates line up where needed).\nBecause there is no way to represent year 0 with a date object (e.g. ss.date(), which is based on pd.Timestamp), for this (important) special case we need to switch to a different object, ss.datedur() (more on that below).\nWe assume the user means integer days, unless they have explicitly requested otherwise (e.g. dt=ss.days(0.1)).\nUnits are loose when comparing to unitless quantities (ss.days(5) == 5), but are strict when comparing with other units (e.g. ss.years(1) == ss.days(365)).\nIn Starsim v2, we chose the former by default. In Starsim v3, we decided we were wrong to do that and now choose the latter.\nProbabilities are always constrained to [0, 1], so ss.prob(0.5)*2 == ss.prob(0.75), but this also means that ss.prob(0.1)*2 ≈ ss.prob(0.19).\n\nMore information about the philosophy of time is available here.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Time"
    ]
  },
  {
    "objectID": "user_guide/advanced_time.html#dates",
    "href": "user_guide/advanced_time.html#dates",
    "title": "Time",
    "section": "Dates",
    "text": "Dates\nStarsim defines a custom date object, ss.date, which is based on pd.Timestamp. It is quite flexible in terms of input:\n\nimport pandas as pd\nimport datetime as dt\nimport starsim as ss\nimport matplotlib.pyplot as plt\nss.options(jupyter=True)\n\nd1 = ss.date(2020)\nd2 = ss.date(2020, 1, 1)\nd3 = ss.date('2020-01-01')\nd4 = ss.date(pd.Timestamp('2020-01-01'))\nd5 = ss.date(dt.datetime(2020, 1, 1))\n\nassert d1 == d2 == d3 == d4 == d5\nprint(d1)\n\n2020.01.01\n\n\nDates are interchangeable with floating point years (although be careful, as despite our best efforts, some rounding errors can still occur):\n\nd = ss.date('2025.08.02')\nprint(d)\nprint(d.years)\nprint(float(d)) # Alias to d.years\n\n2025.08.02\n2025.5835616438355\n2025.5835616438355\n\n\nLike many Starsim objects, you can get all the properties of an ss.date object with .disp():\n\nd.disp()\n\n&lt;starsim.time.date at 0x7e28af4fabd0&gt;\n[&lt;class 'starsim.time.date'&gt;, &lt;class 'pandas.Timestamp'&gt;, &lt;class 'pandas._libs.tslibs.timestamps._Timestamp'&gt;, &lt;class 'pandas._libs.tslibs.base.ABCTimestamp'&gt;, &lt;class 'datetime.datetime'&gt;, &lt;class 'datetime.date'&gt;]\n————————————————————————————————————————————————————————————————————————\nMethods:\n  _from_dt64()            from_year()             to_json()               \n  _from_value_and_reso()  fromordinal()           to_julian_date()        \n  _rebuild()              fromtimestamp()         to_numpy()              \n  _reset_class()          isocalendar()           to_pandas()             \n  _round()                isoformat()             to_period()             \n  _timestamp_add()        isoweekday()            to_pydatetime()         \n  arange()                month_name()            to_year()               \n  as_unit()               normalize()             today()                 \n  astimezone()            now()                   toordinal()             \n  ceil()                  replace()               tz_convert()            \n  combine()               round()                 tz_localize()           \n  ctime()                 strftime()              tzname()                \n  date()                  strptime()              utcfromtimestamp()      \n  day_name()              subdaily()              utcnow()                \n  disp()                  time()                  utcoffset()             \n  dst()                   timestamp()             utctimetuple()          \n  floor()                 timetuple()             weekday()               \n  from_array()            timetz()                from_json()             \n  to_datetime64()         \n————————————————————————————————————————————————————————————————————————\nProperties:\n  tz                      tzinfo                  years                   \n————————————————————————————————————————————————————————————————————————\n          _creso: 9\n      _date_repr: '2025-08-02'\n  _docstring_max: \"\\n    Returns the maximum bound possible for\n                  Timestamp.\\n\\n     [...]\n  _docstring_min: \"\\n    Returns the minimum bound possible for\n                  Timestamp.\\n\\n     [...]\n _docstring_reso: \"\\n    Returns the smallest possible difference\n                  between non-equa [...]\n     _nanosecond: 0\n      _repr_base: '2025-08-02 00:00:00'\n      _time_repr: '00:00:00'\n          _value: 1754092800000000\n           _year: 2025\n            asm8: numpy.datetime64('2025-08-02T00:00:00.000000')\n             day: 2\n     day_of_week: 5\n     day_of_year: 214\n       dayofweek: 5\n       dayofyear: 214\n   days_in_month: 31\n     daysinmonth: 31\n            fold: 0\n fromisocalendar: &lt;built-in method fromisocalendar of type object at\n                  0x5b1fbd3db97 [...]\n   fromisoformat: &lt;built-in method fromisoformat of type object at\n                  0x5b1fbd3db970&gt;\n            hour: 0\n    is_leap_year: False\n    is_month_end: False\n  is_month_start: False\n  is_quarter_end: False\nis_quarter_start: False\n     is_year_end: False\n   is_year_start: False\n             max: Timestamp('294247-01-10 04:00:54.775807')\n     microsecond: 0\n             min: Timestamp('-290308-12-21 19:59:05.224193')\n          minute: 0\n           month: 8\n      nanosecond: 0\n         quarter: 3\n      resolution: Timedelta('0 days 00:00:00.000001')\n          second: 0\n            unit: 'us'\n           value: 1754092800000000000\n            week: 31\n      weekofyear: 31\n            year: 2025\n————————————————————————————————————————————————————————————————————————\n\n\n\nYou can do some kinds of arithmetic on date, mostly addition or subtraction:\n\nd = ss.date('2015.8.10')\nprint(d)\nprint(d + ss.years(10))\nprint(d + ss.datedur(months=3, days=-5))\n\n2015.08.10\n2025.08.10\n2015.11.05\n\n\nThere is also an ss.DateArray() object, which you are unlikely to need to work with directly, but which is used to handle timelines (more on those later):\n\nimport numpy as np\ndatearr = ss.date.from_array(np.arange(1990, 2020))\nprint('From an array:\\n', datearr)\n\nweekarr = ss.date.arange(start='2025-07-01', stop='2025-09-18', step=ss.week)\nprint('Using arange:\\n', weekarr)\n\nFrom an array:\n [&lt;1990.01.01&gt; &lt;1991.01.01&gt; &lt;1992.01.01&gt; &lt;1993.01.01&gt; &lt;1994.01.01&gt;\n &lt;1995.01.01&gt; &lt;1996.01.01&gt; &lt;1997.01.01&gt; &lt;1998.01.01&gt; &lt;1999.01.01&gt;\n &lt;2000.01.01&gt; &lt;2001.01.01&gt; &lt;2002.01.01&gt; &lt;2003.01.01&gt; &lt;2004.01.01&gt;\n &lt;2005.01.01&gt; &lt;2006.01.01&gt; &lt;2007.01.01&gt; &lt;2008.01.01&gt; &lt;2009.01.01&gt;\n &lt;2010.01.01&gt; &lt;2011.01.01&gt; &lt;2012.01.01&gt; &lt;2013.01.01&gt; &lt;2014.01.01&gt;\n &lt;2015.01.01&gt; &lt;2016.01.01&gt; &lt;2017.01.01&gt; &lt;2018.01.01&gt; &lt;2019.01.01&gt;]\nUsing arange:\n [&lt;2025.07.01&gt; &lt;2025.07.08&gt; &lt;2025.07.15&gt; &lt;2025.07.22&gt; &lt;2025.07.29&gt;\n &lt;2025.08.05&gt; &lt;2025.08.12&gt; &lt;2025.08.19&gt; &lt;2025.08.26&gt; &lt;2025.09.02&gt;\n &lt;2025.09.09&gt; &lt;2025.09.16&gt;]",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Time"
    ]
  },
  {
    "objectID": "user_guide/advanced_time.html#timeline",
    "href": "user_guide/advanced_time.html#timeline",
    "title": "Time",
    "section": "Timeline",
    "text": "Timeline\nSince different modules are allowed to have their own start, stop, and timestep, we need to coordinate their events with each other and with the sim. The class that does this is called ss.Timeline. You will rarely (if ever) need to invoke it directly, but it’s important to understand how it works.\nIt’s so important, it’s stored as .t in the sim and each module, e.g. sim.t. Let’s start with a simple example:\n\nsim = ss.Sim(verbose=False).run() # Can use an empty sim\nprint(sim.t)\n\nTimeline(2000-2050.0; dt=1.0; now=2050.0; ti=50/50)\n\n\nThe ss.Timeline object has several different ways of representing (the same) time; each is useful for a different purpose. We can see each of these with the .to_dict() method:\n\nt = ss.Timeline(start=2020, stop=2022, dt=ss.month)\nprint(t.to_dict())\n\n#0. 'tvec':\nDateArray([years(2020), years(2020.08), years(2020.17), years(2020.25),\n           years(2020.33), years(2020.42), years(2020.5), years(2020.58),\n           years(2020.67), years(2020.75), years(2020.83), years(2020.92),\n           years(2021), years(2021.08), years(2021.17), years(2021.25),\n           years(2021.33), years(2021.42), years(2021.5), years(2021.58),\n           years(2021.67), years(2021.75), years(2021.83), years(2021.92),\n           years(2022)], dtype=object)\n————————————————————————————————————————\n#1. 'tivec':\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24])\n————————————————————————————————————————\n#2. 'timevec':\nDateArray([&lt;2020.01.01&gt;, &lt;2020.01.31&gt;, &lt;2020.03.02&gt;, &lt;2020.04.02&gt;,\n           &lt;2020.05.02&gt;, &lt;2020.06.02&gt;, &lt;2020.07.02&gt;, &lt;2020.08.01&gt;,\n           &lt;2020.09.01&gt;, &lt;2020.10.01&gt;, &lt;2020.11.01&gt;, &lt;2020.12.02&gt;,\n           &lt;2021.01.01&gt;, &lt;2021.01.31&gt;, &lt;2021.03.03&gt;, &lt;2021.04.02&gt;,\n           &lt;2021.05.03&gt;, &lt;2021.06.02&gt;, &lt;2021.07.02&gt;, &lt;2021.08.02&gt;,\n           &lt;2021.09.01&gt;, &lt;2021.10.02&gt;, &lt;2021.11.01&gt;, &lt;2021.12.02&gt;,\n           &lt;2022.01.01&gt;], dtype=object)\n————————————————————————————————————————\n#3. 'yearvec':\narray([2020.        , 2020.08333333, 2020.16666667, 2020.25      ,\n       2020.33333333, 2020.41666667, 2020.5       , 2020.58333333,\n       2020.66666667, 2020.75      , 2020.83333333, 2020.91666667,\n       2021.        , 2021.08333333, 2021.16666667, 2021.25      ,\n       2021.33333333, 2021.41666667, 2021.5       , 2021.58333333,\n       2021.66666667, 2021.75      , 2021.83333333, 2021.91666667,\n       2022.        ])\n————————————————————————————————————————\n#4. 'datevec':\nDateArray([&lt;2020.01.01&gt;, &lt;2020.02.01&gt;, &lt;2020.03.01&gt;, &lt;2020.04.01&gt;,\n           &lt;2020.05.01&gt;, &lt;2020.06.01&gt;, &lt;2020.07.01&gt;, &lt;2020.08.01&gt;,\n           &lt;2020.09.01&gt;, &lt;2020.10.01&gt;, &lt;2020.11.01&gt;, &lt;2020.12.01&gt;,\n           &lt;2021.01.01&gt;, &lt;2021.02.01&gt;, &lt;2021.03.01&gt;, &lt;2021.04.01&gt;,\n           &lt;2021.05.01&gt;, &lt;2021.06.01&gt;, &lt;2021.07.01&gt;, &lt;2021.08.01&gt;,\n           &lt;2021.09.01&gt;, &lt;2021.10.01&gt;, &lt;2021.11.01&gt;, &lt;2021.12.01&gt;,\n           &lt;2022.01.01&gt;], dtype=object)\n————————————————————————————————————————\n#5. 'relvec':\narray([datedur(0), datedur(months=1), datedur(months=2),\n       datedur(months=3), datedur(months=4), datedur(months=5),\n       datedur(months=6), datedur(months=7), datedur(months=8),\n       datedur(months=9), datedur(months=10), datedur(months=11),\n       datedur(years=1), datedur(years=1, months=1),\n       datedur(years=1, months=2), datedur(years=1, months=3),\n       datedur(years=1, months=4), datedur(years=1, months=5),\n       datedur(years=1, months=6), datedur(years=1, months=7),\n       datedur(years=1, months=8), datedur(years=1, months=9),\n       datedur(years=1, months=10), datedur(years=1, months=11),\n       datedur(years=2)], dtype=object)\n\n\nWe have four different vectors that represent the time:\n\ndatevec: calendar dates;\nyearvec: floating-point years;\nrelvec: relative times since the start of the sim;\ntivec: timesteps.\n\nThe other two, tvec and timevec, match one of these four, but which one they match depends on what the user’s inputs are. For example, if we use a duration-based timeline, we get different results:\n\nt = ss.Timeline(start=ss.days(0), stop=ss.days(10), dt=ss.day)\nprint(t.to_dict())\n\n#0. 'tvec':\nDateArray([days(0), days(1), days(2), days(3), days(4), days(5), days(6),\n           days(7), days(8), days(9), days(10)], dtype=object)\n#1. 'tivec':   array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])\n#2. 'timevec': DateArray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.,\n10.])\n#3. 'yearvec':\narray([0.        , 0.00273973, 0.00547945, 0.00821918, 0.0109589 ,\n       0.01369863, 0.01643836, 0.01917808, 0.02191781, 0.02465753,\n       0.02739726])\n#4. 'datevec':\nDateArray([datedur(0), datedur(days=1), datedur(days=2), datedur(days=3),\n           datedur(days=4), datedur(days=5), datedur(days=6),\n           datedur(days=7), datedur(days=8), datedur(days=9),\n           datedur(days=10)], dtype=object)\n#5. 'relvec':  array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])\n\n\ntvec is what the ss.Timeline object uses internally as “canonical” simulation time. timevec is the “most-human-friendly” representation of the time, and is what is e.g. stored in results to help with plotting.\n\nPlotting with dates\nPlotting with dates is hard. Consider this example (from the interventions tutorial):\n\n# Define the parameters\nstart = 2015\nvax = ss.routine_vx(start_year=start, prob=0.8, product=ss.simple_vx(efficacy=0.9))\npars = dict(diseases='sis', networks='random', n_agents=5000)\n\n# Create and run the sims\ns1 = ss.Sim(pars)\ns2 = ss.Sim(pars, interventions=vax)\nss.parallel(s1, s2) # Run the sims\nr1 = s1.results\nr2 = s2.results\n\n# Use Matplotlib to plot the results\nplt.figure()\nplt.plot(r1.timevec, r1.sis.prevalence, label='Baseline')\nplt.plot(r2.timevec, r2.sis.prevalence, label='With vaccine')\nplt.axvline(start, color='k', label='Intervention')\nplt.legend()\n\nInitializing sim \"Sim 1\" with 5000 agentsInitializing sim \"Sim 0\" with 5000 agents\n\n  Running \"Sim 0\": 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running \"Sim 1\": 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running \"Sim 0\": 2010.01.01 (10/51) (0.18 s)  ••••———————————————— 22%\n  Running \"Sim 1\": 2010.01.01 (10/51) (0.18 s)  ••••———————————————— 22%\n  Running \"Sim 0\": 2020.01.01 (20/51) (0.20 s)  ••••••••———————————— 41%\n  Running \"Sim 1\": 2020.01.01 (20/51) (0.21 s)  ••••••••———————————— 41%\n  Running \"Sim 0\": 2030.01.01 (30/51) (0.23 s)  ••••••••••••———————— 61%\n  Running \"Sim 1\": 2030.01.01 (30/51) (0.23 s)  ••••••••••••———————— 61%\n  Running \"Sim 0\": 2040.01.01 (40/51) (0.26 s)  ••••••••••••••••———— 80%\n  Running \"Sim 1\": 2040.01.01 (40/51) (0.26 s)  ••••••••••••••••———— 80%\n  Running \"Sim 0\": 2050.01.01 (50/51) (0.28 s)  •••••••••••••••••••• 100%\n\n  Running \"Sim 1\": 2050.01.01 (50/51) (0.29 s)  •••••••••••••••••••• 100%\n\n\n\n\n\n\n\n\n\n\nWhat the heck! The vertical line is in totally the wrong place. That’s because the x-axis is plotting using ss.date, which underneath is pd.Timestamp, and underneath that is np.datetime64[ns], which interprets “2015” as '1970-01-01T00:00:00.000002015' (i.e., 2,015 nanoseconds after the “start of the epoch”, which is defined as January 1st, 1970).\nWe have two ways of fixing this. The first is to simply remember to convert to a date:\n\nplt.figure()\nplt.plot(r1.timevec, r1.sis.prevalence, label='Baseline')\nplt.plot(r2.timevec, r2.sis.prevalence, label='With vaccine')\nplt.axvline(ss.date(start), color='k', label='Intervention')  # Fix by converting to a date\nplt.legend()\n\n\n\n\n\n\n\n\n(Are you wondering why the lines diverge before the intervention starts? It’s because the vaccine takes effect immediately, so by the start year there’s already a difference in the number of infections, and Matplotlib is interpolating the lines.)\nThe second is by using the .years property of timevec, so we don’t have to worry about dates at all:\n\nplt.figure()\nyears = r1.timevec.years # Fix by using floating-point years\nplt.scatter(years, r1.sis.prevalence, label='Baseline')\nplt.scatter(years, r2.sis.prevalence, label='With vaccine')\nplt.axvline(start, color='k', label='Intervention')\nplt.legend()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Time"
    ]
  },
  {
    "objectID": "user_guide/advanced_time.html#timepars",
    "href": "user_guide/advanced_time.html#timepars",
    "title": "Time",
    "section": "Timepars",
    "text": "Timepars\nDates say when things happen, but disease modeling is really mostly about durations and rates: how may days from infection to recovery? What is the probability of transmission per week? In Starsim, we call these unit-aware quantities time parameters (or timepars for short), represented by the class ss.TimePar. Timepars are all available in four base units: days, weeks, months, or years (noting that a week is defined as exactly 7 days, and a month is defined as exactly 1/12th of a year). The full class hierarchy of the time parameters is:\nTimePar  # All time parameters\n├── dur  # All durations, units of *time*\n│   ├── days  # Duration with units of days\n│   ├── weeks\n│   ├── months\n│   ├── years\n│   └── datedur  # Calendar durations\n└── Rate  # All rates, units of *per* (e.g. per time or per event)\n    ├── per  # Probability rates over time (e.g., death rate per year)\n    │   ├── perday\n    │   ├── perweek\n    │   ├── permonth\n    │   └── peryear\n    ├── prob  # Unitless probability (e.g., probability of death per infection)\n    │   ├── probperday\n    │   ├── probperweek\n    │   ├── probpermonth\n    │   └── probperyear\n    └── freq  # Number of events (e.g., number of acts per year)\n        ├── freqperday\n        ├── freqperweek\n        ├── freqpermonth\n        └── freqperyear\n\nDurations\nDurations are relatively straightforward. The base class for durations is ss.dur(), but in almost all cases you’ll want to use ss.days(), ss.weeks(), ss.months(), or ss.years() instead. (In fact, if you type ss.dur(3, 'years'), it will return ss.years(3).)\nDurations operate more or less how you would expect, with the left hand operator taking precedence:\n\nd1 = ss.years(2)\nd2 = ss.days(3)\nprint(d1 + d2)\nprint(d2 + d1)\n\nyears(2.00822)\ndays(733)\n\n\nYou can also easily convert durations:\n\nd1 = ss.years(10)\nprint(d1.days) # Represent as days, but keep as years internally\nd2 = d1.to('days')\nprint(d2)\n\n3650.0\ndays(3650)\n\n\nNote: in almost all cases, you can use either with or without the ‘s’, i.e. ss.years(1).to('day') or ss.years(1).to('days') both work.\nAlso, there are shortcut classes for unit values:\n\nprint(ss.weeks(1))\nprint(ss.week)\nassert ss.weeks(1.0) == ss.weeks(1) == ss.week\n\nweek\nweek\n\n\n\nDate durations\nIn most cases, the durations above can be used for arithmetic with dates. But sometimes we need precise date arithmetic that keeps track of each unit separately. For this we can use ss.datedur. For example:\n\nd = ss.date('2025.1.1')\nyears = ss.years(0.5)\ndatedur = ss.datedur(months=6)\n\nprint(d + years)\nprint(d + datedur)\n\n2025.07.02\n2025.07.01\n\n\nWhy is this happening? Because 2025.5 is closer to July 2nd than July 1st. There are fewer days from the start of the year to July 1st than there are days from July 1st to the end of the year:\n\nprint(ss.date('2025.7.1') - ss.date('2025.1.1'))\nprint(ss.date('2025.12.31') - ss.date('2025.7.1'))\n\ndatedur(months=6)\ndatedur(months=5, days=30)\n\n\nSo even though a month is “usually” 1/12th of a year exactly, and although 6/12ths is certainly 0.5, this is an example where we get a different answer depending on whether we do date-based arithmetic or float-based arithmetic.\n\n\n\nRates\nRates are more complicated than durations since there are three different meanings of the term “rate”, each reflected by a different class.\n\nFrequencies\nWe define a “frequency”, or ss.freq, as the “number of events happening in a given amount of time”. Frequencies are the simplest type of rate to understand, since arithmetic operators work the same as they would for a float, with the caveat that the numerator and denominator of a frequency are stored separately:\n\n# Construct directly\nf1 = ss.freqperday(0.5)\n\n# Construct as the inverse of a duration\nd = ss.days(2)\nf2 = 1/d\n\nprint(f1)\nprint(f2)\nassert f1 == f2\n\n# Can multiply by a float\nprint(f1*10)\n\nfreqperday(0.5)\nfreq(1/2)\nfreqperday(5)\n\n\n\n\nProbabilities\nProbabilities, called ss.prob() in Starsim, can either have units or be unitless. A unitless probability is fairly straightforward, with the caveat about multiplication above (i.e., ss.prob(0.5)*2 == ss.prob(0.75)).\nWith a unit, e.g. ss.probperday(0.5), it represents the probability of an event occurring during a specified period of time. This allows the probability of an event over one time period to be converted to the probability of an event over a different time period. To do this, the underlying rate (see “Probability rates” below for more information) is first calculated:\nrate = -np.log(1 - prob)\nThen, the probability over the new duration is\np = 1 - np.exp(-rate/factor)\nwhere factor is the ratio of the new duration to the original duration.\nFor example,\np = ss.prob(0.8, ss.years(1))\nindicates a 80% chance of an event occurring in one year.\nWhen multiplied by the original denominator, 1 year in this case, the probability remains unchanged, 80%:\np*ss.years(1) == 0.8\nMultiplying p by ss.years(2) does not simply double the probability to 160% (which is not possible), but rather returns a new probability of 96% representing the chance of the event occurring at least once over the new duration of two years:\np * ss.years(2) == 0.96\n\n\nProbability rates\nThis quantity is often simply called a “rate”, but this is confusing because “rate” as ambiguous. A “probability rate”, which in Starsim is simply ss.per(), represents the rate at which a single event happens. For example, death rate and birth rates are examples of probability rates, since you can’t die (or be born) more than once. Since this is the “normal” definition of the term “rate”, it’s called ss.per() so that its unit-specific versions (ss.perday, ss.peryear, etc.) are as concise as possible.\nProbability rates must be non-negative, but need not be less than 1. Thus, ss.perday(2) is a valid rate (whereas ss.probperday(2) is not valid).\nWhen a per is multiplied by a scalar or array, the rate is simply scaled. Such multiplication occurs frequently in epidemiological models, where the base rate is multiplied by “rate ratio” or “relative rate” to represent agents experiencing higher (multiplier &gt; 1) or lower (multiplier &lt; 1) event rates.\nAlternatively, when a per is multiplied by a duration (type ss.dur), a probability is calculated. The conversion from rate to probability on multiplication by a duration is exactly the same as for ss.prob:\np = 1 - np.exp(-rate/factor)\nThe only difference is that we are using the rate directly, rather than back-calculating it first.\nFor example, consider\np = ss.peryear(0.8)\nWhen multiplied by a duration of 1 year, the calculated probability is 1 - np.exp(-0.8), which is approximately 55%:\np*ss.years(1) ≈ 0.55\nWhen multiplied by a scalar, the rate is simply scaled.\np*2 == 1.6\nThe difference between ss.prob and ss.per is subtle, but important. per works directly with the instantaneous rate of an event occurring. In contrast, ss.prob starts with a probability and a duration, and the underlying rate is calculated. On multiplication by a duration:\n\nss.freq: rate → number of events\nss.per: rate → probability\nss.prob: probability → underlying rate → probability\n\n\n\nUsing rates\nEach of these quantities has .to_prob() and .to_events() methods; in fact, the only difference between ss.freq and ss.per is that multiplying ss.freq by a duration calls .to_events(), while multiplying ss.per by a duration calls .to_prob().\nIn most cases, you will be using ss.per() together with the simulation (or module) timestep dt. In order to convert your rate into a probability of an event happening, simply call .to_prob() – remember to do this as the last step of the calculation, so that the probability is scaled correctly:\n# Define the death rate\ndeath_rate = ss.peryear(0.1)\nrel_death_age = 3.4 # Older age, higher risk\nrel_death_ses = 5.7 # Lower SES, higher risk\n\n# ✓ Right -- multiply first, and then convert to probability\np_death = (death_rate * rel_death_age * rel_death_ses).to_prob()\n\n# × WRONG -- will produce an invalid probability\np_death = death_rate.to_prob() * rel_death_age * rel_death_ses\nHow does a rate know how to convert itself to a probability? When a sim is initialized, it finds all the timepars, and adds a default_dur property to them that’s equal to module dt. This means that death_rate.to_prob() is simply a shortcut for death_rate * self.dt, but both are equivalent.\n\n\nSummary\nHere is a quick summary of when you should use each type of quantity:\n\nss.freq: Use when you want a number of events, e.g. sexual acts per year: acts = ss.freqperyear(80).\nss.per: Use when you want to calculate the probability of an event, e.g. death: death_rate = ss.peryear(0.01).\nss.prob: Use when you are sure you want to convert a probability from one time period to another, e.g. if after a 1 year period, 10 out of 1000 people had died: death_prob = ss.probperyear(0.01).\n\nConfused? That’s OK. As we said, time is complex.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Time"
    ]
  },
  {
    "objectID": "user_guide/modules_analyzers.html",
    "href": "user_guide/modules_analyzers.html",
    "title": "Analyzers",
    "section": "",
    "text": "Each Starsim module can have its own results, which get added to the full list of results in the Sim object. For example, the ss.Pregnancy module adds results like sim.results.pregnancy.pregnant, and the ss.HIV module adds results like sim.results.hiv.new_infections. If you are writing your own module, you can add whatever custom results you want. However, another option is to create an Analyzer to store results that you might need for one particular analysis but won’t need all the time. An Analyzer is very similar to other Starsim modules in its structure, but the general idea of an analyzer is that it gets called at the end of a timestep, and reports of the state of things after everything else has been updated without changing any of the module states itself.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Analyzers"
    ]
  },
  {
    "objectID": "user_guide/modules_analyzers.html#simple-usage",
    "href": "user_guide/modules_analyzers.html#simple-usage",
    "title": "Analyzers",
    "section": "Simple usage",
    "text": "Simple usage\nFor simple reporting, it’s possible to use a single function as an analyzer. In this case, the function receives a single argument, sim, which it has full access to. For example, if you wanted to know the number of connections in the network on each timestep, you could write a small analyzer as follows:\n\nimport numpy as np\nimport starsim as ss\nimport matplotlib.pyplot as plt\nss.options(jupyter=True)\n\n# Store the number of edges\nn_edges = []\n\ndef count_edges(sim):\n    \"\"\" Print out the number of edges in the network on each timestep \"\"\"\n    network = sim.networks[0] # Get the first network\n    n = len(network)\n    n_edges.append(n)\n    print(f'Number of edges for network {network.name} on step {sim.ti}: {n}')\n    return\n\n# Create the sim\npars = dict(\n    diseases = 'sis',\n    networks = 'mf',\n    analyzers = count_edges,\n    demographics = True,\n)\n\n# Run the sim\nsim = ss.Sim(pars).run()\nsim.plot()\n\n# Plot the number of edges\nplt.figure()\nplt.plot(sim.timevec, n_edges)\nplt.title('Number of edges over time')\nplt.ylim(bottom=0)\nplt.show()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\nNumber of edges for network mfnet on step 0: 3286\nNumber of edges for network mfnet on step 1: 3319\nNumber of edges for network mfnet on step 2: 3357\nNumber of edges for network mfnet on step 3: 3395\nNumber of edges for network mfnet on step 4: 3426\nNumber of edges for network mfnet on step 5: 3475\nNumber of edges for network mfnet on step 6: 3509\nNumber of edges for network mfnet on step 7: 3548\nNumber of edges for network mfnet on step 8: 3593\nNumber of edges for network mfnet on step 9: 3618\n  Running 2010.01.01 (10/51) (0.18 s)  ••••———————————————— 22%\nNumber of edges for network mfnet on step 10: 3634\nNumber of edges for network mfnet on step 11: 3682\nNumber of edges for network mfnet on step 12: 3713\nNumber of edges for network mfnet on step 13: 3740\nNumber of edges for network mfnet on step 14: 3775\nNumber of edges for network mfnet on step 15: 3816\nNumber of edges for network mfnet on step 16: 3850\nNumber of edges for network mfnet on step 17: 3896\nNumber of edges for network mfnet on step 18: 3945\nNumber of edges for network mfnet on step 19: 3987\n  Running 2020.01.01 (20/51) (0.22 s)  ••••••••———————————— 41%\nNumber of edges for network mfnet on step 20: 4010\nNumber of edges for network mfnet on step 21: 4048\nNumber of edges for network mfnet on step 22: 4085\nNumber of edges for network mfnet on step 23: 4124\nNumber of edges for network mfnet on step 24: 4149\nNumber of edges for network mfnet on step 25: 4164\nNumber of edges for network mfnet on step 26: 4200\nNumber of edges for network mfnet on step 27: 4250\nNumber of edges for network mfnet on step 28: 4299\nNumber of edges for network mfnet on step 29: 4314\n  Running 2030.01.01 (30/51) (0.26 s)  ••••••••••••———————— 61%\nNumber of edges for network mfnet on step 30: 4346\nNumber of edges for network mfnet on step 31: 4373\nNumber of edges for network mfnet on step 32: 4409\nNumber of edges for network mfnet on step 33: 4465\nNumber of edges for network mfnet on step 34: 4506\nNumber of edges for network mfnet on step 35: 4559\nNumber of edges for network mfnet on step 36: 4609\nNumber of edges for network mfnet on step 37: 4642\nNumber of edges for network mfnet on step 38: 4694\nNumber of edges for network mfnet on step 39: 4742\n  Running 2040.01.01 (40/51) (0.31 s)  ••••••••••••••••———— 80%\nNumber of edges for network mfnet on step 40: 4768\nNumber of edges for network mfnet on step 41: 4830\nNumber of edges for network mfnet on step 42: 4887\nNumber of edges for network mfnet on step 43: 4947\nNumber of edges for network mfnet on step 44: 5010\nNumber of edges for network mfnet on step 45: 5047\nNumber of edges for network mfnet on step 46: 5109\nNumber of edges for network mfnet on step 47: 5165\nNumber of edges for network mfnet on step 48: 5216\nNumber of edges for network mfnet on step 49: 5259\n  Running 2050.01.01 (50/51) (0.35 s)  •••••••••••••••••••• 100%\n\nNumber of edges for network mfnet on step 50: 5283\nFigure(896x672)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Analyzers"
    ]
  },
  {
    "objectID": "user_guide/modules_analyzers.html#advanced-usage",
    "href": "user_guide/modules_analyzers.html#advanced-usage",
    "title": "Analyzers",
    "section": "Advanced usage",
    "text": "Advanced usage\nSuppose we wanted to create an analyzer that would report on the number of new HIV infections in pregnant women:\n\nimport starsim as ss\nimport starsim_examples as sse\nimport pandas as pd\n\nclass HIV_preg(ss.Analyzer):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        return\n    \n    def init_results(self):\n        super().init_results()\n        self.define_results(\n            ss.Result('new_infections_pregnancy'),\n        )\n        return\n\n    def step(self):\n        sim = self.sim\n        ti = sim.ti\n        hiv = sim.diseases.hiv\n        pregnant = sim.demographics.pregnancy.pregnant\n        newly_infected = hiv.ti_infected == ti\n        self.results['new_infections_pregnancy'][ti] = len((newly_infected & pregnant).uids)\n        return\n\npregnancy = ss.Pregnancy(fertility_rate=pd.read_csv('test_data/nigeria_asfr.csv'))\nhiv = sse.HIV(beta={'mfnet':[0.5,0.25]})\nsim = ss.Sim(diseases=hiv, networks='mfnet', demographics=pregnancy, analyzers=HIV_preg())\nsim.run()\nprint(f'Total infections among pregnant women: {sim.results.hiv_preg.new_infections_pregnancy.sum()}')\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.09 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.20 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.34 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.48 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.65 s)  •••••••••••••••••••• 100%\n\nTotal infections among pregnant women: 164.0\n\n\nAnalyzers are ideal for adding custom results, and because they get added to the sim in the same way as any other result, they also get automatically exported in the same format, e.g. using sim.to_df().\nHere’s a plot of the results from our HIV in pregnancy analyzer:\n\nimport matplotlib.pyplot as plt\n\nres = sim.results.hiv_preg\n\nplt.figure()\nplt.bar(res.timevec.years, res.new_infections_pregnancy)\nplt.title('HIV infections acquired during pregnancy')\nplt.show()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Analyzers"
    ]
  },
  {
    "objectID": "user_guide/modules_analyzers.html#built-in-analyzers",
    "href": "user_guide/modules_analyzers.html#built-in-analyzers",
    "title": "Analyzers",
    "section": "Built-in analyzers",
    "text": "Built-in analyzers\nStarsim comes with two built-in analyzers, an infection log and an age analyzer.\n\nInfection log\nThe infection log produces a line list of infections. It’s integrated into the logic of ss.Disease in order to track infection sources and targets, which are not kept beyond this (for memory reasons).\n\n# Demonstrate infection log\nsim = ss.Sim(n_agents=1000, dt=0.2, dur=15, diseases='sir', networks='random', analyzers='infection_log')\nsim.run()\ninfection_log = sim.analyzers[0]\ninfection_log.plot()\n\nInitializing sim with 1000 agents\n  Running 2000.01.01 ( 0/76) (0.00 s)  ———————————————————— 1%\n  Running 2002.01.01 (10/76) (0.02 s)  ••—————————————————— 14%\n  Running 2004.01.01 (20/76) (0.03 s)  •••••——————————————— 28%\n  Running 2006.01.01 (30/76) (0.05 s)  ••••••••———————————— 41%\n  Running 2008.01.01 (40/76) (0.07 s)  ••••••••••—————————— 54%\n  Running 2010.01.01 (50/76) (0.08 s)  •••••••••••••——————— 67%\n  Running 2012.01.01 (60/76) (0.09 s)  ••••••••••••••••———— 80%\n  Running 2014.01.01 (70/76) (0.11 s)  ••••••••••••••••••—— 93%\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nYou can see how this raster plot aligns with the peak of infections:\n\nsim.diseases.sir.plot()\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\n(Note: ss.infection_log() also has an .animate() method, which we will leave for you to try out!)\n\n\nDynamics by age\nThis analyzer illustrates how you could track infections by age. Since it illustrates some additional key principles of building analyzers, here it is in full:\n\nclass dynamics_by_age(ss.Analyzer):\n    def __init__(self, state, age_bins=(0, 20, 40, 100)):\n        super().__init__()\n        self.state = state\n        self.age_bins = age_bins\n        self.mins = age_bins[:-1]\n        self.maxes = age_bins[1:]\n        self.hist = {k: [] for k in self.mins}\n        return\n\n    def step(self):\n        people = self.sim.people\n        for min, max in zip(self.mins, self.maxes):\n            mask = (people.age &gt;= min) & (people.age &lt; max)\n            self.hist[min].append(people.states[self.state][mask].sum())\n        return\n\n    def finalize_results(self):\n        \"\"\" Convert to an array \"\"\"\n        super().finalize_results()\n        for k,hist in self.hist.items():\n            self.hist[k] = np.array(hist)\n        return\n\n    def plot(self, **kwargs):\n        kw = ss.plot_args(kwargs)\n        with ss.style(**kw.style):\n            fig = plt.figure(**kw.fig)\n            for minage, maxage in zip(self.mins, self.maxes):\n                plt.plot(self.sim.t.timevec, self.hist[minage], label=f'Age {minage}-{maxage}', **kw.plot)\n            plt.legend(**kw.legend)\n            plt.xlabel('Model time')\n            plt.ylabel('Count')\n            plt.ylim(bottom=0)\n        return ss.return_fig(fig, **kw.return_fig)\n\n# Demonstrate\nby_age = dynamics_by_age('sis.infected', age_bins=(0, 10, 30, 100))\nsim = ss.Sim(diseases='sis', networks='random', analyzers=by_age, copy_inputs=False)\nsim.run()\nby_age.plot()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.04 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.07 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.11 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.14 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.17 s)  •••••••••••••••••••• 100%\n\nFigure(672x480)\n\n\n\n\n\n\n\n\n\nSince we are using a random network, we wouldn’t expect any differences in transission by age, so what you’re seeing here is the difference in age bin size.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Analyzers"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html",
    "href": "user_guide/modules_demographics.html",
    "title": "Demographics",
    "section": "",
    "text": "Starsim can include detailed population dynamics through its demographics modules. These modules handle births, deaths, and pregnancy to model realistic population changes over time. By default, Starsim simulations have a fixed population size, but adding demographics allows the population to grow, shrink, and change age structure naturally.\nDemographics modules are essential for modeling disease transmission over longer time periods, understanding generational effects, and capturing realistic population dynamics.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html#simple-usage",
    "href": "user_guide/modules_demographics.html#simple-usage",
    "title": "Demographics",
    "section": "Simple usage",
    "text": "Simple usage\nLet’s start by comparing two identical simulations, one with demographics enabled and one without:\n\nimport starsim as ss\nimport sciris as sc\nsc.options(jupyter=True)\n\n# Simulation parameters\npars = dict(diseases='sis', networks='random', verbose=0)\n\n# Create simulations\nsim1 = ss.Sim(label='No demographics', **pars)\nsim2 = ss.Sim(label='With demographics', demographics=True, **pars)\n\n# Run both simulations and plot\nmsim = ss.parallel(sim1, sim2)\nmsim.plot(['n_alive', 'cum_deaths', 'sis_n_susceptible', 'sis_n_infected'])\n\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html#advanced-usage-pregnancy-and-births",
    "href": "user_guide/modules_demographics.html#advanced-usage-pregnancy-and-births",
    "title": "Demographics",
    "section": "Advanced usage: Pregnancy and births",
    "text": "Advanced usage: Pregnancy and births\nFor more detailed modeling, you can use the Pregnancy module instead of simple Births. The pregnancy module models:\n\nAge-specific fertility rates\nPregnancy duration and outcomes\nMaternal and neonatal mortality\nMother-to-child transmission pathways\n\n\nimport numpy as np\nimport pandas as pd\nimport sciris as sc\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\n# Create age-specific birth and fertility data\n\nbirth_data = pd.DataFrame({\n    'Year': [2000, 2005, 2010, 2015, 2020, 2025, 2030],\n    'CBR': [40, 35, 30, 31, 32, 30, 28]  # Age-specific birth rates\n})\n\nfertility_data = pd.DataFrame({\n    'Time': [2020]*7,\n    'AgeGrp': [15, 20, 25, 30, 35, 40, 45],\n    'ASFR': [0.05, 0.15, 0.20, 0.15, 0.10, 0.05, 0.01]  # Age-specific fertility rates\n})\n\n# Create a simple births module\nbirths = ss.Births(birth_rate=birth_data)\n\n# Create a pregnancy module with custom parameters\npregnancy = ss.Pregnancy(\n    fertility_rate = fertility_data,\n    rel_fertility = 1000,                                   # Whether data are per person or per 1000\n    p_maternal_death = ss.bernoulli(0.001),                  # 0.1% maternal mortality\n    p_survive_maternal_death = ss.bernoulli(0.98),           # 98% chance unborn survives if mother dies\n    dur_breastfeed = ss.lognorm_ex(mean=ss.years(0.5), std=ss.years(0.25)),  # Breastfeeding duration\n    min_age = 15,\n    max_age = 50,\n)\n\n# Create deaths module\ndeaths = ss.Deaths(death_rate=ss.peryear(8))  # 8 deaths per 1000 per year\n\n# Create simulations\nn_agents = 5_000 # Number of agents\nnga_pop_1995 = 106819805 # \nage_data = pd.read_csv('test_data/nigeria_age.csv')\nppl = ss.People(n_agents, age_data=age_data)\n\npars = dict(start=1995, people=ppl, n_agents=n_agents, diseases='sis', networks='random', verbose=0)\n\nsim1 = ss.Sim(label='Births', **pars, demographics=[births, deaths])\nsim2 = ss.Sim(label='Pregnancy', **pars, demographics=[pregnancy, deaths])\n\n# Plot histograms of the age distributions - simulated vs data at initialization\nsim1.init() # This creates the population\nbins = np.arange(0, 101, 1)\ninit_scale = nga_pop_1995 / n_agents\ncounts, bins = np.histogram(sim1.people.age, bins)\nplt.bar(bins, age_data.value.values * 1000, alpha=0.5, color='r', label='Data')\nplt.bar(bins[:-1], counts * init_scale, alpha=0.5, label='Simulated')\nplt.legend(loc='upper right')\nplt.ylabel('Population')\nplt.xlabel('Age')\nsc.SIticks()\n\n# Run and plot simulations\nmsim = ss.parallel(sim1, sim2)\nmsim.plot()\n\nFigure(896x672)\n\n\n/home/cliffk/idm/starsim/starsim/run.py:394: RuntimeWarning: \nSim \"Pregnancy\" has different results keys:\nExtra: pregnancy_n_breastfeeding, pregnancy_n_fecund, pregnancy_pregnancies, pregnancy_births, pregnancy_n_breastfed, pregnancy_mmr, pregnancy_n_carrying_multiple, pregnancy_n_susceptible, pregnancy_n_fertile, pregnancy_n_pregnant, pregnancy_tfr, pregnancy_n_infertile, pregnancy_cbr, pregnancy_maternal_deaths\nMissing: births_cbr, births_new, births_cumulative\nResults may not plot correctly (i.e. axes titles may not be correct for all sims)\n  ss.warn(warnmsg)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/modules_demographics.html#summary",
    "href": "user_guide/modules_demographics.html#summary",
    "title": "Demographics",
    "section": "Summary",
    "text": "Summary\n\nDemographics modules enable realistic population dynamics in Starsim:\n\nBirths: Simple constant or time-varying birth rates\nDeaths: Background mortality separate from disease deaths\n\nPregnancy: Detailed pregnancy modeling with maternal/neonatal outcomes\n\nKey considerations:\n\nUse demographics=True for default birth/death rates\nUse birth_rate and death_rate for custom constant rates\nUse ss.Pregnancy() for age-specific fertility, pregnancy modeling, and mother-to-child transmission\nDemographics automatically enables aging; if you want to use demographics without aging, set use_aging=False (and conversely, use_aging=True to enable aging without demographics)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Demographics"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html",
    "href": "user_guide/intro_starsim.html",
    "title": "What is Starsim?",
    "section": "",
    "text": "Starsim is a framework for modeling the spread of diseases among agents via dynamic transmission networks. Starsim supports:\n\nCo-transmission of multiple diseases at once, capturing how they interact biologically and behaviorally\nNon-infectious diseases, either on their own or as factors affecting the transmission or mortality of infectious diseases\nDetailed modeling of mother-child relationships starting from conception, allowing investigation of infant and childhood diseases\nMultiple types of transmission network, including theoretical (e.g. Erdős–Rényi) and realistic (e.g. age-assortative sexual partnerships)\nDifferent intervention types, such as vaccines or treatments, and showing their impact through different delivery methods such as mass campaigns or targeted outreach\nAutomated calibration to data, plus careful handling of random numbers to minimize variance between simulations\n\nStarsim is available for both Python and R, and is fully open-source under the MIT license.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#introduction",
    "href": "user_guide/intro_starsim.html#introduction",
    "title": "What is Starsim?",
    "section": "",
    "text": "Starsim is a framework for modeling the spread of diseases among agents via dynamic transmission networks. Starsim supports:\n\nCo-transmission of multiple diseases at once, capturing how they interact biologically and behaviorally\nNon-infectious diseases, either on their own or as factors affecting the transmission or mortality of infectious diseases\nDetailed modeling of mother-child relationships starting from conception, allowing investigation of infant and childhood diseases\nMultiple types of transmission network, including theoretical (e.g. Erdős–Rényi) and realistic (e.g. age-assortative sexual partnerships)\nDifferent intervention types, such as vaccines or treatments, and showing their impact through different delivery methods such as mass campaigns or targeted outreach\nAutomated calibration to data, plus careful handling of random numbers to minimize variance between simulations\n\nStarsim is available for both Python and R, and is fully open-source under the MIT license.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#types-of-disease-modeling",
    "href": "user_guide/intro_starsim.html#types-of-disease-modeling",
    "title": "What is Starsim?",
    "section": "Types of disease modeling",
    "text": "Types of disease modeling\nStarsim is an agent-based model (ABM). ABMs are most suitable for questions that are moderately complex, and have medium to large amounts of data available:\n\n\n\nTypes of Model\n\n\nFor simpler questions, statistical or compartmental models are often all that’s needed. For very complex questions, LLMs (which themselves might be trained on agent-based model outputs) may be more suitable. Examples of each type of question are:\n\nStatistical models: “Are people who received the vaccine less likely to get infected?”\nMachine learning models: “What behavioral factors influence vaccination uptake?”\nCompartmental models: “What is disease prevalence going to be in 5 years given 100% vaccine uptake?”\nAgent-based models: “What is disease prevalence going to be in 5 years given realistic assumptions about screening and vaccine coverage?”",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#why-starsim",
    "href": "user_guide/intro_starsim.html#why-starsim",
    "title": "What is Starsim?",
    "section": "Why Starsim?",
    "text": "Why Starsim?\nStarsim aims to address the limitations of existing ABMs, specifically along the dimensions of usability, capability, and outcome:\n\n\n\n\n\n\n\n\nDimension\nStarsim\nStatus quo\n\n\n\n\nUsability\nStarsim is fast, has a simple interface, and only requires knowledge of Python\nMany ABMs are slow, complex, or require knowledge of C++/Java\n\n\nCapability\nStarsim supports multiple custom diseases and networks, including co-transmission\nMost other disease models are single-disease or hard-coded to a handful of diseases\n\n\nOutcome\nOnce you’ve collected your data, modeling your questions with Starsim takes days to weeks\nWriting, testing, and calibrating a custom model can take months to years\n\n\n\nWhile of course not all existing aABMs have these limitations, many of them have at least one. (For a good review of general-purpose ABMs, see Antelmi et al. 2023).",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#starsim-principles",
    "href": "user_guide/intro_starsim.html#starsim-principles",
    "title": "What is Starsim?",
    "section": "Starsim principles",
    "text": "Starsim principles\nStarsim’s design philosophy has two parts. First, “Common tasks should be simple”. Examples include:\n\nDefining parameters\nRunning a simulation\nPlotting results\n\nThese are things you need to do in every single Starsim analysis, so we’ve tried to make them as easy as possible.\nThe second part of the philosophy is “Custom tasks can’t always be simple, but they should still be possible”. Examples include:\n\nIntroducing a new vaccine\nImplementing a new disease\nWriting a custom calibration function\n\nIf you’re implementing a complicated disease, there will always be some irreducible complexity involved in that. Starsim’s job is to help you where it can, but then get out of the way and let you write your code.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/intro_starsim.html#should-i-use-starsim",
    "href": "user_guide/intro_starsim.html#should-i-use-starsim",
    "title": "What is Starsim?",
    "section": "Should I use Starsim?",
    "text": "Should I use Starsim?\nStarsim is suitable for many use cases, but not all. Some examples of suitable Starsim use cases are:\n\nIf you are currently doing agent-based modeling but your model is too slow/inflexible/hard to use for your research questions\n\nExample: Your model takes 14 hours for a single run, and every year you’re worried that your computing grant won’t be renewed\n\nIf you are currently doing compartmental modeling, and want to try out an agent-based model without investing 3-6 months learning how to use it\n\nExample: Your compartmental mpox model has so far been very effective, but you’ve been asked to evaluate an individually-targeted intervention that requires tracking individual agents\n\nIf you want to quickly prototype different diseases or networks before deciding whether to implement them in your full model\n\nExample: You know and love your HIV model, but you want to see what the impact would be of including syphilis co-transmission or a different type of MSM network\n\n\nHowever, there are other cases where Starsim is not suitable. These include:\n\nIf compartmental models are sufficient for your questions, you should probably stick with them (for R, consider Epidemics; for Python, consider Atomica or Epydemix)\nIf your current model is highly specialized to a given context, the switching cost of moving to Starsim may not be worthwhile (but we are working on AI tools to translate other disease models automatically)\nIf you are modeling malaria or other spatial simulations, Starsim doesn’t currently support spatial interactions natively (but we are considering adding it in future)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Introduction",
      "What is Starsim?"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html",
    "href": "user_guide/advanced_distributions.html",
    "title": "Distributions",
    "section": "",
    "text": "Agent-based models draw random numbers from distributions to simulate various phenomena. Realizations (also called draws or samples) from distributions are used to model everything from the duration of each infection to the number of contacts each individual has in a network to the outcomes of individual diagnostic tests. The Starsim framework includes state of the art functionality for specifying and sampling from statistical distributions.\nIn this guide, you will:\nOne key advantage of Starsim distributions is that they enable low-variance comparison between simulations through a technique called “common random numbers” (CRN). To learn more about CRN, see the Common Random Numbers guide.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#available-distributions",
    "href": "user_guide/advanced_distributions.html#available-distributions",
    "title": "Distributions",
    "section": "Available distributions",
    "text": "Available distributions\nThe starsim framework includes a wide range of distributions that can be used to model various phenomena. The following distributions are available:\n\n\n\n\n\n\n\n\n\nDistribution\nStarsim Dist\nParameters\nDescription\n\n\n\n\nRandom\nrandom\nNone\nRandom number between 0 and 1.\n\n\nUniform\nuniform\nlow, high\nRandom number between a specified minimum and maximum.\n\n\nNormal\nnormal\nloc (mean), scale (standard deviation)\nRandom number from a normal (Gaussian) distribution with specified mean and standard deviation.\n\n\nLognormal (implicit)\nlognormal_im\nmean, sigma (of the underlying normal distribution)\nRandom number from a lognormal distribution specified by the mean and standard deviation of the underlying normal distribution.\n\n\nLognormal (explicit)\nlognormal_ex\nmean, std (of the distribution itself; mean must be positive)\nRandom number from a lognormal distribution specified by the mean and standard deviation of the distribution itself.\n\n\nExponential\nexpon\nscale (mean of the distribution, equivalent to 1/λ)\nRandom number from an exponential distribution with specified scale parameter.\n\n\nPoisson\npoisson\nlam\nRandom number from a Poisson distribution with specified rate parameter.\n\n\nNegative Binomial\nnbinom\nn, p (number of successes, probability of success)\nRandom number from a negative binomial distribution with specified parameters.\n\n\nWeibull\nweibull\nc (shape parameter, sometimes called “k”), loc (shifts the distribution), scale (sometimes called “λ”)\nRandom number from a Weibull distribution with specified parameters, uses scipy’s weibull_min.\n\n\nGamma\ngamma\na (shape parameter, sometimes called “k”), loc (shifts the distribution), scale (sometimes called “θ”)\nRandom number from a gamma distribution with specified shape and scale parameters.\n\n\nBeta\nbeta_dist\na (shape parameter, must be &gt; 0), b (shape parameter, must be &gt; 0)\nRandom number from a beta distribution with specified shape parameters.\n\n\nConstant\nconstant\nv\nConstant value, useful for fixed parameters and testing.\n\n\nRandom Integer\nrandint\nlow, high\nRandom integer between a specified minimum and maximum.\n\n\nBernoulli\nbernoulli\np\nRandom number from a Bernoulli distribution with specified probability of success. Bernoulli distributions are used frequently to determine binary outcomes, such as whether an agent is infected or not.\n\n\nChoice\nchoice\na (int or list of choices), p (probability of each choice)\nRandomly select from a list of values. This distribution only supports fixed parameters.\n\n\nHistogram\nhistogram\nvalues, bins, density, data\nRandom number from a histogram distribution specified by a list of values and their corresponding probabilities.\n\n\n\nSee the API reference for more details.\nYou can also create a custom distribution by extending the Dist class from Starsim.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#how-to-use-starsim-distributions",
    "href": "user_guide/advanced_distributions.html#how-to-use-starsim-distributions",
    "title": "Distributions",
    "section": "How to use Starsim distributions",
    "text": "How to use Starsim distributions\nParameters for Starsim distributions can have fixed parameters (the same for all agents) or vary dynamically. We will start with a simple normal distribution with fixed parameters:\n\nimport starsim as ss\nimport numpy as np\n\n# Create a Normal distribution with mean 0 and standard deviation 1\n# The \"strict\" flag is needed only for this example to avoid warnings\nd = ss.normal(name=\"Normal with fixed parameters\", loc=0, scale=1, strict=False)\n# ^^^ The above \"d\" object is the \"frozen\" distribution.\n\nprint(d)\n\nss.normal(loc=0, scale=1)\n\n\n\nDrawing samples\nSamples from a distribution can be drawn using the rvs method.\nWhile possible to request a specific number of samples, as shown below, please know that this is not the preferred way to use distribution in Starsim:\n\ndraws = d.rvs(5)\nprint(draws)\n\n[-0.98800114  1.40033713 -0.00723223 -2.0299323  -1.02095412]\n\n\nThe above approach is better than calling numpy.random directly, but still not ideal because it does not allow for dynamic parameter nor low-noise sampling. Therefore, please instead call the rvs method with the unique identifiers (uids) of the agents for which you need samples. Alternatively, you can pass a boolean mask of length equal to the number of agents in the simulation:\n\n # Create a simulation for context\n # [you will not need to do this when working within the framework]\nsim = ss.Sim(n_agents=10).init()\n\n# Specify the distribution, here a random integer between -10 and 10\nd_sim = ss.randint(name=\"Random integer with fixed parameters\", low=-10, high=10)\nd_sim.init(sim=sim) # Initialize the distribution [done automatically in the framework]\n\n# Instead of requesting 5 random numbers, the preferred pattern is to request\n# random numbers for specific agents by passing a list of agent IDs. Doing so\n# enable the powerful dynamic parameters to be used while also supporting the\n# low-noise common random number sampling.\ndraws = d_sim.rvs([3, 5, 2, 9, 4]) # Draw samples for specific agents by UID\nprint(f\"Draws for agents 3, 5, 2, 9, and 4: {draws}\")\n\nmask = sim.people.age &lt; 25\ndraws_mask = d_sim.rvs(mask) # Draw samples for agents under 25 from a boolean mask\nprint(f\"Draws for agents under 25: {draws_mask}\")\n\ndraws_all = d_sim.rvs(sim.people.uid) # Draw samples for all agents\nprint(f\"Draws for all agents (0, 1, 2, ..., n_agents): {draws_all}\")\n\nInitializing sim with 10 agents\nDraws for agents 3, 5, 2, 9, and 4: [ 2 -9  1 -8  7]\nDraws for agents under 25: [-10  -1   9]\nDraws for all agents (0, 1, 2, ..., n_agents): [ 0  6  4 -9  3 -8  2  6 -9  8]\n\n\n\n\nVisualizing distributions\nLet’s take a look at the distribution by plotting a histogram of samples:\n\nrvs = d.plot_hist(n=1000, bins=30)\n\n\n\n\n\n\n\n\n\n\nExtracting distribution statistics\nWe can quickly calculate statistics of the distribution by accessing the underlying “dist” property of the distribution:\n\nunderlying_dist = d.dist\nprint(\"Mean:\", underlying_dist.mean())\nprint(\"Standard Deviation:\", underlying_dist.std())\nprint(\"95% Interval:\", underlying_dist.ppf([0.025, 0.975]))\n\nMean: 0.0\nStandard Deviation: 1.0\n95% Interval: [-1.95996398  1.95996398]",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#setting-model-parameters-that-are-distributions",
    "href": "user_guide/advanced_distributions.html#setting-model-parameters-that-are-distributions",
    "title": "Distributions",
    "section": "Setting model parameters that are distributions",
    "text": "Setting model parameters that are distributions\nMany Starsim modules directly expose distributions as parameters for user customization. For example, the SIR disease module has three parameters are distributions:\n\n\n\n\n\n\n\n\nParameter\nMeaning\nDefault Value\n\n\n\n\ninit_prev\nInitial prevalence of infection\nss.bernoulli(p=0.01)\n\n\ndur_inf\nDuration of infection\nss.lognorm_ex(mean=ss.dur(6))\n\n\np_death\nProbability of death given infection\nss.bernoulli(p=0.01)\n\n\n\nYou can change these parameters away from their defaults by passing in a different distribution, as demonstrated below:\n\nsir = ss.SIR(\n    # Set the init_prev parameter to randomly infect 15% of the population\n    init_prev = ss.bernoulli(p=0.15),\n\n    # Set the dur_inf parameter to a Weibull\n    dur_inf = ss.weibull(c=2, loc=1, scale=2)\n)\n\n# Alternatively, update parameters of a default distribution\nsir.pars.p_death.set(p=0.5) # Update the death probability to 50%\n\n# Create, run, and plot a sim using the SIR disease model\nsim = ss.Sim(n_agents=100, diseases=sir, dur=15, dt=1, start=0, networks=ss.RandomNet())\nsim.run().plot()\n\nInitializing sim with 100 agents\n  Running 0.0 ( 0/16) (0.00 s)  •——————————————————— 6%\n  Running 10.0 (10/16) (0.14 s)  •••••••••••••——————— 69%\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nIt’s easy to inspect distributions, for example dur_inf of the SIR module using plot_hist.\nNOTE: in the code below that we access dur_inf at sim.diseases.sir.pars rather than at sir.pars (referencing the module in the previous cell) because Starsim makes a copy. The sir is not initialized and does not have the sim context.\n\nrvs = sim.diseases.sir.pars.dur_inf.plot_hist()",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#using-distributions-with-dynamic-parameters",
    "href": "user_guide/advanced_distributions.html#using-distributions-with-dynamic-parameters",
    "title": "Distributions",
    "section": "Using distributions with dynamic parameters",
    "text": "Using distributions with dynamic parameters\nUp to this point, the distributions we have used have had fixed parameters. Every agent draws will draw from the same distribution at every time step. But Starsim has a powerful feature to specify distributions with dynamic parameters that can change based on agent attributes, simulation time, or other factors.\nLet’s continue with the SIR example, but make the initial prevalence of infection depend on the age of the agent. Instead of a fixed probability for all agents, let’s make it so that children under 15 years old have a 25% chance of being selected as a “seed” infection and adults over 15 years old have a 10% chance.\nTo implement dynamic parameters, we set the parameter (p in the case of a Bernoulli distribution) to a callable like a function. The callable must accept three arguments:\n\nself: The module that is calling the distribution\nsim: The simulation object\nuids: The unique IDs of the agents being processed\n\nIt should return a numpy array of the same length as uids containing the parameter value for each agent, or a scalar if the parameter is the same for all agents.\n\ndef set_p_by_age(self, sim, uids):\n    p = np.full(len(uids), fill_value=0.10)  # Default 10% infection probability\n    p[sim.people.age &lt; 15] = 0.25  # 25% for ages &lt; 15\n    \n    # For demonstration, print the age and probability for each agent:\n    for uid, age, prob in zip(uids, sim.people.age[uids], p):\n        print(f\"Agent {uid} | Age: {age:5.2f} |  Infection Seed Probability: {prob:.0%}\")\n    return p\n\nsir = ss.SIR(\n    # Set init_prev as a dynamic parameter\n    init_prev = ss.bernoulli(p=set_p_by_age),\n)\n\n# Create, run, and plot a sim using the SIR disease model\nsim = ss.Sim(n_agents=10, diseases=[sir], dur=30)\nsim.run()\n\nInitializing sim with 10 agents\nAgent 0 | Age: 25.15 |  Infection Seed Probability: 10%\nAgent 1 | Age:  4.99 |  Infection Seed Probability: 25%\nAgent 2 | Age: 58.15 |  Infection Seed Probability: 10%\nAgent 3 | Age:  0.13 |  Infection Seed Probability: 25%\nAgent 4 | Age: 43.82 |  Infection Seed Probability: 10%\nAgent 5 | Age: 42.69 |  Infection Seed Probability: 10%\nAgent 6 | Age: 54.29 |  Infection Seed Probability: 10%\nAgent 7 | Age: 52.60 |  Infection Seed Probability: 10%\nAgent 8 | Age:  7.08 |  Infection Seed Probability: 25%\nAgent 9 | Age: 27.23 |  Infection Seed Probability: 10%\n  Running 2000.01.01 ( 0/31) (0.00 s)  ———————————————————— 3%\n  Running 2010.01.01 (10/31) (0.00 s)  •••••••————————————— 35%\n  Running 2020.01.01 (20/31) (0.01 s)  •••••••••••••——————— 68%\n  Running 2030.01.01 (30/31) (0.01 s)  •••••••••••••••••••• 100%\n\n\n\nSim(n=10; 2000—2030.0; diseases=sir)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_distributions.html#example-starsim-intervention-using-dynamic-distributions",
    "href": "user_guide/advanced_distributions.html#example-starsim-intervention-using-dynamic-distributions",
    "title": "Distributions",
    "section": "Example Starsim intervention using dynamic distributions",
    "text": "Example Starsim intervention using dynamic distributions\nTo demonstrate the use and power of distributions in the Starsim framework, we next create an intervention that delivers a vaccine to a random subset of agents using a Bernoulli distribution. The default distribution will be fixed, the same for all agents, but we’ll make it a parameter to that the user can change it without having to modify the source code.\nNOTE: That we create the distribution only one time in the __init__ method of the intervention. Here, the distribution is part of the parameters, so will appear at self.pars.p_vx. Alternatively, we could create a distribution between update_pars and return, as noted. Please avoid recreating a Starsim distribution on every time step.\n\nclass MyVx(ss.Intervention):\n    def __init__(self, pars=None, **kwargs):\n        super().__init__()\n        self.define_states(\n            ss.BoolState('vaccinated', label=\"Vaccinated\", default=False)\n        )\n        self.define_pars(\n            # Create a Bernoulli distribution as a module parameter\n            # The value p=0.1 is a placeholder, the user will override\n            p_vx = ss.bernoulli(p=0.1, name=\"Vaccination Probability\")\n        )\n        self.update_pars(pars=pars, **kwargs)\n\n        # NOTE, this is a great place to create other distributions, for example\n        # self.my_dist = ss.normal(loc=0, scale=1)\n\n        return\n\n    def init_results(self):\n        super().init_results()\n        self.define_results(\n            ss.Result('new_vx', dtype=int, label=\"Newly Vaccinated\")\n        )\n        return\n\n    def step(self):\n        # Choose which agents to vaccinate\n        novx = self.vaccinated == False # Boolean mask\n        # Filter to select agents for which the Bernoulli sample is True\n        vx_uids = self.pars.p_vx.filter(novx) # &lt;-- can pass in mask or uids\n        self.vaccinated[vx_uids] = True  # Set the state to vaccinated\n        sim.diseases.sir.rel_sus[vx_uids] = 0.0  # Set susceptibility to 0 for vaccinated agents\n        \n        # Store the results\n        self.results.new_vx[sim.ti] = len(vx_uids)\n\nNow that we have created the intervention, we can configure it with a custom p_vx_func in “user space” and run the simulation.\n\ndef p_vx_func(self, sim, uids):\n    # Set the probability of vaccination for each agent in uids\n    # This is the \"dynamic\" callable for p_vx\n\n    # Let's only administer the vaccine on the 5th time step\n    if sim.ti != 5:\n        return 0.0 \n\n    # Set vaccination probability proportional to age\n    p = sim.people.age[uids] / 100.0  # Normalize age to a probability between 0 and 1\n    p = p.clip(0.0, 1.0)  # Ensure probabilities are between 0 and 1\n    return p # p has the same length as uids\n\n\nvx_intv = MyVx(p_vx = ss.bernoulli(p=p_vx_func))\n\n# Create, run, and plot a sim using the SIR disease model\nsim = ss.Sim(n_agents=1000, dur=10, dt=1, start=0,\n    diseases=ss.SIR(), # Default SIR disease model\n    interventions=[vx_intv],\n    networks=ss.RandomNet()\n)\nsim.run().plot('myvx') # Verify vaccinations only on the 5th time step\n\nInitializing sim with 1000 agents\n  Running 0.0 ( 0/11) (0.00 s)  •——————————————————— 9%\n  Running 10.0 (10/11) (0.02 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nSee how vaccines were delivered only on time step 5? If we were to look at which agents received the vaccine, we would see probability increasing with age.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Distributions"
    ]
  },
  {
    "objectID": "user_guide/advanced_random.html",
    "href": "user_guide/advanced_random.html",
    "title": "Random numbers",
    "section": "",
    "text": "The Starsim framework implements a novel approach to sampling from distributions that prevents random number noise from corrupting differences between two simulations. This user guide will demonstrate how to use the common random number (CRN) feature to achieve low-variance differences in simulation results. This feature is important for scenario and sensitivity analyses, where the goal is to isolate the effects of specific changes in model parameters or configurations.\nFor technical details and additional examples, please refer to the following publication: D. J. Klein, R. G. Abeysuriya, R. M. Stuart, and C. C. Kerr, “Noise-free comparison of stochastic agent-based simulations using common random numbers.” arXiv preprint arXiv:2409.02086 (2024).\nThis guide builds on the Distributions guide, so please familiarize yourself with that guide before proceeding.\nIn this user guide, you will: - Understand the concept of common random numbers (CRN) - Learn how to sample from distributions using common random numbers - See the benefits of using CRN for low-variance differences",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Random numbers"
    ]
  },
  {
    "objectID": "user_guide/advanced_random.html#understanding-common-random-numbers-crn",
    "href": "user_guide/advanced_random.html#understanding-common-random-numbers-crn",
    "title": "Random numbers",
    "section": "Understanding Common Random Numbers (CRN)",
    "text": "Understanding Common Random Numbers (CRN)\nCommon Random Numbers (CRN) is a sophisticated technique that enables noise-free accounting of the effects of different parameters or interventions on outcomes like infections averted or lives saved. Starsim is the first and only simulation framework that fully supports CRN, including agent-agent interactions like disease transmission and vital dynamics including births.\nTo understand CRN, you first have to know a little about where random numbers come from. As discussed in the Advanced Distributions guide, random numbers are used to make stochastic decisions within the model. Individuals realizations are generated from a pseudo-random number generator (PRNG) using a user-specified seed. The PRNG produces a sequence of numbers that appear random but are actually deterministic, meaning that the same seed will always produce the same sequence of numbers. Here is a simple demonstration using the numpy library:\n\nimport numpy as np\nnp.random.seed(42) # Set the seed to 42\ndraws1 = np.random.random(size=10) # Draw 10 realizations\nprint(f'First draws: {draws1.round(2)}')\n\nnp.random.seed(42) # Reset the seed to 42\ndraws2 = np.random.random(size=10) # Draw 10 realizations\nprint(f'Second draws: {draws2.round(2)}')\n\nassert np.array_equal(draws1, draws2), \"The two sets of draws should be equal since the seed is the same.\"\n\nFirst draws: [0.37 0.95 0.73 0.6  0.16 0.16 0.06 0.87 0.6  0.71]\nSecond draws: [0.37 0.95 0.73 0.6  0.16 0.16 0.06 0.87 0.6  0.71]\n\n\n\nThe problem solved by CRN in agent-based simulation modeling\nMost agent-based modeling frameworks dole out random numbers to agents sequentially, as needed, drawing values from a single centralized random number generator. The problem arises when you want to compare two similar, but different simulations.\nEven if the two simulations are run with the same seed, the difference in outcomes will be a combination of:\n\nReal and meaningful “mechanistic” differences caused by the different inputs, and\nRandom number noise caused by “stochastic branching.”\n\nStochastic branching is just a technical term used to describe which random numbers are used to make each decision. The random number noise obscures the real differences, making it difficult to determine the true impact of the changes made in the second simulation.\n\n\nExample of stochastic branching: Fishing 🎣\nAs a simple example, consider the following two simulations of a Fishing module.\n\nSimulation A has 20 agents who are trying to catch fish. On each time step, each agent has a 50% chance of going fishing, and a 20% chance of catching a fish if they go fishing.\nSimulation B is identical to Simulation A, except that agent 0 is banned from fishing.\n\nBoth simulations will use the same random number seed. Because the agents do not interact (they’re not actually competing for the same fish!), the only difference in outcomes should be that agent 0 does not go fishing and therefore will never catch a fish. However, because of the way random numbers are generated, the two simulations will use the same random numbers for different purposes. This means that banning agent 0 from fishing will change which other agents go fishing and catch fish!\nNOTE: We have to specifically disable Starsim’s CRN to observe the problem that all other agent-based modeling frameworks face. To do that in Starsim, we set the single_rng option to True in this example.\nAs a first step, we will create a Fishing module:\n\nimport starsim as ss\n\nclass Fishing(ss.Module):\n    def __init__(self, pars=None, **kwargs):\n        super().__init__()\n        self.define_pars(\n            p_fishing = ss.bernoulli(p=0.5),\n            p_catch = ss.bernoulli(p=0.2),\n            banned_uids = [],\n            verbose = True\n        )\n        self.update_pars(pars=pars, **kwargs)\n        self.define_states(\n            ss.BoolState('fish_caught', default=0)\n        )\n        return\n\n    def step(self):\n        going_fishing_uids = self.pars.p_fishing.filter() # Filter with no arguments tests all agents\n\n        # Remove banned agents from going fishing\n        going_fishing_uids = going_fishing_uids.remove(self.pars.banned_uids)\n\n        catch_uids = self.pars.p_catch.filter(going_fishing_uids)\n        if self.pars.verbose:\n            print(f'Time step {self.ti}:')\n            print(f' * Agents going fishing: {going_fishing_uids}')\n            print(f' * Agents that caught fish: {catch_uids}')\n        self.fish_caught[catch_uids] = self.fish_caught[catch_uids] + 1 # Increment the number of fish caught for each agent that caught a fish\n        return\n\nNow we can build and run the two simulations to compare the results:\n\n# NOTE: For this example, we configure the simulation to be centralized!\nss.options.single_rng = True\n\n# Shared parameters for both simulations\npars = dict(n_agents=20, start=ss.days(0), dur=ss.days(1), rand_seed=42)\n\nprint('SIMULATION A: WITHOUT BANNED AGENTS', '-'*25)\nsimA = ss.Sim(modules=Fishing(), **pars)\nsimA.run()\n\nprint('\\nSIMULATION B: WITH AGENT 0 BANNED', '-'*25)\nsimB = ss.Sim(modules=Fishing(banned_uids=[0]), **pars)\nsimB.run()\n\nSIMULATION A: WITHOUT BANNED AGENTS -------------------------\nInitializing sim with 20 agents\n  Running 0.0 ( 0/2) (0.00 s)  ••••••••••—————————— 50%\nTime step 0:\n * Agents going fishing: [ 0  1  2  4  6  9 16 17 18 19]\n * Agents that caught fish: [16 18]\nTime step 1:\n * Agents going fishing: [ 1  2  7  8  9 12 13 14 15 19]\n * Agents that caught fish: [ 1 15 19]\n\nSIMULATION B: WITH AGENT 0 BANNED -------------------------\nInitializing sim with 20 agents\n  Running 0.0 ( 0/2) (0.00 s)  ••••••••••—————————— 50%\nTime step 0:\n * Agents going fishing: [ 1  2  4  6  9 16 17 18 19]\n * Agents that caught fish: [17 19]\nTime step 1:\n * Agents going fishing: [ 2  3  8  9 10 13 14 15 16]\n * Agents that caught fish: [3]\n\n\nSim(n=20; 0—1.0; modules=fishing)\n\n\nIn simulation A, agents 16 and 18 catch fish on the first time step, but in simulation B, agents 17 and 19 catch fish. Then on the second timestep, we can see that different agents go fishing and that 1, 15, and 19 catch fish in A but only 3 is lucky in B – what?! All we did was to ban agent 0 from fishing. The agents do not interact, so there should not have been a difference!\nWhat we are seeing here is a simple example of the stochastic branching problem. This “random number noise” could easily make it look like banning agent 0 could result in more fish being caught, which should be physically impossible as there are fewer agents fishing.\nTo see the benefit of CRN, we can simply repeat the above example, but this time restoring the single_rng option to its default value of False. This will ensure that the same random numbers are used for the exact same decisions in both simulations, allowing us to see the true impact of banning agent 1 from fishing:\n\n# Restore the single_rng option to False (this is the default, so you don't have to do this)\nss.options.single_rng = False\n\nprint('SIMULATION A: WITHOUT BANNED AGENTS', '-'*25)\nsimA = ss.Sim(modules=Fishing(), **pars)\nsimA.run()\n\nprint('\\nSIMULATION B: WITH AGENT 1 BANNED', '-'*25)\nsimB = ss.Sim(modules=Fishing(banned_uids=[1]), **pars)\nsimB.run()\n\nSIMULATION A: WITHOUT BANNED AGENTS -------------------------\nInitializing sim with 20 agents\n  Running 0.0 ( 0/2) (0.00 s)  ••••••••••—————————— 50%\nTime step 0:\n * Agents going fishing: [ 1  4  5  6  7  9 15 19]\n * Agents that caught fish: [ 7 19]\nTime step 1:\n * Agents going fishing: [ 1  2  3  7  9 12 14 15 17 19]\n * Agents that caught fish: [ 1 12 15]\n\nSIMULATION B: WITH AGENT 1 BANNED -------------------------\nInitializing sim with 20 agents\n  Running 0.0 ( 0/2) (0.00 s)  ••••••••••—————————— 50%\nTime step 0:\n * Agents going fishing: [ 4  5  6  7  9 15 19]\n * Agents that caught fish: [ 7 19]\nTime step 1:\n * Agents going fishing: [ 2  3  7  9 12 14 15 17 19]\n * Agents that caught fish: [12 15]\n\n\nSim(n=20; 0—1.0; modules=fishing)\n\n\nWith CRN, banning agent 0 only prevents agent 0 from catching fish. Everything else is identical, as expected. This is the power of common random numbers.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Random numbers"
    ]
  },
  {
    "objectID": "user_guide/advanced_random.html#tips-for-crn-enabled-sampling-in-starsim",
    "href": "user_guide/advanced_random.html#tips-for-crn-enabled-sampling-in-starsim",
    "title": "Random numbers",
    "section": "Tips for CRN-enabled sampling in Starsim",
    "text": "Tips for CRN-enabled sampling in Starsim\nThis advanced CRN functionality is built into every distribution in Starsim! You will automatically get the benefits of CRN whenever you properly use distributions in your modules. Here are a few tips to ensure proper usage:\n\nUse a separate distribution for each “decision” in your code. Ideally, each distribution would only be called one time per time step.\nCreate each distribution one time per module. The __init__ method is a great place to do this. Do not create a new distribution on every step.\nWhen sampling from a distribution, pass uids or a boolean mask with length equal to the number of agents in the simulation. This ensures that each agent gets the right random number.\nIf the parameters of your distribution change every step, set the parameter values to a callable function that performs the calculation.\n\nPreferred and avoided usage examples:\n# PREFERRED: use uids\nall_uids = self.sim.people.auids\nvalues = self.dist.rvs(all_uids)\n\n# PREFERRED: use a boolean mask\nmask = (self.infected) & (self.ti &gt;= self.ti_next_event)\nvalues = self.dist.rvs(mask)\n\n# PREFERRED: set dynamic parameters using a callable\ndef dynamic_p(self, sim, uids):\n    p = np.full_like(uids, fill_value=0.5, dtype=float)\n    p[sim.people.age[uids] &lt; 18] = 0.1\n    return p\ndef __init__(self):\n    self.dist = self.bernoulli(p=dynamic_p)\nuids = self.dist.filter(mask) # Reminder: filter returns the uids where the bernoulli trial is True\n\n# AVOID calling a distribution with a scalar argument\nvalues = self.dist.rvs(len(all_uids))\n\n# AVOID: numpy random\nvalues = np.random.rand(len(all_uids))\n\n# AVOID creating a new distribution every time\ndef step(self):\n    new_dist_every_time = self.bernoulli(p=0.5)\n    values = new_dist_every_time.rvs(all_uids) \n\n# AVOID using the same distribution for multiple decisions\nmy_bernoulli = self.bernoulli(p=0)\nmy_bernoulli.set(p=p_infection)\ninfected_uids = my_bernoulli.filter()\nmy_bernoulli.set(p=p_die)\ndied_uids = my_bernoulli.filter()\n\n# Try to AVOID calling rvs multiple times per step\n# (It's better to get all the values you need in one call)\nfor uid in all_uids:\n    value = self.dist.rvs(uid)\n\n# Try to AVOID overriding parameters every time step\n# (Use dynamic parameters instead)\ndef step(self):\n    my_p_vec = np.full(self.sim.n, fill_value=0.5)\n    my_p_vec[self.sim.people.age &lt; 18] = 0.1\n    self.dist.set(p=my_p_vec)\n    uids = self.dist.filter(mask)\nPlease don’t hesitate to create issues related to any problems you encounter or questions you have!",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Random numbers"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html",
    "href": "user_guide/modules_connectors.html",
    "title": "Connectors",
    "section": "",
    "text": "Connectors enable interactions between different modules in Starsim, particularly between disease models. They allow you to model complex epidemiological scenarios where one disease affects the transmission or progression of another disease. For example, you might want to model how having syphilis increases susceptibility to HIV, or how HIV affects the treatment outcomes of other sexually transmitted infections.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#basic-concepts",
    "href": "user_guide/modules_connectors.html#basic-concepts",
    "title": "Connectors",
    "section": "Basic concepts",
    "text": "Basic concepts\nA connector inherits from ss.Connector and implements custom logic to modify disease parameters or agent states based on the presence of other diseases. Connectors are called during each simulation timestep and can dynamically adjust transmission parameters, susceptibility, or other disease characteristics. Specifically, connectors are called after demographics and disease state updates, but before networks, interventions, and disease transmission updates. This means they can influence disease transmission for the current timestep.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#simple-usage",
    "href": "user_guide/modules_connectors.html#simple-usage",
    "title": "Connectors",
    "section": "Simple usage",
    "text": "Simple usage\nThe most straightforward way to use connectors is to define a custom class that inherits from ss.Connector and implements a step() method. This method is called during each simulation timestep and can modify disease parameters based on the current state of the simulation.\nHere’s a simple example showing how HIV and “SIS” diseases can interact, and also illustrates how you would use an analyzer to compare the two simulations:\n\nimport starsim as ss\nimport starsim_examples as sse\nimport sciris as sc\nimport numpy as np\nimport matplotlib.pyplot as plt\nsc.options(jupyter=True)\n\nclass SIS_HIV(ss.Connector):\n    \"\"\"\n    Simple connector that modifies HIV susceptibility based on SIS infection status.\n    People with SIS infection are protected from HIV (rel_sus = 0),\n    while susceptible people have normal HIV susceptibility (rel_sus = 1).\n    \"\"\"\n    \n    def step(self):\n        # Get disease modules\n        hiv = self.sim.diseases.hiv\n        sis = self.sim.diseases.sis\n        sis_pos = (sis.infected).uids\n        sis_neg = (sis.susceptible).uids\n        \n        # Modify HIV relative susceptibility based on SIS infection status\n        hiv.rel_sus[sis_neg] = 1.0  # Reset to baseline\n        hiv.rel_sus[sis_pos] = 0  # SIS-infected people cannot acquire HIV\n        return\n\n\nclass check_connector(ss.Analyzer):\n    \"\"\"\n    Analyzer that tracks and plots HIV relative susceptibility and disease prevalence over time.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.time = sc.autolist()     # Store timesteps\n        self.rel_sus = sc.autolist()  # Store mean HIV relative susceptibility\n        self.sis_prev = sc.autolist() # Store SIS prevalence\n        self.hiv_prev = sc.autolist() # Store HIV prevalence\n        return\n\n    def step(self):\n        \"\"\"Record data at each timestep\"\"\"\n        # Get disease references\n        sis = self.sim.diseases.sis\n        hiv = self.sim.diseases.hiv\n        \n        # Append current timestep data\n        self.time += self.ti\n        self.rel_sus += hiv.rel_sus.mean()  # Average HIV relative susceptibility\n        self.sis_prev += sis.results.prevalence[self.ti]  # SIS prevalence\n        self.hiv_prev += hiv.results.prevalence[self.ti]  # HIV prevalence\n        return\n\n    def plot(self):\n        \"\"\"\n        Plot the time series of relative susceptibility and disease prevalence.\n        \"\"\"\n        fig = plt.figure()\n        \n        # Plot each metric\n        for key in ['rel_sus', 'sis_prev', 'hiv_prev']:\n            plt.plot(self.time, self[key], label=key)\n        \n        plt.legend()\n        plt.title(self.sim.label)\n        plt.show()\n        return fig\n    \n# Create disease models\nhiv = sse.HIV(beta=dict(mf=0.1, random=0), init_prev=0.001)\nsis = ss.SIS(beta=dict(mf=0.0, random=0.05))\nmf = ss.MFNet(duration=ss.lognorm_ex(mean=ss.years(5), std=ss.years(5)))\n\n# Configure simulation parameters\npars = dict(\n    diseases=[hiv, sis],\n    networks=[mf,'random'],\n    analyzers=check_connector(),\n    verbose=0\n)\n\n# Create simulations with and without connector\ns1 = ss.Sim(label='Without connector', **pars)\ns2 = ss.Sim(label='With connector', **pars, connectors=SIS_HIV())\n\n# Run simulations in parallel\nmsim = ss.parallel(s1, s2)\n\n# Plot results\nmsim.plot()\nfor sim in msim.sims:\n    sim.analyzers[0].plot()\n\nFigure(896x672)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this example, the connector modifies HIV susceptibility based on SIS infection status. You can see that when the connector is active, HIV transmission is significantly reduced because SIS-infected individuals cannot acquire HIV.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#advanced-usage-with-parameters",
    "href": "user_guide/modules_connectors.html#advanced-usage-with-parameters",
    "title": "Connectors",
    "section": "Advanced usage with parameters",
    "text": "Advanced usage with parameters\nFor more complex interactions, you can define parameters in your connector class to control the strength and nature of the interactions. Here’s an example showing bi-directional interactions between HIV and syphilis:\n\nclass HIV_Syphilis(ss.Connector):\n    \"\"\"\n    Advanced connector showing bi-directional interactions between HIV and syphilis.\n    Models how HIV affects syphilis susceptibility/transmission and vice versa,\n    with different effects based on CD4 count (AIDS progression).\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.define_pars(\n            label='HIV-Syphilis',\n            rel_sus_syph_hiv=2,      # People with HIV are 2x more likely to acquire syphilis\n            rel_sus_syph_aids=5,     # People with AIDS are 5x more likely to acquire syphilis\n            rel_trans_syph_hiv=1.5,  # People with HIV are 1.5x more likely to transmit syphilis\n            rel_trans_syph_aids=3,   # People with AIDS are 3x more likely to transmit syphilis\n            rel_sus_hiv_syph=2.7,    # People with syphilis are 2.7x more likely to acquire HIV\n            rel_trans_hiv_syph=2.7,  # People with syphilis are 2.7x more likely to transmit HIV\n        )\n        self.update_pars(**kwargs)\n        return\n\n    def step(self):\n        \"\"\"Apply HIV-syphilis interactions based on CD4 count and infection status\"\"\"\n        diseases = self.sim.diseases\n        syph = diseases.syphilis\n        hiv = diseases.hiv\n        cd4 = self.sim.people.hiv.cd4\n\n        # Reset relative susceptibility and transmission to baseline\n        syph.rel_sus[:] = 1.0\n        syph.rel_trans[:] = 1.0\n        hiv.rel_sus[:] = 1.0\n        hiv.rel_trans[:] = 1.0\n\n        # People with HIV are more likely to acquire syphilis\n        syph.rel_sus[cd4 &lt; 500] = self.pars.rel_sus_syph_hiv\n        syph.rel_sus[cd4 &lt; 200] = self.pars.rel_sus_syph_aids  # AIDS stage\n\n        # People with HIV are more likely to transmit syphilis\n        syph.rel_trans[cd4 &lt; 500] = self.pars.rel_trans_syph_hiv\n        syph.rel_trans[cd4 &lt; 200] = self.pars.rel_trans_syph_aids\n\n        # People with syphilis are more likely to acquire HIV\n        hiv.rel_sus[syph.active] = self.pars.rel_sus_hiv_syph\n\n        # People with syphilis are more likely to transmit HIV\n        hiv.rel_trans[syph.active] = self.pars.rel_trans_hiv_syph\n        return\n\n# Create disease models\nhiv = sse.HIV(beta={'mf': [0.0008, 0.0004]}, init_prev=0.2)\nsyph = sse.Syphilis(beta={'mf': [0.1, 0.05]}, init_prev=0.05)\n\n# Create network\nmf = ss.MFNet()\n\n# Configure simulation parameters\nkw = dict(\n    diseases=[hiv, syph], \n    networks=mf,\n    n_agents=2000,\n    verbose=0\n)\n\n# Create simulations\ns1 = ss.Sim(label='Without connector', **kw)\ns2 = ss.Sim(label='With connector', connectors=HIV_Syphilis(), **kw)\n\n# Run simulations\nmsim = ss.parallel(s1, s2)\n\n# Compare results\nprint(\"\\nFinal infection counts:\")\nprint(f\"HIV infections - Without connector: {s1.results.hiv.n_infected[-1]}\")\nprint(f\"HIV infections - With connector: {s2.results.hiv.n_infected[-1]}\")\nprint(f\"Syphilis infections - Without connector: {s1.results.syphilis.n_infected[-1]}\")\nprint(f\"Syphilis infections - With connector: {s2.results.syphilis.n_infected[-1]}\")\n\n# Plot comparative results\nfig = plt.figure(figsize=(12, 4))\n\n# HIV infections\nplt.subplot(121)\nplt.plot(s1.timevec, s1.results.hiv.n_infected, label='Without connector', alpha=0.8)\nplt.plot(s2.timevec, s2.results.hiv.n_infected, label='With connector', alpha=0.8)\nplt.title('HIV infections over time')\nplt.xlabel('Year')\nplt.ylabel('Number infected')\nplt.legend()\n\n# Syphilis infections\nplt.subplot(122)\nplt.plot(s1.timevec, s1.results.syphilis.n_infected, label='Without connector', alpha=0.8)\nplt.plot(s2.timevec, s2.results.syphilis.n_infected, label='With connector', alpha=0.8)\nplt.title('Syphilis infections over time')\nplt.xlabel('Year')\nplt.ylabel('Number infected')\nplt.legend()\nplt.show()\n\n\nFinal infection counts:\nHIV infections - Without connector: 134.0\nHIV infections - With connector: 134.0\nSyphilis infections - Without connector: 220.0\nSyphilis infections - With connector: 392.0\n\n\n\n\n\n\n\n\n\nThis more complex example demonstrates several important concepts:\n\nParameter definition: Using define_pars() to set configurable parameters for the interaction strengths\nBi-directional effects: Both diseases affect each other’s transmission and susceptibility\nDisease progression considerations: Different effects based on HIV progression (CD4 count)\nMultiple attributes: Modifying both relative susceptibility (rel_sus) and relative transmission (rel_trans)",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/modules_connectors.html#combining-connectors-with-interventions",
    "href": "user_guide/modules_connectors.html#combining-connectors-with-interventions",
    "title": "Connectors",
    "section": "Combining connectors with interventions",
    "text": "Combining connectors with interventions\nConnectors can work alongside interventions to model complex treatment scenarios. Here’s an example that combines the HIV-syphilis connector with a treatment intervention:\n\nclass Penicillin(ss.Intervention):\n    \"\"\"\n    Penicillin treatment intervention for syphilis.\n    Also resets HIV transmission/susceptibility parameters when syphilis is cured.\n    \"\"\"\n    \n    def __init__(self, year=2020, prob=0.8):\n        super().__init__()\n        self.prob = prob  # Probability of receiving treatment\n        self.year = ss.date(year)  # Year treatment becomes available\n        return\n\n    def step(self):\n        sim = self.sim\n        if sim.now &gt;= self.year:\n            syphilis = sim.diseases.syphilis\n\n            # Define who is eligible for treatment (currently infected)\n            eligible_ids = syphilis.infected.uids\n            n_eligible = len(eligible_ids)\n\n            if n_eligible &gt; 0:\n                # Determine who receives treatment\n                is_treated = np.random.rand(n_eligible) &lt; self.prob\n                treat_ids = eligible_ids[is_treated]\n\n                # Cure syphilis\n                syphilis.infected[treat_ids] = False\n                syphilis.susceptible[treat_ids] = True\n\n                # Reset HIV parameters (removes syphilis co-infection effects)\n                sim.diseases.hiv.rel_sus[treat_ids] = 1.0\n                sim.diseases.hiv.rel_trans[treat_ids] = 1.0\n        return\n\n# Create simulations with different combinations\nsims = {}\n\n# Base configuration\nbase_kw = dict(\n    diseases=[sse.HIV(beta={'mf': [0.0008, 0.0004]}, init_prev=0.2),\n              sse.Syphilis(beta={'mf': [0.1, 0.05]}, init_prev=0.05)], \n    networks=ss.MFNet(),\n    n_agents=2000,\n    verbose=0\n)\n\n# 1. No connector, no treatment\nsims['baseline'] = ss.Sim(label='Baseline (no connector, no treatment)', **base_kw)\n\n# 2. Connector only\nsims['connector'] = ss.Sim(label='With connector only', \n                          connectors=HIV_Syphilis(), **base_kw)\n\n# 3. Connector + treatment\nsims['both'] = ss.Sim(label='Connector + treatment', \n                     connectors=HIV_Syphilis(), \n                     interventions=Penicillin(year=2020, prob=0.8), **base_kw)\n\n# Run all simulations\nmsim = ss.parallel(*sims.values())\n\n# Create comparison plot\nfig, ax = plt.subplots(2, 2, figsize=(12, 8))\n\n# HIV infections\nax[0,0].set_title('HIV infections over time')\nfor sim in sims.values():\n    ax[0,0].plot(sim.timevec, sim.results.hiv.n_infected, label=sim.label, alpha=0.8)\nax[0,0].axvline(2020, color='red', linestyle='--', alpha=0.5, label='Treatment start')\nax[0,0].set_xlabel('Year')\nax[0,0].set_ylabel('Number infected')\nax[0,0].legend()\n\n# Syphilis infections\nax[0,1].set_title('Syphilis infections over time')\nfor sim in sims.values():\n    ax[0,1].plot(sim.timevec, sim.results.syphilis.n_infected, label=sim.label, alpha=0.8)\nax[0,1].axvline(2020, color='red', linestyle='--', alpha=0.5, label='Treatment start')\nax[0,1].set_xlabel('Year')\nax[0,1].set_ylabel('Number infected')\nax[0,1].legend()\n\n# Cumulative HIV infections\nax[1,0].set_title('Cumulative HIV infections')\nfor sim in sims.values():\n    ax[1,0].plot(sim.timevec, sim.results.hiv.cum_infections, label=sim.label, alpha=0.8)\nax[1,0].set_xlabel('Year')\nax[1,0].set_ylabel('Cumulative infections')\nax[1,0].legend()\n\n# Cumulative syphilis infections\nax[1,1].set_title('Cumulative syphilis infections')\nfor sim in sims.values():\n    ax[1,1].plot(sim.timevec, sim.results.syphilis.cum_infections, label=sim.label, alpha=0.8)\nax[1,1].set_xlabel('Year')\nax[1,1].set_ylabel('Cumulative infections')\nax[1,1].legend()\n\nplt.tight_layout()\nplt.show()\n\n# Print summary statistics\nsc.heading(\"Final results summary:\")\nfor sim in sims.values():\n    hiv_final = sim.results.hiv.n_infected[-1]\n    syph_final = sim.results.syphilis.n_infected[-1]\n    hiv_cum = sim.results.hiv.cum_infections[-1]\n    syph_cum = sim.results.syphilis.cum_infections[-1]\n    print(f\"{sim.label}:\")\n    print(f\"  HIV: {hiv_final:3.0f} current, {hiv_cum:4.0f} cumulative\")\n    print(f\"  Syphilis: {syph_final:3.0f} current, {syph_cum:4.0f} cumulative\")\n\n\n\n\n\n\n\n\n\n\n——————————————————————\nFinal results summary:\n——————————————————————\n\nBaseline (no connector, no treatment):\n  HIV: 134 current,  225 cumulative\n  Syphilis: 220 current,  167 cumulative\nWith connector only:\n  HIV: 134 current,  225 cumulative\n  Syphilis: 392 current,  363 cumulative\nConnector + treatment:\n  HIV: 134 current,  225 cumulative\n  Syphilis: 380 current, 6123 cumulative\n\n\nThis example demonstrates how interventions and connectors work together. The treatment intervention not only cures syphilis but also resets the HIV transmission parameters, effectively removing the co-infection effects when syphilis is treated.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Connectors"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html",
    "href": "user_guide/basics_model.html",
    "title": "Model structure",
    "section": "",
    "text": "Starsim models are designed to capture disease dynamics within a population of agents, which typically represent people (but may represent animals or other things). In keeping with this, the basic ingredients of a Starsim model are the People class, which store all the relevant attributes about people, a collection of Modules that determine what happens to people on each time step, and the Sim class, which pulls all the components together, runs the simulation, and stores the Results.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-people",
    "href": "user_guide/basics_model.html#overview-of-people",
    "title": "Model structure",
    "section": "Overview of People",
    "text": "Overview of People\nMore details on the People class are in the separate user guide page, but we give a basic introduction here since people are so central to the model structure. When people are created, by default they come with basic states that are stored for each person. These basic states include age, sex, and whether the person is alive. All of these states are stored as arrays, so the basic structure of the People class can be easily exported to a dataframe, e.g.:\n\nimport starsim as ss\n\nsim = ss.Sim(n_agents=10)\nsim.init()\ndf = sim.people.to_df()\nprint(df)\n\nInitializing sim with 10 agents\n   uid  slot  alive        age  female  ti_dead  ti_removed  scale\n0    0     0   True  25.152369   False      NaN         NaN    1.0\n1    1     1   True   4.988294    True      NaN         NaN    1.0\n2    2     2   True  58.149414   False      NaN         NaN    1.0\n3    3     3   True   0.130237   False      NaN         NaN    1.0\n4    4     4   True  43.819874   False      NaN         NaN    1.0\n5    5     5   True  42.690937   False      NaN         NaN    1.0\n6    6     6   True  54.292294    True      NaN         NaN    1.0\n7    7     7   True  52.604046   False      NaN         NaN    1.0\n8    8     8   True   7.076855   False      NaN         NaN    1.0\n9    9     9   True  27.229174   False      NaN         NaN    1.0\n\n\nWhen a module is added to a sim, this can add additional states to people. Tracking and updating the states of people is one of the main ways in which Starsim models disease dynamics. For example:\n\nimport starsim as ss\n\nsim = ss.Sim(n_agents=20, diseases=dict(type='sis', init_prev=0.2), networks='random')\nsim.run()\ndf = sim.people.to_df()\ndf.disp()\n\nInitializing sim with 20 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.14 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.15 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.17 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.18 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.19 s)  •••••••••••••••••••• 100%\n\n    uid  slot  alive      age  female  ti_dead  ti_removed  scale  randomnet.participant  sis.susceptible  sis.infected  sis.rel_sus  sis.rel_trans  sis.ti_infected  sis.ti_recovered  sis.immunity\n0     0     0   True  25.1524   False      NaN         NaN    1.0                  False             True         False       0.3449            1.0             33.0           42.7465        0.6551\n1     1     1   True   4.9883    True      NaN         NaN    1.0                  False            False          True       0.0000            1.0             42.0           52.0214        1.0051\n2     2     2   True  58.1494   False      NaN         NaN    1.0                  False             True         False       0.6627            1.0             23.0           31.5178        0.3373\n3     3     3   True   0.1302   False      NaN         NaN    1.0                  False            False          True       0.0000            1.0             49.0           59.3261        1.5559\n4     4     4   True  43.8199   False      NaN         NaN    1.0                  False             True         False       0.1787            1.0             38.0           48.7212        0.8213\n5     5     5   True  42.6909   False      NaN         NaN    1.0                  False             True         False       0.3620            1.0             29.0           37.6566        0.6380\n6     6     6   True  54.2923    True      NaN         NaN    1.0                  False             True         False       0.1526            1.0             38.0           47.5738        0.8474\n7     7     7   True  52.6040   False      NaN         NaN    1.0                  False             True         False       0.1201            1.0             39.0           49.7212        0.8799\n8     8     8   True   7.0769   False      NaN         NaN    1.0                  False             True         False       0.6627            1.0             22.0           31.8954        0.3373\n9     9     9   True  27.2292   False      NaN         NaN    1.0                  False             True         False       0.6816            1.0             18.0           28.5382        0.3184\n10   10    10   True   4.0500    True      NaN         NaN    1.0                  False             True         False       0.5393            1.0             29.0           38.6003        0.4607\n11   11    11   True  42.6985   False      NaN         NaN    1.0                  False             True         False       0.7392            1.0             16.0           23.6503        0.2608\n12   12    12   True  25.2828    True      NaN         NaN    1.0                  False             True         False       0.6321            1.0             24.0           33.8575        0.3679\n13   13    13   True  27.6266    True      NaN         NaN    1.0                  False             True         False       0.6454            1.0             23.0           32.7132        0.3546\n14   14    14   True  24.6072   False      NaN         NaN    1.0                  False             True         False       0.5097            1.0             30.0           40.1969        0.4903\n15   15    15   True  48.8226   False      NaN         NaN    1.0                  False             True         False       0.3416            1.0             32.0           42.4071        0.6584\n16   16    16   True  16.9486   False      NaN         NaN    1.0                  False             True         False       0.3998            1.0             31.0           40.2152        0.6002\n17   17    17   True  19.6193    True      NaN         NaN    1.0                  False             True         False       0.5808            1.0             28.0           37.0291        0.4192\n18   18    18   True  40.8453    True      NaN         NaN    1.0                  False             True         False       0.3479            1.0             29.0           39.7353        0.6521\n19   19    19   True  25.0690   False      NaN         NaN    1.0                  False            False          True       0.7392            1.0             50.0           60.8258        1.2608\n\n\nWe can see even in this very simple example with only one disease and 20 agents, a lot of data is generated!",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-modules",
    "href": "user_guide/basics_model.html#overview-of-modules",
    "title": "Model structure",
    "section": "Overview of Modules",
    "text": "Overview of Modules\nStarsim contains the following kinds of modules, listed below in the order that they are typically updated:\n\nDemographics\nDiseases\nConnectors\nNetworks\nInterventions\nAnalyzers\n\nModules typically store parameters (e.g. the transmission probability), states of people (e.g. whether they are susceptible, infected, or recovered), and results (e.g. the number of people infected at each point in time).",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-a-sim",
    "href": "user_guide/basics_model.html#overview-of-a-sim",
    "title": "Model structure",
    "section": "Overview of a Sim",
    "text": "Overview of a Sim\nThe Sim object is responsible for storing assembling, initializing, and running the model. The Sim class contains some top-level parameters (including the number of agents in the simulation, the start and stop times, and the random seed) and results (e.g. the population size over time), but almost all other parameters and results are specific to modules and stored within them. There are more details on the Sim on the linked page.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#what-happens-when-you-add-a-module",
    "href": "user_guide/basics_model.html#what-happens-when-you-add-a-module",
    "title": "Model structure",
    "section": "What happens when you add a module?",
    "text": "What happens when you add a module?\nWhen you add a module to a Sim, the module’s parameters, states, and results will be added to the centralized collections of parameters, states, and results that are maintained within the Sim. To illustrate this, let’s create a Sim with an SIR disease module and a random contact network:\n\nimport starsim as ss \nsir = ss.SIR(dur_inf=10, beta=0.2, init_prev=0.4, p_death=0.2)\nsim = ss.Sim(diseases=sir, networks='random')\nsim.init()  # Initialize the sim to create \n\nInitializing sim with 10000 agents\n\n\nSim(n=10000; 2000—2050.0; networks=randomnet; diseases=sir)\n\n\nThe call to sim.init() means that the SIR module gets added to sim.diseases and the RandomNet network gets added to sim.networks. In addition, the following updates are made: * the parameters of the modules are added to the sim’s centralized parameter dictionary, so you can access them via either sim.pars.sir.init_prev or sim.diseases.sir.pars.init_prev * the states specific to each module are added to People, so you can access them via sim.diseases.sir.infected or sim.people.sir.infected * the results specific to each module are added to the centralized Results dictionary of the Sim, so you can access them via sim.diseases.sir.results.n_infected or sim.results.sir.n_infected.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/basics_model.html#overview-of-results",
    "href": "user_guide/basics_model.html#overview-of-results",
    "title": "Model structure",
    "section": "Overview of Results",
    "text": "Overview of Results\nOnce you’ve run a Sim, all the results are stored under sim.results. This is structured similarly to a nested dictionary, with results specific to each module stored in their own dictionaries, like the sim.results.sir.n_infected example above.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Basic concepts",
      "Model structure"
    ]
  },
  {
    "objectID": "user_guide/workflows_calibration.html",
    "href": "user_guide/workflows_calibration.html",
    "title": "Calibration using Optuna-Starsim integration",
    "section": "",
    "text": "Disease models typically require contextualization to a relevant setting of interest prior to addressing “what-if” scenario questions. The process of tuning model input parameters so that model outputs match observed data is known as calibration. There are many approaches to model calibration, ranging from manual tuning to fully Bayesian methods.\nFor many applications, we have found that an optimization-based approach is sufficient for initial exploration. Such methods avoid the tedious process of manual tuning and are less computationally expensive than fully Bayesian methods. One such optimization-based approach is the Optuna library, which is a Bayesian hyperparameter optimization framework. Optuna is designed for tuning hyperparameters of machine learning models, but it can also be used to calibrate disease models.\nCalibration libraries often treat the disease model as a black box, where the input parameters are the “hyperparameters” to be tuned. The calibration process is often iterative and requires a combination of expert knowledge and computational tools. The optimization algorithm iteratively chooses new parameter values to evaluate, and the model is run with these values to generate outputs. The outputs are compared to observed data, and a loss function is calculated to quantify the difference between the model outputs and the observed data. The optimization algorithm then uses this loss function to update its search strategy and choose new parameter values to evaluate. This process continues until the algorithm converges to a set of parameter values that minimize the loss function.\nWhile many optimization algorithms are available, Starsim has a built-in interface to the Optuna library, which we will demonstrate in this guide. We will use a simple Susceptible-Infected-Recovered (SIR) model as an example. We will tune three input parameters, the infectivity parameter, beta, the initial prevalence parameter, init_prev, and the Poisson-distributed degree distribution parameter, n_contacts. We will calibrate the model using a beta-binomial likelihood function so as to match prevalence at three distinct time points.\nFor a comparison of optimization-based and Bayesian approaches to calibration, see the SIR calibration workflows notebook.\nWe begin with a few imports and default settings:\n\n# Notebook configuration\n%load_ext autoreload\n%autoreload 2\n%matplotlib inline\n\n##%% Imports and settings\nimport sciris as sc\nimport starsim as ss\nimport numpy as np\nimport pandas as pd\n\nn_agents = 2e3\ndebug = False # If true, will run in serial\n\nThe calibration class will require a base Sim object. This sim will later be modified according to parameters selected by the optimization engine. The following function creates the base Sim object.\n\ndef make_sim():\n    sir = ss.SIR(\n        beta = ss.perday(0.075),\n        init_prev = ss.bernoulli(0.02),\n    )\n    random = ss.RandomNet(n_contacts=ss.poisson(4))\n\n    sim = ss.Sim(\n        n_agents = n_agents,\n        start = ss.date('2020-01-01'),\n        stop = ss.date('2020-02-12'),\n        dt = ss.days(1),\n        diseases = sir,\n        networks = random,\n        verbose = 0,\n    )\n\n    return sim\n\nNow let’s define the calibration parameters. These are the inputs that Optuna will be able to modify. Here, we define three such parameters, beta, init_prev, and n_contacts.\nEach parameter entry should have range defined by low and high as well as a guess values. The guess value is not used by Optuna, rather only for a check after calibration completes to see if the new parameters are better than the guess values.\nYou’ll notice there are a few other parameters that can be specified. For example, the data type of the parameter appears in suggest_type. Possible values are listed in the Optuna documentation, and include suggest_float for float values and suggest_int for integer types.\nTo make things easier for the search algorithm, it’s helpful to indicate how outputs are expected to change with inputs. For example, increasing beta from 0.01 to 0.02 should double disease transmission, but increasing from 0.11 to 0.12 will have a small effect. Thus, we indicate that this parameter should be calibrated with log=True.\n\n# Define the calibration parameters\ncalib_pars = dict(\n    beta = dict(low=0.01, high=0.30, guess=0.15, suggest_type='suggest_float', log=True), # Note the log scale\n    init_prev = dict(low=0.01, high=0.05, guess=0.15), # Default type is suggest_float, no need to re-specify\n    n_contacts = dict(low=2, high=10, guess=3, suggest_type='suggest_int'), # Suggest int just for this demo\n)\n\nThe optimization engine iteratively chooses input parameters to simulate. Those parameters are passed into the following build_sim function as a dictionary of calib_pars along with the base sim and any other key word arguments. The calib_pars will be as above, but importantly will have an additional key named value containing the value selected by Optuna.\nWhen modifying a sim, it is important to realize that the simulation has not been initialized yet. Nonetheless, the configuration is available for modification at sim.pars, as demonstrated in the function below for the SIR example.\n\ndef build_sim(sim, calib_pars, n_reps=1, **kwargs):\n    \"\"\"\n    Modify the base simulation by applying calib_pars. The result can be a\n    single simulation or multiple simulations if n_reps&gt;1. Note that here we are\n    simply building the simulation by modifying the base sim. Running the sims\n    and extracting results will be done by the calibration function.\n    \"\"\"\n\n    sir = sim.pars.diseases # There is only one disease in this simulation and it is a SIR\n    net = sim.pars.networks # There is only one network in this simulation and it is a RandomNet\n\n    for k, pars in calib_pars.items(): # Loop over the calibration parameters\n        if k == 'rand_seed':\n            sim.pars.rand_seed = v\n            continue\n\n        # Each item in calib_pars is a dictionary with keys like 'low', 'high',\n        # 'guess', 'suggest_type', and importantly 'value'. The 'value' key is\n        # the one we want to use as that's the one selected by the algorithm\n        v = pars['value']\n        if k == 'beta':\n            sir.pars.beta = ss.perday(v)\n        elif k == 'init_prev':\n            sir.pars.init_prev = ss.bernoulli(v)\n        elif k == 'n_contacts':\n            net.pars.n_contacts = ss.poisson(v)\n        else:\n            raise NotImplementedError(f'Parameter {k} not recognized')\n\n    # If just one simulation per parameter set, return the single simulation\n    if n_reps == 1:\n        return sim\n\n    # But if you'd like to run multiple simulations with the same parameters, we return a MultiSim instead\n    # Note that each simulation will have a different random seed, you can set specific seeds if you like\n    # Also note that parallel=False and debug=True are important to avoid issues with parallelism in the calibration\n    # Advanced: If running multiple reps, you can choose if/how they are combined using the \"combine_reps\" argument to each CalibComponent, introduced below.\n    ms = ss.MultiSim(sim, iterpars=dict(rand_seed=np.random.randint(0, 1e6, n_reps)), initialize=True, debug=True, parallel=False)\n    return ms\n\n\n# Lets plot a single simulation to see what it looks like\nsim = make_sim()\nsim.run()\nsim.plot()\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nThe Starsim framework has been integrated with the Optuna hyperparameter optimization algorithm to facilitate calibration through the Calibration class. Recall that an optimization-based approach to calibration minimizes a function of the input parameters. This function is key to achieving an acceptable calibration.\nThere are two ways to describe the goodness-of-fit function for the Calibration. The first method is to directly provide a function that the algorithm will call. The eval_fn will be passed each completed sim after running, and is expected to return a float representing the mismatch (lower is better as the optimization algorithm is configured to minimize). Data can be passed into the eval_fn via eval_kwargs.\nAs an alternative to directly specifying the evaluation function, you can use CalibComponents. Each component includes real data, for example from a survey, that is compared against simulation data from the model. Several components can be used at the same time, for example one for disease prevalence and another for treatment coverage. Each component computes a likelihood of the data given the input parameters, as assessed via simulation. Components are combined assuming independence.\nThe base class for a component is called CalibComponent, which you can use to define your own likelihood. However, we have provided components for several key likelihood functions including BetaBinomial, Binomial, DirichletMultinomial, GammaPoisson, and Normal. The Normal component is most like a traditional squared error. Each component takes in a name and a weight, which is used when combining log likelihoods.\nImportantly, each component takes in the calibration target, the real data that was observed, in an argument called expected. This argument should be a Pandas Dataframe with one row per time point and columns that will depend on the specific component type. For example, the Binomial component requires columns of n (trials) and x (successes).\nThe components also handle extracting data from each simulation using the extract_fn argument. The value of this argument should be a function that takes in a simulation and returns a Pandas DataFrame. The specifics of the columns will depend a bit on the type of component (e.g. BetaBinomial is different from Normal), but often looks like a simulated version of expected. We will see examples below.\nWe’ll also see how to use the conform argument, the purpose of which is to temporally align the simulation output to the real data. This argument works along with the extract_fn to produce the final simulation outputs that are used in the likelihood function. The conformer is a function that takes in the expected data you provided and the actual simulation result the comes out of the extract_fn. The conformers we have built in are as follows:\n\nstep_containing: Conform by simply choosing the simulated timestep that contains the time indicated in the real data (expected)\nprevalent: Interpolate the simulated timepoints to estimate the values that would have occurred at each real timepoint\nincident: While the two methods above capture the state of the model at a particular point in time (stocks), this component allows you to capture the behavior of the model over time (flows). Instead of just giving one time value, t, you’ll provide a second time value as well called t1. This conformer will add up events occurring between the two time points.\n\nLet’s make a simple Normal component to capture prevalence at three time points. We’ll use the prevalent conformer to align the simulation output to the real data.\n\nprevalence = ss.Normal(\n    name = 'Disease prevalence',\n    conform = 'prevalent',\n\n    expected = pd.DataFrame({\n        'x': [0.13, 0.16, 0.06],    # Prevalence of infection\n    }, index=pd.Index([ss.date(d) for d in ['2020-01-12', '2020-01-25', '2020-02-02']], name='t')), # On these dates\n    \n    extract_fn = lambda sim: pd.DataFrame({\n        'x': sim.results.sir.prevalence,\n    }, index=pd.Index(sim.results.timevec, name='t')),\n\n    # You can specify the variance as well, but it's optional (max likelihood estimates will be used if not provided)\n    # This could be a single float or an array with the same shape as the expected values\n    sigma2 = 0.05, # e.g. (num_replicates/sigma2_model + 1/sigma2_data)^-1\n    # Alternatively, specify a variance for each data point\n    #sigma2 = np.array([0.05, 0.25, 0.01])\n)\n\nFinally, we can bring all the pieces together. We make a single base simulation and create an instance of a Starsim Calibration object. This object requires a few arguments, like the calib_pars and sim. We also pass in the function that modifies the base sim, here our build_sim function. No additional build_kw are required in this example.\nWe also pass in a list of components. Instead of using this “component-based” system, a user could simply provide an eval_fn, which takes in a completed sim an any eval_kwargs and returns a “mismatch” score to be minimized.\nWe can also specify the total number of trials to run, the number of parallel works, and a few other parameters.\n\nsc.heading('Beginning calibration')\n\n# Make the sim and data\nsim = make_sim()\n\n# Make the calibration\ncalib = ss.Calibration(\n    calib_pars = calib_pars,\n    sim = sim,\n    build_fn = build_sim,\n    build_kw = dict(n_reps=3), # Run 3 replicates for each parameter set\n    reseed = True, # If true, a different random seed will be provided to each configuration\n    components = [prevalence],\n    total_trials = 100, # Use more for a real calibration\n    n_workers = None, # None indicates to use all available CPUs\n    die = True,\n    debug = debug, # Run in serial if True\n    verbose = 0,\n)\n\n# Perform the calibration\nsc.printcyan('\\nPerforming calibration...')\ncalib.calibrate();\n\n\n\n—————————————————————\nBeginning calibration\n—————————————————————\n\n\nPerforming calibration...\n\n\n[I 2026-02-13 23:26:13,450] A new study created in RDB with name: starsim_calibration\n\n\nLet’s look at the best parameters that were found. Note that the rand_seed was selected at random, but the other parameters are meaningful.\n\ncalib.best_pars\n\n{'beta': 0.010096640575685052,\n 'init_prev': 0.04001580625187935,\n 'n_contacts': 3,\n 'rand_seed': 682806}\n\n\nOnce the calibration is complete, we can compare the guess values to the best values found by calling check_fit.\n\n# Confirm - Note the comparison is here configured over n_reps=15 replicates\nsc.printcyan('\\nConfirming fit...')\n\n# Increase replicates to 15 for more representative results when running check_fit\ncalib.build_kw['n_reps'] = 15\n\ncalib.check_fit(do_plot=False)\n\n\nConfirming fit...\nFit with original pars: 6.927809785316569\nFit with best-fit pars: -0.5314127146834339\n✓ Calibration improved fit 6.927809785316569 --&gt; -0.5314127146834339\n\n\nTrue\n\n\nAfter calling check_fit, we can plot the results. This first plot shows the Normal likelihood distributions from each of the 15 simulations we did in check_fit as the colored lines. The vertical dashed line is located at the real (expected) data. Top row is the “guess” values and the bottom row is the new “best” parameters. We want the vertical dashed line to cross the Gaussians at high points, representing high likelihood.\n\ncalib.plot()\n\n\n\n\n\n\n\n\nAnother way to plot the results is via bootstrapping. Here we repeatedly choose 15 from the n_reps=15 simulations (with replacement), compute the average (or sum for some components), and repeatedly calculate the mean. We then plot the distribution of means, and hope it lands near the vertical dashed lines representing the real data.\n\ncalib.plot(bootstrap=True); # Pass bootstrap=True to produce this plot\n\n/home/cliffk/idm/starsim/starsim/calibration.py:1137: UserWarning: Dataset has 0 variance; skipping density estimate. Pass `warn_singular=False` to disable this warning.\n  ax = sns.kdeplot(means)\n\n\n\n\n\n\n\n\n\nWe can view some plots of the final fitted results. Whereas the two plots above were from the check_fit, running both “guess” and “best” parameters, here we make make new simulations to visualize the results.\n\ng = calib.plot_final(); # Run the model for build_kw['n_reps'] = 15 replicates\n\n\n\n\n\n\n\n\nOptuna has lots of diagnostic plots that we can explore. Possible plots include:\n\nplot_contour\nplot_edf\nplot_hypervolume_history\nplot_intermediate_values\nplot_optimization_history\nplot_parallel_coordinate\nplot_param_importances\nplot_pareto_front\nplot_rank\nplot_slice\nplot_terminator_improvement\nplot_timeline\n\nHere are some examples:\n\ncalib.plot_optuna('plot_optimization_history'); # Plot the optimization history\n\n/home/cliffk/idm/starsim/starsim/calibration.py:440: ExperimentalWarning: optuna.visualization.matplotlib._optimization_history.plot_optimization_history is experimental (supported from v2.2.0). The interface can change in the future.\n  fig = getattr(vis, method)(self.study)\n\n\n\n\n\n\n\n\n\n\ncalib.plot_optuna('plot_contour');\n\n/home/cliffk/idm/starsim/starsim/calibration.py:438: ExperimentalWarning: optuna.visualization.matplotlib._contour.plot_contour is experimental (supported from v2.2.0). The interface can change in the future.\n  fig = vis.plot_contour(self.study, params=params)\n\n\n\n\n\n\n\n\n\n\ncalib.plot_optuna('plot_param_importances');\n\nCould not run plot_param_importances: Tried to import 'sklearn' but failed. Please make sure that the package is installed correctly to use this feature. Actual error: No module named 'sklearn'.\n\n\n/home/cliffk/idm/starsim/starsim/calibration.py:440: ExperimentalWarning: optuna.visualization.matplotlib._param_importances.plot_param_importances is experimental (supported from v2.2.0). The interface can change in the future.\n  fig = getattr(vis, method)(self.study)\n\n\nIf you choose not to use components, you can always create your own mismatch function, as in the following example:\n\nmy_data = (ss.date('2020-01-12'), 0.13)\n\ndef eval(sim, expected):\n    # Compute the squared error at one point in time.\n    # expected will contain my_data in this example due to eval_kw\n    date, p = expected\n    if not isinstance(sim, ss.MultiSim):\n        sim = ss.MultiSim(sims=[sim])\n\n    ret = 0\n    for s in sim.sims:\n        ind = np.searchsorted(s.results.timevec, date, side='left')\n        prev = s.results.sir.prevalence[ind]\n        ret += (prev - p)**2\n    return ret\n\n\n# Define the calibration parameters\ncalib_pars = dict(\n    beta = dict(low=0.01, high=0.30, guess=0.15, suggest_type='suggest_float', log=True),\n)\n\n# Make the sim and data\nsim = make_sim()\n\n# Make the calibration\ncalib = ss.Calibration(\n    calib_pars = calib_pars,\n    sim = sim,\n    build_fn = build_sim,\n    build_kw = dict(n_reps=2), # Two reps per point\n    reseed = True,\n    eval_fn = eval, # Will call my_function(msim, eval_kwargs)\n    eval_kw = dict(expected=my_data), # Will call eval(sim, **eval_kw)\n    total_trials = 20,\n    n_workers = None, # None indicates to use all available CPUs\n    die = True,\n    debug = debug,\n    verbose = 0,\n)\n\n# Perform the calibration\nsc.printcyan('\\nPeforming calibration...')\ncalib.calibrate()\n\n# Check\ncalib.check_fit()\n\n[I 2026-02-13 23:26:30,679] A new study created in RDB with name: starsim_calibration\n\n\n\nPeforming calibration...\nFit with original pars: 1.07281525\nFit with best-fit pars: 0.0024852500000000005\n✓ Calibration improved fit 1.07281525 --&gt; 0.0024852500000000005\n\n\nTrue\n\n\nFor more, take a look at test_calibration.py in the tests directory.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Workflows",
      "Calibration using Optuna-Starsim integration"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html",
    "href": "user_guide/advanced_indexing.html",
    "title": "Array indexing",
    "section": "",
    "text": "This guide covers array indexing concepts in Starsim, including universal identifiers (UIDs), active UIDs (auids), and proper array operations.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Array indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#overview",
    "href": "user_guide/advanced_indexing.html#overview",
    "title": "Array indexing",
    "section": "Overview",
    "text": "Overview\nStarsim uses an indexing system built on NumPy arrays to efficiently manage agents throughout their lifecycle, including when they die or are removed from the simulation. Understanding this system is crucial for writing correct and efficient code.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Array indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#key-concepts",
    "href": "user_guide/advanced_indexing.html#key-concepts",
    "title": "Array indexing",
    "section": "Key concepts",
    "text": "Key concepts\n\nUniversal identifiers (UIDs)\nEvery agent in Starsim has a unique identifier called a universal identifier or UID. UIDs are integers that:\n\nAre assigned sequentially starting from 0\nNever change during an agent’s lifetime\nAre not reused when agents die\nCan be used to index any agent, whether alive or dead\n\n\n\nActive UIDs (auids)\nThe simulation also maintains a list of active UIDs (auids), which are the UIDs of agents who are currently alive and active in the simulation. This is a dynamic subset of all UIDs.\n\n\nArray structure\nStarsim arrays have two main components:\n\nraw: Contains data for all agents ever created (indexed by UID)\nvalues: Contains data for active agents only (indexed by position in auids)\n\nLet’s see this in action:\n\nimport starsim as ss\n\n# Create a simple simulation to demonstrate indexing\npars = dict(\n    n_agents=10,\n    diseases=dict(type='sir', init_prev=0.5, p_death=0.2),\n    networks='random',\n)\n\nsim = ss.Sim(pars)\nsim.run()\n\nprint(f\"Number of agents: {len(sim.people)}\")\nprint(f\"UIDs: {sim.people.uid}\")\nprint(f\"Active UIDs (auids): {sim.people.auids}\")\nprint(f\"All UIDs: {sim.people.uid.raw}\")\nprint(f\"Alive: {sim.people.alive.raw}\")\nprint(f\"Ages (values): {sim.people.age}\")\nprint(f\"Ages (raw): {sim.people.age.raw}\")\n\nInitializing sim with 10 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.15 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.16 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.17 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.18 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.19 s)  •••••••••••••••••••• 100%\n\nNumber of agents: 6\nUIDs: &lt;IndexArr \"uid\", len=6, [2 3 4 5 6 9]&gt;\nActive UIDs (auids): [2 3 4 5 6 9]\nAll UIDs: [0 1 2 3 4 5 6 7 8 9]\nAlive: [False False  True  True  True  True  True False False  True]\nAges (values): &lt;FloatArr \"age\", len=6, [58.149414    0.13023734 43.819874   42.690937   54.292294   27.229174  ]&gt;\nAges (raw): [25.152369    4.9882936  58.149414    0.13023734 43.819874   42.690937\n 54.292294   52.604046    7.0768547  27.229174  ]",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Array indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#operations-on-active-vs-all-agents",
    "href": "user_guide/advanced_indexing.html#operations-on-active-vs-all-agents",
    "title": "Array indexing",
    "section": "Operations on active vs all agents",
    "text": "Operations on active vs all agents\nThis is a crucial distinction in Starsim:\n\nStatistical operations (like .mean(), .sum(), .std()) operate on active agents only\nIndexing operations depend on what type of index you use:\n\nint or slice: operates on active agents (values)\nss.uids(): operates on all agents (raw)\n\n\nLet’s demonstrate this:\n\nprint(f\"After simulation:\")\nprint(f\"Total agents ever created: {len(sim.people.uid.raw)}\")\nprint(f\"Active agents: {len(sim.people.auids)}\")\nprint(f\"Active UIDs: {sim.people.auids}\")\n\n# Statistical operations work on active agents only\nprint(f\"\\nMean age (active agents): {sim.people.age.mean():.2f}\")\nprint(f\"Mean age (manual calculation): {sim.people.age.values.mean():.2f}\")\n\n# This would be different if we included all agents (including dead ones)\nprint(f\"Mean age (all agents, including dead): {sim.people.age.raw[sim.people.age.raw != sim.people.age.nan].mean():.2f}\")\n\nAfter simulation:\nTotal agents ever created: 10\nActive agents: 6\nActive UIDs: [2 3 4 5 6 9]\n\nMean age (active agents): 37.72\nMean age (manual calculation): 37.72\nMean age (all agents, including dead): 31.61",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Array indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#proper-indexing-examples",
    "href": "user_guide/advanced_indexing.html#proper-indexing-examples",
    "title": "Array indexing",
    "section": "Proper indexing examples",
    "text": "Proper indexing examples\nHere are examples of correct and incorrect ways to index Starsim arrays:\n\nCorrect indexing patterns\n\n# ✅ Using integer indices (works on active agents)\nage_of_first_active = sim.people.age[0]\nprint(f\"Age of first active agent: {age_of_first_active}\")\n\n# ✅ Using ss.uids() for specific UIDs\nspecific_uids = ss.uids([0, 1, 2])\nages_by_uid = sim.people.age[specific_uids]\nprint(f\"Ages of UIDs {specific_uids}: {ages_by_uid}\")\n\n# ✅ Using boolean arrays from states\nfemale_uids = sim.people.female.uids  # This gets UIDs of female agents\nfemale_ages = sim.people.age[female_uids]\nprint(f\"Ages of female agents: {female_ages}\")\n\n# ✅ Using .true() and .false() methods\nalive_uids = sim.people.alive.true()\ndead_uids = sim.people.alive.false()\nprint(f\"Alive UIDs: {alive_uids}\")\nprint(f\"Dead UIDs: {dead_uids}\")\n\nAge of first active agent: 25.152368545532227\nAges of UIDs [0 1 2]: [25.152369   4.9882936 58.149414 ]\nAges of female agents: [54.292294]\nAlive UIDs: [2 3 4 5 6 9]\nDead UIDs: []\n\n\n\n\nIncorrect indexing patterns\nThese examples show what NOT to do:\n\nimport sciris as sc\n\n# ❌ Don't index with raw lists of integers - this is ambiguous!\nwith sc.tryexcept() as tc:\n    print('This raises an error:')\n    sim.people.age[[0, 1, 2]]  # This would raise an error\n\n# ❌ Don't mix up .values and .raw\nage = sim.people.age\nprint('Mean age:', age.mean())\nprint('Mean age (values):', age.values.mean()) # &lt;- same as above\nprint('Mean age (raw):', age.raw.mean()) # &lt;- different since includes dead agents\n\nThis raises an error:\n&lt;class 'Exception'&gt; Indexing an Arr (age) by ([0, 1, 2]) is ambiguous or not supported. Use ss.uids() instead, or index Arr.raw or Arr.values.\nMean age: 37.718655\nMean age (values): 37.718655\nMean age (raw): 31.613348",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Array indexing"
    ]
  },
  {
    "objectID": "user_guide/advanced_indexing.html#best-practices-and-common-pitfalls",
    "href": "user_guide/advanced_indexing.html#best-practices-and-common-pitfalls",
    "title": "Array indexing",
    "section": "Best practices and common pitfalls",
    "text": "Best practices and common pitfalls\n\nDo:\n\nUse ss.uids() when you need to index by specific UIDs\nUse statistical methods (.mean(), .sum(), etc.) directly on arrays - they automatically work on active agents\nUse .uids property of boolean arrays to get UIDs of agents matching criteria\nUse .true() and .false() methods for cleaner boolean array handling\nRemember that integer indexing works on active agents, not UIDs\n\n\n\nDon’t:\n\nDon’t index with raw lists of integers - use ss.uids() instead\nDon’t use .raw arrays for statistics unless you specifically need to include dead agents\nDon’t use boolean operators (&, |) on non-boolean arrays - use comparison operators instead\nDon’t forget to check if UID arrays are empty before performing operations on them\n\n\n\nPerformance tips:\n\nBoolean indexing is efficient - use it to filter large populations\nUID operations are optimized - use set operations like .intersect() and .union() when appropriate\nStatistical operations on arrays are fast - they use NumPy under the hood\nAvoid loops when possible - vectorized operations are much faster",
    "crumbs": [
      "Home",
      "**User guide**",
      "Advanced topics",
      "Array indexing"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html",
    "href": "user_guide/modules_networks.html",
    "title": "Networks",
    "section": "",
    "text": "This guide provides technical reference for implementing and customizing networks in Starsim. For learning-oriented examples, see the Networks tutorial.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Networks"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#transmission-routes-and-the-route-base-class",
    "href": "user_guide/modules_networks.html#transmission-routes-and-the-route-base-class",
    "title": "Networks",
    "section": "Transmission routes and the Route base class",
    "text": "Transmission routes and the Route base class\nAll disease transmission in Starsim occurs via routes - pathways through which infectious agents can spread. Both contact networks and mixing pools inherit from the base ss.Route class, which defines the interface for transmission mechanisms.\n\nRoute hierarchy\nss.Route (base class for all transmission pathways)\n├── ss.Network (contact-based transmission)\n│   └── ss.DynamicNetwork (time-varying connections)\n│       └── ss.SexualNetwork (sexual partnership networks)\n└── ss.MixingPool (group-based transmission)\nWhen diseases calculate transmission, they iterate through all routes in the simulation and call each route’s transmission methods. This unified interface allows diseases to work seamlessly with any combination of networks and mixing pools.\n\n\nHow transmission works via routes\n\nDisease calls route: Each disease loops through sim.networks (which contains all routes)\nRoute calculates transmission: Each route computes new infections based on its transmission model\nRoute returns new cases: UIDs of newly infected agents are returned to the disease\nDisease processes infections: The disease handles state changes and prognoses for new cases\n\nThis separation allows you to mix and match different transmission mechanisms in a single simulation.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Networks"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#network-architecture-overview",
    "href": "user_guide/modules_networks.html#network-architecture-overview",
    "title": "Networks",
    "section": "Network architecture overview",
    "text": "Network architecture overview\nContact networks inherit from ss.Network and manage collections of edges (connections between agents). All networks must implement methods for creating, updating, and removing connections between agents.\n\nKey network components:\n\nEdges: The fundamental unit - connections between two agents with transmission parameters\nParameters: Network-specific settings that control connection behavior\nState management: Tracking which agents can form connections\nUpdate methods: Logic for adding/removing connections over time",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Networks"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#comparison-of-networks",
    "href": "user_guide/modules_networks.html#comparison-of-networks",
    "title": "Networks",
    "section": "Comparison of networks",
    "text": "Comparison of networks\nStarsim provides different network types for different transmission scenarios:\n\nBase classes\n\n\n\nClass\nPurpose\nKey Features\nWhen to Use\n\n\n\n\nRoute\nBase for all transmission pathways\nDefines transmission interface\nNever directly - inherit from this\n\n\nNetwork\nBase contact network\nEdge management, validation\nRarely - use concrete classes\n\n\nDynamicNetwork\nTime-varying connections\nAdds/removes edges over time\nWhen relationships form/dissolve\n\n\nSexualNetwork\nSexual partnerships\nAge of debut, acts per partnership\nFor STI modeling\n\n\n\n\n\nContact network implementations\n\n\n\nClass\nPurpose\nParameters\nUse Case\n\n\n\n\nStaticNet\nNetworkX graph conversion\ngraph, p, n_contacts\nPre-defined network structures\n\n\nRandomNet\nRandom connections\nn_contacts, dur\nGeneral infectious diseases\n\n\nMFNet\nMale-female partnerships\nduration, acts, debut\nHeterosexual STI transmission\n\n\nMSMNet\nMale-male partnerships\nduration, acts, participation\nMSM STI transmission\n\n\nMaternalNet\nMother-child (base)\ndur, start, end\nVertical transmission\n\n\nPrenatalNet\nPrenatal transmission\nInherits from MaternalNet\nIn-utero transmission\n\n\nPostnatalNet\nPostnatal transmission\nInherits from MaternalNet\nBreastfeeding, birth canal\n\n\n\n\n\nAdditional example contact networks\nNote: these are available in the starsim_examples module.\n\n\n\nClass\nPurpose\nParameters\nUse Case\n\n\n\n\nErdosRenyiNet\nProbabilistic edges\np (edge probability), dur\nTheoretical network studies\n\n\nDiskNet\nSpatial proximity\nr (radius), v (velocity)\nGeographic transmission\n\n\nNullNet\nSelf-connections only\nn_people\nDebugging, placeholders\n\n\nEmbeddingNet\nAge-assortative MF\nmale_shift, embedding_func\nAge-structured STI modeling\n\n\n\n\n\nMixing pool classes\n\n\n\nClass\nPurpose\nParameters\nUse Case\n\n\n\n\nAgeGroup\nAge-based filtering\nlow, high\nDefining age groups for mixing\n\n\nMixingPool\nSingle group transmission\nsrc, dst, beta, contacts\nSimple group-to-group mixing\n\n\nMixingPools\nMulti-group mixing\nsrc, dst, contacts (matrix)\nComplex age/risk structured mixing\n\n\n\n\n\nChoosing the right network type\n\nFor respiratory diseases (flu, COVID-19, measles):\n\nRandomNet: Simple random mixing; the default in most cases\nMixingPools: Age-structured mixing with contact matrices\n\nFor sexually transmitted infections:\n\nMFNet: Male-female (heterosexual) transmission\nMSMNet: Transmission between men who have sex with men (MSM)\nEmbeddingNet: Age-assortative heterosexual mixing\n\nFor mother-to-child transmission:\n\nPrenatalNet: In-utero transmission (HIV, syphilis)\nPostnatalNet: Birth/breastfeeding transmission (HIV, HBV)\n\nFor special purposes:\n\nStaticNet: Use existing NetworkX graphs\nDiskNet: Proof-of-concept spatial/geographic transmission\n\nNullNet: Testing/debugging without transmission\nErdosRenyiNet: Theoretical network analysis",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Networks"
    ]
  },
  {
    "objectID": "user_guide/modules_networks.html#core-implementation-methods",
    "href": "user_guide/modules_networks.html#core-implementation-methods",
    "title": "Networks",
    "section": "Core implementation methods",
    "text": "Core implementation methods\nAll networks inherit key methods from the base classes. Override these to create custom network behavior:\n\n\n\nMethod\nPurpose\nWhen to override\n\n\n\n\n__init__()\nInitialize parameters and state\nAlways for custom networks\n\n\ninit_pre()\nPre-simulation initialization\nRarely\n\n\ninit_post()\nPost-simulation initialization\nWhen you need access to people\n\n\nadd_pairs()\nCreate new connections\nKey method for custom logic\n\n\nremove_pairs()\nRemove existing connections\nFor dynamic networks\n\n\nupdate()\nMain update method each timestep\nRarely - calls add/remove pairs\n\n\nfind_contacts()\nQuery network connections\nOverride for custom queries\n\n\n\nLet’s compare a simple SIR model configured with transmission using a single Mixing Pool to a similar model using a contact network. Mixing pools are not the same as contact networks, so the results are not expected to be identical.\n\nimport starsim as ss\n\n# Transmission using a mixing pool\nmp = ss.MixingPool(beta=1.0, n_contacts=ss.poisson(lam=3)) # A single mixing pool\nsir = ss.SIR()\nsim1 = ss.Sim(diseases=sir, networks=mp, verbose=0, label='Mixing Pool')\n\n# Transmission using a network\nnet = ss.RandomNet(n_contacts=ss.poisson(lam=3))\nsir = ss.SIR()\nsim2 = ss.Sim(diseases=sir, networks=net, verbose=0, label='Contact Network')\n\nmsim = ss.MultiSim([sim1, sim2]).run()\nmsim.plot()\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nEach MixingPool has several configuration parameters, including src and dst. The value of these parameters can either be an array of uids, like ss.uids([0,1,2]) or a callable function that takes sim as an argument and returns an array of uids (or a BoolArr) like lambda sim: sim.people.age&lt;10. One helper class we have created is called AgeGroup, which takes low and high ages as parameters. This class has some performance advantages when using multiple pools via MixingPools through caching.\nWhile mixing pools do not represent individual agent-to-agent connections, each agent does have an “effective” number of contacts, typically drawn from a Poisson distribution. Individuals retain their number of contacts within each pool for the duration of the simulation. Effective contacts are used on the acquisition sides. On the transmission side, the “average” infection level, called trans, against which susceptible agents are challenged is computed as:\ntrans = np.mean(disease.infectious[self.src_uids] * disease.rel_trans[self.src_uids])\nAnd on the acquisition side, each susceptible agent can be thought of as connected to eff_contacts average infectious agents, computed as:\nacq = self.eff_contacts[self.dst_uids] * disease.susceptible[self.dst_uids] * disease.rel_sus[self.dst_uids]\nUltimately, the acquisition probability for each susceptible agent in dst_uids is computed as\np = self.pars.beta * trans * acq\nYou can see the beta parameter here, which is another pool parameter and should use ss.timeprob() to automatically adjust for time units. Mixing pools do not currently use the beta parameters configured in individual disease modules.\n\nmp = ss.MixingPool(\n    diseases = 'sir', # Use this pool only for SIR, not other diseases (HIV in this example)\n    src = lambda sim: sim.people.age &lt; 15, # Infection sources will be agents under age 15\n    dst = ss.AgeGroup(low=15, high=None), # Here demonstrating the AgeGroup class, identical to lambda sim: sim.people.age &gt;= 15\n    n_contacts = ss.poisson(lam=5), # Contacts will be poisson distributed with a mean of 5\n)\nsim = ss.Sim(diseases=['sir', 'sis'], networks=mp) # Two diseases, but only \"sir\" will have transmission\nsim.run()\nsim.plot()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.01 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.02 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.03 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.04 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.05 s)  •••••••••••••••••••• 100%\n\nFigure(896x672)\n\n\n\n\n\n\n\n\n\nMixingPools (plural) allows you to configure multiple individual MixingPool pools. This first example shows how to do age mixing. Like MixingPool, MixingPools also takes src and dst, however each of these parameters must be a dictionary with key specifying the name of each group and value as in the singlular mixing pool proving the uids by a callable function or list of uids.\n\nimport numpy as np\nimport sciris as sc\nimport matplotlib.pyplot as plt\n\nbin_size = 5\nlows = np.arange(0, 80, bin_size)\nhighs = sc.cat(lows[1:], 100)\ngroups = ss.ndict([ss.AgeGroup(low=low, high=high) for low, high in zip(lows, highs)])\nn_groups = len(groups)\n\n# Let's create a random contact matrix. If using contact matrices from Prem et al., put data here.\ncm = np.random.random((n_groups, n_groups)) + 3*np.diag(np.random.rand(n_groups))\n\nprint('The first axis (rows) of the contact matrix is the SOURCE group')\nprint('The second axis (columns) of the contact matrix is the DESTINATION group')\nplt.imshow(cm)\n\nmps = ss.MixingPools(\n    n_contacts = cm,\n    src = groups,\n    dst = groups,\n)\n\n# Track new infections by age using an Analyzer, you'll learn about these in a subsequent tutorial\nclass InfectionsByAge(ss.Analyzer):\n    def __init__(self, bins, **kwargs):\n        super().__init__()\n        self.bins = bins\n        self.update_pars(**kwargs)\n\n    def init_post(self):\n        super().init_post()\n        self.new_cases = np.zeros((len(self), len(self.bins)-1))\n\n    def step(self):\n        new_inf = self.sim.diseases.sir.ti_infected == self.ti\n        if not new_inf.any(): return\n        self.new_cases[self.ti, :] = np.histogram(self.sim.people.age[new_inf], bins=self.bins)[0]\n\n    def plot(self):\n        fig, ax = plt.subplots()\n        ax.set_prop_cycle('color', plt.cm.nipy_spectral(np.linspace(0, 1, len(self.bins))))\n\n        for i, (b1, b2) in enumerate(zip(self.bins[:-1], self.bins[1:])):\n            ax.plot(self.timevec, self.new_cases[:,i], label=f'Age {b1}-{b2}')\n        ax.legend(); ax.set_xlabel('Year'); ax.set_ylabel('New Infections')\n\naz = InfectionsByAge(np.concatenate([lows, [1000]]))\n\nsir = ss.SIR()\nsim = ss.Sim(diseases=sir, networks=mps, analyzers=az, dur=5, dt=1/4, n_agents=1000, verbose=0)\nsim.run()\nsim.analyzers[0].plot()\nprint('↑ The default age distribution is uniform, so the 75+ group contains many more people than the other age groups, explaining the larger number of new infections.')\n\nThe first axis (rows) of the contact matrix is the SOURCE group\nThe second axis (columns) of the contact matrix is the DESTINATION group\n↑ The default age distribution is uniform, so the 75+ group contains many more people than the other age groups, explaining the larger number of new infections.\n\n\nMixing pools work well with properties other than age. Here’s an example that mixes by socio-economic status (SES).\n\n# Define SES states\nses = sc.objdict(low=0, mid=1, high=2)\n\n# Create 5,000 people adding 50% LOW, 30% MID, and 20% HIGH SES\nses_arr = ss.FloatArr('ses', default=ss.choice(a=ses.values(), p=[0.5, 0.3, 0.2]))\nppl = ss.People(n_agents=5_000, extra_states=ses_arr)\n\n# Create the mixing pools, note that the contact matrix need not be symmetric\nmps = ss.MixingPools(\n    src = {k: lambda sim, s=v: ss.uids(sim.people.ses == s) for k,v in ses.items()},\n    dst = {k: lambda sim, s=v: ss.uids(sim.people.ses == s) for k,v in ses.items()[:-1]}, # People in the HIGH group have no route to acquire new infections, for demonstration purposes here\n\n    # src on rows (1st dimension), dst on cols (2nd dimension)\n    n_contacts = np.array([\n        [2.50, 0.00], # low→low,  low→mid\n        [0.05, 1.75], # mid→low,  mid→mid\n        [0.00, 0.15], # high→low, high→mid\n    ]),\n)\n\n# Create an analyzer to track results by SES group\nclass New_Infections_By_SES(ss.Analyzer):\n    def init_results(self):\n        super().init_results()\n        self.new_cases = np.zeros((len(self), len(ses)))\n\n    def step(self):\n        new_inf = self.sim.diseases.sir.ti_infected == self.ti\n        if not new_inf.any():\n            return\n\n        for value in ses.values():\n            self.new_cases[self.ti, value] = np.count_nonzero(new_inf & (self.sim.people.ses==value))\n\naz = New_Infections_By_SES()\n\ndef seeding(self, sim, uids):\n    p = np.zeros(len(uids))\n    high_ses = ss.uids(sim.people.ses == ses.high)\n    p[high_ses] = 0.1 # Seed infections into 10% of SES HIGH\n    return p\nsir = ss.SIR(init_prev = ss.bernoulli(p=seeding), beta=ss.peryear(0.2)) # The probability of being selected as a seed is determined on a per-agent basis by the above 'seeding' function\n\nsim = ss.Sim(people=ppl, diseases=sir, networks=mps, analyzers=az, dt=1/12, dur=35, verbose=0)\nsim.run()\n\nfig, ax = plt.subplots()\nnew_cases = sim.analyzers[0].new_cases\nfor key,value in ses.items():\n    ax.plot(sim.results.timevec, new_cases[:,value], label=key)\nax.legend()\nax.set_xlabel('Year')\nax.set_ylabel('New Infections')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the above figure, infections are seeded into the high group at the beginning of the simulation, explaining the spike in new cases at that time. High SES can only infect mid SES, so the mid (orange) wave follows. Low SES can only become infected by mid SES in this example, so the blue wave follows. This example intentionally demonstrates the directional nature of mixing pools and includes strong mixing within groups and bottlenecks between groups to make the point.",
    "crumbs": [
      "Home",
      "**User guide**",
      "Modules",
      "Networks"
    ]
  },
  {
    "objectID": "migration/v3.0_v3.1.html",
    "href": "migration/v3.0_v3.1.html",
    "title": "Starsim v3.0 to v3.1 migration guide",
    "section": "",
    "text": "This guide describes the breaking changes introduced in Starsim v3.1.0 and the steps required to migrate code from Starsim v3.0.x. It was mostly written by an LLM, and is mostly written for other LLMs.\nMost of the changes are in the Pregnancy module and maternal networks. If your code does not use ss.Pregnancy, ss.MaternalNet, ss.PrenatalNet, or ss.PostnatalNet, you may only need to check the general changes in sections 1-3.\nNote: If you are an LLM reading this, perform each of the following migrations one at a time and confirm with the user after each step.\n\n\n\n\n\nPreviously, people.sir returned a proxy object that exposed only module states (e.g. people.sir.infected). Now it returns a direct reference to the module itself, so all attributes – including dynamically computed @property values – are accessible.\nWhat to change: In most cases, no change is needed – people.sir.infected still works. However, if your code relied on people.sir being a state-only namespace, be aware that it is now the full module object.\n# v3.0 -- worked for states, but not for properties\npeople.sir.infected      # OK\npeople.sir.infectious    # AttributeError\n\n# v3.1 -- both work\npeople.sir.infected      # OK (state)\npeople.sir.infectious    # OK (property)\n\n\n\nThese boolean attributes have been removed. Type checking is used instead.\nWhat to change: Replace attribute checks with isinstance() checks.\n# v3.0\nfor nw in sim.networks.values():\n    if nw.prenatal:\n        ...\n    if nw.postnatal:\n        ...\n\n# v3.1\nfor nw in sim.networks.values():\n    if isinstance(nw, ss.PrenatalNet):\n        ...\n    if isinstance(nw, ss.PostnatalNet):\n        ...\n\n\n\nThe arguments mother_inds and unborn_inds have been renamed to mother_uids and unborn_uids. The dur, start, and end arguments have been removed – edge lifespans are now managed by the Pregnancy module.\nWhat to change: Update argument names and remove dur/start/end arguments.\n# v3.0\nnet.add_pairs(mother_inds=mothers, unborn_inds=babies, dur=dur_preg, start=ti)\n\n# v3.1\nnet.add_pairs(mother_uids=mothers, unborn_uids=babies)\n\n\n\nPostnatalNet is no longer a subclass of MaternalNet. It is now a DynamicNetwork that accepts an optional dur parameter for the postnatal period. Its add_pairs() method now takes mother_uids and infant_uids (not unborn_uids).\nWhat to change: Update how you construct and interact with PostnatalNet.\n# v3.0\npostnatal = ss.PostnatalNet()\n# Pairs were added by Pregnancy with dur/start/end\n\n# v3.1\npostnatal = ss.PostnatalNet(dur=ss.lognorm_ex(mean=ss.years(0.5), std=ss.years(0.5)))\n# Pairs are automatically added at delivery by Pregnancy\n\n\n\nA new ss.BreastfeedingNet is available for modeling breastfeeding transmission. It automatically tracks breastfeeding status from the Pregnancy module. This is additive – no migration is required – but if you were previously using PostnatalNet to model breastfeeding transmission, consider switching.\n# v3.1\nsim = ss.Sim(\n    demographics=ss.Pregnancy(),\n    networks=[ss.PrenatalNet(), ss.BreastfeedingNet()],\n    diseases=ss.SIR(),\n)\n\n\n\n\n\n\nPreviously fecund was a BoolState that was manually set to True/False. It is now a read-only @property that dynamically computes fecundity based on age and sex.\nWhat to change: Remove any code that sets fecund directly.\n# v3.0\npregnancy.fecund[uids] = False  # Manually mark as infecund\npregnancy.fecund[uids] = True   # Manually mark as fecund\n\n# v3.1\n# fecund is now read-only, computed from age, sex, and min_age/max_age\n# Use pregnancy.infertile to mark agents as unable to conceive\npregnancy.infertile[uids] = True\n\n\n\nThe postpartum BoolState and associated dur_postpartum / ti_postpartum states have been removed. Breastfeeding is now tracked separately.\nWhat to change: Replace postpartum references with breastfeeding or use PostnatalNet with a dur parameter.\n# v3.0\npregnancy.postpartum         # BoolState\npregnancy.dur_postpartum     # FloatArr\npregnancy.ti_postpartum      # FloatArr\n\n# v3.1\npregnancy.breastfeeding      # BoolState (mothers currently breastfeeding)\npregnancy.dur_breastfeed     # FloatArr (duration of breastfeeding)\npregnancy.ti_stop_breastfeed # FloatArr (time breastfeeding stops)\npregnancy.breastfed          # BoolState (newborns who were breastfed)\n\n\n\nThe child_uid FloatArr has been removed. Unborn children are now found dynamically via people.parent.\nWhat to change: Use pregnancy.find_unborn_children(parent_uids) instead.\n# v3.0\nchild = pregnancy.child_uid[mother_uid]\n\n# v3.1\nchildren = pregnancy.find_unborn_children(mother_uids)\n\n\n\nThe method and associated distribution have been renamed.\nWhat to change: Rename method calls and references.\n# v3.0\np = pregnancy.make_p_fertility(eligible_uids)\npregnancy.pars.p_fertility  # Bernoulli distribution\n\n# v3.1\np = pregnancy.make_p_conceive(eligible_uids)\npregnancy._p_conceive  # Bernoulli distribution (now private)\n\n\n\nThe semantics have been inverted and the name clarified. Despite its name, p_neonatal_death in v3.0 was only applied when a mother dies during pregnancy – it was the probability that the neonate also dies conditional on maternal death. It was never a general neonatal mortality parameter.\nIn v3.1, p_survive_maternal_death makes this conditional relationship explicit: it is the probability that an unborn child survives the mother’s death (default 0, meaning unborn children do not survive maternal death).\nNote: Neither v3.0 nor v3.1 includes a built-in parameter for general neonatal mortality (e.g. from prematurity or birth complications). To model that, override the process_newborns() hook in a Pregnancy subclass.\nWhat to change: Rename the parameter and invert the probability value.\n# v3.0\npregnancy = ss.Pregnancy(p_neonatal_death=ss.bernoulli(0.8))  # 80% chance neonate dies given maternal death\n\n# v3.1\npregnancy = ss.Pregnancy(p_survive_maternal_death=ss.bernoulli(0.2))  # 20% chance unborn survives maternal death\n\n\n\nPreviously, dur_pregnancy was a fixed value (default ss.years(0.75)). It is now an ss.choice distribution that draws from gestational weeks 32-42, and duration is assigned per-agent.\nWhat to change: If you were relying on a fixed pregnancy duration or accessing self.pars.dur_pregnancy.years, update accordingly.\n# v3.0\npregnancy = ss.Pregnancy(dur_pregnancy=ss.years(0.75))\n# Internally: self.pars.dur_pregnancy.years was a single float\n\n# v3.1\n# Default draws from weeks 32-42; to override with a fixed duration:\npregnancy = ss.Pregnancy(dur_pregnancy=ss.choice(a=ss.weeks(np.arange(38, 43))))\n# Per-agent durations are stored in: pregnancy.dur_pregnancy[uids]  (a FloatArr)\n\n\n\nThe set_prognoses() method has been removed. Its functionality is now split across make_pregnancies(), process_delivery(), and set_breastfeeding().\nWhat to change: If you had a subclass that overrode set_prognoses(), move the logic to the appropriate new method.\n# v3.0\nclass MyPregnancy(ss.Pregnancy):\n    def set_prognoses(self, uids):\n        super().set_prognoses(uids)\n        # Custom logic for new pregnancies\n\n# v3.1\nclass MyPregnancy(ss.Pregnancy):\n    def make_pregnancies(self, uids):\n        embryo_counts = super().make_pregnancies(uids)\n        # Custom logic for new pregnancies\n        return embryo_counts\n\n\n\nThe step() method no longer delegates to do_step() and update_states(). The burn-in logic has also been moved from step() to init_post(). The new step() calls a sequence of smaller, overridable methods.\nWhat to change: If you had a subclass that overrode do_step() or update_states(), restructure to override the new methods.\n# v3.0 step flow\nstep() -&gt; do_step() -&gt; update_states() + make_pregnancies() + make_embryos()\n\n# v3.1 step flow\ninit_post()           # Burn-in happens here now\nstep():\n    updates_pre()           # Set base states, check breastfeeding\n    progress_pregnancies()  # Advance gestational clock\n    process_delivery()      # Handle births\n    set_rel_sus()           # Update susceptibility\n    select_conceivers()     # Find who conceives\n    make_pregnancies()      # Set pregnancy states\n    make_embryos()          # Create embryo agents\n    update_maternal_deaths()# Handle maternal deaths\nUse the _post_delivery() hook for custom post-delivery logic:\n# v3.1\nclass MyPregnancy(ss.Pregnancy):\n    def _post_delivery(self, mother_uids, newborn_uids):\n        # Custom post-delivery logic here\n        pass\n\n\n\nmake_embryos() now returns a tuple (conceive_uids_with_repeats, new_uids) instead of just new_uids. The first element accounts for multiple embryos per pregnancy (e.g. twins).\nWhat to change: Update any code that captures the return value.\n# v3.0\nnew_uids = pregnancy.make_embryos(conceive_uids)\n\n# v3.1\nconceive_uids_with_repeats, new_uids = pregnancy.make_embryos(conceive_uids, embryo_counts)\n\n\n\nThe old make_pregnancies() both selected who conceives and set prognoses. These are now separate: select_conceivers() returns UIDs of women who will conceive, and make_pregnancies() sets pregnancy states and durations for those UIDs.\nWhat to change: If you overrode make_pregnancies() in a subclass, split the logic.\n# v3.0\nclass MyPregnancy(ss.Pregnancy):\n    def make_pregnancies(self):\n        # Custom selection + prognosis logic\n\n# v3.1\nclass MyPregnancy(ss.Pregnancy):\n    def select_conceivers(self, uids=None):\n        # Custom selection logic\n        return conceive_uids\n\n    def make_pregnancies(self, uids):\n        # Custom prognosis logic\n        embryo_counts = super().make_pregnancies(uids)\n        return embryo_counts\n\n\n\nThe following new parameters are available via PregnancyPars. No migration is required, but you may want to use them:\n\n\n\n\n\n\n\n\nParameter\nDefault\nDescription\n\n\n\n\np_infertile\nss.bernoulli(p=0)\nPrimary infertility probability\n\n\ndur_breastfeed\nss.lognorm_ex(mean=ss.years(0.75), std=ss.years(0.5))\nBreastfeeding duration\n\n\np_breastfeed\nss.bernoulli(p=1)\nProbability of breastfeeding\n\n\nembryos_per_pregnancy\nss.choice(a=[1,2], p=[1.0, 0.0])\nNumber of embryos (twins support)\n\n\nrr_ptb\nss.normal(loc=1, scale=0.1)\nBaseline relative risk of pre-term birth\n\n\nrr_ptb_age\nAge-dependent array\nRelative risk of pre-term birth by age\n\n\np_survive_maternal_death\nss.bernoulli(0)\nProbability unborn survives mother’s death\n\n\ntrimesters\n[ss.weeks(13), ss.weeks(26)]\nTrimester boundaries\n\n\n\n\n\n\nThe following results are now available. No migration is required.\n\n\n\nResult\nDescription\n\n\n\n\nmaternal_deaths\nNumber of maternal deaths per timestep\n\n\nmmr\nMaternal mortality rate (per 100,000 births)\n\n\ntfr\nTotal fertility rate\n\n\nn_fecund\nNumber of fecund women\n\n\nn_fertile\nNumber of fertile women\n\n\nn_susceptible\nNumber of susceptible (non-pregnant fertile) women\n\n\n\nAge-specific fertility rates are available via pregnancy.asfr (a 2D array, not a standard Result)."
  },
  {
    "objectID": "migration/v3.0_v3.1.html#overview",
    "href": "migration/v3.0_v3.1.html#overview",
    "title": "Starsim v3.0 to v3.1 migration guide",
    "section": "",
    "text": "This guide describes the breaking changes introduced in Starsim v3.1.0 and the steps required to migrate code from Starsim v3.0.x. It was mostly written by an LLM, and is mostly written for other LLMs.\nMost of the changes are in the Pregnancy module and maternal networks. If your code does not use ss.Pregnancy, ss.MaternalNet, ss.PrenatalNet, or ss.PostnatalNet, you may only need to check the general changes in sections 1-3.\nNote: If you are an LLM reading this, perform each of the following migrations one at a time and confirm with the user after each step."
  },
  {
    "objectID": "migration/v3.0_v3.1.html#general-changes",
    "href": "migration/v3.0_v3.1.html#general-changes",
    "title": "Starsim v3.0 to v3.1 migration guide",
    "section": "",
    "text": "Previously, people.sir returned a proxy object that exposed only module states (e.g. people.sir.infected). Now it returns a direct reference to the module itself, so all attributes – including dynamically computed @property values – are accessible.\nWhat to change: In most cases, no change is needed – people.sir.infected still works. However, if your code relied on people.sir being a state-only namespace, be aware that it is now the full module object.\n# v3.0 -- worked for states, but not for properties\npeople.sir.infected      # OK\npeople.sir.infectious    # AttributeError\n\n# v3.1 -- both work\npeople.sir.infected      # OK (state)\npeople.sir.infectious    # OK (property)\n\n\n\nThese boolean attributes have been removed. Type checking is used instead.\nWhat to change: Replace attribute checks with isinstance() checks.\n# v3.0\nfor nw in sim.networks.values():\n    if nw.prenatal:\n        ...\n    if nw.postnatal:\n        ...\n\n# v3.1\nfor nw in sim.networks.values():\n    if isinstance(nw, ss.PrenatalNet):\n        ...\n    if isinstance(nw, ss.PostnatalNet):\n        ...\n\n\n\nThe arguments mother_inds and unborn_inds have been renamed to mother_uids and unborn_uids. The dur, start, and end arguments have been removed – edge lifespans are now managed by the Pregnancy module.\nWhat to change: Update argument names and remove dur/start/end arguments.\n# v3.0\nnet.add_pairs(mother_inds=mothers, unborn_inds=babies, dur=dur_preg, start=ti)\n\n# v3.1\nnet.add_pairs(mother_uids=mothers, unborn_uids=babies)\n\n\n\nPostnatalNet is no longer a subclass of MaternalNet. It is now a DynamicNetwork that accepts an optional dur parameter for the postnatal period. Its add_pairs() method now takes mother_uids and infant_uids (not unborn_uids).\nWhat to change: Update how you construct and interact with PostnatalNet.\n# v3.0\npostnatal = ss.PostnatalNet()\n# Pairs were added by Pregnancy with dur/start/end\n\n# v3.1\npostnatal = ss.PostnatalNet(dur=ss.lognorm_ex(mean=ss.years(0.5), std=ss.years(0.5)))\n# Pairs are automatically added at delivery by Pregnancy\n\n\n\nA new ss.BreastfeedingNet is available for modeling breastfeeding transmission. It automatically tracks breastfeeding status from the Pregnancy module. This is additive – no migration is required – but if you were previously using PostnatalNet to model breastfeeding transmission, consider switching.\n# v3.1\nsim = ss.Sim(\n    demographics=ss.Pregnancy(),\n    networks=[ss.PrenatalNet(), ss.BreastfeedingNet()],\n    diseases=ss.SIR(),\n)"
  },
  {
    "objectID": "migration/v3.0_v3.1.html#pregnancy-module-changes",
    "href": "migration/v3.0_v3.1.html#pregnancy-module-changes",
    "title": "Starsim v3.0 to v3.1 migration guide",
    "section": "",
    "text": "Previously fecund was a BoolState that was manually set to True/False. It is now a read-only @property that dynamically computes fecundity based on age and sex.\nWhat to change: Remove any code that sets fecund directly.\n# v3.0\npregnancy.fecund[uids] = False  # Manually mark as infecund\npregnancy.fecund[uids] = True   # Manually mark as fecund\n\n# v3.1\n# fecund is now read-only, computed from age, sex, and min_age/max_age\n# Use pregnancy.infertile to mark agents as unable to conceive\npregnancy.infertile[uids] = True\n\n\n\nThe postpartum BoolState and associated dur_postpartum / ti_postpartum states have been removed. Breastfeeding is now tracked separately.\nWhat to change: Replace postpartum references with breastfeeding or use PostnatalNet with a dur parameter.\n# v3.0\npregnancy.postpartum         # BoolState\npregnancy.dur_postpartum     # FloatArr\npregnancy.ti_postpartum      # FloatArr\n\n# v3.1\npregnancy.breastfeeding      # BoolState (mothers currently breastfeeding)\npregnancy.dur_breastfeed     # FloatArr (duration of breastfeeding)\npregnancy.ti_stop_breastfeed # FloatArr (time breastfeeding stops)\npregnancy.breastfed          # BoolState (newborns who were breastfed)\n\n\n\nThe child_uid FloatArr has been removed. Unborn children are now found dynamically via people.parent.\nWhat to change: Use pregnancy.find_unborn_children(parent_uids) instead.\n# v3.0\nchild = pregnancy.child_uid[mother_uid]\n\n# v3.1\nchildren = pregnancy.find_unborn_children(mother_uids)\n\n\n\nThe method and associated distribution have been renamed.\nWhat to change: Rename method calls and references.\n# v3.0\np = pregnancy.make_p_fertility(eligible_uids)\npregnancy.pars.p_fertility  # Bernoulli distribution\n\n# v3.1\np = pregnancy.make_p_conceive(eligible_uids)\npregnancy._p_conceive  # Bernoulli distribution (now private)\n\n\n\nThe semantics have been inverted and the name clarified. Despite its name, p_neonatal_death in v3.0 was only applied when a mother dies during pregnancy – it was the probability that the neonate also dies conditional on maternal death. It was never a general neonatal mortality parameter.\nIn v3.1, p_survive_maternal_death makes this conditional relationship explicit: it is the probability that an unborn child survives the mother’s death (default 0, meaning unborn children do not survive maternal death).\nNote: Neither v3.0 nor v3.1 includes a built-in parameter for general neonatal mortality (e.g. from prematurity or birth complications). To model that, override the process_newborns() hook in a Pregnancy subclass.\nWhat to change: Rename the parameter and invert the probability value.\n# v3.0\npregnancy = ss.Pregnancy(p_neonatal_death=ss.bernoulli(0.8))  # 80% chance neonate dies given maternal death\n\n# v3.1\npregnancy = ss.Pregnancy(p_survive_maternal_death=ss.bernoulli(0.2))  # 20% chance unborn survives maternal death\n\n\n\nPreviously, dur_pregnancy was a fixed value (default ss.years(0.75)). It is now an ss.choice distribution that draws from gestational weeks 32-42, and duration is assigned per-agent.\nWhat to change: If you were relying on a fixed pregnancy duration or accessing self.pars.dur_pregnancy.years, update accordingly.\n# v3.0\npregnancy = ss.Pregnancy(dur_pregnancy=ss.years(0.75))\n# Internally: self.pars.dur_pregnancy.years was a single float\n\n# v3.1\n# Default draws from weeks 32-42; to override with a fixed duration:\npregnancy = ss.Pregnancy(dur_pregnancy=ss.choice(a=ss.weeks(np.arange(38, 43))))\n# Per-agent durations are stored in: pregnancy.dur_pregnancy[uids]  (a FloatArr)\n\n\n\nThe set_prognoses() method has been removed. Its functionality is now split across make_pregnancies(), process_delivery(), and set_breastfeeding().\nWhat to change: If you had a subclass that overrode set_prognoses(), move the logic to the appropriate new method.\n# v3.0\nclass MyPregnancy(ss.Pregnancy):\n    def set_prognoses(self, uids):\n        super().set_prognoses(uids)\n        # Custom logic for new pregnancies\n\n# v3.1\nclass MyPregnancy(ss.Pregnancy):\n    def make_pregnancies(self, uids):\n        embryo_counts = super().make_pregnancies(uids)\n        # Custom logic for new pregnancies\n        return embryo_counts\n\n\n\nThe step() method no longer delegates to do_step() and update_states(). The burn-in logic has also been moved from step() to init_post(). The new step() calls a sequence of smaller, overridable methods.\nWhat to change: If you had a subclass that overrode do_step() or update_states(), restructure to override the new methods.\n# v3.0 step flow\nstep() -&gt; do_step() -&gt; update_states() + make_pregnancies() + make_embryos()\n\n# v3.1 step flow\ninit_post()           # Burn-in happens here now\nstep():\n    updates_pre()           # Set base states, check breastfeeding\n    progress_pregnancies()  # Advance gestational clock\n    process_delivery()      # Handle births\n    set_rel_sus()           # Update susceptibility\n    select_conceivers()     # Find who conceives\n    make_pregnancies()      # Set pregnancy states\n    make_embryos()          # Create embryo agents\n    update_maternal_deaths()# Handle maternal deaths\nUse the _post_delivery() hook for custom post-delivery logic:\n# v3.1\nclass MyPregnancy(ss.Pregnancy):\n    def _post_delivery(self, mother_uids, newborn_uids):\n        # Custom post-delivery logic here\n        pass\n\n\n\nmake_embryos() now returns a tuple (conceive_uids_with_repeats, new_uids) instead of just new_uids. The first element accounts for multiple embryos per pregnancy (e.g. twins).\nWhat to change: Update any code that captures the return value.\n# v3.0\nnew_uids = pregnancy.make_embryos(conceive_uids)\n\n# v3.1\nconceive_uids_with_repeats, new_uids = pregnancy.make_embryos(conceive_uids, embryo_counts)\n\n\n\nThe old make_pregnancies() both selected who conceives and set prognoses. These are now separate: select_conceivers() returns UIDs of women who will conceive, and make_pregnancies() sets pregnancy states and durations for those UIDs.\nWhat to change: If you overrode make_pregnancies() in a subclass, split the logic.\n# v3.0\nclass MyPregnancy(ss.Pregnancy):\n    def make_pregnancies(self):\n        # Custom selection + prognosis logic\n\n# v3.1\nclass MyPregnancy(ss.Pregnancy):\n    def select_conceivers(self, uids=None):\n        # Custom selection logic\n        return conceive_uids\n\n    def make_pregnancies(self, uids):\n        # Custom prognosis logic\n        embryo_counts = super().make_pregnancies(uids)\n        return embryo_counts\n\n\n\nThe following new parameters are available via PregnancyPars. No migration is required, but you may want to use them:\n\n\n\n\n\n\n\n\nParameter\nDefault\nDescription\n\n\n\n\np_infertile\nss.bernoulli(p=0)\nPrimary infertility probability\n\n\ndur_breastfeed\nss.lognorm_ex(mean=ss.years(0.75), std=ss.years(0.5))\nBreastfeeding duration\n\n\np_breastfeed\nss.bernoulli(p=1)\nProbability of breastfeeding\n\n\nembryos_per_pregnancy\nss.choice(a=[1,2], p=[1.0, 0.0])\nNumber of embryos (twins support)\n\n\nrr_ptb\nss.normal(loc=1, scale=0.1)\nBaseline relative risk of pre-term birth\n\n\nrr_ptb_age\nAge-dependent array\nRelative risk of pre-term birth by age\n\n\np_survive_maternal_death\nss.bernoulli(0)\nProbability unborn survives mother’s death\n\n\ntrimesters\n[ss.weeks(13), ss.weeks(26)]\nTrimester boundaries\n\n\n\n\n\n\nThe following results are now available. No migration is required.\n\n\n\nResult\nDescription\n\n\n\n\nmaternal_deaths\nNumber of maternal deaths per timestep\n\n\nmmr\nMaternal mortality rate (per 100,000 births)\n\n\ntfr\nTotal fertility rate\n\n\nn_fecund\nNumber of fecund women\n\n\nn_fertile\nNumber of fertile women\n\n\nn_susceptible\nNumber of susceptible (non-pregnant fertile) women\n\n\n\nAge-specific fertility rates are available via pregnancy.asfr (a 2D array, not a standard Result)."
  },
  {
    "objectID": "tutorials/t6_interventions.html",
    "href": "tutorials/t6_interventions.html",
    "title": "T6 - Interventions",
    "section": "",
    "text": "Understanding the impact of interventions is one of the most common reasons to use a disease model. This tutorial shows how to implement standard interventions, as well as how to define your own custom interventions.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#products-and-interventions",
    "href": "tutorials/t6_interventions.html#products-and-interventions",
    "title": "T6 - Interventions",
    "section": "Products and interventions",
    "text": "Products and interventions\nStarsim contains products, which can be thought of as the actual test, diagnostic, treatment, or vaccine product being used, as well as interventions, which are responsible for delivering the products to the population.\nDepending on what disease you’re modeling, you might need to define your own custom products and interventions, or you might be able to directly use some of the examples provided in Starsim.\nStarsim includes three basic “types” of products: diagnostics, treatment, and vaccination. There isn’t a lot of detail in the templates for each of these, because most of the details about products is specific to a disease. There are also some disease-specific products built in the Starsim’s library of diseases - these can generally be found in the diseases subfolder (e.g. the cholera interventions are in cholera.py.\nStarsim also includes several basic types of intervention:\n\nroutine_vx() for routine vaccination, campaign_vx() for one-off campaigns\nsimilarly, routine_screening() and campaign_screening() for different types of screening program\ntreat_num(), which treats a certain number of people each timestep (by default, as many people as need treatment, but you can also set a maximum).\n\nThese are sometimes general enough that they don’t need to be tailored to a particular disease, and you can just use them directly. That being said, you are always welcome to tailor them as you like to capture particular features of the intervention you’re modeling.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#vaccination",
    "href": "tutorials/t6_interventions.html#vaccination",
    "title": "T6 - Interventions",
    "section": "Vaccination",
    "text": "Vaccination\nTo create an example, let’s first create the parameters that we want to use for the simulation:\n\nimport starsim as ss\n\npars = dict(\n    n_agents = 5_000,\n    birth_rate = ss.peryear(20),\n    death_rate = 15,\n    networks = dict(\n        type = 'randomnet', # Or 'random'\n        n_contacts = 4\n    ),\n    diseases = dict(\n        type = 'sir',\n        dur_inf = 10,\n        beta = 0.1,\n    )\n)\n\nNow we’ll create a vaccine product and a vaccination intervention:\n\n# Create the product - a vaccine with 50% efficacy\nmy_vaccine = ss.simple_vx(efficacy=0.5)\n\n# Create the intervention\nmy_intervention = ss.routine_vx(\n    start_year=2015,    # Begin vaccination in 2015\n    prob=0.2,           # 20% coverage\n    product=my_vaccine   # Use the MyVaccine product\n)\n\n# Now create two sims: a baseline sim and one with the intervention\nsim_base = ss.Sim(pars=pars)\nsim_base.run()\nsim_intv = ss.Sim(pars=pars, interventions=my_intervention)\nsim_intv.run()\n\nInitializing sim with 5000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.16 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.19 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.21 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.24 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.27 s)  •••••••••••••••••••• 100%\n\nInitializing sim with 5000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.03 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.06 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.09 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.12 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.15 s)  •••••••••••••••••••• 100%\n\n\n\nSim(n=5000; 2000—2050.0; demographics=births, deaths; networks=randomnet; interventions=routine_vx; diseases=sir)\n\n\nIf we want to see the impact, we can create a plot:\n\nimport matplotlib.pyplot as plt\n\nres_base = sim_base.results\nres_intv = sim_intv.results\n\nplt.figure()\nplt.plot(res_base.timevec, res_base.sir.prevalence, label='Baseline')\nplt.plot(res_intv.timevec, res_intv.sir.prevalence, label='Vax')\nplt.axvline(x=ss.date(2015), color='k', ls='--')\nplt.title('Prevalence')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nWe can see that from the year of introducing the vaccine, prevalence starts to fall.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#custom-interventions",
    "href": "tutorials/t6_interventions.html#custom-interventions",
    "title": "T6 - Interventions",
    "section": "Custom interventions",
    "text": "Custom interventions\nThe most common way of accessing diseases for modification by interventions is via their names (e.g. sir, sis). This means that typically, different interventions need to be defined for different diseases. The example below shows how to define a simple vaccine for SIS which is just a function, rather than a class:\n\nimport starsim as ss\n\ndef simple_sis_vaccine(sim, start=2030, eff=0.9):\n    if sim.now == start:\n        sim.diseases.sis.rel_trans[:] *= 1-eff\n    return\n\npars = dict(\n    start=2000,\n    stop=2050,\n    diseases='sis',\n    networks='random',\n    interventions=simple_sis_vaccine,\n)\n\nsim = ss.Sim(pars)\nsim.run()\nsim.plot()\nss.show()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.03 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.06 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.09 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.12 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.15 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t6_interventions.html#exercises",
    "href": "tutorials/t6_interventions.html#exercises",
    "title": "T6 - Interventions",
    "section": "Exercises",
    "text": "Exercises\n\nIf we change the disease from SIR to SIS and set coverage to 100%, what minimum efficacy of vaccine is required to eradicate the disease by 2050? You will need to implement an sis_vaccine class as well (based on ss.sir_vaccine – not the simple vaccine above), but can re-use ss.routine_vx.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T6 - Interventions"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html",
    "href": "tutorials/t3_demographics.html",
    "title": "T3 - Demographics",
    "section": "",
    "text": "An interactive version of this notebook is available on Google Colab or Binder.\nThere are a few basic ways to add vital dynamics to your model, e.g.\nimport starsim as ss\n\npars = dict(\n    birth_rate = ss.peryear(20),      # Annual crude birth rate (per 1000 people)\n    death_rate = ss.peryear(15),      # Annual crude death rate (per 1000 people)\n    networks = 'random',\n    diseases = 'sir'\n)\nsim = ss.Sim(pars)\nThis will apply annual birth and death rates as specified in the pars dict. Alternatively, we can make demographic components, which achieves the same thing:\ndemographics = [\n    ss.Births(birth_rate=ss.peryear(20)),\n    ss.Deaths(death_rate=ss.peryear(15))\n]\nsim = ss.Sim(demographics=demographics)\nYou can even simply set demographics=True to use default rates:\nss.Sim(demographics=True).run().plot();\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.01 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.02 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.03 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.04 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.05 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\nBy default, agents age if and only if at least one demographics module is included. You can override this behavior by setting use_aging, e.g. ss.Sim(use_aging=False)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html#scaling-results-to-whole-populations",
    "href": "tutorials/t3_demographics.html#scaling-results-to-whole-populations",
    "title": "T3 - Demographics",
    "section": "Scaling results to whole populations",
    "text": "Scaling results to whole populations\nEven though we’ve been simulating populations of a few thousand agents, we can also use the total_pop parameter to scale our results so that they reflect a much larger population. You can think of this as a kind of statistical sampling approximation. If we want to model the population of Nigeria, for example, it would be much too computationally intensive to simulate 200 million agents. However, we could simulate 50,000 agents and then say that each agent represents 4,000 people. Again, we can do this by passing total_pop=200e6 to the sim or in the pars dictionary. Here’s an example:\n\ndemographics = [\n    ss.Births(birth_rate=ss.peryear(20)),\n    ss.Deaths(death_rate=ss.peryear(15))\n]\nsim = ss.Sim(pars={'total_pop': 200e6, 'n_agents': 50e3}, demographics=demographics)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html#using-realistic-vital-demographics",
    "href": "tutorials/t3_demographics.html#using-realistic-vital-demographics",
    "title": "T3 - Demographics",
    "section": "Using realistic vital demographics",
    "text": "Using realistic vital demographics\nFor more realistic demographics, we can also pass in a file that has birth or death rates over time and by age/sex. There are examples of these files in the test_data folder. Here’s how we would read them in and construct realistic vital dynamics for Nigeria:\n\nimport starsim as ss\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read in age-specific fertility rates\nfertility_rates = pd.read_csv('test_data/nigeria_asfr.csv')\npregnancy = ss.Pregnancy(fertility_rate=fertility_rates)\n\ndeath_rates = pd.read_csv('test_data/nigeria_deaths.csv')\ndeath = ss.Deaths(death_rate=death_rates, rate_units=1)\n\ndemographics = [pregnancy, death]\n\n# Make people using the distribution of the population by age/sex in 1995\nn_agents = 5_000\nnga_pop_1995 = 106819805  # Population of Nigeria in 1995, the year we will start the model\nage_data = pd.read_csv('test_data/nigeria_age.csv')\nppl = ss.People(n_agents, age_data=age_data)\n\n# Make the sim, run and plot\nsim = ss.Sim(total_pop=nga_pop_1995, start=1995, people=ppl, demographics=demographics, networks='random', diseases='sir')\nsim.run()\n\n# Read in a file with the actual population size\nnigeria_popsize = pd.read_csv('test_data/nigeria_popsize.csv')\ndata = nigeria_popsize[(nigeria_popsize.year &gt;= 1995) & (nigeria_popsize.year &lt;= 2030)]\n\n# Plot the overall population size - simulated vs data\nfig, ax = plt.subplots(1, 1)\nres = sim.results\nax.scatter(data.year, data.n_alive, alpha=0.5, label='Data')\nax.plot(sim.t.yearvec, res.n_alive, color='k', label='Model')\nax.legend()\nax.set_title('Population')\nplt.show()\n\nInitializing sim with 5000 agents\n  Running 1995.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2005.01.01 (10/51) (0.24 s)  ••••———————————————— 22%\n  Running 2015.01.01 (20/51) (0.33 s)  ••••••••———————————— 41%\n  Running 2025.01.01 (30/51) (0.44 s)  ••••••••••••———————— 61%\n  Running 2035.01.01 (40/51) (0.56 s)  ••••••••••••••••———— 80%\n  Running 2045.01.01 (50/51) (0.73 s)  •••••••••••••••••••• 100%\n\n\n\n\n\n\n\n\n\n\nIf you want to use realistic demographics for your model, you can adapt the data files and code snippet above to read in the relevant demographic data files for your country/setting.\nNote: In the code block above, we set the units of the mortality data to 1, as opposed to 1/1000. If your data come in the form of deaths per 1000 people, set units to 1/1000. Note also that as per standard definitions, fertility_rate is defined per woman, whereas birth_rate is defined per person.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t3_demographics.html#exercises",
    "href": "tutorials/t3_demographics.html#exercises",
    "title": "T3 - Demographics",
    "section": "Exercises",
    "text": "Exercises\n\nIn Niger, the crude birth rate is 45 and the crude death rate is 9. Assuming these rates stay constant, and starting with a total population of 24 million in 2020, how many people will there be in 2040? (You do not need to include any diseases in your model.)",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T3 - Demographics"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html",
    "href": "tutorials/t4_diseases.html",
    "title": "T4 - Diseases",
    "section": "",
    "text": "An interactive version of this notebook is available on Google Colab or Binder.\nDiseases are the cornerstone of almost any Starsim analysis. In this tutorial, you’ll learn how to work with diseases in Starsim, starting with simple modifications and building up to creating your own custom disease models.\nBy the end of this tutorial, you’ll understand how to: - Modify parameters of existing diseases - Run simulations with multiple diseases - Create your own custom disease from scratch",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#step-1-modifying-disease-parameters",
    "href": "tutorials/t4_diseases.html#step-1-modifying-disease-parameters",
    "title": "T4 - Diseases",
    "section": "Step 1: Modifying disease parameters",
    "text": "Step 1: Modifying disease parameters\nThe easiest way to customize a disease is by changing its parameters. Much like sims or networks, a Disease can be customized by passing in a pars dictionary containing parameters. Let’s start with a simple SIR model and see how different parameters affect the simulation:\n\nimport starsim as ss\nsir = ss.SIR(dur_inf=10, beta=0.2, init_prev=0.4, p_death=0.2)\nsim = ss.Sim(n_agents=2_000, diseases=sir, networks='random')\nsim.run().plot()\n\nInitializing sim with 2000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.15 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.16 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.17 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.19 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.20 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nNotice how we modified several key parameters: - dur_inf=10: How long people stay infectious (10 years) - beta=0.2: Transmission probability per contact - init_prev=0.4: Starting with 40% of the population infected - p_death=0.2: 20% of infected people die\nWe already saw that this model creates results that are stored in sim.results.sir. The results can also be directly accessed via sir.results.\nFor more detail on any of the diseases that are in the Starsim library of diseases, please refer to the docstrings and source code of the disease files.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#step-2-simulating-multiple-diseases",
    "href": "tutorials/t4_diseases.html#step-2-simulating-multiple-diseases",
    "title": "T4 - Diseases",
    "section": "Step 2: Simulating multiple diseases",
    "text": "Step 2: Simulating multiple diseases\nYou can add multiple diseases to the same simulation, like so. Here we are making use of a “connector”. A connector is a module in Starsim that tells you how two things relate to one another - in this case, how HIV modifies a person’s transmissibility and susceptibility to gonorrhea and vice versa. Unlike dieases, networks, interventions, etc., connectors don’t have any pre-specified location in the sim. Instead, they can be placed wherever they make the most sense (for example, a connector that mediated how two networks behaved might be placed at the beginning or end of the list of networks; for diseases, it might be placed at the beginning or end of the list of diseases).\n\nimport starsim as ss\nimport starsim_examples as sse\n\nclass simple_hiv_ng(ss.Module):\n    \"\"\" Simple connector whereby rel_sus to NG (Neisseria gonorrhoeae) doubles if CD4 count is &lt;200\"\"\"\n    def __init__(self, pars=None, label='HIV-Gonorrhea', **kwargs):\n        super().__init__()\n        self.define_pars(\n            rel_trans_hiv  = 2,\n            rel_trans_aids = 5,\n            rel_sus_hiv    = 2,\n            rel_sus_aids   = 5,\n        )\n        self.update_pars(pars, **kwargs)\n        return\n\n    def step(self):\n        \"\"\" Specify how HIV increases NG rel_sus and rel_trans \"\"\"\n        ng = self.sim.people.gonorrhea\n        hiv = self.sim.people.hiv\n        p = self.pars\n        ng.rel_sus[hiv.cd4 &lt; 500] = p.rel_sus_hiv\n        ng.rel_sus[hiv.cd4 &lt; 200] = p.rel_sus_aids\n        ng.rel_trans[hiv.cd4 &lt; 500] = p.rel_trans_hiv\n        ng.rel_trans[hiv.cd4 &lt; 200] = p.rel_trans_aids\n        return\n\n# Make HIV\nhiv = sse.HIV(\n    beta = {'mf': [0.0008, 0.0004]},  # Specify transmissibility over the MF network\n    init_prev = 0.05,\n)\n\n# Make gonorrhea\nng = sse.Gonorrhea(\n    beta = {'mf': [0.05, 0.025]},  # Specify transmissibility over the MF network\n    init_prev = 0.025,\n)\n\n# Make the sim, including a connector betweeh HIV and gonorrhea:\nn_agents = 5_000\nsim = ss.Sim(n_agents=n_agents, networks='mf', diseases=[simple_hiv_ng(), hiv, ng])\nsim.run()\nsim.plot('hiv')\nsim.plot('gonorrhea')\n\nInitializing sim with 5000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.03 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.07 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.10 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.14 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.17 s)  •••••••••••••••••••• 100%\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nFigure(768x576)\n\n\n\n\n\n\n\n\n\nYou can see how the two diseases interact - HIV creates a vulnerable population that’s more susceptible to gonorrhea infection.",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#step-3-creating-your-own-disease-model",
    "href": "tutorials/t4_diseases.html#step-3-creating-your-own-disease-model",
    "title": "T4 - Diseases",
    "section": "Step 3: Creating your own disease model",
    "text": "Step 3: Creating your own disease model\nNow for the fun part - creating your own disease from scratch! Let’s modify the SIR model to create an SEIR model, which adds an “Exposed” state where people are infected but not yet infectious.\nThis is a common pattern in epidemiology - think of it as the incubation period before someone becomes contagious.\nIf you want to make your own disease, you could either inherit from one of the templates in diseases.py, or you could copy the examples and extend them to capture features of the disease that you want to model. For example, suppose you wanted to change the SIR model to an SEIR model (i.e., add an ‘exposed’ state where people were transmissible but did not yet have symptoms. You might hope that this would be a relatively simple change to make. Here’s how it would look:\n\nimport starsim as ss\nimport matplotlib.pyplot as plt\n\nclass SEIR(ss.SIR):\n    def __init__(self, pars=None, *args, **kwargs):\n        super().__init__()\n        self.define_pars(\n            dur_exp = ss.lognorm_ex(0.5),\n        )\n        self.update_pars(pars, **kwargs)\n\n        # Additional states beyond the SIR ones \n        self.define_states(\n            ss.BoolState('exposed', label='Exposed'),\n            ss.FloatArr('ti_exposed', label='TIme of exposure'),\n        )\n        return\n\n    @property\n    def infectious(self):\n        return self.infected | self.exposed\n\n    def step_state(self):\n        \"\"\" Make all the updates from the SIR model \"\"\"\n        # Perform SIR updates\n        super().step_state()\n\n        # Additional updates: progress exposed -&gt; infected\n        infected = self.exposed & (self.ti_infected &lt;= self.ti)\n        self.exposed[infected] = False\n        self.infected[infected] = True\n        return\n\n    def step_die(self, uids):\n        super().step_die(uids)\n        self.exposed[uids] = False\n        return\n\n    def set_prognoses(self, uids, sources=None):\n        \"\"\" Carry out state changes associated with infection \"\"\"\n        super().set_prognoses(uids, sources)\n        ti = self.ti\n        self.susceptible[uids] = False\n        self.exposed[uids] = True\n        self.ti_exposed[uids] = ti\n\n        # Calculate and schedule future outcomes\n        p = self.pars # Shorten for convenience\n        dur_exp = p.dur_exp.rvs(uids)\n        self.ti_infected[uids] = ti + dur_exp\n        dur_inf = p.dur_inf.rvs(uids)\n        will_die = p.p_death.rvs(uids)        \n        self.ti_recovered[uids[~will_die]] = ti + dur_inf[~will_die]\n        self.ti_dead[uids[will_die]] = ti + dur_inf[will_die]\n        return\n    \n    def plot(self):\n        \"\"\" Update the plot with the exposed compartment \"\"\"\n        with ss.options.context(show=False): # Don't show yet since we're adding another line\n            fig = super().plot()\n            ax = plt.gca()\n            res = self.results.n_exposed\n            ax.plot(res.timevec, res, label=res.label)\n            plt.legend()\n        return ss.return_fig(fig)\n\nThe new class includes the following main changes:\n\nIn __init__ we added the extra pars and states needed for our model\nWe defined infectious to include both infected and exposed people - this means that we can just reuse the existing logic for how the SIR model handles transmission\nWe updated update_pre and update_death to include changes to the exposed state\nWe rewrote set_prognoses to include the new exposed state.\n\nHere’s how it would look in practice:\n\nseir = SEIR()\nsim = ss.Sim(diseases=seir, networks='random')\nsim.run()\nsim.plot()\nsim.diseases.seir.plot()\n\nInitializing sim with 10000 agents\n  Running 2000.01.01 ( 0/51) (0.00 s)  ———————————————————— 2%\n  Running 2010.01.01 (10/51) (0.04 s)  ••••———————————————— 22%\n  Running 2020.01.01 (20/51) (0.09 s)  ••••••••———————————— 41%\n  Running 2030.01.01 (30/51) (0.12 s)  ••••••••••••———————— 61%\n  Running 2040.01.01 (40/51) (0.15 s)  ••••••••••••••••———— 80%\n  Running 2050.01.01 (50/51) (0.17 s)  •••••••••••••••••••• 100%\n\nFigure(896x672)\n\n\n\n\n\n\n\n\n\nFigure(672x480)\nNone",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "tutorials/t4_diseases.html#exercises",
    "href": "tutorials/t4_diseases.html#exercises",
    "title": "T4 - Diseases",
    "section": "Exercises",
    "text": "Exercises\n\nParameter exploration: Try different values of dur_exp in the SEIR model - how does it affect the epidemic curve?\nSEIRS model: Adapt the SEIR example above to be SEIRS (where recovered people can become susceptible again)\nMulti-strain model: Can you create a model with two strains of the same disease that provide partial cross-immunity?",
    "crumbs": [
      "Home",
      "**Tutorials**",
      "T4 - Diseases"
    ]
  },
  {
    "objectID": "api/timeline.html",
    "href": "api/timeline.html",
    "title": "timeline",
    "section": "",
    "text": "timeline\nSimulation and module timelines\n\n\n\n\n\nName\nDescription\n\n\n\n\nTimeline\nHandle time vectors and sequencing (“timelines”) for both simulations and modules.\n\n\n\n\n\ntimeline.Timeline(\n    start=None,\n    stop=None,\n    dt=None,\n    dur=None,\n    name=None,\n    init=None,\n    sim=None,\n)\nHandle time vectors and sequencing (“timelines”) for both simulations and modules.\nEach module can have its own time instance, in the case where the time vector is defined by absolute dates, these time vectors are by definition aligned. Otherwise they can be specified using dur objects which express relative times (they can be added to a date to get an absolute time)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nstr/int/float/ss.date/ss.dur\nwhen the simulation/module starts, e.g. ‘2000’, ‘2000-01-01’, 2000, ss.date(2000), or ss.years(2000)\nNone\n\n\nstop\nstr/int/float/ss.date/ss.dur\nwhen the simulation/module ends (note: if start is a date, stop must be too)\nNone\n\n\ndt\nint/float/ss.dur\nSimulation step size\nNone\n\n\ndur\nint/float/ss.dur\nIf “stop” is not provided, run for this duration\nNone\n\n\nname\nstr\nif provided, name the Timeline object\nNone\n\n\ninit\nbool\nwhether or not to immediately initialize the Timeline object (by default, yes if start and stop or start and dur are provided; otherwise no)\nNone\n\n\nsim\nSim\nif provided, initialize the Timeline with this as the parent (i.e. populating missing values)\nNone\n\n\n\nThe Timeline object, after initialization, has the following time vectors, each representing a different way of representing time:\n\ntvec: ground truth simulation time, either as absolute ss.date instances, or relative ss.dur instances, e.g. DateArray([&lt;2021.01.01&gt;, &lt;2021.01.03&gt;, &lt;2021.01.05&gt;, &lt;2021.01.07&gt;])\ntivec: the vector of time indices (np.arange(len(tvec)))\ntimevec: the “human-friendly” representation of tvec: same as tvec if using ss.date, else floats if using ss.dur\nyearvec: time represented as floating-point years\ndatevec: time represented as ss.date instances\nrelvec: relative time, in the sim’s time units\n\nThe Timeline object also has the following attributes/methods:\n\nti (int): the current timestep\nnpts (int): the total number of timesteps\nnow() (ss.date/float/str): the current time, based on the timevec by default or a different vector if specified\n\nExamples:\nt1 = ss.Timeline(start=2000, stop=2020, dt=1.0)\nt2 = ss.Timeline(start='2021-01-01', stop='2021-04-04', dt=ss.days(2))\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndt_year\nThe timestep size in years\n\n\nfinished\nCheck if the simulation is finished, i.e. we’re at the last time point\n\n\nis_absolute\nCheck whether the fundamental simulation unit is absolute\n\n\nready\nCheck if all parameters are in place to be initialized\n\n\nyear\nThe current time in years\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit\nInitialize all vectors\n\n\nnow\nGet the current simulation time\n\n\nreconcile_args\nReconcile the different options for the input parameters\n\n\nto_dict\nReturn a dictionary of all time vectors\n\n\nupdate\nReconcile different ways of supplying inputs\n\n\n\n\n\ntimeline.Timeline.init(sim=None, max_steps=20000, force=False)\nInitialize all vectors\n\n\n\ntimeline.Timeline.now(key=None)\nGet the current simulation time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr\nwhich type of time to get: “time” (default), “year”, “date”, “tvec”, or “str”\nNone\n\n\n\nExamples:\nt = ss.Timeline(start='2021-01-01', stop='2022-02-02', dt='week')\nt.ti = 25\nt.now() # Returns &lt;2021-06-25&gt;\nt.now('date') # Returns &lt;2021-06-25&gt;\nt.now('year') # Returns 2021.479\nt.now('str') # Returns '2021-06-25'\n\n\n\n\ntimeline.Timeline.reconcile_args(sim=None)\nReconcile the different options for the input parameters\n\n\n\ntimeline.Timeline.to_dict()\nReturn a dictionary of all time vectors\n\n\n\ntimeline.Timeline.update(\n    pars=None,\n    parent=None,\n    reset=True,\n    force=None,\n    **kwargs,\n)\nReconcile different ways of supplying inputs",
    "crumbs": [
      "**Utilities**",
      "timeline"
    ]
  },
  {
    "objectID": "api/timeline.html#classes",
    "href": "api/timeline.html#classes",
    "title": "timeline",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nTimeline\nHandle time vectors and sequencing (“timelines”) for both simulations and modules.\n\n\n\n\n\ntimeline.Timeline(\n    start=None,\n    stop=None,\n    dt=None,\n    dur=None,\n    name=None,\n    init=None,\n    sim=None,\n)\nHandle time vectors and sequencing (“timelines”) for both simulations and modules.\nEach module can have its own time instance, in the case where the time vector is defined by absolute dates, these time vectors are by definition aligned. Otherwise they can be specified using dur objects which express relative times (they can be added to a date to get an absolute time)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nstr/int/float/ss.date/ss.dur\nwhen the simulation/module starts, e.g. ‘2000’, ‘2000-01-01’, 2000, ss.date(2000), or ss.years(2000)\nNone\n\n\nstop\nstr/int/float/ss.date/ss.dur\nwhen the simulation/module ends (note: if start is a date, stop must be too)\nNone\n\n\ndt\nint/float/ss.dur\nSimulation step size\nNone\n\n\ndur\nint/float/ss.dur\nIf “stop” is not provided, run for this duration\nNone\n\n\nname\nstr\nif provided, name the Timeline object\nNone\n\n\ninit\nbool\nwhether or not to immediately initialize the Timeline object (by default, yes if start and stop or start and dur are provided; otherwise no)\nNone\n\n\nsim\nSim\nif provided, initialize the Timeline with this as the parent (i.e. populating missing values)\nNone\n\n\n\nThe Timeline object, after initialization, has the following time vectors, each representing a different way of representing time:\n\ntvec: ground truth simulation time, either as absolute ss.date instances, or relative ss.dur instances, e.g. DateArray([&lt;2021.01.01&gt;, &lt;2021.01.03&gt;, &lt;2021.01.05&gt;, &lt;2021.01.07&gt;])\ntivec: the vector of time indices (np.arange(len(tvec)))\ntimevec: the “human-friendly” representation of tvec: same as tvec if using ss.date, else floats if using ss.dur\nyearvec: time represented as floating-point years\ndatevec: time represented as ss.date instances\nrelvec: relative time, in the sim’s time units\n\nThe Timeline object also has the following attributes/methods:\n\nti (int): the current timestep\nnpts (int): the total number of timesteps\nnow() (ss.date/float/str): the current time, based on the timevec by default or a different vector if specified\n\nExamples:\nt1 = ss.Timeline(start=2000, stop=2020, dt=1.0)\nt2 = ss.Timeline(start='2021-01-01', stop='2021-04-04', dt=ss.days(2))\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndt_year\nThe timestep size in years\n\n\nfinished\nCheck if the simulation is finished, i.e. we’re at the last time point\n\n\nis_absolute\nCheck whether the fundamental simulation unit is absolute\n\n\nready\nCheck if all parameters are in place to be initialized\n\n\nyear\nThe current time in years\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit\nInitialize all vectors\n\n\nnow\nGet the current simulation time\n\n\nreconcile_args\nReconcile the different options for the input parameters\n\n\nto_dict\nReturn a dictionary of all time vectors\n\n\nupdate\nReconcile different ways of supplying inputs\n\n\n\n\n\ntimeline.Timeline.init(sim=None, max_steps=20000, force=False)\nInitialize all vectors\n\n\n\ntimeline.Timeline.now(key=None)\nGet the current simulation time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr\nwhich type of time to get: “time” (default), “year”, “date”, “tvec”, or “str”\nNone\n\n\n\nExamples:\nt = ss.Timeline(start='2021-01-01', stop='2022-02-02', dt='week')\nt.ti = 25\nt.now() # Returns &lt;2021-06-25&gt;\nt.now('date') # Returns &lt;2021-06-25&gt;\nt.now('year') # Returns 2021.479\nt.now('str') # Returns '2021-06-25'\n\n\n\n\ntimeline.Timeline.reconcile_args(sim=None)\nReconcile the different options for the input parameters\n\n\n\ntimeline.Timeline.to_dict()\nReturn a dictionary of all time vectors\n\n\n\ntimeline.Timeline.update(\n    pars=None,\n    parent=None,\n    reset=True,\n    force=None,\n    **kwargs,\n)\nReconcile different ways of supplying inputs",
    "crumbs": [
      "**Utilities**",
      "timeline"
    ]
  },
  {
    "objectID": "api/interventions.html",
    "href": "api/interventions.html",
    "title": "interventions",
    "section": "",
    "text": "interventions\nDefine interventions, which are used to modify the state of the sim during run.\nInterventions typically include things like testing, treatment, and vaccination.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBaseScreening\nBase class for screening.\n\n\nBaseTest\nBase class for screening and triage.\n\n\nBaseTreatment\nBase treatment class.\n\n\nBaseTriage\nBase class for triage.\n\n\nBaseVaccination\nBase vaccination class for determining who will receive a vaccine.\n\n\nCampaignDelivery\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\nIntervention\nBase class for interventions.\n\n\nRoutineDelivery\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\ncampaign_screening\nCampaign screening - an instance of base screening combined with campaign delivery.\n\n\ncampaign_triage\nCampaign triage - an instance of base triage combined with campaign delivery.\n\n\ncampaign_vx\nCampaign vaccination - an instance of base vaccination combined with campaign delivery.\n\n\nroutine_screening\nRoutine screening - an instance of base screening combined with routine delivery.\n\n\nroutine_triage\nRoutine triage - an instance of base triage combined with routine delivery.\n\n\nroutine_vx\nRoutine vaccination - an instance of base vaccination combined with routine delivery.\n\n\ntreat_num\nTreat a fixed number of people each timestep.\n\n\n\n\n\ninterventions.BaseScreening(product=None, prob=None, eligibility=None, **kwargs)\nBase class for screening.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseScreening.step()\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest(product=None, prob=None, eligibility=None, **kwargs)\nBase class for screening and triage.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct (Product)\n\nthe diagnostic to use\nrequired\n\n\nprob (float/arr)\n\nannual probability of eligible people receiving the diagnostic\nrequired\n\n\neligibility (inds/callable)\n\nindices OR callable that returns inds\nrequired\n\n\nkwargs (dict)\n\npassed to Intervention()\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nReturn an array of indices of agents eligible for screening at time t,\n\n\ndeliver\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest.check_eligibility()\nReturn an array of indices of agents eligible for screening at time t, e.g. matching demographic characteristics\n\n\n\ninterventions.BaseTest.deliver()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTreatment(product=None, prob=None, eligibility=None, **kwargs)\nBase treatment class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct (str/Product)\n\nthe treatment product to use\nrequired\n\n\nprob (float/arr)\n\nprobability of treatment aong those eligible\nrequired\n\n\neligibility (inds/callable)\n\nindices OR callable that returns inds\nrequired\n\n\nkwargs (dict)\n\npassed to Intervention()\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_accept_inds\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\nget_candidates\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\nstep\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTreatment.get_accept_inds()\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\n\ninterventions.BaseTreatment.get_candidates()\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\n\ninterventions.BaseTreatment.step()\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTriage(product=None, prob=None, eligibility=None, **kwargs)\nBase class for triage.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\ninterventions.BaseVaccination(\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nBase vaccination class for determining who will receive a vaccine.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct (str/Product)\n\nthe vaccine to use\nrequired\n\n\nprob (float/arr)\n\nannual probability of eligible population getting vaccinated\nrequired\n\n\nlabel (str)\n\nthe name of vaccination strategy\nrequired\n\n\nkwargs (dict)\n\npassed to Intervention()\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseVaccination.step()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.CampaignDelivery(\n    *args,\n    years=None,\n    interpolate=None,\n    prob=None,\n    **kwargs,\n)\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\n\ninterventions.Intervention(*args, eligibility=None, **kwargs)\nBase class for interventions.\nThe key method of the intervention is step(), which is called with the sim on each timestep.\n\n\n\n\n\nName\nDescription\n\n\n\n\nhas_product\nCheck if the intervention has a product\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.Intervention.check_eligibility()\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.RoutineDelivery(\n    *args,\n    years=None,\n    start_year=None,\n    end_year=None,\n    prob=None,\n    annual_prob=True,\n    **kwargs,\n)\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\n\ninterventions.campaign_screening(\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign screening - an instance of base screening combined with campaign delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.campaign_screening(product=my_prod, prob=0.2, years=2030) # Screen 20% of the eligible population in 2020\nscreen2 = ss.campaign_screening(product=my_prod, prob=0.02, years=[2025,2030]) # Screen 20% of the eligible population in 2025 and again in 2030\n\n\n\ninterventions.campaign_triage(\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign triage - an instance of base triage combined with campaign delivery. See base classes for a description of input arguments.\nExamples: # Example: In 2030, triage all positive screens into confirmatory testing screened_pos = lambda sim: sim.interventions.screening.outcomes[‘positive’] triage1 = ss.campaign_triage(product=my_triage, eligibility=screen_pos, prob=0.9, years=2030)\n\n\n\ninterventions.campaign_vx(*args, product=None, prob=None, label=None, **kwargs)\nCampaign vaccination - an instance of base vaccination combined with campaign delivery. See base classes for a description of input arguments.\n\n\n\ninterventions.routine_screening(\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nRoutine screening - an instance of base screening combined with routine delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.routine_screening(product=my_prod, prob=0.02) # Screen 2% of the eligible population every year\nscreen2 = ss.routine_screening(product=my_prod, prob=0.02, start_year=2020) # Screen 2% every year starting in 2020\nscreen3 = ss.routine_screening(product=my_prod, prob=np.linspace(0.005,0.025,5), years=np.arange(2020,2025)) # Scale up screening over 5 years starting in 2020",
    "crumbs": [
      "**Modules**",
      "interventions"
    ]
  },
  {
    "objectID": "api/interventions.html#classes",
    "href": "api/interventions.html#classes",
    "title": "interventions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBaseScreening\nBase class for screening.\n\n\nBaseTest\nBase class for screening and triage.\n\n\nBaseTreatment\nBase treatment class.\n\n\nBaseTriage\nBase class for triage.\n\n\nBaseVaccination\nBase vaccination class for determining who will receive a vaccine.\n\n\nCampaignDelivery\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\nIntervention\nBase class for interventions.\n\n\nRoutineDelivery\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\ncampaign_screening\nCampaign screening - an instance of base screening combined with campaign delivery.\n\n\ncampaign_triage\nCampaign triage - an instance of base triage combined with campaign delivery.\n\n\ncampaign_vx\nCampaign vaccination - an instance of base vaccination combined with campaign delivery.\n\n\nroutine_screening\nRoutine screening - an instance of base screening combined with routine delivery.\n\n\nroutine_triage\nRoutine triage - an instance of base triage combined with routine delivery.\n\n\nroutine_vx\nRoutine vaccination - an instance of base vaccination combined with routine delivery.\n\n\ntreat_num\nTreat a fixed number of people each timestep.\n\n\n\n\n\ninterventions.BaseScreening(product=None, prob=None, eligibility=None, **kwargs)\nBase class for screening.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseScreening.step()\nPerform screening by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest(product=None, prob=None, eligibility=None, **kwargs)\nBase class for screening and triage.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct (Product)\n\nthe diagnostic to use\nrequired\n\n\nprob (float/arr)\n\nannual probability of eligible people receiving the diagnostic\nrequired\n\n\neligibility (inds/callable)\n\nindices OR callable that returns inds\nrequired\n\n\nkwargs (dict)\n\npassed to Intervention()\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nReturn an array of indices of agents eligible for screening at time t,\n\n\ndeliver\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTest.check_eligibility()\nReturn an array of indices of agents eligible for screening at time t, e.g. matching demographic characteristics\n\n\n\ninterventions.BaseTest.deliver()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseTreatment(product=None, prob=None, eligibility=None, **kwargs)\nBase treatment class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct (str/Product)\n\nthe treatment product to use\nrequired\n\n\nprob (float/arr)\n\nprobability of treatment aong those eligible\nrequired\n\n\neligibility (inds/callable)\n\nindices OR callable that returns inds\nrequired\n\n\nkwargs (dict)\n\npassed to Intervention()\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_accept_inds\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\nget_candidates\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\nstep\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTreatment.get_accept_inds()\nGet indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment\n\n\n\ninterventions.BaseTreatment.get_candidates()\nGet candidates for treatment on this timestep. Implemented by derived classes.\n\n\n\ninterventions.BaseTreatment.step()\nPerform treatment by getting candidates, checking their eligibility, and then treating them.\n\n\n\n\n\ninterventions.BaseTriage(product=None, prob=None, eligibility=None, **kwargs)\nBase class for triage.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to BaseTest\n{}\n\n\n\n\n\n\n\ninterventions.BaseVaccination(\n    *args,\n    product=None,\n    prob=None,\n    label=None,\n    **kwargs,\n)\nBase vaccination class for determining who will receive a vaccine.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nproduct (str/Product)\n\nthe vaccine to use\nrequired\n\n\nprob (float/arr)\n\nannual probability of eligible population getting vaccinated\nrequired\n\n\nlabel (str)\n\nthe name of vaccination strategy\nrequired\n\n\nkwargs (dict)\n\npassed to Intervention()\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nstep\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.BaseVaccination.step()\nDeliver the diagnostics by finding who’s eligible, finding who accepts, and applying the product.\n\n\n\n\n\ninterventions.CampaignDelivery(\n    *args,\n    years=None,\n    interpolate=None,\n    prob=None,\n    **kwargs,\n)\nBase class for any intervention that uses campaign delivery; handles interpolation of input years.\n\n\n\ninterventions.Intervention(*args, eligibility=None, **kwargs)\nBase class for interventions.\nThe key method of the intervention is step(), which is called with the sim on each timestep.\n\n\n\n\n\nName\nDescription\n\n\n\n\nhas_product\nCheck if the intervention has a product\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_eligibility\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.Intervention.check_eligibility()\nReturn an array of indices of agents eligible for screening at time t\n\n\n\n\n\ninterventions.RoutineDelivery(\n    *args,\n    years=None,\n    start_year=None,\n    end_year=None,\n    prob=None,\n    annual_prob=True,\n    **kwargs,\n)\nBase class for any intervention that uses routine delivery; handles interpolation of input years.\n\n\n\ninterventions.campaign_screening(\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign screening - an instance of base screening combined with campaign delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.campaign_screening(product=my_prod, prob=0.2, years=2030) # Screen 20% of the eligible population in 2020\nscreen2 = ss.campaign_screening(product=my_prod, prob=0.02, years=[2025,2030]) # Screen 20% of the eligible population in 2025 and again in 2030\n\n\n\ninterventions.campaign_triage(\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nCampaign triage - an instance of base triage combined with campaign delivery. See base classes for a description of input arguments.\nExamples: # Example: In 2030, triage all positive screens into confirmatory testing screened_pos = lambda sim: sim.interventions.screening.outcomes[‘positive’] triage1 = ss.campaign_triage(product=my_triage, eligibility=screen_pos, prob=0.9, years=2030)\n\n\n\ninterventions.campaign_vx(*args, product=None, prob=None, label=None, **kwargs)\nCampaign vaccination - an instance of base vaccination combined with campaign delivery. See base classes for a description of input arguments.\n\n\n\ninterventions.routine_screening(\n    product=None,\n    prob=None,\n    eligibility=None,\n    **kwargs,\n)\nRoutine screening - an instance of base screening combined with routine delivery. See base classes for a description of input arguments.\nExamples:\nscreen1 = ss.routine_screening(product=my_prod, prob=0.02) # Screen 2% of the eligible population every year\nscreen2 = ss.routine_screening(product=my_prod, prob=0.02, start_year=2020) # Screen 2% every year starting in 2020\nscreen3 = ss.routine_screening(product=my_prod, prob=np.linspace(0.005,0.025,5), years=np.arange(2020,2025)) # Scale up screening over 5 years starting in 2020",
    "crumbs": [
      "**Modules**",
      "interventions"
    ]
  },
  {
    "objectID": "api/debugtools.html",
    "href": "api/debugtools.html",
    "title": "debugtools",
    "section": "",
    "text": "debugtools\nUtilities to help with debugging Starsim runs\n\n\n\n\n\nName\nDescription\n\n\n\n\nDebugger\nStep through one or more sims and pause or raise an exception when a condition is met\n\n\nProfile\nClass to profile the performance of a simulation\n\n\n\n\n\ndebugtools.Debugger(*args, func, skip=None, verbose=True, die=True, run=False)\nStep through one or more sims and pause or raise an exception when a condition is met\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nthe sim or sims to step through\n()\n\n\nfunc\nfunc / str\nthe function to run on the sims (or can use a built-in one, e.g. ‘equal’)\nrequired\n\n\nskip\nlist\nif provided, additional object names/types to skip (not check)\nNone\n\n\nverbose\nbool\nwhether to print progress during the run\nTrue\n\n\ndie\nbool\nwhether to raise an exception if the condition is met; alternatively ‘pause’ will pause execution, and False will just print\nTrue\n\n\nrun\nbool\nwhether to run immediately\nFalse\n\n\n\nExamples:\n## Example 1: Identical sims are identical\nimport starsim as ss\n\ns1 = ss.Sim(pars=dict(diseases='sis', networks='random'), n_agents=250)\ns2 = s1.copy()\ns3 = s1.copy()\ndb = ss.Debugger(s1, s2, s3, func='equal')\ndb.run()\n\n## Example 2: Pause when sim results diverge\nimport sciris as sc\nimport starsim as ss\n\n# Set up the sims\npars = dict(networks='random', n_agents=1000, verbose=0)\nsis1 = ss.SIS(beta=0.050)\nsis2 = ss.SIS(beta=0.051) # Very slightly more\ns1 = ss.Sim(pars, diseases=sis1)\ns2 = ss.Sim(pars, diseases=sis2)\n\n# Run the debugger\ndb = ss.Debugger(s1, s2, func='equal_results', die='pause')\ndb.run()\n\n# Show non-matching results\nsc.heading('Differing results')\ndf = db.results[-1].df\ndf = df[~df['equal']]\ndf.disp()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nequal\nRun all other tests\n\n\nequal_check\nCheck if equality is false, and print a message or die\n\n\nequal_dists\nCheck if the dists are equal\n\n\nequal_pars\nCheck if SimPars are equal\n\n\nequal_people\nCheck if people are equal\n\n\n\n\n\ndebugtools.Debugger.equal(*sims)\nRun all other tests\n\n\n\ndebugtools.Debugger.equal_check(e, which)\nCheck if equality is false, and print a message or die\n\n\n\ndebugtools.Debugger.equal_dists(*sims)\nCheck if the dists are equal\n\n\n\ndebugtools.Debugger.equal_pars(*sims, skip='label')\nCheck if SimPars are equal\n\n\n\ndebugtools.Debugger.equal_people(*sims)\nCheck if people are equal\n\n\n\n\n\ndebugtools.Profile(\n    sim,\n    follow=None,\n    do_run=True,\n    plot=True,\n    verbose=True,\n    **kwargs,\n)\nClass to profile the performance of a simulation\nTypically invoked via sim.profile().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\nss.Sim\nthe sim to profile\nrequired\n\n\nfollow\nfunc / list\na list of functions/methods to follow in detail\nNone\n\n\ndo_run\nbool\nwhether to immediately run the sim\nTrue\n\n\nplot\nbool\nwhether to plot time spent per module step\nTrue\n\n\n**kwargs\ndict\npassed to sc.profile()\n{}\n\n\n\nExample:\nimport starsim as ss\n\nnet = ss.RandomNet()\nsis = ss.SIS()\nsim = ss.Sim(networks=net, diseases=sis)\nprof = sim.profile(follow=[net.add_pairs, sis.infect])\nprof.disp()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndisp\nSame as sc.profile.disp(), but skip the run function by default\n\n\nplot_cpu\nShortcut to sim.loop.plot_cpu()\n\n\nprofile_init\nHandle sim init – both run it and profile it\n\n\nrun\nProfile the performance of the simulation\n\n\n\n\n\ndebugtools.Profile.disp(bytime=1, maxentries=10, skiprun=True)\nSame as sc.profile.disp(), but skip the run function by default\n\n\n\ndebugtools.Profile.plot_cpu()\nShortcut to sim.loop.plot_cpu()\n\n\n\ndebugtools.Profile.profile_init()\nHandle sim init – both run it and profile it\n\n\n\ndebugtools.Profile.run(disp=None)\nProfile the performance of the simulation\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_requires\nCheck that the module’s requirements (of other modules) are met\n\n\ncheck_version\nCheck the expected Starsim version with the one actually installed. The expected\n\n\nmetadata\nStore metadata; like sc.metadata(), but optimized for speed\n\n\nmock_module\nCreate a minimal mock “Module” object\n\n\nmock_people\nCreate a minimal mock “People” object\n\n\nmock_sim\nCreate a minimal mock “Sim” object to initialize objects that require it\n\n\nmock_time\nCreate a minimal mock “Time” object\n\n\n\n\n\ndebugtools.check_requires(sim, requires, *args)\nCheck that the module’s requirements (of other modules) are met\n\n\n\ndebugtools.check_version(expected, die=False, warn=True)\nCheck the expected Starsim version with the one actually installed. The expected version string may optionally start with ‘&gt;=’ or ‘&lt;=’ (== is implied otherwise), but other operators (e.g. ~=) are not supported. Note that ‘&gt;’ and ‘&lt;’ are interpreted to mean ‘&gt;=’ and ‘&lt;=’; ‘&gt;’ and ‘&lt;’ are not supported.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\nstr\nexpected version information\nrequired\n\n\ndie\nbool\nwhether or not to raise an exception if the check fails\nFalse\n\n\nwarn\nbool\nwhether to raise a warning if the check fails\nTrue\n\n\n\nExample:\nss.check_version('&gt;=3.0.0', die=True) # Will raise an exception if an older version is used\n\n\n\n\ndebugtools.metadata(comments=None)\nStore metadata; like sc.metadata(), but optimized for speed\n\n\n\ndebugtools.mock_module(dur=10, **kwargs)\nCreate a minimal mock “Module” object\n\n\n\ndebugtools.mock_people(n_agents=100)\nCreate a minimal mock “People” object\n\n\n\ndebugtools.mock_sim(n_agents=100, **kwargs)\nCreate a minimal mock “Sim” object to initialize objects that require it\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_agents\nint\nthe number of agents to create\n100\n\n\n**kwargs\ndict\npassed to ss.mock_time()\n{}\n\n\n\n\n\n\n\ndebugtools.mock_time(dt=1.0, dur=10, start=2000)\nCreate a minimal mock “Time” object",
    "crumbs": [
      "**Utilities**",
      "debugtools"
    ]
  },
  {
    "objectID": "api/debugtools.html#classes",
    "href": "api/debugtools.html#classes",
    "title": "debugtools",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDebugger\nStep through one or more sims and pause or raise an exception when a condition is met\n\n\nProfile\nClass to profile the performance of a simulation\n\n\n\n\n\ndebugtools.Debugger(*args, func, skip=None, verbose=True, die=True, run=False)\nStep through one or more sims and pause or raise an exception when a condition is met\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nlist\nthe sim or sims to step through\n()\n\n\nfunc\nfunc / str\nthe function to run on the sims (or can use a built-in one, e.g. ‘equal’)\nrequired\n\n\nskip\nlist\nif provided, additional object names/types to skip (not check)\nNone\n\n\nverbose\nbool\nwhether to print progress during the run\nTrue\n\n\ndie\nbool\nwhether to raise an exception if the condition is met; alternatively ‘pause’ will pause execution, and False will just print\nTrue\n\n\nrun\nbool\nwhether to run immediately\nFalse\n\n\n\nExamples:\n## Example 1: Identical sims are identical\nimport starsim as ss\n\ns1 = ss.Sim(pars=dict(diseases='sis', networks='random'), n_agents=250)\ns2 = s1.copy()\ns3 = s1.copy()\ndb = ss.Debugger(s1, s2, s3, func='equal')\ndb.run()\n\n## Example 2: Pause when sim results diverge\nimport sciris as sc\nimport starsim as ss\n\n# Set up the sims\npars = dict(networks='random', n_agents=1000, verbose=0)\nsis1 = ss.SIS(beta=0.050)\nsis2 = ss.SIS(beta=0.051) # Very slightly more\ns1 = ss.Sim(pars, diseases=sis1)\ns2 = ss.Sim(pars, diseases=sis2)\n\n# Run the debugger\ndb = ss.Debugger(s1, s2, func='equal_results', die='pause')\ndb.run()\n\n# Show non-matching results\nsc.heading('Differing results')\ndf = db.results[-1].df\ndf = df[~df['equal']]\ndf.disp()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nequal\nRun all other tests\n\n\nequal_check\nCheck if equality is false, and print a message or die\n\n\nequal_dists\nCheck if the dists are equal\n\n\nequal_pars\nCheck if SimPars are equal\n\n\nequal_people\nCheck if people are equal\n\n\n\n\n\ndebugtools.Debugger.equal(*sims)\nRun all other tests\n\n\n\ndebugtools.Debugger.equal_check(e, which)\nCheck if equality is false, and print a message or die\n\n\n\ndebugtools.Debugger.equal_dists(*sims)\nCheck if the dists are equal\n\n\n\ndebugtools.Debugger.equal_pars(*sims, skip='label')\nCheck if SimPars are equal\n\n\n\ndebugtools.Debugger.equal_people(*sims)\nCheck if people are equal\n\n\n\n\n\ndebugtools.Profile(\n    sim,\n    follow=None,\n    do_run=True,\n    plot=True,\n    verbose=True,\n    **kwargs,\n)\nClass to profile the performance of a simulation\nTypically invoked via sim.profile().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim\nss.Sim\nthe sim to profile\nrequired\n\n\nfollow\nfunc / list\na list of functions/methods to follow in detail\nNone\n\n\ndo_run\nbool\nwhether to immediately run the sim\nTrue\n\n\nplot\nbool\nwhether to plot time spent per module step\nTrue\n\n\n**kwargs\ndict\npassed to sc.profile()\n{}\n\n\n\nExample:\nimport starsim as ss\n\nnet = ss.RandomNet()\nsis = ss.SIS()\nsim = ss.Sim(networks=net, diseases=sis)\nprof = sim.profile(follow=[net.add_pairs, sis.infect])\nprof.disp()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndisp\nSame as sc.profile.disp(), but skip the run function by default\n\n\nplot_cpu\nShortcut to sim.loop.plot_cpu()\n\n\nprofile_init\nHandle sim init – both run it and profile it\n\n\nrun\nProfile the performance of the simulation\n\n\n\n\n\ndebugtools.Profile.disp(bytime=1, maxentries=10, skiprun=True)\nSame as sc.profile.disp(), but skip the run function by default\n\n\n\ndebugtools.Profile.plot_cpu()\nShortcut to sim.loop.plot_cpu()\n\n\n\ndebugtools.Profile.profile_init()\nHandle sim init – both run it and profile it\n\n\n\ndebugtools.Profile.run(disp=None)\nProfile the performance of the simulation",
    "crumbs": [
      "**Utilities**",
      "debugtools"
    ]
  },
  {
    "objectID": "api/debugtools.html#functions",
    "href": "api/debugtools.html#functions",
    "title": "debugtools",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_requires\nCheck that the module’s requirements (of other modules) are met\n\n\ncheck_version\nCheck the expected Starsim version with the one actually installed. The expected\n\n\nmetadata\nStore metadata; like sc.metadata(), but optimized for speed\n\n\nmock_module\nCreate a minimal mock “Module” object\n\n\nmock_people\nCreate a minimal mock “People” object\n\n\nmock_sim\nCreate a minimal mock “Sim” object to initialize objects that require it\n\n\nmock_time\nCreate a minimal mock “Time” object\n\n\n\n\n\ndebugtools.check_requires(sim, requires, *args)\nCheck that the module’s requirements (of other modules) are met\n\n\n\ndebugtools.check_version(expected, die=False, warn=True)\nCheck the expected Starsim version with the one actually installed. The expected version string may optionally start with ‘&gt;=’ or ‘&lt;=’ (== is implied otherwise), but other operators (e.g. ~=) are not supported. Note that ‘&gt;’ and ‘&lt;’ are interpreted to mean ‘&gt;=’ and ‘&lt;=’; ‘&gt;’ and ‘&lt;’ are not supported.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\nstr\nexpected version information\nrequired\n\n\ndie\nbool\nwhether or not to raise an exception if the check fails\nFalse\n\n\nwarn\nbool\nwhether to raise a warning if the check fails\nTrue\n\n\n\nExample:\nss.check_version('&gt;=3.0.0', die=True) # Will raise an exception if an older version is used\n\n\n\n\ndebugtools.metadata(comments=None)\nStore metadata; like sc.metadata(), but optimized for speed\n\n\n\ndebugtools.mock_module(dur=10, **kwargs)\nCreate a minimal mock “Module” object\n\n\n\ndebugtools.mock_people(n_agents=100)\nCreate a minimal mock “People” object\n\n\n\ndebugtools.mock_sim(n_agents=100, **kwargs)\nCreate a minimal mock “Sim” object to initialize objects that require it\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_agents\nint\nthe number of agents to create\n100\n\n\n**kwargs\ndict\npassed to ss.mock_time()\n{}\n\n\n\n\n\n\n\ndebugtools.mock_time(dt=1.0, dur=10, start=2000)\nCreate a minimal mock “Time” object",
    "crumbs": [
      "**Utilities**",
      "debugtools"
    ]
  },
  {
    "objectID": "api/demographics.html",
    "href": "api/demographics.html",
    "title": "demographics",
    "section": "",
    "text": "demographics\nDefine pregnancy, deaths, migration, etc.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBirths\nCreate births based on rates, rather than based on pregnancy.\n\n\nDeaths\nConfigure disease-independent “background” deaths.\n\n\nDemographics\nA demographic module typically handles births/deaths/migration and takes\n\n\nPregnancy\nCreate births via pregnancies for each agent.\n\n\nPregnancyPars\nPregnancy parameters and default values\n\n\n\n\n\ndemographics.Births(\n    pars=None,\n    birth_rate=_,\n    rel_birth=_,\n    rate_units=_,\n    metadata=None,\n    **kwargs,\n)\nCreate births based on rates, rather than based on pregnancy.\nBirths are generated using population-level birth rates that can vary by year. The number of births per timestep is determined by applying the birth rate to the current population size.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbirth_rate\nfloat / rate / dataframe\nvalue for birth rate, or birth rate data\n_\n\n\nrel_birth\nfloat\nconstant used to scale all birth rates\n_\n\n\nrate_units\nfloat\nunits for birth rates (default assumes per 1000)\n_\n\n\nmetadata\ndict\ndict with data column mappings for birth rate data (if birth_rate is a dataframe)\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_births\nAdd n_new births to each state in the sim\n\n\nget_births\nExtract the right birth rates to use and translate it into a number of people to add.\n\n\ninit_pre\nInitialize with sim information\n\n\nstandardize_birth_data\nStandardize/validate birth rates - handled in an external file due to shared functionality\n\n\nupdate_results\nCalculate new births and crude birth rate\n\n\n\n\n\ndemographics.Births.add_births()\nAdd n_new births to each state in the sim\n\n\n\ndemographics.Births.get_births()\nExtract the right birth rates to use and translate it into a number of people to add.\n\n\n\ndemographics.Births.init_pre(sim)\nInitialize with sim information\n\n\n\ndemographics.Births.standardize_birth_data()\nStandardize/validate birth rates - handled in an external file due to shared functionality\n\n\n\ndemographics.Births.update_results()\nCalculate new births and crude birth rate\n\n\n\n\n\ndemographics.Deaths(\n    pars=None,\n    rel_death=_,\n    death_rate=_,\n    rate_units=_,\n    metadata=None,\n    **kwargs,\n)\nConfigure disease-independent “background” deaths.\nThe probability of death for each agent on each timestep is determined by the death_rate parameter and the time step. The default value of this parameter is 0.01, indicating that all agents will face a 1% chance of death per year.\nHowever, this function can be made more realistic by using a dataframe for the death_rate parameter, to allow it to vary by year, sex, and age. The separate ‘metadata’ argument can be used to configure the details of the input datafile.\nAlternatively, it is possible to override the death_rate parameter with a bernoulli distribution containing a constant value of function of your own design.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\n\ndict with arguments including: rel_death: constant used to scale all death rates death_rate: float, dict, or pandas dataframe/series containing mortality data rate_units: units for death rates (see in-line comment on par dict below)\nNone\n\n\nmetadata\n\ndata about the data contained within the data input. “data_cols” is is a dictionary mapping standard keys, like “year” to the corresponding column name in data. Similar for “sex_keys”.\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nmake_p_death\nTake in the module, sim, and uids, and return the probability of death for each UID on this timestep\n\n\nstandardize_death_data\nStandardize/validate death rates - handled in an external file due to shared functionality\n\n\nstep\nSelect people to die\n\n\n\n\n\ndemographics.Deaths.make_p_death()\nTake in the module, sim, and uids, and return the probability of death for each UID on this timestep\n\n\n\ndemographics.Deaths.standardize_death_data()\nStandardize/validate death rates - handled in an external file due to shared functionality\n\n\n\ndemographics.Deaths.step()\nSelect people to die\n\n\n\n\n\ndemographics.Demographics(name=None, label=None, **kwargs)\nA demographic module typically handles births/deaths/migration and takes place at the start of the timestep, before networks are updated and before any disease modules are executed.\n\n\n\ndemographics.Pregnancy(\n    pars=None,\n    fertility_rate=_,\n    rel_fertility=_,\n    p_infertile=_,\n    min_age=_,\n    max_age=_,\n    rate_units=_,\n    dur_pregnancy=_,\n    dur_breastfeed=_,\n    p_breastfeed=_,\n    rr_ptb=_,\n    rr_ptb_age=_,\n    p_maternal_death=_,\n    p_survive_maternal_death=_,\n    sex_ratio=_,\n    burnin=_,\n    slot_scale=_,\n    min_slots=_,\n    trimesters=_,\n    metadata=None,\n    **kwargs,\n)\nCreate births via pregnancies for each agent.\nThis module models conception, pregnancy, and birth at the individual level using age-specific fertility rates. Supports prenatal and postnatal transmission networks, maternal and neonatal mortality, and burn-in of existing pregnancies at simulation start.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfertility_rate\nfloat / dataframe\nvalue or dataframe with age-specific fertility rates\n_\n\n\nrel_fertility\nfloat\nconstant used to scale all fertility rates\n_\n\n\np_infertile\nbernoulli\nprobability of primary infertility (default 0)\n_\n\n\nmin_age\nfloat\nminimum age for pregnancy (default 15)\n_\n\n\nmax_age\nfloat\nmaximum age for pregnancy (default 50)\n_\n\n\nrate_units\nfloat\nunits for fertility rates (default assumes per 1000)\n_\n\n\ndur_pregnancy\nfloat / dur\nduration of pregnancy (default: drawn from choice distribution, 32-42 weeks)\n_\n\n\ndur_breastfeed\nfloat / dur\nduration of breastfeeding (default: drawn from lognormal distribution, 9±6 months)\n_\n\n\nrr_ptb\nfloat\nbase relative risk of pre-term birth (default normal with mean 1, std 0.1)\n_\n\n\nrr_ptb_age\narray\nrelative risk of pre-term birth by maternal age (default [[18,35,100],[1.2,1,1.2]])\n_\n\n\np_maternal_death\nfloat\nprobability of maternal death during pregnancy (default 0.0)\n_\n\n\np_survive_maternal_death\nfloat\nprobability that an unborn agent will survive death of the mother (default 0)\n_\n\n\nsex_ratio\nfloat\nprobability of female births (default 0.5)\n_\n\n\nburnin\nbool\nwhether to seed pregnancies from before simulation start (default true)\n_\n\n\nslot_scale\nfloat\nscale factor for assigning slots to newborn agents (default 5)\n_\n\n\nmin_slots\nint\nminimum number of slots for newborn agents (default 100)\n_\n\n\ntrimesters\nlist\nlist of durations defining the end of each trimester\n_\n\n\nmetadata\ndict\ndata column mappings for fertility rate data if a dataframe is supplied\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndur_gestation\nReturn duration of gestation for currently-pregnant women in years\n\n\ndur_gestation_at_birth\nReturn duration of gestation at birth for agents born during the simulation\n\n\nfecund\nDefined as women of childbearing age\n\n\nfertile\nDefined as women of childbearing age who are not infertile. Includes women who may be pregnant\n\n\nnulliparous\nWomen of childbearing age who have never been pregnant\n\n\nsusceptible\nDefined as fertile women of childbearing age who are not pregnant, and so are susceptible to conception\n\n\ntri1_uids\nReturn UIDs of those in their first trimester\n\n\ntri2_uids\nReturn UIDs of those in their second trimester\n\n\ntri3_uids\nReturn UIDs of those in their third trimester\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_asfr\nComputes age-specific fertility rates (ASFR). Since this is calculated each timestep,\n\n\ninit_results\nInitialize results. By default, this includes:\n\n\nmake_embryos\nMake newly-conceived agents. This method calls two helper methods, which grow the population\n\n\nmake_p_conceive\nTake in the module, sim, and uids, and return the conception probability for each UID on this timestep\n\n\nmake_pregnancies\nMake pregnancies, assign durations, and determine multiples\n\n\nprocess_delivery\nHandle delivery by updating all states for the mother. This method also transfers\n\n\nprocess_maternal_deaths\nIf any pregnant mothers die, we also process the death of the unborn agent.\n\n\nprocess_newborns\nSet states for newborn agents\n\n\nprocess_prenatal_deaths\nIf any deaths occur in unborn agents, we handle changes to pregnancy and record as a miscarriage\n\n\nprogress_pregnancies\nUpdate pregnant women. The method can be enhanced by derived classes that add logic\n\n\nselect_conceivers\nSelect people to make pregnant\n\n\nset_breastfeeding\nSet breastfeeding durations for new mothers. This method could be extended to\n\n\nset_ptb\nUpdate relative risk of pre-term birth\n\n\nset_rel_sus\nSet relative susceptibility to pregnancy. Note that rel_sus isn’t used in this module,\n\n\nstandardize_fertility_data\nStandardize/validate fertility rates\n\n\nstep\nPerform all updates except for deaths, which are handled in finish_step\n\n\nstep_die\nWipe dates and states following death\n\n\nupdate_maternal_deaths\nCheck for maternal deaths\n\n\nupdates_pre\nThis runs prior at the beginning of each timestep, prior to calculating pregnancy exposure,\n\n\n\n\n\ndemographics.Pregnancy.compute_asfr()\nComputes age-specific fertility rates (ASFR). Since this is calculated each timestep, the annualized results should compute the sum.\n\n\n\ndemographics.Pregnancy.init_results()\nInitialize results. By default, this includes: - pregnancies: number of new pregnancies on each timestep - births: number of new births on each timestep - cbr: crude birth rate on each timestep - tfr: total fertility rate on each timestep - The number of people who are fecund, (in)fertile, susceptible, postpartum, pregnant, infertile, breastfeeding\n\n\n\ndemographics.Pregnancy.make_embryos(conceive_uids, embryo_counts=None)\nMake newly-conceived agents. This method calls two helper methods, which grow the population and set the states for the newborn agents.\n\n\n\ndemographics.Pregnancy.make_p_conceive(filter_uids=None)\nTake in the module, sim, and uids, and return the conception probability for each UID on this timestep\n\n\n\ndemographics.Pregnancy.make_pregnancies(uids)\nMake pregnancies, assign durations, and determine multiples\n\n\n\ndemographics.Pregnancy.process_delivery(mother_uids, newborn_uids)\nHandle delivery by updating all states for the mother. This method also transfers recorded information stored with the mother to the newborn. During pregnancy, gestational age is tracked with the mother; at birth, this value is transferred to the newborn agent before being reset for the mother. Likewise, during pregnancy, the child UID is stored with the mother; at birth, this value is removed from the mother, although newborn agents can still be linked to the mother via the parent state.\n\n\n\ndemographics.Pregnancy.process_maternal_deaths(death_uids)\nIf any pregnant mothers die, we also process the death of the unborn agent. Default probability is set to 1 meaning we assume that unborn children do not survive.\n\n\n\ndemographics.Pregnancy.process_newborns(uids)\nSet states for newborn agents\n\n\n\ndemographics.Pregnancy.process_prenatal_deaths(death_uids)\nIf any deaths occur in unborn agents, we handle changes to pregnancy and record as a miscarriage\n\n\n\ndemographics.Pregnancy.progress_pregnancies()\nUpdate pregnant women. The method can be enhanced by derived classes that add logic for miscarriage, termination, maternal death, etc.\n\n\n\ndemographics.Pregnancy.select_conceivers(uids=None)\nSelect people to make pregnant\n\n\n\ndemographics.Pregnancy.set_breastfeeding(mother_uids, newborn_uids)\nSet breastfeeding durations for new mothers. This method could be extended to store duration of exclusive breastfeeding, partial breastfeeding, etc, and these properties could be stored with the infant for tracking other health outcomes.\n\n\n\ndemographics.Pregnancy.set_ptb()\nUpdate relative risk of pre-term birth\n\n\n\ndemographics.Pregnancy.set_rel_sus()\nSet relative susceptibility to pregnancy. Note that rel_sus isn’t used in this module, but it’s a key ingredient for derived modules that compute pregnancies based on exposure.\n\n\n\ndemographics.Pregnancy.standardize_fertility_data()\nStandardize/validate fertility rates\n\n\n\ndemographics.Pregnancy.step()\nPerform all updates except for deaths, which are handled in finish_step\n\n\n\ndemographics.Pregnancy.step_die(uids)\nWipe dates and states following death\n\n\n\ndemographics.Pregnancy.update_maternal_deaths()\nCheck for maternal deaths\n\n\n\ndemographics.Pregnancy.updates_pre(uids=None, upper_age=None)\nThis runs prior at the beginning of each timestep, prior to calculating pregnancy exposure, advancing pregnancies, adding new pregnancies, or determing delivery outcomes. Here we make any updates that affect the risk of pregnancy or pre-term birth on this timestep. We also set the baseline values for newborn agents.\n\n\n\n\n\ndemographics.PregnancyPars(**kwargs)\nPregnancy parameters and default values",
    "crumbs": [
      "**Modules**",
      "demographics"
    ]
  },
  {
    "objectID": "api/demographics.html#classes",
    "href": "api/demographics.html#classes",
    "title": "demographics",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBirths\nCreate births based on rates, rather than based on pregnancy.\n\n\nDeaths\nConfigure disease-independent “background” deaths.\n\n\nDemographics\nA demographic module typically handles births/deaths/migration and takes\n\n\nPregnancy\nCreate births via pregnancies for each agent.\n\n\nPregnancyPars\nPregnancy parameters and default values\n\n\n\n\n\ndemographics.Births(\n    pars=None,\n    birth_rate=_,\n    rel_birth=_,\n    rate_units=_,\n    metadata=None,\n    **kwargs,\n)\nCreate births based on rates, rather than based on pregnancy.\nBirths are generated using population-level birth rates that can vary by year. The number of births per timestep is determined by applying the birth rate to the current population size.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbirth_rate\nfloat / rate / dataframe\nvalue for birth rate, or birth rate data\n_\n\n\nrel_birth\nfloat\nconstant used to scale all birth rates\n_\n\n\nrate_units\nfloat\nunits for birth rates (default assumes per 1000)\n_\n\n\nmetadata\ndict\ndict with data column mappings for birth rate data (if birth_rate is a dataframe)\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_births\nAdd n_new births to each state in the sim\n\n\nget_births\nExtract the right birth rates to use and translate it into a number of people to add.\n\n\ninit_pre\nInitialize with sim information\n\n\nstandardize_birth_data\nStandardize/validate birth rates - handled in an external file due to shared functionality\n\n\nupdate_results\nCalculate new births and crude birth rate\n\n\n\n\n\ndemographics.Births.add_births()\nAdd n_new births to each state in the sim\n\n\n\ndemographics.Births.get_births()\nExtract the right birth rates to use and translate it into a number of people to add.\n\n\n\ndemographics.Births.init_pre(sim)\nInitialize with sim information\n\n\n\ndemographics.Births.standardize_birth_data()\nStandardize/validate birth rates - handled in an external file due to shared functionality\n\n\n\ndemographics.Births.update_results()\nCalculate new births and crude birth rate\n\n\n\n\n\ndemographics.Deaths(\n    pars=None,\n    rel_death=_,\n    death_rate=_,\n    rate_units=_,\n    metadata=None,\n    **kwargs,\n)\nConfigure disease-independent “background” deaths.\nThe probability of death for each agent on each timestep is determined by the death_rate parameter and the time step. The default value of this parameter is 0.01, indicating that all agents will face a 1% chance of death per year.\nHowever, this function can be made more realistic by using a dataframe for the death_rate parameter, to allow it to vary by year, sex, and age. The separate ‘metadata’ argument can be used to configure the details of the input datafile.\nAlternatively, it is possible to override the death_rate parameter with a bernoulli distribution containing a constant value of function of your own design.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npars\n\ndict with arguments including: rel_death: constant used to scale all death rates death_rate: float, dict, or pandas dataframe/series containing mortality data rate_units: units for death rates (see in-line comment on par dict below)\nNone\n\n\nmetadata\n\ndata about the data contained within the data input. “data_cols” is is a dictionary mapping standard keys, like “year” to the corresponding column name in data. Similar for “sex_keys”.\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nmake_p_death\nTake in the module, sim, and uids, and return the probability of death for each UID on this timestep\n\n\nstandardize_death_data\nStandardize/validate death rates - handled in an external file due to shared functionality\n\n\nstep\nSelect people to die\n\n\n\n\n\ndemographics.Deaths.make_p_death()\nTake in the module, sim, and uids, and return the probability of death for each UID on this timestep\n\n\n\ndemographics.Deaths.standardize_death_data()\nStandardize/validate death rates - handled in an external file due to shared functionality\n\n\n\ndemographics.Deaths.step()\nSelect people to die\n\n\n\n\n\ndemographics.Demographics(name=None, label=None, **kwargs)\nA demographic module typically handles births/deaths/migration and takes place at the start of the timestep, before networks are updated and before any disease modules are executed.\n\n\n\ndemographics.Pregnancy(\n    pars=None,\n    fertility_rate=_,\n    rel_fertility=_,\n    p_infertile=_,\n    min_age=_,\n    max_age=_,\n    rate_units=_,\n    dur_pregnancy=_,\n    dur_breastfeed=_,\n    p_breastfeed=_,\n    rr_ptb=_,\n    rr_ptb_age=_,\n    p_maternal_death=_,\n    p_survive_maternal_death=_,\n    sex_ratio=_,\n    burnin=_,\n    slot_scale=_,\n    min_slots=_,\n    trimesters=_,\n    metadata=None,\n    **kwargs,\n)\nCreate births via pregnancies for each agent.\nThis module models conception, pregnancy, and birth at the individual level using age-specific fertility rates. Supports prenatal and postnatal transmission networks, maternal and neonatal mortality, and burn-in of existing pregnancies at simulation start.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfertility_rate\nfloat / dataframe\nvalue or dataframe with age-specific fertility rates\n_\n\n\nrel_fertility\nfloat\nconstant used to scale all fertility rates\n_\n\n\np_infertile\nbernoulli\nprobability of primary infertility (default 0)\n_\n\n\nmin_age\nfloat\nminimum age for pregnancy (default 15)\n_\n\n\nmax_age\nfloat\nmaximum age for pregnancy (default 50)\n_\n\n\nrate_units\nfloat\nunits for fertility rates (default assumes per 1000)\n_\n\n\ndur_pregnancy\nfloat / dur\nduration of pregnancy (default: drawn from choice distribution, 32-42 weeks)\n_\n\n\ndur_breastfeed\nfloat / dur\nduration of breastfeeding (default: drawn from lognormal distribution, 9±6 months)\n_\n\n\nrr_ptb\nfloat\nbase relative risk of pre-term birth (default normal with mean 1, std 0.1)\n_\n\n\nrr_ptb_age\narray\nrelative risk of pre-term birth by maternal age (default [[18,35,100],[1.2,1,1.2]])\n_\n\n\np_maternal_death\nfloat\nprobability of maternal death during pregnancy (default 0.0)\n_\n\n\np_survive_maternal_death\nfloat\nprobability that an unborn agent will survive death of the mother (default 0)\n_\n\n\nsex_ratio\nfloat\nprobability of female births (default 0.5)\n_\n\n\nburnin\nbool\nwhether to seed pregnancies from before simulation start (default true)\n_\n\n\nslot_scale\nfloat\nscale factor for assigning slots to newborn agents (default 5)\n_\n\n\nmin_slots\nint\nminimum number of slots for newborn agents (default 100)\n_\n\n\ntrimesters\nlist\nlist of durations defining the end of each trimester\n_\n\n\nmetadata\ndict\ndata column mappings for fertility rate data if a dataframe is supplied\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndur_gestation\nReturn duration of gestation for currently-pregnant women in years\n\n\ndur_gestation_at_birth\nReturn duration of gestation at birth for agents born during the simulation\n\n\nfecund\nDefined as women of childbearing age\n\n\nfertile\nDefined as women of childbearing age who are not infertile. Includes women who may be pregnant\n\n\nnulliparous\nWomen of childbearing age who have never been pregnant\n\n\nsusceptible\nDefined as fertile women of childbearing age who are not pregnant, and so are susceptible to conception\n\n\ntri1_uids\nReturn UIDs of those in their first trimester\n\n\ntri2_uids\nReturn UIDs of those in their second trimester\n\n\ntri3_uids\nReturn UIDs of those in their third trimester\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_asfr\nComputes age-specific fertility rates (ASFR). Since this is calculated each timestep,\n\n\ninit_results\nInitialize results. By default, this includes:\n\n\nmake_embryos\nMake newly-conceived agents. This method calls two helper methods, which grow the population\n\n\nmake_p_conceive\nTake in the module, sim, and uids, and return the conception probability for each UID on this timestep\n\n\nmake_pregnancies\nMake pregnancies, assign durations, and determine multiples\n\n\nprocess_delivery\nHandle delivery by updating all states for the mother. This method also transfers\n\n\nprocess_maternal_deaths\nIf any pregnant mothers die, we also process the death of the unborn agent.\n\n\nprocess_newborns\nSet states for newborn agents\n\n\nprocess_prenatal_deaths\nIf any deaths occur in unborn agents, we handle changes to pregnancy and record as a miscarriage\n\n\nprogress_pregnancies\nUpdate pregnant women. The method can be enhanced by derived classes that add logic\n\n\nselect_conceivers\nSelect people to make pregnant\n\n\nset_breastfeeding\nSet breastfeeding durations for new mothers. This method could be extended to\n\n\nset_ptb\nUpdate relative risk of pre-term birth\n\n\nset_rel_sus\nSet relative susceptibility to pregnancy. Note that rel_sus isn’t used in this module,\n\n\nstandardize_fertility_data\nStandardize/validate fertility rates\n\n\nstep\nPerform all updates except for deaths, which are handled in finish_step\n\n\nstep_die\nWipe dates and states following death\n\n\nupdate_maternal_deaths\nCheck for maternal deaths\n\n\nupdates_pre\nThis runs prior at the beginning of each timestep, prior to calculating pregnancy exposure,\n\n\n\n\n\ndemographics.Pregnancy.compute_asfr()\nComputes age-specific fertility rates (ASFR). Since this is calculated each timestep, the annualized results should compute the sum.\n\n\n\ndemographics.Pregnancy.init_results()\nInitialize results. By default, this includes: - pregnancies: number of new pregnancies on each timestep - births: number of new births on each timestep - cbr: crude birth rate on each timestep - tfr: total fertility rate on each timestep - The number of people who are fecund, (in)fertile, susceptible, postpartum, pregnant, infertile, breastfeeding\n\n\n\ndemographics.Pregnancy.make_embryos(conceive_uids, embryo_counts=None)\nMake newly-conceived agents. This method calls two helper methods, which grow the population and set the states for the newborn agents.\n\n\n\ndemographics.Pregnancy.make_p_conceive(filter_uids=None)\nTake in the module, sim, and uids, and return the conception probability for each UID on this timestep\n\n\n\ndemographics.Pregnancy.make_pregnancies(uids)\nMake pregnancies, assign durations, and determine multiples\n\n\n\ndemographics.Pregnancy.process_delivery(mother_uids, newborn_uids)\nHandle delivery by updating all states for the mother. This method also transfers recorded information stored with the mother to the newborn. During pregnancy, gestational age is tracked with the mother; at birth, this value is transferred to the newborn agent before being reset for the mother. Likewise, during pregnancy, the child UID is stored with the mother; at birth, this value is removed from the mother, although newborn agents can still be linked to the mother via the parent state.\n\n\n\ndemographics.Pregnancy.process_maternal_deaths(death_uids)\nIf any pregnant mothers die, we also process the death of the unborn agent. Default probability is set to 1 meaning we assume that unborn children do not survive.\n\n\n\ndemographics.Pregnancy.process_newborns(uids)\nSet states for newborn agents\n\n\n\ndemographics.Pregnancy.process_prenatal_deaths(death_uids)\nIf any deaths occur in unborn agents, we handle changes to pregnancy and record as a miscarriage\n\n\n\ndemographics.Pregnancy.progress_pregnancies()\nUpdate pregnant women. The method can be enhanced by derived classes that add logic for miscarriage, termination, maternal death, etc.\n\n\n\ndemographics.Pregnancy.select_conceivers(uids=None)\nSelect people to make pregnant\n\n\n\ndemographics.Pregnancy.set_breastfeeding(mother_uids, newborn_uids)\nSet breastfeeding durations for new mothers. This method could be extended to store duration of exclusive breastfeeding, partial breastfeeding, etc, and these properties could be stored with the infant for tracking other health outcomes.\n\n\n\ndemographics.Pregnancy.set_ptb()\nUpdate relative risk of pre-term birth\n\n\n\ndemographics.Pregnancy.set_rel_sus()\nSet relative susceptibility to pregnancy. Note that rel_sus isn’t used in this module, but it’s a key ingredient for derived modules that compute pregnancies based on exposure.\n\n\n\ndemographics.Pregnancy.standardize_fertility_data()\nStandardize/validate fertility rates\n\n\n\ndemographics.Pregnancy.step()\nPerform all updates except for deaths, which are handled in finish_step\n\n\n\ndemographics.Pregnancy.step_die(uids)\nWipe dates and states following death\n\n\n\ndemographics.Pregnancy.update_maternal_deaths()\nCheck for maternal deaths\n\n\n\ndemographics.Pregnancy.updates_pre(uids=None, upper_age=None)\nThis runs prior at the beginning of each timestep, prior to calculating pregnancy exposure, advancing pregnancies, adding new pregnancies, or determing delivery outcomes. Here we make any updates that affect the risk of pregnancy or pre-term birth on this timestep. We also set the baseline values for newborn agents.\n\n\n\n\n\ndemographics.PregnancyPars(**kwargs)\nPregnancy parameters and default values",
    "crumbs": [
      "**Modules**",
      "demographics"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "API reference",
    "section": "",
    "text": "Full details on all Starsim classes and functions.\n\n\n\nanalyzers\nDefine analyzers, which are used to track variables when the sim is run.\n\n\narrays\nDefine array-handling classes, including agent states\n\n\ncalibration\nDefine the calibration class\n\n\nconnectors\nDefine connectors, which are used to mediate interactions between modules when the sim is run.\n\n\ndebugtools\nUtilities to help with debugging Starsim runs\n\n\ndemographics\nDefine pregnancy, deaths, migration, etc.\n\n\ndiseases\nBase classes for diseases\n\n\ndistributions\nDefine random-number-safe distributions.\n\n\ninterventions\nDefine interventions, which are used to modify the state of the sim during run.\n\n\nloop\nParent class for the integration loop.\n\n\nmodules\nGeneral module class – base class for diseases, interventions, etc. Also\n\n\nnetworks\nNetworks that connect people within a population\n\n\nparameters\nSet parameters\n\n\npeople\nDefines the People class and functions associated with making people\n\n\nproducts\nDefine products\n\n\nresults\nResult structures.\n\n\nrun\nUtilities for running in parallel\n\n\nsamples\nCreate a class for storing a large number of simulations.\n\n\nsettings\nDefine options for Starsim.\n\n\nsim\nDefine core Sim classes\n\n\ntime\nFunctions and classes for handling time\n\n\ntimeline\nSimulation and module timelines\n\n\nutils\nNumerical utilities and other helper functions",
    "crumbs": [
      "Home",
      "**API reference**"
    ]
  },
  {
    "objectID": "api/index.html#api-reference-1",
    "href": "api/index.html#api-reference-1",
    "title": "API reference",
    "section": "",
    "text": "Full details on all Starsim classes and functions.\n\n\n\nanalyzers\nDefine analyzers, which are used to track variables when the sim is run.\n\n\narrays\nDefine array-handling classes, including agent states\n\n\ncalibration\nDefine the calibration class\n\n\nconnectors\nDefine connectors, which are used to mediate interactions between modules when the sim is run.\n\n\ndebugtools\nUtilities to help with debugging Starsim runs\n\n\ndemographics\nDefine pregnancy, deaths, migration, etc.\n\n\ndiseases\nBase classes for diseases\n\n\ndistributions\nDefine random-number-safe distributions.\n\n\ninterventions\nDefine interventions, which are used to modify the state of the sim during run.\n\n\nloop\nParent class for the integration loop.\n\n\nmodules\nGeneral module class – base class for diseases, interventions, etc. Also\n\n\nnetworks\nNetworks that connect people within a population\n\n\nparameters\nSet parameters\n\n\npeople\nDefines the People class and functions associated with making people\n\n\nproducts\nDefine products\n\n\nresults\nResult structures.\n\n\nrun\nUtilities for running in parallel\n\n\nsamples\nCreate a class for storing a large number of simulations.\n\n\nsettings\nDefine options for Starsim.\n\n\nsim\nDefine core Sim classes\n\n\ntime\nFunctions and classes for handling time\n\n\ntimeline\nSimulation and module timelines\n\n\nutils\nNumerical utilities and other helper functions",
    "crumbs": [
      "Home",
      "**API reference**"
    ]
  },
  {
    "objectID": "api/products.html",
    "href": "api/products.html",
    "title": "products",
    "section": "",
    "text": "products\nDefine products\n\n\n\n\n\nName\nDescription\n\n\n\n\nDx\nGeneric class for diagnostics\n\n\nProduct\nGeneric product implementation\n\n\nTx\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\nVx\nVaccine product\n\n\nsimple_vx\nCreate a simple vaccine product that affects the probability of infection.\n\n\n\n\n\nproducts.Dx(df=None, hierarchy=None, *args, **kwargs)\nGeneric class for diagnostics\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminister a testing product.\n\n\n\n\n\nproducts.Dx.administer(uids, return_format='dict')\nAdminister a testing product.\nReturns:\n if return_format=='array': an array of length len(inds) with integer entries that map each person to one of the result_states\n if return_format=='dict': a dictionary keyed by result_states with values containing the indices of people classified into this state\n\n\n\n\n\nproducts.Product(name=None, label=None, **kwargs)\nGeneric product implementation\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Product.administer(uids)\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Tx(df=None, *args, **kwargs)\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Tx.administer(uids, return_format='dict')\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Vx(diseases=None, *args, **kwargs)\nVaccine product\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nApply the vaccine to the requested uids.\n\n\n\n\n\nproducts.Vx.administer(uids)\nApply the vaccine to the requested uids.\n\n\n\n\n\nproducts.simple_vx(**kwargs)\nCreate a simple vaccine product that affects the probability of infection.\nThe vaccine can be either “leaky”, in which everyone who receives the vaccine receives the same amount of protection (specified by the efficacy parameter) each time they are exposed to an infection. The alternative (leaky=False) is that the efficacy is the probability that the vaccine “takes”, in which case that person is 100% protected (and the remaining people are 0% protected).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nefficacy\nfloat\nefficacy of the vaccine (0&lt;=efficacy&lt;=1)\nrequired\n\n\ndisease\nint / str / list\nthe disease to modify (if None, modify all)\nrequired\n\n\nleaky\nbool\nsee above\nrequired",
    "crumbs": [
      "**Modules**",
      "products"
    ]
  },
  {
    "objectID": "api/products.html#classes",
    "href": "api/products.html#classes",
    "title": "products",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDx\nGeneric class for diagnostics\n\n\nProduct\nGeneric product implementation\n\n\nTx\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\nVx\nVaccine product\n\n\nsimple_vx\nCreate a simple vaccine product that affects the probability of infection.\n\n\n\n\n\nproducts.Dx(df=None, hierarchy=None, *args, **kwargs)\nGeneric class for diagnostics\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminister a testing product.\n\n\n\n\n\nproducts.Dx.administer(uids, return_format='dict')\nAdminister a testing product.\nReturns:\n if return_format=='array': an array of length len(inds) with integer entries that map each person to one of the result_states\n if return_format=='dict': a dictionary keyed by result_states with values containing the indices of people classified into this state\n\n\n\n\n\nproducts.Product(name=None, label=None, **kwargs)\nGeneric product implementation\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Product.administer(uids)\nAdminster a Product - implemented by derived classes\n\n\n\n\n\nproducts.Tx(df=None, *args, **kwargs)\nTreatment products change fundamental properties about People, including their prognoses and infectiousness.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Tx.administer(uids, return_format='dict')\nLoop over treatment states to determine those who are successfully treated and clear infection\n\n\n\n\n\nproducts.Vx(diseases=None, *args, **kwargs)\nVaccine product\n\n\n\n\n\nName\nDescription\n\n\n\n\nadminister\nApply the vaccine to the requested uids.\n\n\n\n\n\nproducts.Vx.administer(uids)\nApply the vaccine to the requested uids.\n\n\n\n\n\nproducts.simple_vx(**kwargs)\nCreate a simple vaccine product that affects the probability of infection.\nThe vaccine can be either “leaky”, in which everyone who receives the vaccine receives the same amount of protection (specified by the efficacy parameter) each time they are exposed to an infection. The alternative (leaky=False) is that the efficacy is the probability that the vaccine “takes”, in which case that person is 100% protected (and the remaining people are 0% protected).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nefficacy\nfloat\nefficacy of the vaccine (0&lt;=efficacy&lt;=1)\nrequired\n\n\ndisease\nint / str / list\nthe disease to modify (if None, modify all)\nrequired\n\n\nleaky\nbool\nsee above\nrequired",
    "crumbs": [
      "**Modules**",
      "products"
    ]
  },
  {
    "objectID": "api/settings.html",
    "href": "api/settings.html",
    "title": "settings",
    "section": "",
    "text": "settings\nDefine options for Starsim. All options should be set using set() or directly, e.g.:\nss.options(verbose=False)\n\n\n\n\n\nName\nDescription\n\n\n\n\nstyle\nSet the style in a with block.\n\n\n\n\n\nsettings.style(style=None, **kwargs)\nSet the style in a with block.\nNote: Starsim comes bundled with three fonts: Mulish (default), Raleway, and Rosario. Use font='sans-serif' to use the Matplotlib default font.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nstr\nthe style to use; if None, use current; otherwise, ‘starsim’, ‘simple’, ‘fancy’, plus all of the Matplotlib styles are options\nNone\n\n\n**kwargs\ndict\npassed to sc.options.with_style()\n{}\n\n\n\nExamples::\n# Create a plot using default Starsim styling\nwith ss.style():\n    plt.plot()\n\n# Create a plot using a built-in Matplotlib style\nwith ss.style('seaborn-v0_8-whitegrid'):\n    plt.plot()\n\n# Customize the current style\nwith ss.style(font='Rosario'):\n    plt.plot()",
    "crumbs": [
      "**Utilities**",
      "settings"
    ]
  },
  {
    "objectID": "api/settings.html#functions",
    "href": "api/settings.html#functions",
    "title": "settings",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nstyle\nSet the style in a with block.\n\n\n\n\n\nsettings.style(style=None, **kwargs)\nSet the style in a with block.\nNote: Starsim comes bundled with three fonts: Mulish (default), Raleway, and Rosario. Use font='sans-serif' to use the Matplotlib default font.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nstr\nthe style to use; if None, use current; otherwise, ‘starsim’, ‘simple’, ‘fancy’, plus all of the Matplotlib styles are options\nNone\n\n\n**kwargs\ndict\npassed to sc.options.with_style()\n{}\n\n\n\nExamples::\n# Create a plot using default Starsim styling\nwith ss.style():\n    plt.plot()\n\n# Create a plot using a built-in Matplotlib style\nwith ss.style('seaborn-v0_8-whitegrid'):\n    plt.plot()\n\n# Customize the current style\nwith ss.style(font='Rosario'):\n    plt.plot()",
    "crumbs": [
      "**Utilities**",
      "settings"
    ]
  },
  {
    "objectID": "api/time.html",
    "href": "api/time.html",
    "title": "time",
    "section": "",
    "text": "time\nFunctions and classes for handling time\nHierarchy of TimePars: TimePar # All time parameters ├── dur # All durations, units of time │ ├── days # Duration with units of days │ ├── weeks │ ├── months │ ├── years │ └── datedur # Calendar durations └── Rate # All rates, units of per (e.g. per time or per event) ├── per # Probability rates over time (e.g., death rate per year) │ ├── perday │ ├── perweek │ ├── permonth │ └── peryear ├── prob # Unitless probability (e.g., probability of death per infection) │ ├── probperday │ ├── probperweek │ ├── probpermonth │ └── probperyear └── freq # Number of events (e.g., number of acts per year) ├── freqperday ├── freqperweek ├── freqpermonth └── freqperyear\n\n\n\n\n\nName\nDescription\n\n\n\n\nDateArray\nLightweight wrapper for an array of dates\n\n\nRate\nStore a value per unit time e.g., 2 per day\n\n\nTimePar\nParent class for all TimePars – dur, Rate, etc.\n\n\ndate\nDefine a point in time, based on pd.Timestamp\n\n\ndatedur\nDate based duration e.g., if requiring a week to be 7 calendar days later\n\n\ndur\nBase class for durations\n\n\nfreq\nClass for the number of events (rather than probability) in a specified period\n\n\nper\nA per represents an instantaneous rate of an event occurring. Rates\n\n\nprob\nprob represents the probability of an event occurring during a\n\n\n\n\n\ntime.DateArray()\nLightweight wrapper for an array of dates\n\n\n\n\n\nName\nDescription\n\n\n\n\nsubdaily\nCheck if the array has sub-daily timesteps\n\n\nyears\nRepresent the dates as floating point years\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nis_\nChecks if the DateArray is comprised of ss.date objects\n\n\nto_array\nForce conversion to an array\n\n\nto_date\nConvert to ss.date\n\n\nto_float\nConvert to a float, returning a new DateArray unless inplace=True\n\n\nto_human\nReturn the most human-friendly (i.e. plotting-friendly) version of the dates,\n\n\n\n\n\ntime.DateArray.is_(which)\nChecks if the DateArray is comprised of ss.date objects\n\n\n\ntime.DateArray.to_array(*args, **kwargs)\nForce conversion to an array\n\n\n\ntime.DateArray.to_date(inplace=False, day_round=None, die=True)\nConvert to ss.date\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninplace\nbool\nwhether to modify in place\nFalse\n\n\nday_round\nbool\nwhether to round dates to the nearest day (otherwise, keep timestamp); if None, round if and only if the span of the first timestep is at least one day\nNone\n\n\ndie\nbool\nif False, then fall back to float if conversion to date fails (e.g. year 0)\nTrue\n\n\n\n\n\n\n\ntime.DateArray.to_float(inplace=False, to_numpy=False)\nConvert to a float, returning a new DateArray unless inplace=True\n\n\n\ntime.DateArray.to_human()\nReturn the most human-friendly (i.e. plotting-friendly) version of the dates, i.e. ss.date if possible, float otherwise\n\n\n\n\n\ntime.Rate(value, unit=None)\nStore a value per unit time e.g., 2 per day - self.value - the numerator (e.g., 2) - a scalar float - self.unit - the denominator (e.g., 1 day) - a dur object\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_default_dur\nSet the default duration, e.g. module.dt, so .to_prob() can be used with no input\n\n\nto_events\nSimple multiplication: calculate the number of events over the time period\n\n\nto_prob\nConvert from one time probability to another\n\n\n\n\n\ntime.Rate.set_default_dur(dur)\nSet the default duration, e.g. module.dt, so .to_prob() can be used with no input\n\n\n\ntime.Rate.to_events(dur=None)\nSimple multiplication: calculate the number of events over the time period\n\n\n\ntime.Rate.to_prob(dur=None, scale=1.0)\nConvert from one time probability to another\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndur\nss.dur\nthe duration over which to convert the probability to\nNone\n\n\nscale\nfloat\nan optional additional mutliplicative scale factor to incorporate in the calculation\n1.0\n\n\n\nExample:\np_month = ss.probpermonth(0.05)\np_year = p_month.to_prob(ss.year) # Slightly less than 0.05*12\n\n\n\n\n\n\ntime.TimePar()\nParent class for all TimePars – dur, Rate, etc.\n\n\n\n\n\nName\nDescription\n\n\n\n\nto\nConvert this TimePar to one of a different class\n\n\nto_array\nForce conversion to an array\n\n\nto_base\nClass method to convert another TimePar object to this TimePar’s base units; in most cases\n\n\n\n\n\ntime.TimePar.to(unit)\nConvert this TimePar to one of a different class\n\n\n\ntime.TimePar.to_array(*args, **kwargs)\nForce conversion to an array\n\n\n\ntime.TimePar.to_base(other)\nClass method to convert another TimePar object to this TimePar’s base units; in most cases\n\n\n\n\n\ntime.date()\nDefine a point in time, based on pd.Timestamp\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndate\nint / float / str / datetime\nAny type of date input (ints and floats will be interpreted as years)\nrequired\n\n\nallow_zero\nbool\nif True, allow a year 0 by creating a datedur instead; if False, raise an exception; if None, give a warning\nrequired\n\n\nkwargs\ndict\npassed to pd.Timestamp()\nrequired\n\n\n\nExamples:\nss.date(2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2024.75) # Returns &lt;2024-10-01&gt;\nss.date('2024-04-04') # Returns &lt;2024-04-04&gt;\nss.date(year=2024, month=4, day=4) # Returns &lt;2024-04-04&gt;\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nyears\nReturn the date as a number of years\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\narange\nConstruct an array of dates\n\n\ndisp\nShow the full object\n\n\nfrom_array\nConvert an array of float years into an array of date instances\n\n\nfrom_json\nReconstruct a date from a JSON; reverse of to_json()\n\n\nfrom_year\nConvert an int or float year to a date.\n\n\nreplace\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\nround\nRound to a given interval (by default a day\n\n\nsubdaily\nCheck if a subdaily timestep is used\n\n\nto_json\nReturns a JSON representation of the date\n\n\nto_pandas\nConvert to a standard pd.Timestamp instance\n\n\nto_year\nConvert a date to a floating-point year\n\n\n\n\n\ntime.date.arange(\n    start,\n    stop,\n    step=1.0,\n    inclusive=True,\n    day_round=None,\n    allow_zero=True,\n)\nConstruct an array of dates\nFunctions similarly to np.arange, but returns date objects\nExample usage:\n\n\n\ndate.arange(2020, 2025) array([&lt;2020.01.01&gt;, &lt;2021.01.01&gt;, &lt;2022.01.01&gt;, &lt;2023.01.01&gt;, &lt;2024.01.01&gt;, &lt;2025.01.01&gt;], dtype=object)\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nfloat / ss.date / ss.dur\nLower bound - can be a date or a numerical year\nrequired\n\n\n\nstop (float/ss.date/ss.dur): Upper bound - can be a date or a numerical year step (float/ss.dur): Assumes 1 calendar year steps by default inclusive (bool): Whether to include “stop” in the output day_round (bool): Whether to round to the nearest day (by default, True if step &gt; 1 day) allow_zero (bool): if True, allow a year 0 by creating a datedur instead; if False, raise an exception; if None, give a warning\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.disp(**kwargs)\nShow the full object\n\n\n\ntime.date.from_array(array, day_round=True, allow_zero=True, date_type=None)\nConvert an array of float years into an array of date instances\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narray\narray\nAn array of float years\nrequired\n\n\nday_round\nbool\nWhether to round to the nearest day\nTrue\n\n\nallow_zero\nbool\nif True, allow a year 0 by creating a datedur instead; if False, raise an exception; if None, give a warning\nTrue\n\n\ndate_type\ntype\nOptionally convert to a class other than ss.date (e.g. ss.datedur)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.from_json(json)\nReconstruct a date from a JSON; reverse of to_json()\n\n\n\ntime.date.from_year(year, day_round=True, allow_zero=None)\nConvert an int or float year to a date.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nyear\nfloat\nthe year to round\nrequired\n\n\nday_round\nbool\nwhether to round to the nearest day\nTrue\n\n\nallow_zero\nbool\nwhether to allow year 0 (if so, return ss.datedur instead)\nNone\n\n\n\nExamples:\nss.date.from_year(2020) # Returns &lt;2020-01-01&gt;\nss.date.from_year(2024.75) # Returns &lt;2024-10-01&gt;\n\n\n\n\ntime.date.replace(*args, **kwargs)\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\n\ntime.date.round(to='d')\nRound to a given interval (by default a day\n\n\n\ntime.date.subdaily(years)\nCheck if a subdaily timestep is used\nA date has no concept of a timestep, but add this as a convienence method since this is required by other methods (e.g. ss.date.arange()).\n\n\n\ntime.date.to_json()\nReturns a JSON representation of the date\n\n\n\ntime.date.to_pandas()\nConvert to a standard pd.Timestamp instance\n\n\n\ntime.date.to_year()\nConvert a date to a floating-point year\nExamples:\nss.date('2020-01-01').to_year() # Returns 2020.0\nss.date('2024-10-01').to_year() # Returns 2024.7486\n\n\n\n\n\ntime.datedur(*args, **kwargs)\nDate based duration e.g., if requiring a week to be 7 calendar days later\n\n\n\n\n\nName\nDescription\n\n\n\n\ndays\nShortcut to datedur.to(‘days’)\n\n\nmonths\nShortcut to datedur.to(‘months’)\n\n\nweeks\nShortcut to datedur.to(‘weeks’)\n\n\nyears\nShortcut to datedur.to(‘years’)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nround_duration\nRound a dictionary of duration values by overflowing remainders\n\n\nscale\nScale a pd.DateOffset by a factor\n\n\nto\nReturn approximate conversion into the provided quantity\n\n\nto_array\nConvert to a Numpy array (NB, different than to_numpy() which converts to fractional years\n\n\nto_dict\nConvert to a dictionary\n\n\nto_dur\nConvert to the smallest non-zero value, e.g. ss.datedur(years=1, days=10).to_dur() = ss.days(375)\n\n\n\n\n\ntime.datedur.round_duration(vals=None, **kwargs)\nRound a dictionary of duration values by overflowing remainders\nThe input can be - A numpy array of length ss.time.factors containing values in key order - A pd.DateOffset instance - A dictionary with keys from ss.time.factors\nThe output will be a pd.DateOffset with integer values, where non-integer values have been handled by overflow using the factors in ss.time.factors. For example, 2.5 weeks would first become 2 weeks and 0.57 = 3.5 days, and then become 3 days + 0.524 = 12 hours.\nNegative values are supported - -1.5 weeks for example will become (-1w, -3d, -12h)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA pd.DateOffset\n\n\n\n\n\n\n\ntime.datedur.scale(dateoffset, scale)\nScale a pd.DateOffset by a factor\nThis function will automatically cascade remainders to finer units using ss.time.factors so for example 2.5 weeks would first become 2 weeks and 0.57 = 3.5 days, and then become 3 days + 0.524 = 12 hours.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndateoffset\n\nA pd.DateOffset instance\nrequired\n\n\nscale\n\nA float scaling factor (must be positive)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA pd.DateOffset instance scaled by the requested amount\n\n\n\n\n\n\n\ntime.datedur.to(unit)\nReturn approximate conversion into the provided quantity\nThis allows interoperability with years objects (which would typically be expected to occur if module parameters have been entered with datedur durations, but the simulation timestep is in years units).\nThe conversion is based on ss.time.factors which defines the conversion from each time unit to the next.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nunit\nstr\nthe unit to convert to: years, months, weeks, or days\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA float representing the duration in that unit\n\n\n\n\n\n\n\ntime.datedur.to_array(*args, **kwargs)\nConvert to a Numpy array (NB, different than to_numpy() which converts to fractional years\n\n\n\ntime.datedur.to_dict()\nConvert to a dictionary\n\n\n\ntime.datedur.to_dur()\nConvert to the smallest non-zero value, e.g. ss.datedur(years=1, days=10).to_dur() = ss.days(375)\n\n\n\n\n\ntime.dur(value=1, base=None)\nBase class for durations\nNote: this class should not be used by the user directly; instead, use ss.years(), ss.days(), etc. These classes can be interconverted using .to(), e.g. ss.years(3).to('days').\n\n\n\n\n\nName\nDescription\n\n\n\n\narange\nConstruct an array of dur instances\n\n\n\n\n\ntime.dur.arange(start, stop, step=1.0, inclusive=True)\nConstruct an array of dur instances\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nfloat / ss.dur\nStarting point, e.g., ss.years(0)\nrequired\n\n\nstop\nfloat / ss.dur\nEnding point, e.g. ss.years(20)\nrequired\n\n\nstep\nfloat / ss.dur\nStep size, e.g. ss.years(2)\n1.0\n\n\n\n\n\n\n\n\n\ntime.freq(value, unit=None)\nClass for the number of events (rather than probability) in a specified period\nIdentical to ss.per, except by default multiplication returns a number of events rather than a probability. Use ss.freq for events (e.g., number of acts per year) and ss.per for probabilities (e.g., probability of death per year).\n\n\n\n\n\nName\nDescription\n\n\n\n\nrate\nAlias to self.value\n\n\n\n\n\n\n\ntime.per(value, unit=None)\nA per represents an instantaneous rate of an event occurring. Rates must be non-negative, but need not be less than 1.\nThrough multiplication, rate can be modified or converted to a probability, depending on the data type of the object being multiplied.\nWhen a per is multiplied by a scalar or array, the rate is simply scaled. Such multiplication occurs frequently in epidemiological models, where the base rate is multiplied by “rate ratio” or “relative rate” to represent agents experiencing higher (multiplier &gt; 1) or lower (multiplier &lt; 1) event rates.\nAlternatively, when a per is multiplied by a duration (type ss.dur), a probability is calculated. The conversion from rate to probability on multiplication by a duration is 1 - np.exp(-rate/factor), where factor is the ratio of the multiplied duration to the original period (denominator).\nFor example, consider &gt;&gt;&gt; p = ss.per(0.8, ss.years(1)) When multiplied by a duration of 1 year, the calculated probability is 1 - np.exp(-0.8), which is approximately 55%. &gt;&gt;&gt; p*ss.years(1)\nWhen multiplied by a scalar, the rate is simply scaled. &gt;&gt;&gt; p*2\nThe difference between prob and per is subtle, but important. per works directly with the instantaneous rate of an event occurring. In contrast, prob starts with a probability and a duration, and the underlying rate is calculated. On multiplication by a duration, * per: rate -&gt; probability * prob: probability -&gt; rate -&gt; probability\nThe behavior of both classes is depending on the data type of the object being multiplied.\nss.per is identical to ss.freq, except by default multiplication returns a probability rather than a number of events. Use ss.per for probabilities (e.g., probability of death per year), and ss.freq for events (e.g., number of acts per year).\n\n\n\n\n\nName\nDescription\n\n\n\n\nrate\nAlias to self.value\n\n\n\n\n\n\n\ntime.prob(value=None, unit=None, rate=None)\nprob represents the probability of an event occurring during a specified period of time.\nThe class is designed to allow conversion of a probability from one duration to another through multiplication. However, the behavior of this conversion depends on the data type of the the object being multiplied.\nWhen multiplied by a duration (type ss.dur), the underlying constant rate is calculated as rate = -np.log(1 - self.value). Then, the probability over the new duration is p = 1 - np.exp(-rate/factor), where factor is the ratio of the new duration to the original duration.\nFor example, &gt;&gt;&gt; p = ss.prob(0.8, ss.years(1)) indicates a 80% chance of an event occurring in one year.\n\n\n\np*ss.years(1) When multiplied by the original denominator, 1 year in this case, the probability remains unchanged, 80%.\n\n\n\n\n\n\np * ss.years(2) Multiplying p by ss.years(2) does not simply double the probability to 160% (which is not possible), but rather returns a new probability of 96% representing the chance of the event occurring at least once over the new duration of two years.\n\n\n\nHowever, the behavior is different when a prob object is multiplied by a scalar or array. In this case, the probability is simply scaled. This scaling may result in a value greater than 1, which is not valid. For example, &gt;&gt;&gt; p * 2 raises an AssertionError because the resulting probability (160%) exceeds 100%.\nUse per instead if prob if you would prefer to directly specify the instantaneous rate.\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_prob\nConvert from one time probability to another\n\n\n\n\n\ntime.prob.to_prob(dur=None, scale=1.0)\nConvert from one time probability to another\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndur\nss.dur\nthe duration over which to convert the probability to\nNone\n\n\nscale\nfloat\nan optional additional mutliplicative scale factor to incorporate in the calculation\n1.0\n\n\n\nExample:\np_month = ss.probpermonth(0.05)\np_year = p_month.to_prob(ss.year) # Slightly less than 0.05*12\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrate\nBackwards compatibility function for Rate\n\n\nrate_prob\nBackwards compatibility function for per\n\n\ntime_prob\nBackwards compatibility function for prob\n\n\n\n\n\ntime.rate(value, unit=None)\nBackwards compatibility function for Rate\n\n\n\ntime.rate_prob(value, unit=None)\nBackwards compatibility function for per\n\n\n\ntime.time_prob(value, unit=None)\nBackwards compatibility function for prob",
    "crumbs": [
      "**Utilities**",
      "time"
    ]
  },
  {
    "objectID": "api/time.html#classes",
    "href": "api/time.html#classes",
    "title": "time",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDateArray\nLightweight wrapper for an array of dates\n\n\nRate\nStore a value per unit time e.g., 2 per day\n\n\nTimePar\nParent class for all TimePars – dur, Rate, etc.\n\n\ndate\nDefine a point in time, based on pd.Timestamp\n\n\ndatedur\nDate based duration e.g., if requiring a week to be 7 calendar days later\n\n\ndur\nBase class for durations\n\n\nfreq\nClass for the number of events (rather than probability) in a specified period\n\n\nper\nA per represents an instantaneous rate of an event occurring. Rates\n\n\nprob\nprob represents the probability of an event occurring during a\n\n\n\n\n\ntime.DateArray()\nLightweight wrapper for an array of dates\n\n\n\n\n\nName\nDescription\n\n\n\n\nsubdaily\nCheck if the array has sub-daily timesteps\n\n\nyears\nRepresent the dates as floating point years\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nis_\nChecks if the DateArray is comprised of ss.date objects\n\n\nto_array\nForce conversion to an array\n\n\nto_date\nConvert to ss.date\n\n\nto_float\nConvert to a float, returning a new DateArray unless inplace=True\n\n\nto_human\nReturn the most human-friendly (i.e. plotting-friendly) version of the dates,\n\n\n\n\n\ntime.DateArray.is_(which)\nChecks if the DateArray is comprised of ss.date objects\n\n\n\ntime.DateArray.to_array(*args, **kwargs)\nForce conversion to an array\n\n\n\ntime.DateArray.to_date(inplace=False, day_round=None, die=True)\nConvert to ss.date\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninplace\nbool\nwhether to modify in place\nFalse\n\n\nday_round\nbool\nwhether to round dates to the nearest day (otherwise, keep timestamp); if None, round if and only if the span of the first timestep is at least one day\nNone\n\n\ndie\nbool\nif False, then fall back to float if conversion to date fails (e.g. year 0)\nTrue\n\n\n\n\n\n\n\ntime.DateArray.to_float(inplace=False, to_numpy=False)\nConvert to a float, returning a new DateArray unless inplace=True\n\n\n\ntime.DateArray.to_human()\nReturn the most human-friendly (i.e. plotting-friendly) version of the dates, i.e. ss.date if possible, float otherwise\n\n\n\n\n\ntime.Rate(value, unit=None)\nStore a value per unit time e.g., 2 per day - self.value - the numerator (e.g., 2) - a scalar float - self.unit - the denominator (e.g., 1 day) - a dur object\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_default_dur\nSet the default duration, e.g. module.dt, so .to_prob() can be used with no input\n\n\nto_events\nSimple multiplication: calculate the number of events over the time period\n\n\nto_prob\nConvert from one time probability to another\n\n\n\n\n\ntime.Rate.set_default_dur(dur)\nSet the default duration, e.g. module.dt, so .to_prob() can be used with no input\n\n\n\ntime.Rate.to_events(dur=None)\nSimple multiplication: calculate the number of events over the time period\n\n\n\ntime.Rate.to_prob(dur=None, scale=1.0)\nConvert from one time probability to another\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndur\nss.dur\nthe duration over which to convert the probability to\nNone\n\n\nscale\nfloat\nan optional additional mutliplicative scale factor to incorporate in the calculation\n1.0\n\n\n\nExample:\np_month = ss.probpermonth(0.05)\np_year = p_month.to_prob(ss.year) # Slightly less than 0.05*12\n\n\n\n\n\n\ntime.TimePar()\nParent class for all TimePars – dur, Rate, etc.\n\n\n\n\n\nName\nDescription\n\n\n\n\nto\nConvert this TimePar to one of a different class\n\n\nto_array\nForce conversion to an array\n\n\nto_base\nClass method to convert another TimePar object to this TimePar’s base units; in most cases\n\n\n\n\n\ntime.TimePar.to(unit)\nConvert this TimePar to one of a different class\n\n\n\ntime.TimePar.to_array(*args, **kwargs)\nForce conversion to an array\n\n\n\ntime.TimePar.to_base(other)\nClass method to convert another TimePar object to this TimePar’s base units; in most cases\n\n\n\n\n\ntime.date()\nDefine a point in time, based on pd.Timestamp\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndate\nint / float / str / datetime\nAny type of date input (ints and floats will be interpreted as years)\nrequired\n\n\nallow_zero\nbool\nif True, allow a year 0 by creating a datedur instead; if False, raise an exception; if None, give a warning\nrequired\n\n\nkwargs\ndict\npassed to pd.Timestamp()\nrequired\n\n\n\nExamples:\nss.date(2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2020) # Returns &lt;2020-01-01&gt;\nss.date(year=2024.75) # Returns &lt;2024-10-01&gt;\nss.date('2024-04-04') # Returns &lt;2024-04-04&gt;\nss.date(year=2024, month=4, day=4) # Returns &lt;2024-04-04&gt;\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nyears\nReturn the date as a number of years\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\narange\nConstruct an array of dates\n\n\ndisp\nShow the full object\n\n\nfrom_array\nConvert an array of float years into an array of date instances\n\n\nfrom_json\nReconstruct a date from a JSON; reverse of to_json()\n\n\nfrom_year\nConvert an int or float year to a date.\n\n\nreplace\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\nround\nRound to a given interval (by default a day\n\n\nsubdaily\nCheck if a subdaily timestep is used\n\n\nto_json\nReturns a JSON representation of the date\n\n\nto_pandas\nConvert to a standard pd.Timestamp instance\n\n\nto_year\nConvert a date to a floating-point year\n\n\n\n\n\ntime.date.arange(\n    start,\n    stop,\n    step=1.0,\n    inclusive=True,\n    day_round=None,\n    allow_zero=True,\n)\nConstruct an array of dates\nFunctions similarly to np.arange, but returns date objects\nExample usage:\n\n\n\ndate.arange(2020, 2025) array([&lt;2020.01.01&gt;, &lt;2021.01.01&gt;, &lt;2022.01.01&gt;, &lt;2023.01.01&gt;, &lt;2024.01.01&gt;, &lt;2025.01.01&gt;], dtype=object)\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nfloat / ss.date / ss.dur\nLower bound - can be a date or a numerical year\nrequired\n\n\n\nstop (float/ss.date/ss.dur): Upper bound - can be a date or a numerical year step (float/ss.dur): Assumes 1 calendar year steps by default inclusive (bool): Whether to include “stop” in the output day_round (bool): Whether to round to the nearest day (by default, True if step &gt; 1 day) allow_zero (bool): if True, allow a year 0 by creating a datedur instead; if False, raise an exception; if None, give a warning\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.disp(**kwargs)\nShow the full object\n\n\n\ntime.date.from_array(array, day_round=True, allow_zero=True, date_type=None)\nConvert an array of float years into an array of date instances\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narray\narray\nAn array of float years\nrequired\n\n\nday_round\nbool\nWhether to round to the nearest day\nTrue\n\n\nallow_zero\nbool\nif True, allow a year 0 by creating a datedur instead; if False, raise an exception; if None, give a warning\nTrue\n\n\ndate_type\ntype\nOptionally convert to a class other than ss.date (e.g. ss.datedur)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nAn array of date instances\n\n\n\n\n\n\n\ntime.date.from_json(json)\nReconstruct a date from a JSON; reverse of to_json()\n\n\n\ntime.date.from_year(year, day_round=True, allow_zero=None)\nConvert an int or float year to a date.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nyear\nfloat\nthe year to round\nrequired\n\n\nday_round\nbool\nwhether to round to the nearest day\nTrue\n\n\nallow_zero\nbool\nwhether to allow year 0 (if so, return ss.datedur instead)\nNone\n\n\n\nExamples:\nss.date.from_year(2020) # Returns &lt;2020-01-01&gt;\nss.date.from_year(2024.75) # Returns &lt;2024-10-01&gt;\n\n\n\n\ntime.date.replace(*args, **kwargs)\nReturns a new ss.date(); pd.Timestamp is immutable\n\n\n\ntime.date.round(to='d')\nRound to a given interval (by default a day\n\n\n\ntime.date.subdaily(years)\nCheck if a subdaily timestep is used\nA date has no concept of a timestep, but add this as a convienence method since this is required by other methods (e.g. ss.date.arange()).\n\n\n\ntime.date.to_json()\nReturns a JSON representation of the date\n\n\n\ntime.date.to_pandas()\nConvert to a standard pd.Timestamp instance\n\n\n\ntime.date.to_year()\nConvert a date to a floating-point year\nExamples:\nss.date('2020-01-01').to_year() # Returns 2020.0\nss.date('2024-10-01').to_year() # Returns 2024.7486\n\n\n\n\n\ntime.datedur(*args, **kwargs)\nDate based duration e.g., if requiring a week to be 7 calendar days later\n\n\n\n\n\nName\nDescription\n\n\n\n\ndays\nShortcut to datedur.to(‘days’)\n\n\nmonths\nShortcut to datedur.to(‘months’)\n\n\nweeks\nShortcut to datedur.to(‘weeks’)\n\n\nyears\nShortcut to datedur.to(‘years’)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nround_duration\nRound a dictionary of duration values by overflowing remainders\n\n\nscale\nScale a pd.DateOffset by a factor\n\n\nto\nReturn approximate conversion into the provided quantity\n\n\nto_array\nConvert to a Numpy array (NB, different than to_numpy() which converts to fractional years\n\n\nto_dict\nConvert to a dictionary\n\n\nto_dur\nConvert to the smallest non-zero value, e.g. ss.datedur(years=1, days=10).to_dur() = ss.days(375)\n\n\n\n\n\ntime.datedur.round_duration(vals=None, **kwargs)\nRound a dictionary of duration values by overflowing remainders\nThe input can be - A numpy array of length ss.time.factors containing values in key order - A pd.DateOffset instance - A dictionary with keys from ss.time.factors\nThe output will be a pd.DateOffset with integer values, where non-integer values have been handled by overflow using the factors in ss.time.factors. For example, 2.5 weeks would first become 2 weeks and 0.57 = 3.5 days, and then become 3 days + 0.524 = 12 hours.\nNegative values are supported - -1.5 weeks for example will become (-1w, -3d, -12h)\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA pd.DateOffset\n\n\n\n\n\n\n\ntime.datedur.scale(dateoffset, scale)\nScale a pd.DateOffset by a factor\nThis function will automatically cascade remainders to finer units using ss.time.factors so for example 2.5 weeks would first become 2 weeks and 0.57 = 3.5 days, and then become 3 days + 0.524 = 12 hours.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndateoffset\n\nA pd.DateOffset instance\nrequired\n\n\nscale\n\nA float scaling factor (must be positive)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA pd.DateOffset instance scaled by the requested amount\n\n\n\n\n\n\n\ntime.datedur.to(unit)\nReturn approximate conversion into the provided quantity\nThis allows interoperability with years objects (which would typically be expected to occur if module parameters have been entered with datedur durations, but the simulation timestep is in years units).\nThe conversion is based on ss.time.factors which defines the conversion from each time unit to the next.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nunit\nstr\nthe unit to convert to: years, months, weeks, or days\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA float representing the duration in that unit\n\n\n\n\n\n\n\ntime.datedur.to_array(*args, **kwargs)\nConvert to a Numpy array (NB, different than to_numpy() which converts to fractional years\n\n\n\ntime.datedur.to_dict()\nConvert to a dictionary\n\n\n\ntime.datedur.to_dur()\nConvert to the smallest non-zero value, e.g. ss.datedur(years=1, days=10).to_dur() = ss.days(375)\n\n\n\n\n\ntime.dur(value=1, base=None)\nBase class for durations\nNote: this class should not be used by the user directly; instead, use ss.years(), ss.days(), etc. These classes can be interconverted using .to(), e.g. ss.years(3).to('days').\n\n\n\n\n\nName\nDescription\n\n\n\n\narange\nConstruct an array of dur instances\n\n\n\n\n\ntime.dur.arange(start, stop, step=1.0, inclusive=True)\nConstruct an array of dur instances\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nfloat / ss.dur\nStarting point, e.g., ss.years(0)\nrequired\n\n\nstop\nfloat / ss.dur\nEnding point, e.g. ss.years(20)\nrequired\n\n\nstep\nfloat / ss.dur\nStep size, e.g. ss.years(2)\n1.0\n\n\n\n\n\n\n\n\n\ntime.freq(value, unit=None)\nClass for the number of events (rather than probability) in a specified period\nIdentical to ss.per, except by default multiplication returns a number of events rather than a probability. Use ss.freq for events (e.g., number of acts per year) and ss.per for probabilities (e.g., probability of death per year).\n\n\n\n\n\nName\nDescription\n\n\n\n\nrate\nAlias to self.value\n\n\n\n\n\n\n\ntime.per(value, unit=None)\nA per represents an instantaneous rate of an event occurring. Rates must be non-negative, but need not be less than 1.\nThrough multiplication, rate can be modified or converted to a probability, depending on the data type of the object being multiplied.\nWhen a per is multiplied by a scalar or array, the rate is simply scaled. Such multiplication occurs frequently in epidemiological models, where the base rate is multiplied by “rate ratio” or “relative rate” to represent agents experiencing higher (multiplier &gt; 1) or lower (multiplier &lt; 1) event rates.\nAlternatively, when a per is multiplied by a duration (type ss.dur), a probability is calculated. The conversion from rate to probability on multiplication by a duration is 1 - np.exp(-rate/factor), where factor is the ratio of the multiplied duration to the original period (denominator).\nFor example, consider &gt;&gt;&gt; p = ss.per(0.8, ss.years(1)) When multiplied by a duration of 1 year, the calculated probability is 1 - np.exp(-0.8), which is approximately 55%. &gt;&gt;&gt; p*ss.years(1)\nWhen multiplied by a scalar, the rate is simply scaled. &gt;&gt;&gt; p*2\nThe difference between prob and per is subtle, but important. per works directly with the instantaneous rate of an event occurring. In contrast, prob starts with a probability and a duration, and the underlying rate is calculated. On multiplication by a duration, * per: rate -&gt; probability * prob: probability -&gt; rate -&gt; probability\nThe behavior of both classes is depending on the data type of the object being multiplied.\nss.per is identical to ss.freq, except by default multiplication returns a probability rather than a number of events. Use ss.per for probabilities (e.g., probability of death per year), and ss.freq for events (e.g., number of acts per year).\n\n\n\n\n\nName\nDescription\n\n\n\n\nrate\nAlias to self.value\n\n\n\n\n\n\n\ntime.prob(value=None, unit=None, rate=None)\nprob represents the probability of an event occurring during a specified period of time.\nThe class is designed to allow conversion of a probability from one duration to another through multiplication. However, the behavior of this conversion depends on the data type of the the object being multiplied.\nWhen multiplied by a duration (type ss.dur), the underlying constant rate is calculated as rate = -np.log(1 - self.value). Then, the probability over the new duration is p = 1 - np.exp(-rate/factor), where factor is the ratio of the new duration to the original duration.\nFor example, &gt;&gt;&gt; p = ss.prob(0.8, ss.years(1)) indicates a 80% chance of an event occurring in one year.\n\n\n\np*ss.years(1) When multiplied by the original denominator, 1 year in this case, the probability remains unchanged, 80%.\n\n\n\n\n\n\np * ss.years(2) Multiplying p by ss.years(2) does not simply double the probability to 160% (which is not possible), but rather returns a new probability of 96% representing the chance of the event occurring at least once over the new duration of two years.\n\n\n\nHowever, the behavior is different when a prob object is multiplied by a scalar or array. In this case, the probability is simply scaled. This scaling may result in a value greater than 1, which is not valid. For example, &gt;&gt;&gt; p * 2 raises an AssertionError because the resulting probability (160%) exceeds 100%.\nUse per instead if prob if you would prefer to directly specify the instantaneous rate.\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_prob\nConvert from one time probability to another\n\n\n\n\n\ntime.prob.to_prob(dur=None, scale=1.0)\nConvert from one time probability to another\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndur\nss.dur\nthe duration over which to convert the probability to\nNone\n\n\nscale\nfloat\nan optional additional mutliplicative scale factor to incorporate in the calculation\n1.0\n\n\n\nExample:\np_month = ss.probpermonth(0.05)\np_year = p_month.to_prob(ss.year) # Slightly less than 0.05*12",
    "crumbs": [
      "**Utilities**",
      "time"
    ]
  },
  {
    "objectID": "api/time.html#functions",
    "href": "api/time.html#functions",
    "title": "time",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrate\nBackwards compatibility function for Rate\n\n\nrate_prob\nBackwards compatibility function for per\n\n\ntime_prob\nBackwards compatibility function for prob\n\n\n\n\n\ntime.rate(value, unit=None)\nBackwards compatibility function for Rate\n\n\n\ntime.rate_prob(value, unit=None)\nBackwards compatibility function for per\n\n\n\ntime.time_prob(value, unit=None)\nBackwards compatibility function for prob",
    "crumbs": [
      "**Utilities**",
      "time"
    ]
  },
  {
    "objectID": "api/arrays.html",
    "href": "api/arrays.html",
    "title": "arrays",
    "section": "",
    "text": "arrays\nDefine array-handling classes, including agent states\n\n\n\n\n\nName\nDescription\n\n\n\n\nArr\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\n\n\nBaseArr\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\nBoolArr\nSubclass of ss.Arr with defaults for booleans\n\n\nBoolState\nA boolean array being used as a state.\n\n\nFloatArr\nSubclass of ss.Arr with defaults for floats and ints.\n\n\nIndexArr\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\nIntArr\nSubclass of ss.Arr with defaults for ints.\n\n\nuids\nClass to specify that integers should be interpreted as UIDs.\n\n\n\n\n\narrays.Arr(\n    name=None,\n    dtype=None,\n    default=None,\n    nan=None,\n    label=None,\n    raw=None,\n    skip_init=False,\n    people=None,\n    mock=None,\n)\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\nIn practice, Arr objects can be used interchangeably with NumPy arrays. They have two main data interfaces: Arr.raw contains the “raw”, underlying NumPy array of the data. Arr.values contains the “active” values, which usually corresponds to agents who are alive.\nBy default, operations are performed on active agents only (specified by Arr.auids, which is a pointer to sim.people.auids). For example, sim.people.age.mean() will only use the ages of active agents. Thus, sim.people.age.mean() is equal to sim.people.age.values.mean(), not sim.people.age.raw.mean().\nIf indexing by an int or slice, Arr.values is used. If indexing by an ss.uids object, Arr.raw is used. Arr objects can’t be directly indexed by a list or array of ints, as this would be ambiguous about whether values or raw is intended. For example, if there are 1000 people in a simulation and 100 of them have died, sim.people.age[999] will return an IndexError (since sim.people.age[899] is the last active agent), whereas sim.people.age[ss.uids(999)] is valid.\nNote on terminology: the term “states” is often used to refer to all ss.Arr objects, (e.g. in module.define_states(), whether or not they are BoolStates.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name for the state (also used as the dictionary key, so should not have spaces etc.)\nNone\n\n\ndtype\nclass\nThe dtype to use for this instance (if None, infer from value)\nNone\n\n\ndefault\nany\nSpecify default value for new agents. This can be: * A scalar with the same dtype (or castable to the same dtype) as the Arr; * A callable, with a single argument for the number of values to produce; * A ss.Dist instance.\nNone\n\n\nnan\nany\nthe value to use to represent NaN (not a number); also used as the default value if not supplied\nNone\n\n\nlabel\nstr\nThe human-readable name for the state\nNone\n\n\nraw\narray\nIf provided, initialize the array with these raw values\nNone\n\n\nskip_init\nbool\nWhether to skip initialization with the People object (used for uid and slot states)\nFalse\n\n\npeople\n[ss.People](starsim.people.People)\nOptionally specify an initialized People object, used to construct temporary Arr instances\nNone\n\n\nmock\nint\nif provided, create a mock People object (of length mock, unless raw is provided) to initialize the array (for debugging purposes)\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauids\nLink to the indices of active agents – sim.people.auids\n\n\nisnan\nReturn BoolArr for NaN values\n\n\nnotnan\nReturn BoolArr for non-NaN values\n\n\nnotnanvals\nReturn values that are not-NaN\n\n\nvalues\nReturn the values of the active agents\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\nastype\nConvert the Arr type\n\n\nconvert\nCheck if an object is an array, and convert if so\n\n\nfalse\nReverse of true(); return UIDs of falsy values\n\n\ngrow\nAdd new agents to an Arr\n\n\ninit_vals\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\nlink_people\nLink a People object to this state, for access auids\n\n\nset\nSet the values for the specified UIDs\n\n\nset_nan\nShortcut function to set values to NaN\n\n\nto_json\nExport to JSON\n\n\ntrue\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.Arr.asnew(arr=None, cls=None, name=None, copy=None)\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\n\narrays.Arr.astype(cls, copy=False)\nConvert the Arr type\n\n\n\narrays.Arr.convert(obj, copy=None)\nCheck if an object is an array, and convert if so\n\n\n\narrays.Arr.false()\nReverse of true(); return UIDs of falsy values\n\n\n\narrays.Arr.grow(new_uids=None, new_vals=None)\nAdd new agents to an Arr\nThis method is normally only called via People.grow().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_uids\narray\nNumpy array of UIDs for the new agents being added\nNone\n\n\nnew_vals\narray\nIf provided, assign these state values to the new UIDs\nNone\n\n\n\n\n\n\n\narrays.Arr.init_vals()\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\n\narrays.Arr.link_people(people)\nLink a People object to this state, for access auids\n\n\n\narrays.Arr.set(uids, new_vals=None)\nSet the values for the specified UIDs\n\n\n\narrays.Arr.set_nan(uids)\nShortcut function to set values to NaN\n\n\n\narrays.Arr.to_json()\nExport to JSON\n\n\n\narrays.Arr.true()\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.BaseArr(values, *args, **kwargs)\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data\n\n\nconvert\nCheck if an object is an array, and convert if so\n\n\ndisp\nFull display of object\n\n\nto_json\nReturn a dictionary representation of the Arr\n\n\nupdate\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BaseArr.asnew(values=None, cls=None, **kwargs)\nDuplicate and copy (rather than link) data\n\n\n\narrays.BaseArr.convert(obj)\nCheck if an object is an array, and convert if so\n\n\n\narrays.BaseArr.disp()\nFull display of object\n\n\n\narrays.BaseArr.to_json()\nReturn a dictionary representation of the Arr\n\n\n\narrays.BaseArr.update(skip_none=True, overwrite=True, force=False, **kwargs)\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BoolArr(name=None, **kwargs)\nSubclass of ss.Arr with defaults for booleans\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to Arr.true\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nsplit\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.BoolArr.split()\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.BoolState(name=None, **kwargs)\nA boolean array being used as a state.\nAlthough functionally identical to BoolArr, a BoolState is handled differently in terms of automation: specifically, results are automatically generated from a BoolState (but not a BoolArr).\nBoolStates are typically used to keep track of externally-facing variables (e.g. disease.susceptible), while BoolArrs can be used to keep track of internal ones (e.g. disease.has_immunity). A BoolState named “susceptible” will automatically generate a result named “n_susceptible”, for example.\nNote on terminology: the term “states” is often used to refer to all ss.Arr objects, (e.g. in module.define_states(), whether or not they are BoolStates.\n\n\n\narrays.FloatArr(name=None, **kwargs)\nSubclass of ss.Arr with defaults for floats and ints.\nNote: Starsim does not support integer arrays by default since they introduce ambiguity in dealing with NaNs, and float arrays are suitable for most purposes.\n\n\n\narrays.IndexArr(name=None, label=None)\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to self.values, to allow Arr.uids like BoolArr\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ngrow\nChange the size of the array\n\n\n\n\n\narrays.IndexArr.grow(new_uids=None, new_vals=None)\nChange the size of the array\n\n\n\n\n\narrays.IntArr(name=None, **kwargs)\nSubclass of ss.Arr with defaults for ints.\nNote: Because integer arrays do not handle NaN values natively, users are recommended to use ss.FloatArr() in most cases instead.\n\n\n\narrays.uids()\nClass to specify that integers should be interpreted as UIDs.\nFor all practical purposes, behaves like a NumPy integer array. However, has additional methods uids.concat() (instance method), ss.uids.cat() (class method), uids.remove(), and uids.intersect() to simplify common UID operations.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncat\nEquivalent to np.concatenate(), but return correct type\n\n\nconcat\nEquivalent to np.concatenate(), but return correct type\n\n\nintersect\nKeep only UIDs that are also present in the other array\n\n\nremove\nRemove provided UIDs from current array\n\n\nto_numpy\nReturn a view as a standard NumPy array\n\n\nunion\nReturn all UIDs present in both arrays\n\n\nunique\nReturn unique UIDs; equivalent to np.unique()\n\n\nxor\nReturn UIDs present in only one of the arrays\n\n\n\n\n\narrays.uids.cat(*args, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.concat(other, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.intersect(other, **kw)\nKeep only UIDs that are also present in the other array\n\n\n\narrays.uids.remove(other, **kw)\nRemove provided UIDs from current array\n\n\n\narrays.uids.to_numpy()\nReturn a view as a standard NumPy array\n\n\n\narrays.uids.union(other, **kw)\nReturn all UIDs present in both arrays\n\n\n\narrays.uids.unique(return_index=False)\nReturn unique UIDs; equivalent to np.unique()\n\n\n\narrays.uids.xor(other, **kw)\nReturn UIDs present in only one of the arrays",
    "crumbs": [
      "**Utilities**",
      "arrays"
    ]
  },
  {
    "objectID": "api/arrays.html#classes",
    "href": "api/arrays.html#classes",
    "title": "arrays",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nArr\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\n\n\nBaseArr\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\nBoolArr\nSubclass of ss.Arr with defaults for booleans\n\n\nBoolState\nA boolean array being used as a state.\n\n\nFloatArr\nSubclass of ss.Arr with defaults for floats and ints.\n\n\nIndexArr\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\nIntArr\nSubclass of ss.Arr with defaults for ints.\n\n\nuids\nClass to specify that integers should be interpreted as UIDs.\n\n\n\n\n\narrays.Arr(\n    name=None,\n    dtype=None,\n    default=None,\n    nan=None,\n    label=None,\n    raw=None,\n    skip_init=False,\n    people=None,\n    mock=None,\n)\nStore a state of the agents (e.g. age, infection status, etc.) as an array.\nIn practice, Arr objects can be used interchangeably with NumPy arrays. They have two main data interfaces: Arr.raw contains the “raw”, underlying NumPy array of the data. Arr.values contains the “active” values, which usually corresponds to agents who are alive.\nBy default, operations are performed on active agents only (specified by Arr.auids, which is a pointer to sim.people.auids). For example, sim.people.age.mean() will only use the ages of active agents. Thus, sim.people.age.mean() is equal to sim.people.age.values.mean(), not sim.people.age.raw.mean().\nIf indexing by an int or slice, Arr.values is used. If indexing by an ss.uids object, Arr.raw is used. Arr objects can’t be directly indexed by a list or array of ints, as this would be ambiguous about whether values or raw is intended. For example, if there are 1000 people in a simulation and 100 of them have died, sim.people.age[999] will return an IndexError (since sim.people.age[899] is the last active agent), whereas sim.people.age[ss.uids(999)] is valid.\nNote on terminology: the term “states” is often used to refer to all ss.Arr objects, (e.g. in module.define_states(), whether or not they are BoolStates.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name for the state (also used as the dictionary key, so should not have spaces etc.)\nNone\n\n\ndtype\nclass\nThe dtype to use for this instance (if None, infer from value)\nNone\n\n\ndefault\nany\nSpecify default value for new agents. This can be: * A scalar with the same dtype (or castable to the same dtype) as the Arr; * A callable, with a single argument for the number of values to produce; * A ss.Dist instance.\nNone\n\n\nnan\nany\nthe value to use to represent NaN (not a number); also used as the default value if not supplied\nNone\n\n\nlabel\nstr\nThe human-readable name for the state\nNone\n\n\nraw\narray\nIf provided, initialize the array with these raw values\nNone\n\n\nskip_init\nbool\nWhether to skip initialization with the People object (used for uid and slot states)\nFalse\n\n\npeople\n[ss.People](starsim.people.People)\nOptionally specify an initialized People object, used to construct temporary Arr instances\nNone\n\n\nmock\nint\nif provided, create a mock People object (of length mock, unless raw is provided) to initialize the array (for debugging purposes)\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nauids\nLink to the indices of active agents – sim.people.auids\n\n\nisnan\nReturn BoolArr for NaN values\n\n\nnotnan\nReturn BoolArr for non-NaN values\n\n\nnotnanvals\nReturn values that are not-NaN\n\n\nvalues\nReturn the values of the active agents\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\nastype\nConvert the Arr type\n\n\nconvert\nCheck if an object is an array, and convert if so\n\n\nfalse\nReverse of true(); return UIDs of falsy values\n\n\ngrow\nAdd new agents to an Arr\n\n\ninit_vals\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\nlink_people\nLink a People object to this state, for access auids\n\n\nset\nSet the values for the specified UIDs\n\n\nset_nan\nShortcut function to set values to NaN\n\n\nto_json\nExport to JSON\n\n\ntrue\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.Arr.asnew(arr=None, cls=None, name=None, copy=None)\nDuplicate and copy (rather than link) data, optionally resetting the array\n\n\n\narrays.Arr.astype(cls, copy=False)\nConvert the Arr type\n\n\n\narrays.Arr.convert(obj, copy=None)\nCheck if an object is an array, and convert if so\n\n\n\narrays.Arr.false()\nReverse of true(); return UIDs of falsy values\n\n\n\narrays.Arr.grow(new_uids=None, new_vals=None)\nAdd new agents to an Arr\nThis method is normally only called via People.grow().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_uids\narray\nNumpy array of UIDs for the new agents being added\nNone\n\n\nnew_vals\narray\nIf provided, assign these state values to the new UIDs\nNone\n\n\n\n\n\n\n\narrays.Arr.init_vals()\nActually populate the initial values and mark as initialized; only to be used on initialization\n\n\n\narrays.Arr.link_people(people)\nLink a People object to this state, for access auids\n\n\n\narrays.Arr.set(uids, new_vals=None)\nSet the values for the specified UIDs\n\n\n\narrays.Arr.set_nan(uids)\nShortcut function to set values to NaN\n\n\n\narrays.Arr.to_json()\nExport to JSON\n\n\n\narrays.Arr.true()\nEfficiently convert truthy values to UIDs\n\n\n\n\n\narrays.BaseArr(values, *args, **kwargs)\nAn object that acts exactly like a NumPy array, except stores the values in self.values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nasnew\nDuplicate and copy (rather than link) data\n\n\nconvert\nCheck if an object is an array, and convert if so\n\n\ndisp\nFull display of object\n\n\nto_json\nReturn a dictionary representation of the Arr\n\n\nupdate\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BaseArr.asnew(values=None, cls=None, **kwargs)\nDuplicate and copy (rather than link) data\n\n\n\narrays.BaseArr.convert(obj)\nCheck if an object is an array, and convert if so\n\n\n\narrays.BaseArr.disp()\nFull display of object\n\n\n\narrays.BaseArr.to_json()\nReturn a dictionary representation of the Arr\n\n\n\narrays.BaseArr.update(skip_none=True, overwrite=True, force=False, **kwargs)\nUpdate the attributes, skipping None values and raising an error if extra keys are added\n\n\n\n\n\narrays.BoolArr(name=None, **kwargs)\nSubclass of ss.Arr with defaults for booleans\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to Arr.true\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nsplit\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.BoolArr.split()\nReturn UIDs of values that are true and false as separate arrays\n\n\n\n\n\narrays.BoolState(name=None, **kwargs)\nA boolean array being used as a state.\nAlthough functionally identical to BoolArr, a BoolState is handled differently in terms of automation: specifically, results are automatically generated from a BoolState (but not a BoolArr).\nBoolStates are typically used to keep track of externally-facing variables (e.g. disease.susceptible), while BoolArrs can be used to keep track of internal ones (e.g. disease.has_immunity). A BoolState named “susceptible” will automatically generate a result named “n_susceptible”, for example.\nNote on terminology: the term “states” is often used to refer to all ss.Arr objects, (e.g. in module.define_states(), whether or not they are BoolStates.\n\n\n\narrays.FloatArr(name=None, **kwargs)\nSubclass of ss.Arr with defaults for floats and ints.\nNote: Starsim does not support integer arrays by default since they introduce ambiguity in dealing with NaNs, and float arrays are suitable for most purposes.\n\n\n\narrays.IndexArr(name=None, label=None)\nA special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr)\n\n\n\n\n\nName\nDescription\n\n\n\n\nuids\nAlias to self.values, to allow Arr.uids like BoolArr\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ngrow\nChange the size of the array\n\n\n\n\n\narrays.IndexArr.grow(new_uids=None, new_vals=None)\nChange the size of the array\n\n\n\n\n\narrays.IntArr(name=None, **kwargs)\nSubclass of ss.Arr with defaults for ints.\nNote: Because integer arrays do not handle NaN values natively, users are recommended to use ss.FloatArr() in most cases instead.\n\n\n\narrays.uids()\nClass to specify that integers should be interpreted as UIDs.\nFor all practical purposes, behaves like a NumPy integer array. However, has additional methods uids.concat() (instance method), ss.uids.cat() (class method), uids.remove(), and uids.intersect() to simplify common UID operations.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncat\nEquivalent to np.concatenate(), but return correct type\n\n\nconcat\nEquivalent to np.concatenate(), but return correct type\n\n\nintersect\nKeep only UIDs that are also present in the other array\n\n\nremove\nRemove provided UIDs from current array\n\n\nto_numpy\nReturn a view as a standard NumPy array\n\n\nunion\nReturn all UIDs present in both arrays\n\n\nunique\nReturn unique UIDs; equivalent to np.unique()\n\n\nxor\nReturn UIDs present in only one of the arrays\n\n\n\n\n\narrays.uids.cat(*args, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.concat(other, **kw)\nEquivalent to np.concatenate(), but return correct type\n\n\n\narrays.uids.intersect(other, **kw)\nKeep only UIDs that are also present in the other array\n\n\n\narrays.uids.remove(other, **kw)\nRemove provided UIDs from current array\n\n\n\narrays.uids.to_numpy()\nReturn a view as a standard NumPy array\n\n\n\narrays.uids.union(other, **kw)\nReturn all UIDs present in both arrays\n\n\n\narrays.uids.unique(return_index=False)\nReturn unique UIDs; equivalent to np.unique()\n\n\n\narrays.uids.xor(other, **kw)\nReturn UIDs present in only one of the arrays",
    "crumbs": [
      "**Utilities**",
      "arrays"
    ]
  },
  {
    "objectID": "api/calibration.html",
    "href": "api/calibration.html",
    "title": "calibration",
    "section": "",
    "text": "calibration\nDefine the calibration class\n\n\n\n\n\nName\nDescription\n\n\n\n\nCalibComponent\nA class to compare a single channel of observed data with output from a\n\n\nCalibration\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter\n\n\n\n\n\ncalibration.CalibComponent(\n    name,\n    expected,\n    extract_fn,\n    conform,\n    weight=1,\n    include_fn=None,\n    n_boot=None,\n    combine_reps=None,\n)\nA class to compare a single channel of observed data with output from a simulation. The Calibration class can use several CalibComponent objects to form an overall understanding of how will a given simulation reflects observed data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname (str)\n\nthe name of this component. Importantly, if extract_fn is None, the code will attempt to use the name, like “hiv.prevalence” to automatically extract data from the simulation.\nrequired\n\n\nexpected (df)\n\npandas DataFrame containing calibration data. The index should be the time ‘t’ in either floating point years or datetime.\nrequired\n\n\nextract_fn (callable)\n\na function to extract predicted/actual data in the same format and with the same columns as expected.\nrequired\n\n\nconform\nstr | callable\nspecify how to handle timepoints that don’t align exactly between the expected and the actual/predicted/simulated data so they “conform” to a common time grid. Whether the data represents a ‘prevalent’ or an ‘incident’ quantity impacts how this alignment is performed. If ‘prevalent’, it means data in expected & actual dataframes represent the current state of the system, stocks like the number of currently infected individuals. In this case, the data in ‘simulated’ or ‘actual’ will be interpolated to match the timepoints in ‘expected’, allowing for pointwise comparisons between the expected and actual data. If ‘incident’, it means data in expected & actual dataframes represent the accumulation of system states over a period of time, flows like the incidence of new infections. In this case, teh data in ‘simulated’ or ‘actual’ will be interpolated at the start (‘t’) and the end (‘t1’) of the period of interest in ‘expected’. The difference between these two interpolated values will be used for comparison. Finally, ‘step_containing’ is a special case for prevalent data where the actual data is interpolated using a “zero order hold” method. This means that the value of the actual (simulated) data is matched to the timepoint in the expected data that contains the timepoint of the actual data.\nrequired\n\n\nweight\nfloat\nThe weight applied to the log likelihood of this component. The total log likelihood is the sum of the log likelihoods of all components, each multiplied by its weight.\n1\n\n\ninclude_fn\ncallable\nA function accepting a single simulation and returning a boolean to determine if the simulation should be included in the current component. If None, all simulations are included.\nNone\n\n\nn_boot\nint\nExperimental! Bootstrap sum sim results over seeds before comparing against expected results. Not appropriate for all component types.\nNone\n\n\ncombine_reps\nstr\nHow to combine multiple repetitions of the same pars. Options are None, ‘mean’, ‘sum’, or other such operation. Default is None, which evaluates replicates independently instead of first combining before likelihood evaluation.\nNone\n\n\nkwargs\n\nAdditional arguments to pass to the likelihood function\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\neval\nCompute and return the negative log likelihood\n\n\n\n\n\ncalibration.CalibComponent.eval(sim, **kwargs)\nCompute and return the negative log likelihood\n\n\n\n\n\ncalibration.Calibration(\n    sim,\n    calib_pars,\n    n_workers=None,\n    total_trials=None,\n    reseed=True,\n    build_fn=None,\n    build_kw=None,\n    eval_fn=None,\n    eval_kw=None,\n    components=None,\n    prune_fn=None,\n    label=None,\n    study_name=None,\n    db_name=None,\n    keep_db=None,\n    continue_db=None,\n    storage=None,\n    sampler=None,\n    die=False,\n    debug=False,\n    verbose=True,\n)\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter optimization library (optuna.org).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim (Sim)\n\nthe base simulation to calibrate\nrequired\n\n\ncalib_pars (dict)\n\na dictionary of the parameters to calibrate of the format dict(key1=dict(low=1, high=2, guess=1.5, **kwargs), key2=...), where kwargs can include “suggest_type” to choose the suggest method of the trial (e.g. suggest_float) and args passed to the trial suggest function like “log” and “step”\nrequired\n\n\nn_workers (int)\n\nthe number of parallel workers (if None, will use all available CPUs)\nrequired\n\n\ntotal_trials (int)\n\nthe total number of trials to run, each worker will run approximately n_trials = total_trial / n_workers\nrequired\n\n\nreseed (bool)\n\nwhether to generate new random seeds for each trial\nrequired\n\n\nbuild_fn (callable)\n\nfunction that takes a sim object and calib_pars dictionary and returns a modified sim\nrequired\n\n\nbuild_kw (dict)\n\na dictionary of options that are passed to build_fn to aid in modifying the base simulation. The API is self.build_fn(sim, calib_pars=calib_pars, **self.build_kw), where sim is a copy of the base simulation to be modified with calib_pars\nrequired\n\n\ncomponents (list)\n\nCalibComponents independently assess pseudo-likelihood as part of evaluating the quality of input parameters\nrequired\n\n\nprune_fn (callable)\n\nFunction that takes a dictionary of parameters and returns True if the trial should be pruned\nrequired\n\n\neval_fn (callable)\n\nFunction mapping a sim to a float (e.g. negative log likelihood) to be maximized. If None, the default will use CalibComponents.\nrequired\n\n\neval_kw (dict)\n\nAdditional keyword arguments to pass to the eval_fn\nrequired\n\n\nlabel (str)\n\na label for this calibration object\nrequired\n\n\nstudy_name (str)\n\nname of the optuna study\nrequired\n\n\ndb_name (str)\n\nthe name of the database file (default: ‘starsim_calibration.db’)\nrequired\n\n\ncontinue_db (bool)\n\nwhether to continue if the database already exists, removes the database if false (default: false, any existing database will be deleted)\nrequired\n\n\nkeep_db (bool)\n\nwhether to keep the database after calibration (default: false, the database will be deleted)\nrequired\n\n\nstorage (str)\n\nthe location of the database (default: sqlite)\nrequired\n\n\nsampler\nBaseSampler\nthe sampler used by optuna, like optuna.samplers.TPESampler\nNone\n\n\ndie (bool)\n\nwhether to stop if an exception is encountered (default: false)\nrequired\n\n\ndebug (bool)\n\nif True, do not run in parallel\nrequired\n\n\nverbose (bool)\n\nwhether to print details of the calibration\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalibrate\nPerform calibration.\n\n\ncheck_fit\nRun before and after simulations to validate the fit\n\n\nmake_study\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\nparse_study\nParse the study into a data frame – called automatically\n\n\nplot\n”\n\n\nplot_final\nPlot sims after calibration\n\n\nplot_optuna\nPlot Optuna’s visualizations\n\n\nremove_db\nRemove the database file if keep_db is false and the path exists\n\n\nrun_sim\nCreate and run a simulation\n\n\nrun_trial\nDefine the objective for Optuna\n\n\nrun_workers\nRun multiple workers in parallel\n\n\nto_df\nReturn the top K results as a dataframe, sorted by value\n\n\nto_json\nConvert the results to JSON\n\n\nworker\nRun a single worker\n\n\n\n\n\ncalibration.Calibration.calibrate(calib_pars=None, **kwargs)\nPerform calibration.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncalib_pars\ndict\nif supplied, overwrite stored calib_pars\nNone\n\n\nkwargs\ndict\nif supplied, overwrite stored run_args (n_trials, n_workers, etc.)\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.check_fit(do_plot=True)\nRun before and after simulations to validate the fit\n\n\n\ncalibration.Calibration.make_study()\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\n\ncalibration.Calibration.parse_study(study)\nParse the study into a data frame – called automatically\n\n\n\ncalibration.Calibration.plot(**kwargs)\n” Plot the calibration results. For a component-based likelihood, it only makes sense to directly call plot after calling eval_fn.\n\n\n\ncalibration.Calibration.plot_final(**kwargs)\nPlot sims after calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to MultiSim.plot()\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.plot_optuna(methods=None)\nPlot Optuna’s visualizations\n\n\n\ncalibration.Calibration.remove_db()\nRemove the database file if keep_db is false and the path exists\n\n\n\ncalibration.Calibration.run_sim(calib_pars=None, label=None)\nCreate and run a simulation\n\n\n\ncalibration.Calibration.run_trial(trial)\nDefine the objective for Optuna\n\n\n\ncalibration.Calibration.run_workers()\nRun multiple workers in parallel\n\n\n\ncalibration.Calibration.to_df(top_k=None)\nReturn the top K results as a dataframe, sorted by value\n\n\n\ncalibration.Calibration.to_json(filename=None, indent=2, **kwargs)\nConvert the results to JSON\n\n\n\ncalibration.Calibration.worker()\nRun a single worker\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nlinear_accum\nInterpolate in the cumulative sum, then difference. Use for incident data\n\n\nlinear_interp\nSimply interpolate, use for prevalent (stock) data like prevalence\n\n\nstep_containing\nFind the step containing the the timepoint. Use for prevalent data like\n\n\n\n\n\ncalibration.linear_accum(expected, actual)\nInterpolate in the cumulative sum, then difference. Use for incident data (flows) like incidence or new_deaths. The accumulation is done between ‘t’ and ‘t1’, both of which must be present in the index of expected and actual dataframes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\npd.DataFrame\nThe expected data from field observation, must have ‘t’ and ‘t1’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\nactual\npd.DataFrame\nThe actual data from the simulation, must have ‘t’ and ‘t1’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\n\n\n\n\n\ncalibration.linear_interp(expected, actual)\nSimply interpolate, use for prevalent (stock) data like prevalence\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\npd.DataFrame\nThe expected data from field observation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\nactual\npd.DataFrame\nThe actual data from the simulation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\n\n\n\n\n\ncalibration.step_containing(expected, actual)\nFind the step containing the the timepoint. Use for prevalent data like prevalence where you want to match a specific time point rather than interpolate.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\npd.DataFrame\nThe expected data from field observation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\nactual\npd.DataFrame\nThe actual data from the simulation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired",
    "crumbs": [
      "**Workflows**",
      "calibration"
    ]
  },
  {
    "objectID": "api/calibration.html#classes",
    "href": "api/calibration.html#classes",
    "title": "calibration",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nCalibComponent\nA class to compare a single channel of observed data with output from a\n\n\nCalibration\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter\n\n\n\n\n\ncalibration.CalibComponent(\n    name,\n    expected,\n    extract_fn,\n    conform,\n    weight=1,\n    include_fn=None,\n    n_boot=None,\n    combine_reps=None,\n)\nA class to compare a single channel of observed data with output from a simulation. The Calibration class can use several CalibComponent objects to form an overall understanding of how will a given simulation reflects observed data.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname (str)\n\nthe name of this component. Importantly, if extract_fn is None, the code will attempt to use the name, like “hiv.prevalence” to automatically extract data from the simulation.\nrequired\n\n\nexpected (df)\n\npandas DataFrame containing calibration data. The index should be the time ‘t’ in either floating point years or datetime.\nrequired\n\n\nextract_fn (callable)\n\na function to extract predicted/actual data in the same format and with the same columns as expected.\nrequired\n\n\nconform\nstr | callable\nspecify how to handle timepoints that don’t align exactly between the expected and the actual/predicted/simulated data so they “conform” to a common time grid. Whether the data represents a ‘prevalent’ or an ‘incident’ quantity impacts how this alignment is performed. If ‘prevalent’, it means data in expected & actual dataframes represent the current state of the system, stocks like the number of currently infected individuals. In this case, the data in ‘simulated’ or ‘actual’ will be interpolated to match the timepoints in ‘expected’, allowing for pointwise comparisons between the expected and actual data. If ‘incident’, it means data in expected & actual dataframes represent the accumulation of system states over a period of time, flows like the incidence of new infections. In this case, teh data in ‘simulated’ or ‘actual’ will be interpolated at the start (‘t’) and the end (‘t1’) of the period of interest in ‘expected’. The difference between these two interpolated values will be used for comparison. Finally, ‘step_containing’ is a special case for prevalent data where the actual data is interpolated using a “zero order hold” method. This means that the value of the actual (simulated) data is matched to the timepoint in the expected data that contains the timepoint of the actual data.\nrequired\n\n\nweight\nfloat\nThe weight applied to the log likelihood of this component. The total log likelihood is the sum of the log likelihoods of all components, each multiplied by its weight.\n1\n\n\ninclude_fn\ncallable\nA function accepting a single simulation and returning a boolean to determine if the simulation should be included in the current component. If None, all simulations are included.\nNone\n\n\nn_boot\nint\nExperimental! Bootstrap sum sim results over seeds before comparing against expected results. Not appropriate for all component types.\nNone\n\n\ncombine_reps\nstr\nHow to combine multiple repetitions of the same pars. Options are None, ‘mean’, ‘sum’, or other such operation. Default is None, which evaluates replicates independently instead of first combining before likelihood evaluation.\nNone\n\n\nkwargs\n\nAdditional arguments to pass to the likelihood function\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\neval\nCompute and return the negative log likelihood\n\n\n\n\n\ncalibration.CalibComponent.eval(sim, **kwargs)\nCompute and return the negative log likelihood\n\n\n\n\n\ncalibration.Calibration(\n    sim,\n    calib_pars,\n    n_workers=None,\n    total_trials=None,\n    reseed=True,\n    build_fn=None,\n    build_kw=None,\n    eval_fn=None,\n    eval_kw=None,\n    components=None,\n    prune_fn=None,\n    label=None,\n    study_name=None,\n    db_name=None,\n    keep_db=None,\n    continue_db=None,\n    storage=None,\n    sampler=None,\n    die=False,\n    debug=False,\n    verbose=True,\n)\nA class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter optimization library (optuna.org).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsim (Sim)\n\nthe base simulation to calibrate\nrequired\n\n\ncalib_pars (dict)\n\na dictionary of the parameters to calibrate of the format dict(key1=dict(low=1, high=2, guess=1.5, **kwargs), key2=...), where kwargs can include “suggest_type” to choose the suggest method of the trial (e.g. suggest_float) and args passed to the trial suggest function like “log” and “step”\nrequired\n\n\nn_workers (int)\n\nthe number of parallel workers (if None, will use all available CPUs)\nrequired\n\n\ntotal_trials (int)\n\nthe total number of trials to run, each worker will run approximately n_trials = total_trial / n_workers\nrequired\n\n\nreseed (bool)\n\nwhether to generate new random seeds for each trial\nrequired\n\n\nbuild_fn (callable)\n\nfunction that takes a sim object and calib_pars dictionary and returns a modified sim\nrequired\n\n\nbuild_kw (dict)\n\na dictionary of options that are passed to build_fn to aid in modifying the base simulation. The API is self.build_fn(sim, calib_pars=calib_pars, **self.build_kw), where sim is a copy of the base simulation to be modified with calib_pars\nrequired\n\n\ncomponents (list)\n\nCalibComponents independently assess pseudo-likelihood as part of evaluating the quality of input parameters\nrequired\n\n\nprune_fn (callable)\n\nFunction that takes a dictionary of parameters and returns True if the trial should be pruned\nrequired\n\n\neval_fn (callable)\n\nFunction mapping a sim to a float (e.g. negative log likelihood) to be maximized. If None, the default will use CalibComponents.\nrequired\n\n\neval_kw (dict)\n\nAdditional keyword arguments to pass to the eval_fn\nrequired\n\n\nlabel (str)\n\na label for this calibration object\nrequired\n\n\nstudy_name (str)\n\nname of the optuna study\nrequired\n\n\ndb_name (str)\n\nthe name of the database file (default: ‘starsim_calibration.db’)\nrequired\n\n\ncontinue_db (bool)\n\nwhether to continue if the database already exists, removes the database if false (default: false, any existing database will be deleted)\nrequired\n\n\nkeep_db (bool)\n\nwhether to keep the database after calibration (default: false, the database will be deleted)\nrequired\n\n\nstorage (str)\n\nthe location of the database (default: sqlite)\nrequired\n\n\nsampler\nBaseSampler\nthe sampler used by optuna, like optuna.samplers.TPESampler\nNone\n\n\ndie (bool)\n\nwhether to stop if an exception is encountered (default: false)\nrequired\n\n\ndebug (bool)\n\nif True, do not run in parallel\nrequired\n\n\nverbose (bool)\n\nwhether to print details of the calibration\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalibrate\nPerform calibration.\n\n\ncheck_fit\nRun before and after simulations to validate the fit\n\n\nmake_study\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\nparse_study\nParse the study into a data frame – called automatically\n\n\nplot\n”\n\n\nplot_final\nPlot sims after calibration\n\n\nplot_optuna\nPlot Optuna’s visualizations\n\n\nremove_db\nRemove the database file if keep_db is false and the path exists\n\n\nrun_sim\nCreate and run a simulation\n\n\nrun_trial\nDefine the objective for Optuna\n\n\nrun_workers\nRun multiple workers in parallel\n\n\nto_df\nReturn the top K results as a dataframe, sorted by value\n\n\nto_json\nConvert the results to JSON\n\n\nworker\nRun a single worker\n\n\n\n\n\ncalibration.Calibration.calibrate(calib_pars=None, **kwargs)\nPerform calibration.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncalib_pars\ndict\nif supplied, overwrite stored calib_pars\nNone\n\n\nkwargs\ndict\nif supplied, overwrite stored run_args (n_trials, n_workers, etc.)\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.check_fit(do_plot=True)\nRun before and after simulations to validate the fit\n\n\n\ncalibration.Calibration.make_study()\nMake a study, deleting if it already exists and user does not want to continue_db\n\n\n\ncalibration.Calibration.parse_study(study)\nParse the study into a data frame – called automatically\n\n\n\ncalibration.Calibration.plot(**kwargs)\n” Plot the calibration results. For a component-based likelihood, it only makes sense to directly call plot after calling eval_fn.\n\n\n\ncalibration.Calibration.plot_final(**kwargs)\nPlot sims after calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\npassed to MultiSim.plot()\n{}\n\n\n\n\n\n\n\ncalibration.Calibration.plot_optuna(methods=None)\nPlot Optuna’s visualizations\n\n\n\ncalibration.Calibration.remove_db()\nRemove the database file if keep_db is false and the path exists\n\n\n\ncalibration.Calibration.run_sim(calib_pars=None, label=None)\nCreate and run a simulation\n\n\n\ncalibration.Calibration.run_trial(trial)\nDefine the objective for Optuna\n\n\n\ncalibration.Calibration.run_workers()\nRun multiple workers in parallel\n\n\n\ncalibration.Calibration.to_df(top_k=None)\nReturn the top K results as a dataframe, sorted by value\n\n\n\ncalibration.Calibration.to_json(filename=None, indent=2, **kwargs)\nConvert the results to JSON\n\n\n\ncalibration.Calibration.worker()\nRun a single worker",
    "crumbs": [
      "**Workflows**",
      "calibration"
    ]
  },
  {
    "objectID": "api/calibration.html#functions",
    "href": "api/calibration.html#functions",
    "title": "calibration",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nlinear_accum\nInterpolate in the cumulative sum, then difference. Use for incident data\n\n\nlinear_interp\nSimply interpolate, use for prevalent (stock) data like prevalence\n\n\nstep_containing\nFind the step containing the the timepoint. Use for prevalent data like\n\n\n\n\n\ncalibration.linear_accum(expected, actual)\nInterpolate in the cumulative sum, then difference. Use for incident data (flows) like incidence or new_deaths. The accumulation is done between ‘t’ and ‘t1’, both of which must be present in the index of expected and actual dataframes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\npd.DataFrame\nThe expected data from field observation, must have ‘t’ and ‘t1’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\nactual\npd.DataFrame\nThe actual data from the simulation, must have ‘t’ and ‘t1’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\n\n\n\n\n\ncalibration.linear_interp(expected, actual)\nSimply interpolate, use for prevalent (stock) data like prevalence\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\npd.DataFrame\nThe expected data from field observation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\nactual\npd.DataFrame\nThe actual data from the simulation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\n\n\n\n\n\ncalibration.step_containing(expected, actual)\nFind the step containing the the timepoint. Use for prevalent data like prevalence where you want to match a specific time point rather than interpolate.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpected\npd.DataFrame\nThe expected data from field observation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired\n\n\nactual\npd.DataFrame\nThe actual data from the simulation, must have ‘t’ in the index and columns corresponding to specific needs of the selected component.\nrequired",
    "crumbs": [
      "**Workflows**",
      "calibration"
    ]
  },
  {
    "objectID": "api/networks.html",
    "href": "api/networks.html",
    "title": "networks",
    "section": "",
    "text": "networks\nNetworks that connect people within a population\n\n\n\n\n\nName\nDescription\n\n\n\n\nAgeGroup\nA simple age-based filter that returns uids of agents that match the criteria\n\n\nBreastfeedingNet\nNetwork for breastfeeding transmission\n\n\nDynamicNetwork\nA network where partnerships update dynamically\n\n\nMFNet\nThis network is built by randomly pairing males and female with variable\n\n\nMSMNet\nA network that randomly pairs males\n\n\nMaternalNet\nTEMP - for backwards compatibility\n\n\nMixingPool\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\nMixingPools\nA container for creating a rectangular array of MixingPool instances\n\n\nNetwork\nA class holding a single network of contact edges (connections) between people\n\n\nPostnatalNet\nNetwork to track postnatal processes\n\n\nPrenatalNet\nPrenatal transmission network\n\n\nRandomNet\nRandom connectivity between agents\n\n\nRandomSafeNet\nCreate a CRN-safe, O(N) random network\n\n\nRoute\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\nSexualNetwork\nBase class for all sexual networks\n\n\nStaticNet\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships\n\n\n\n\n\nnetworks.AgeGroup(low, high, do_cache=True)\nA simple age-based filter that returns uids of agents that match the criteria\n\n\n\nnetworks.BreastfeedingNet(pars=None, **kwargs)\nNetwork for breastfeeding transmission\nTo model breastfeeding transmission, include this network in a Sim that contains a Pregnancy module. Edges will be automatically added and removed from this network tracking the breastfeeding status from the Pregnancy module.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nAdd pairs upon delivery if the mother is breastfeeding the newborn - called via Pregnancy.process_delivery()\n\n\nend_pairs\nRemove edges for mothers whose breastfeeding status has changed in the Pregnancy module\n\n\n\n\n\nnetworks.BreastfeedingNet.add_pairs(mother_uids=None, newborn_uids=None)\nAdd pairs upon delivery if the mother is breastfeeding the newborn - called via Pregnancy.process_delivery()\n\n\n\nnetworks.BreastfeedingNet.end_pairs()\nRemove edges for mothers whose breastfeeding status has changed in the Pregnancy module\n\n\n\n\n\nnetworks.DynamicNetwork(**kwargs)\nA network where partnerships update dynamically\n\n\n\nnetworks.MFNet(\n    pars=None,\n    duration=_,\n    debut=_,\n    acts=_,\n    participation=_,\n    rel_part_rates=_,\n    **kwargs,\n)\nThis network is built by randomly pairing males and female with variable relationship durations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nduration\nss.Dist\nCan vary by age, year, and individual pair. Set scale=exp(mu) and s=sigma where mu,sigma are of the underlying normal distribution.\n_\n\n\ndebut\nss.Dist\nAge of debut can vary by using callable parameter values\n_\n\n\nacts\nss.Dist\nNumber of acts per year\n_\n\n\nparticipation\nss.Dist\nProbability of participating in this network - can vary by individual properties (age, sex, …) using callable parameter values\n_\n\n\nrel_part_rates\nfloat\nRelative participation in the network\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_debut\nSet debut age\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\nset_participation\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MFNet.set_debut(upper_age=None)\nSet debut age\n\n\n\nnetworks.MFNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\nnetworks.MFNet.set_participation(upper_age=None)\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MSMNet(\n    pars=None,\n    duration=_,\n    debut=_,\n    acts=_,\n    participation=_,\n    **kwargs,\n)\nA network that randomly pairs males\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nduration\nss.Dist\nCan vary by age, year, and individual pair. Set scale=exp(mu) and s=sigma where mu,sigma are of the underlying normal distribution.\n_\n\n\ndebut\nss.Dist\nAge of debut can vary by using callable parameter values\n_\n\n\nacts\nss.Dist\nNumber of acts per year\n_\n\n\nparticipation\nss.Dist\nProbability of participating in this network - can vary by individual properties (age, sex, …) using callable parameter values\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nPair all unpartnered MSM\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MSMNet.add_pairs()\nPair all unpartnered MSM\n\n\n\nnetworks.MSMNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MaternalNet(name=None, label=None, **kwargs)\nTEMP - for backwards compatibility\n\n\n\nnetworks.MixingPool(\n    pars=None,\n    diseases=_,\n    src=_,\n    dst=_,\n    beta=_,\n    n_contacts=_,\n    **kwargs,\n)\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via this mixing pool\n_\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\n_\n\n\ndst\ninds\ndestination agents; as above\n_\n\n\nbeta\nfloat\noverall transmission (note: use a float, not a TimePar; the time component is usually handled by the disease beta)\n_\n\n\nn_contacts\nDist\nthe number of effective contacts of the destination agents\n_\n\n\n\nExample:\nimport starsim as ss\n\n# Set the parameters\nmp_pars = dict(\n    src = lambda sim: sim.people.male, # only males are infectious\n    dst = None, # all agents are susceptible\n    beta = ss.Rate(0.2),\n    n_contacts = ss.poisson(lam=4),\n)\n\n# Seed 5% of the male population\ndef p_init(self, sim, uids):\n    return 0.05*sim.people.male\n\n# Create and run the sim\nsis = ss.SIS(init_prev=p_init)\nmp = ss.MixingPool(**mp_pars)\nsim = ss.Sim(diseases=sis, networks=mp)\nsim.run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCalculate transmission\n\n\nremove_uids\nIf UIDs are supplied explicitly, remove them if people die\n\n\nshrink\nShrink the size of the mixing pool for saving to disk\n\n\nstep\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPool.compute_transmission(\n    rel_sus,\n    rel_trans,\n    disease_beta,\n    disease,\n)\nCalculate transmission\nThis is called from Infection.infect() together with network transmission.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrel_sus\nfloat\nRelative susceptibility\nrequired\n\n\nrel_trans\nfloat\nRelative infectiousness\nrequired\n\n\ndisease_beta\nfloat\nThe beta value for the disease\nrequired\n\n\n\nReturns: UIDs of agents who acquired the disease at this step\n\n\n\n\nnetworks.MixingPool.remove_uids(uids)\nIf UIDs are supplied explicitly, remove them if people die\n\n\n\nnetworks.MixingPool.shrink()\nShrink the size of the mixing pool for saving to disk\n\n\n\nnetworks.MixingPool.step()\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPools(\n    pars=None,\n    diseases=_,\n    src=_,\n    dst=_,\n    beta=_,\n    n_contacts=_,\n    **kwargs,\n)\nA container for creating a rectangular array of MixingPool instances\nBy default, separates the population into &lt;15 and &gt;15 age groups.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via these mixing pools\n_\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\n_\n\n\ndst\ninds\ndestination agents; as above\n_\n\n\nbeta\nfloat\noverall transmission via these mixing pools\n_\n\n\nn_contacts\narray\nthe relative connectivity between different mixing pools (can be float or Dist)\n_\n\n\n\nExample:\nimport starsim as ss\nmps = ss.MixingPools(\n    diseases = 'sis',\n    beta = 0.1,\n    src = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    dst = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    n_contacts = [[2.4, 0.49], [0.91, 0.16]],\n)\nsim = ss.Sim(diseases='sis', networks=mps).run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_post\nInitialize each mixing pool\n\n\nremove_uids\nRemove UIDs from each mixing pool\n\n\nvalidate_pars\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.MixingPools.init_post()\nInitialize each mixing pool\n\n\n\nnetworks.MixingPools.remove_uids(uids)\nRemove UIDs from each mixing pool\n\n\n\nnetworks.MixingPools.validate_pars()\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.Network(name=None, label=None, **kwargs)\nA class holding a single network of contact edges (connections) between people as well as methods for updating these.\nThe input is typically arrays including: person 1 of the connection, person 2 of the connection, the weight of the connection, the duration and start/end times of the connection.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np1\narray\nan array of length N, the number of connections in the network, with the indices of people on one side of the connection.\nrequired\n\n\np2\narray\nan array of length N, the number of connections in the network, with the indices of people on the other side of the connection.\nrequired\n\n\nbeta\narray\nan array representing relative transmissibility of each connection for this network - TODO, do we need this?\nrequired\n\n\nlabel\nstr\nthe name of the network (optional)\nNone\n\n\nkwargs\ndict\nother keys copied directly into the network\n{}\n\n\n\nNote that all arguments (except for label) must be arrays of the same length, although not all have to be supplied at the time of creation (they must all be the same at the time of initialization, though, or else validation will fail).\nExamples:\n# Generate an average of 10 contacts for 1000 people\nn_contacts_pp = 10\nn_people = 1000\nn = n_contacts_pp * n_people\np1 = np.random.randint(n_people, size=n)\np2 = np.random.randint(n_people, size=n)\nbeta = np.ones(n)\nnetwork = ss.Network(p1=p1, p2=p2, beta=beta, label='rand')\nnetwork = ss.Network(dict(p1=p1, p2=p2, beta=beta), label='rand') # Alternate method\n\n# Convert one network to another with extra columns\nindex = np.arange(n)\nself_conn = p1 == p2\nnetwork2 = ss.Network(**network, index=index, self_conn=self_conn, label=network.label)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbeta\nRelative transmission on each network edge\n\n\nmembers\nReturn sorted array of all members\n\n\np1\nThe first half of a network edge (person 1)\n\n\np2\nThe second half of a network edge (person 2)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nDefine how pairs of people are formed\n\n\nappend\nAppend edges to the current network.\n\n\nfind_contacts\nFind all contacts of the specified people\n\n\nfrom_df\nConvert from a dataframe\n\n\nget_inds\nGet the specified indices from the edgelist and return them as a dict.\n\n\ninit_pre\nInitialize with the sim, initialize the edges, and validate p1 and p2\n\n\ninit_results\nStore network length by default\n\n\nmeta_keys\nReturn the keys for the network’s meta information\n\n\nnet_beta\nCalculate the beta for the given disease and network\n\n\nplot\nPlot the network using NetworkX.\n\n\npop_inds\n“Pop” the specified indices from the edgelist and return them as a dict.\n\n\nremove_uids\nRemove interactions involving specified UIDs\n\n\nset_network_states\nMany network states depend on properties of people – e.g. MSM depends on being male,\n\n\nshrink\nShrink the size of the network for saving to disk\n\n\nto_df\nConvert to dataframe\n\n\nto_dict\nConvert to dictionary\n\n\nto_edgelist\nConvert the network to a list of edges (paired nodes)\n\n\nto_graph\nConvert to a networkx DiGraph\n\n\nupdate_results\nStore the number of edges in the network\n\n\nvalidate\nCheck the integrity of the network: right types, right lengths.\n\n\nvalidate_uids\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.Network.add_pairs()\nDefine how pairs of people are formed\n\n\n\nnetworks.Network.append(edges=None, **kwargs)\nAppend edges to the current network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nedges\ndict\na dictionary of arrays with keys p1,p2,beta, as returned from network.pop_inds()\nNone\n\n\n\n\n\n\n\nnetworks.Network.find_contacts(inds, as_array=True)\nFind all contacts of the specified people\nFor some purposes (e.g. contact tracing) it’s necessary to find all the edges associated with a subset of the people in this network. Since edges are bidirectional it’s necessary to check both p1 and p2 for the target indices. The return type is a Set so that there is no duplication of indices (otherwise if the Network has explicit symmetric interactions, they could appear multiple times). This is also for performance so that the calling code doesn’t need to perform its own unique() operation. Note that this cannot be used for cases where multiple connections count differently than a single infection, e.g. exposure risk.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\narray\nindices of people whose edges to return\nrequired\n\n\nas_array\nbool\nif true, return as sorted array (otherwise, return as unsorted set)\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncontact_inds\narray\na set of indices for pairing partners\n\n\n\nExample: If there were a network with - p1 = [1,2,3,4] - p2 = [2,3,1,4] Then find_edges([1,3]) would return {1,2,3}\n\n\n\n\nnetworks.Network.from_df(df, keys=None)\nConvert from a dataframe\n\n\n\nnetworks.Network.get_inds(inds, remove=False)\nGet the specified indices from the edgelist and return them as a dict.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to find\nrequired\n\n\nremove\nbool\nwhether to remove the indices\nFalse\n\n\n\n\n\n\n\nnetworks.Network.init_pre(sim)\nInitialize with the sim, initialize the edges, and validate p1 and p2\n\n\n\nnetworks.Network.init_results()\nStore network length by default\n\n\n\nnetworks.Network.meta_keys()\nReturn the keys for the network’s meta information\n\n\n\nnetworks.Network.net_beta(disease_beta=None, inds=None, disease=None)\nCalculate the beta for the given disease and network\n\n\n\nnetworks.Network.plot(max_edges=500, random=False, alpha=0.2, **kwargs)\nPlot the network using NetworkX.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\n500\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\nalpha\nfloat\nthe alpha value of the edges\n0.2\n\n\nkwargs\ndict\npassed to nx.draw_networkx()\n{}\n\n\n\n\n\n\n\nnetworks.Network.pop_inds(inds)\n“Pop” the specified indices from the edgelist and return them as a dict. Returns arguments in the right format to be used with network.append().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to be removed\nrequired\n\n\n\n\n\n\n\nnetworks.Network.remove_uids(uids)\nRemove interactions involving specified UIDs This method is typically called via People.remove() and is specifically used when removing agents from the simulation.\n\n\n\nnetworks.Network.set_network_states(people)\nMany network states depend on properties of people – e.g. MSM depends on being male, age of debut varies by sex and over time, and participation rates vary by age. Each time states are dynamically grown, this function should be called to set the network states that depend on other states.\n\n\n\nnetworks.Network.shrink()\nShrink the size of the network for saving to disk\n\n\n\nnetworks.Network.to_df()\nConvert to dataframe\n\n\n\nnetworks.Network.to_dict()\nConvert to dictionary\n\n\n\nnetworks.Network.to_edgelist()\nConvert the network to a list of edges (paired nodes)\n\n\n\nnetworks.Network.to_graph(max_edges=None, random=False)\nConvert to a networkx DiGraph\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\nNone\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\n\nExample:\nimport networkx as nx\nsim = ss.Sim(n_agents=100, networks='mf').init()\nG = sim.networks.randomnet.to_graph()\nnx.draw(G)\n\n\n\n\nnetworks.Network.update_results()\nStore the number of edges in the network\n\n\n\nnetworks.Network.validate(force=True)\nCheck the integrity of the network: right types, right lengths.\nIf dtype is incorrect, try to convert automatically; if length is incorrect, do not.\n\n\n\nnetworks.Network.validate_uids()\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.PostnatalNet(pars=None, dur=None, **kwargs)\nNetwork to track postnatal processes\nThis network automatically has edges added between mothers and infants upon birth if a Pregnancy module is present in the simulation. The edges persist until the specified duration has elapsed, at which point they are automatically removed. This allows different PostnatalNet instances have different postnatal periods specific to what is being modelled. Transmission along this network is possible if a beta value &gt;0 is specified. Otherwise, transmission will be skipped.\nBy default, the postnatal duration is based on the maternal UID and would be the same for all infants of that mother, although derived classes could modify this behavior.\n\n\n\nnetworks.PrenatalNet(name=None, label=None, **kwargs)\nPrenatal transmission network\nAlthough edges change over time, the edges are managed via ss.Pregnancy as pregnancies start and finish. The prenatal network therefore is not derived from DynamicNetwork as it does not manage its own updates.\n\n\n\nnetworks.RandomNet(pars=None, n_contacts=_, dur=_, beta=_, **kwargs)\nRandom connectivity between agents\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_contacts\nint/ss.Dist\nthe average number of (bidirectional) contacts between agents\n_\n\n\ndur\nint/ss.dur\nthe duration of each contact\n_\n\n\nbeta\nfloat\nthe default beta value for each edge\n_\n\n\n\nNote: n_contacts = 10 will create 5 edges per agent. Since disease transmission usually occurs bidirectionally, this means that the effective number of contacts per agent is actually 10. Consider 3 agents with 3 edges between them (a triangle): each agent is connected to 2 other agents.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate edges\n\n\nget_edges\nEfficiently find edges\n\n\nget_source\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.RandomNet.add_pairs()\nGenerate edges\n\n\n\nnetworks.RandomNet.get_edges(inds, n_contacts)\nEfficiently find edges\nNote that because of the shuffling operation, each person is assigned 2N contacts (i.e. if a person has 5 contacts, they appear 5 times in the ‘source’ array and 5 times in the ‘target’ array). Therefore, the n_contacts argument to this function should be HALF of the total contacts a person is expected to have, if both the source and target array outputs are used (e.g. for social contacts)\nadjusted_number_of_contacts = np.round(n_contacts / 2).astype(ss.dtype.int)\nWhereas for asymmetric contacts (e.g. staff-public interactions) it might not be necessary\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\nlist / array\nperson indices\nrequired\n\n\nn_contacts\nlist / array\nthe same length as inds with the number of bidirectional contacts to assign to each person\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nTwo arrays, for source and target\n\n\n\n\n\n\n\nnetworks.RandomNet.get_source(inds, n_contacts)\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.RandomSafeNet(pars=None, n_edges=_, dur=_, beta=_, **kwargs)\nCreate a CRN-safe, O(N) random network\nThis network is similar to ss.RandomNet(), but is random-number safe (i.e., the addition of a single new agent will not perturb the entire rest of the network). However, it is somewhat slower than ss.RandomNet(), so should be used where CRN safety is important (e.g., scenario analysis).\nNote: ss.RandomNet uses n_contacts, which is the total number of contacts per agent. ss.RandomSateNet users n_edges, which is the total number of edges per agent. Since contacts are usually bidirectional, n_contacts = 2*n_edges. For example, ss.RandomNet(n_contacts=10) will give (nearly) identical results to ss.RandomSafeNet(n_edges=5). In addition, whereas n_contacts can be a distribution, n_edges can only be an integer.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_edges\nint\nthe average number of (bi-directional) edges between agents\n_\n\n\ndur\nint/ss.dur\nthe duration of each contact\n_\n\n\nbeta\nfloat\nthe default beta value for each edge\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate edges\n\n\nform_pairs\nFrom a 2N input array, return 2N-2 nearest-neighbor pairs\n\n\nplot_matrix\nPlot the distance matrix used for forming pairs: only ±1 from the diagonal is used\n\n\nrep_rand\nReproducible repeated random numbers\n\n\n\n\n\nnetworks.RandomSafeNet.add_pairs()\nGenerate edges\n\n\n\nnetworks.RandomSafeNet.form_pairs(debug=False)\nFrom a 2N input array, return 2N-2 nearest-neighbor pairs\n\n\n\nnetworks.RandomSafeNet.plot_matrix(**kwargs)\nPlot the distance matrix used for forming pairs: only ±1 from the diagonal is used\n\n\n\nnetworks.RandomSafeNet.rep_rand(uids, sort=True)\nReproducible repeated random numbers\n\n\n\n\n\nnetworks.Route(name=None, label=None, **kwargs)\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\n\nnetworks.SexualNetwork(**kwargs)\nBase class for all sexual networks\n\n\n\nnetworks.StaticNet(graph=None, pars=None, **kwargs)\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships and initialized partnerships only end when one of the partners dies. The networkx graph can be created outside Starsim if population size is known. Or the graph can be created by passing a networkx generator function to Starsim.\nIf “seed=True” is passed as a keyword argument or a parameter in pars, it is replaced with the built-in RNG. The parameter “n” is supplied automatically to be equal to n_agents.\nExamples:\n# Generate a networkx graph and pass to Starsim\nimport networkx as nx\nimport starsim as ss\ng = nx.scale_free_graph(n=10000)\nss.StaticNet(graph=g)\n\n# Pass a networkx graph generator to Starsim\nss.StaticNet(graph=nx.erdos_renyi_graph, p=0.0001, seed=True)",
    "crumbs": [
      "**Modules**",
      "networks"
    ]
  },
  {
    "objectID": "api/networks.html#classes",
    "href": "api/networks.html#classes",
    "title": "networks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAgeGroup\nA simple age-based filter that returns uids of agents that match the criteria\n\n\nBreastfeedingNet\nNetwork for breastfeeding transmission\n\n\nDynamicNetwork\nA network where partnerships update dynamically\n\n\nMFNet\nThis network is built by randomly pairing males and female with variable\n\n\nMSMNet\nA network that randomly pairs males\n\n\nMaternalNet\nTEMP - for backwards compatibility\n\n\nMixingPool\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\nMixingPools\nA container for creating a rectangular array of MixingPool instances\n\n\nNetwork\nA class holding a single network of contact edges (connections) between people\n\n\nPostnatalNet\nNetwork to track postnatal processes\n\n\nPrenatalNet\nPrenatal transmission network\n\n\nRandomNet\nRandom connectivity between agents\n\n\nRandomSafeNet\nCreate a CRN-safe, O(N) random network\n\n\nRoute\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\nSexualNetwork\nBase class for all sexual networks\n\n\nStaticNet\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships\n\n\n\n\n\nnetworks.AgeGroup(low, high, do_cache=True)\nA simple age-based filter that returns uids of agents that match the criteria\n\n\n\nnetworks.BreastfeedingNet(pars=None, **kwargs)\nNetwork for breastfeeding transmission\nTo model breastfeeding transmission, include this network in a Sim that contains a Pregnancy module. Edges will be automatically added and removed from this network tracking the breastfeeding status from the Pregnancy module.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nAdd pairs upon delivery if the mother is breastfeeding the newborn - called via Pregnancy.process_delivery()\n\n\nend_pairs\nRemove edges for mothers whose breastfeeding status has changed in the Pregnancy module\n\n\n\n\n\nnetworks.BreastfeedingNet.add_pairs(mother_uids=None, newborn_uids=None)\nAdd pairs upon delivery if the mother is breastfeeding the newborn - called via Pregnancy.process_delivery()\n\n\n\nnetworks.BreastfeedingNet.end_pairs()\nRemove edges for mothers whose breastfeeding status has changed in the Pregnancy module\n\n\n\n\n\nnetworks.DynamicNetwork(**kwargs)\nA network where partnerships update dynamically\n\n\n\nnetworks.MFNet(\n    pars=None,\n    duration=_,\n    debut=_,\n    acts=_,\n    participation=_,\n    rel_part_rates=_,\n    **kwargs,\n)\nThis network is built by randomly pairing males and female with variable relationship durations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nduration\nss.Dist\nCan vary by age, year, and individual pair. Set scale=exp(mu) and s=sigma where mu,sigma are of the underlying normal distribution.\n_\n\n\ndebut\nss.Dist\nAge of debut can vary by using callable parameter values\n_\n\n\nacts\nss.Dist\nNumber of acts per year\n_\n\n\nparticipation\nss.Dist\nProbability of participating in this network - can vary by individual properties (age, sex, …) using callable parameter values\n_\n\n\nrel_part_rates\nfloat\nRelative participation in the network\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_debut\nSet debut age\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\nset_participation\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MFNet.set_debut(upper_age=None)\nSet debut age\n\n\n\nnetworks.MFNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\nnetworks.MFNet.set_participation(upper_age=None)\nSet people who will participate in the network at some point\n\n\n\n\n\nnetworks.MSMNet(\n    pars=None,\n    duration=_,\n    debut=_,\n    acts=_,\n    participation=_,\n    **kwargs,\n)\nA network that randomly pairs males\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nduration\nss.Dist\nCan vary by age, year, and individual pair. Set scale=exp(mu) and s=sigma where mu,sigma are of the underlying normal distribution.\n_\n\n\ndebut\nss.Dist\nAge of debut can vary by using callable parameter values\n_\n\n\nacts\nss.Dist\nNumber of acts per year\n_\n\n\nparticipation\nss.Dist\nProbability of participating in this network - can vary by individual properties (age, sex, …) using callable parameter values\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nPair all unpartnered MSM\n\n\nset_network_states\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MSMNet.add_pairs()\nPair all unpartnered MSM\n\n\n\nnetworks.MSMNet.set_network_states(upper_age=None)\nSet network states including age of entry into network and participation rates\n\n\n\n\n\nnetworks.MaternalNet(name=None, label=None, **kwargs)\nTEMP - for backwards compatibility\n\n\n\nnetworks.MixingPool(\n    pars=None,\n    diseases=_,\n    src=_,\n    dst=_,\n    beta=_,\n    n_contacts=_,\n    **kwargs,\n)\nDefine a single mixing pool; can be used as a drop-in replacement for a network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via this mixing pool\n_\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\n_\n\n\ndst\ninds\ndestination agents; as above\n_\n\n\nbeta\nfloat\noverall transmission (note: use a float, not a TimePar; the time component is usually handled by the disease beta)\n_\n\n\nn_contacts\nDist\nthe number of effective contacts of the destination agents\n_\n\n\n\nExample:\nimport starsim as ss\n\n# Set the parameters\nmp_pars = dict(\n    src = lambda sim: sim.people.male, # only males are infectious\n    dst = None, # all agents are susceptible\n    beta = ss.Rate(0.2),\n    n_contacts = ss.poisson(lam=4),\n)\n\n# Seed 5% of the male population\ndef p_init(self, sim, uids):\n    return 0.05*sim.people.male\n\n# Create and run the sim\nsis = ss.SIS(init_prev=p_init)\nmp = ss.MixingPool(**mp_pars)\nsim = ss.Sim(diseases=sis, networks=mp)\nsim.run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_transmission\nCalculate transmission\n\n\nremove_uids\nIf UIDs are supplied explicitly, remove them if people die\n\n\nshrink\nShrink the size of the mixing pool for saving to disk\n\n\nstep\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPool.compute_transmission(\n    rel_sus,\n    rel_trans,\n    disease_beta,\n    disease,\n)\nCalculate transmission\nThis is called from Infection.infect() together with network transmission.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrel_sus\nfloat\nRelative susceptibility\nrequired\n\n\nrel_trans\nfloat\nRelative infectiousness\nrequired\n\n\ndisease_beta\nfloat\nThe beta value for the disease\nrequired\n\n\n\nReturns: UIDs of agents who acquired the disease at this step\n\n\n\n\nnetworks.MixingPool.remove_uids(uids)\nIf UIDs are supplied explicitly, remove them if people die\n\n\n\nnetworks.MixingPool.shrink()\nShrink the size of the mixing pool for saving to disk\n\n\n\nnetworks.MixingPool.step()\nUpdate source and target UIDs\n\n\n\n\n\nnetworks.MixingPools(\n    pars=None,\n    diseases=_,\n    src=_,\n    dst=_,\n    beta=_,\n    n_contacts=_,\n    **kwargs,\n)\nA container for creating a rectangular array of MixingPool instances\nBy default, separates the population into &lt;15 and &gt;15 age groups.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiseases\nstr\nthe diseases that transmit via these mixing pools\n_\n\n\nsrc\ninds\nsource agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents\n_\n\n\ndst\ninds\ndestination agents; as above\n_\n\n\nbeta\nfloat\noverall transmission via these mixing pools\n_\n\n\nn_contacts\narray\nthe relative connectivity between different mixing pools (can be float or Dist)\n_\n\n\n\nExample:\nimport starsim as ss\nmps = ss.MixingPools(\n    diseases = 'sis',\n    beta = 0.1,\n    src = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    dst = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},\n    n_contacts = [[2.4, 0.49], [0.91, 0.16]],\n)\nsim = ss.Sim(diseases='sis', networks=mps).run()\nsim.plot()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_post\nInitialize each mixing pool\n\n\nremove_uids\nRemove UIDs from each mixing pool\n\n\nvalidate_pars\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.MixingPools.init_post()\nInitialize each mixing pool\n\n\n\nnetworks.MixingPools.remove_uids(uids)\nRemove UIDs from each mixing pool\n\n\n\nnetworks.MixingPools.validate_pars()\nCheck that src and dst have correct types, and contacts is the correct shape\n\n\n\n\n\nnetworks.Network(name=None, label=None, **kwargs)\nA class holding a single network of contact edges (connections) between people as well as methods for updating these.\nThe input is typically arrays including: person 1 of the connection, person 2 of the connection, the weight of the connection, the duration and start/end times of the connection.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np1\narray\nan array of length N, the number of connections in the network, with the indices of people on one side of the connection.\nrequired\n\n\np2\narray\nan array of length N, the number of connections in the network, with the indices of people on the other side of the connection.\nrequired\n\n\nbeta\narray\nan array representing relative transmissibility of each connection for this network - TODO, do we need this?\nrequired\n\n\nlabel\nstr\nthe name of the network (optional)\nNone\n\n\nkwargs\ndict\nother keys copied directly into the network\n{}\n\n\n\nNote that all arguments (except for label) must be arrays of the same length, although not all have to be supplied at the time of creation (they must all be the same at the time of initialization, though, or else validation will fail).\nExamples:\n# Generate an average of 10 contacts for 1000 people\nn_contacts_pp = 10\nn_people = 1000\nn = n_contacts_pp * n_people\np1 = np.random.randint(n_people, size=n)\np2 = np.random.randint(n_people, size=n)\nbeta = np.ones(n)\nnetwork = ss.Network(p1=p1, p2=p2, beta=beta, label='rand')\nnetwork = ss.Network(dict(p1=p1, p2=p2, beta=beta), label='rand') # Alternate method\n\n# Convert one network to another with extra columns\nindex = np.arange(n)\nself_conn = p1 == p2\nnetwork2 = ss.Network(**network, index=index, self_conn=self_conn, label=network.label)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbeta\nRelative transmission on each network edge\n\n\nmembers\nReturn sorted array of all members\n\n\np1\nThe first half of a network edge (person 1)\n\n\np2\nThe second half of a network edge (person 2)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nDefine how pairs of people are formed\n\n\nappend\nAppend edges to the current network.\n\n\nfind_contacts\nFind all contacts of the specified people\n\n\nfrom_df\nConvert from a dataframe\n\n\nget_inds\nGet the specified indices from the edgelist and return them as a dict.\n\n\ninit_pre\nInitialize with the sim, initialize the edges, and validate p1 and p2\n\n\ninit_results\nStore network length by default\n\n\nmeta_keys\nReturn the keys for the network’s meta information\n\n\nnet_beta\nCalculate the beta for the given disease and network\n\n\nplot\nPlot the network using NetworkX.\n\n\npop_inds\n“Pop” the specified indices from the edgelist and return them as a dict.\n\n\nremove_uids\nRemove interactions involving specified UIDs\n\n\nset_network_states\nMany network states depend on properties of people – e.g. MSM depends on being male,\n\n\nshrink\nShrink the size of the network for saving to disk\n\n\nto_df\nConvert to dataframe\n\n\nto_dict\nConvert to dictionary\n\n\nto_edgelist\nConvert the network to a list of edges (paired nodes)\n\n\nto_graph\nConvert to a networkx DiGraph\n\n\nupdate_results\nStore the number of edges in the network\n\n\nvalidate\nCheck the integrity of the network: right types, right lengths.\n\n\nvalidate_uids\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.Network.add_pairs()\nDefine how pairs of people are formed\n\n\n\nnetworks.Network.append(edges=None, **kwargs)\nAppend edges to the current network.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nedges\ndict\na dictionary of arrays with keys p1,p2,beta, as returned from network.pop_inds()\nNone\n\n\n\n\n\n\n\nnetworks.Network.find_contacts(inds, as_array=True)\nFind all contacts of the specified people\nFor some purposes (e.g. contact tracing) it’s necessary to find all the edges associated with a subset of the people in this network. Since edges are bidirectional it’s necessary to check both p1 and p2 for the target indices. The return type is a Set so that there is no duplication of indices (otherwise if the Network has explicit symmetric interactions, they could appear multiple times). This is also for performance so that the calling code doesn’t need to perform its own unique() operation. Note that this cannot be used for cases where multiple connections count differently than a single infection, e.g. exposure risk.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\narray\nindices of people whose edges to return\nrequired\n\n\nas_array\nbool\nif true, return as sorted array (otherwise, return as unsorted set)\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncontact_inds\narray\na set of indices for pairing partners\n\n\n\nExample: If there were a network with - p1 = [1,2,3,4] - p2 = [2,3,1,4] Then find_edges([1,3]) would return {1,2,3}\n\n\n\n\nnetworks.Network.from_df(df, keys=None)\nConvert from a dataframe\n\n\n\nnetworks.Network.get_inds(inds, remove=False)\nGet the specified indices from the edgelist and return them as a dict.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to find\nrequired\n\n\nremove\nbool\nwhether to remove the indices\nFalse\n\n\n\n\n\n\n\nnetworks.Network.init_pre(sim)\nInitialize with the sim, initialize the edges, and validate p1 and p2\n\n\n\nnetworks.Network.init_results()\nStore network length by default\n\n\n\nnetworks.Network.meta_keys()\nReturn the keys for the network’s meta information\n\n\n\nnetworks.Network.net_beta(disease_beta=None, inds=None, disease=None)\nCalculate the beta for the given disease and network\n\n\n\nnetworks.Network.plot(max_edges=500, random=False, alpha=0.2, **kwargs)\nPlot the network using NetworkX.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\n500\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\nalpha\nfloat\nthe alpha value of the edges\n0.2\n\n\nkwargs\ndict\npassed to nx.draw_networkx()\n{}\n\n\n\n\n\n\n\nnetworks.Network.pop_inds(inds)\n“Pop” the specified indices from the edgelist and return them as a dict. Returns arguments in the right format to be used with network.append().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\n(int, array, slice)\nthe indices to be removed\nrequired\n\n\n\n\n\n\n\nnetworks.Network.remove_uids(uids)\nRemove interactions involving specified UIDs This method is typically called via People.remove() and is specifically used when removing agents from the simulation.\n\n\n\nnetworks.Network.set_network_states(people)\nMany network states depend on properties of people – e.g. MSM depends on being male, age of debut varies by sex and over time, and participation rates vary by age. Each time states are dynamically grown, this function should be called to set the network states that depend on other states.\n\n\n\nnetworks.Network.shrink()\nShrink the size of the network for saving to disk\n\n\n\nnetworks.Network.to_df()\nConvert to dataframe\n\n\n\nnetworks.Network.to_dict()\nConvert to dictionary\n\n\n\nnetworks.Network.to_edgelist()\nConvert the network to a list of edges (paired nodes)\n\n\n\nnetworks.Network.to_graph(max_edges=None, random=False)\nConvert to a networkx DiGraph\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_edges\nint\nthe maximum number of edges to show\nNone\n\n\nrandom\nbool\nif true, select edges randomly; otherwise, show the first N\nFalse\n\n\n\nExample:\nimport networkx as nx\nsim = ss.Sim(n_agents=100, networks='mf').init()\nG = sim.networks.randomnet.to_graph()\nnx.draw(G)\n\n\n\n\nnetworks.Network.update_results()\nStore the number of edges in the network\n\n\n\nnetworks.Network.validate(force=True)\nCheck the integrity of the network: right types, right lengths.\nIf dtype is incorrect, try to convert automatically; if length is incorrect, do not.\n\n\n\nnetworks.Network.validate_uids()\nEnsure that p1, p2 are both UID arrays\n\n\n\n\n\nnetworks.PostnatalNet(pars=None, dur=None, **kwargs)\nNetwork to track postnatal processes\nThis network automatically has edges added between mothers and infants upon birth if a Pregnancy module is present in the simulation. The edges persist until the specified duration has elapsed, at which point they are automatically removed. This allows different PostnatalNet instances have different postnatal periods specific to what is being modelled. Transmission along this network is possible if a beta value &gt;0 is specified. Otherwise, transmission will be skipped.\nBy default, the postnatal duration is based on the maternal UID and would be the same for all infants of that mother, although derived classes could modify this behavior.\n\n\n\nnetworks.PrenatalNet(name=None, label=None, **kwargs)\nPrenatal transmission network\nAlthough edges change over time, the edges are managed via ss.Pregnancy as pregnancies start and finish. The prenatal network therefore is not derived from DynamicNetwork as it does not manage its own updates.\n\n\n\nnetworks.RandomNet(pars=None, n_contacts=_, dur=_, beta=_, **kwargs)\nRandom connectivity between agents\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_contacts\nint/ss.Dist\nthe average number of (bidirectional) contacts between agents\n_\n\n\ndur\nint/ss.dur\nthe duration of each contact\n_\n\n\nbeta\nfloat\nthe default beta value for each edge\n_\n\n\n\nNote: n_contacts = 10 will create 5 edges per agent. Since disease transmission usually occurs bidirectionally, this means that the effective number of contacts per agent is actually 10. Consider 3 agents with 3 edges between them (a triangle): each agent is connected to 2 other agents.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate edges\n\n\nget_edges\nEfficiently find edges\n\n\nget_source\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.RandomNet.add_pairs()\nGenerate edges\n\n\n\nnetworks.RandomNet.get_edges(inds, n_contacts)\nEfficiently find edges\nNote that because of the shuffling operation, each person is assigned 2N contacts (i.e. if a person has 5 contacts, they appear 5 times in the ‘source’ array and 5 times in the ‘target’ array). Therefore, the n_contacts argument to this function should be HALF of the total contacts a person is expected to have, if both the source and target array outputs are used (e.g. for social contacts)\nadjusted_number_of_contacts = np.round(n_contacts / 2).astype(ss.dtype.int)\nWhereas for asymmetric contacts (e.g. staff-public interactions) it might not be necessary\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninds\nlist / array\nperson indices\nrequired\n\n\nn_contacts\nlist / array\nthe same length as inds with the number of bidirectional contacts to assign to each person\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nTwo arrays, for source and target\n\n\n\n\n\n\n\nnetworks.RandomNet.get_source(inds, n_contacts)\nOptimized helper function for getting contacts\n\n\n\n\n\nnetworks.RandomSafeNet(pars=None, n_edges=_, dur=_, beta=_, **kwargs)\nCreate a CRN-safe, O(N) random network\nThis network is similar to ss.RandomNet(), but is random-number safe (i.e., the addition of a single new agent will not perturb the entire rest of the network). However, it is somewhat slower than ss.RandomNet(), so should be used where CRN safety is important (e.g., scenario analysis).\nNote: ss.RandomNet uses n_contacts, which is the total number of contacts per agent. ss.RandomSateNet users n_edges, which is the total number of edges per agent. Since contacts are usually bidirectional, n_contacts = 2*n_edges. For example, ss.RandomNet(n_contacts=10) will give (nearly) identical results to ss.RandomSafeNet(n_edges=5). In addition, whereas n_contacts can be a distribution, n_edges can only be an integer.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_edges\nint\nthe average number of (bi-directional) edges between agents\n_\n\n\ndur\nint/ss.dur\nthe duration of each contact\n_\n\n\nbeta\nfloat\nthe default beta value for each edge\n_\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_pairs\nGenerate edges\n\n\nform_pairs\nFrom a 2N input array, return 2N-2 nearest-neighbor pairs\n\n\nplot_matrix\nPlot the distance matrix used for forming pairs: only ±1 from the diagonal is used\n\n\nrep_rand\nReproducible repeated random numbers\n\n\n\n\n\nnetworks.RandomSafeNet.add_pairs()\nGenerate edges\n\n\n\nnetworks.RandomSafeNet.form_pairs(debug=False)\nFrom a 2N input array, return 2N-2 nearest-neighbor pairs\n\n\n\nnetworks.RandomSafeNet.plot_matrix(**kwargs)\nPlot the distance matrix used for forming pairs: only ±1 from the diagonal is used\n\n\n\nnetworks.RandomSafeNet.rep_rand(uids, sort=True)\nReproducible repeated random numbers\n\n\n\n\n\nnetworks.Route(name=None, label=None, **kwargs)\nA transmission route – e.g., a network, mixing pool, environmental transmission, etc.\n\n\n\nnetworks.SexualNetwork(**kwargs)\nBase class for all sexual networks\n\n\n\nnetworks.StaticNet(graph=None, pars=None, **kwargs)\nA network class of static partnerships converted from a networkx graph. There’s no formation of new partnerships and initialized partnerships only end when one of the partners dies. The networkx graph can be created outside Starsim if population size is known. Or the graph can be created by passing a networkx generator function to Starsim.\nIf “seed=True” is passed as a keyword argument or a parameter in pars, it is replaced with the built-in RNG. The parameter “n” is supplied automatically to be equal to n_agents.\nExamples:\n# Generate a networkx graph and pass to Starsim\nimport networkx as nx\nimport starsim as ss\ng = nx.scale_free_graph(n=10000)\nss.StaticNet(graph=g)\n\n# Pass a networkx graph generator to Starsim\nss.StaticNet(graph=nx.erdos_renyi_graph, p=0.0001, seed=True)",
    "crumbs": [
      "**Modules**",
      "networks"
    ]
  },
  {
    "objectID": "api/utils.html",
    "href": "api/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\nNumerical utilities and other helper functions\n\n\n\n\n\nName\nDescription\n\n\n\n\nndict\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nutils.ndict(\n    *args,\n    nameattr='name',\n    type=None,\n    strict=True,\n    overwrite=False,\n    **kwargs,\n)\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnameattr\nstr\nThe attribute of the item to use as the dict key (i.e., all items should have this attribute defined)\n'name'\n\n\ntype\ntype\nThe expected type of items.\nNone\n\n\nstrict\nbool\nIf True, only items with the specified attribute will be accepted.\nTrue\n\n\noverwrite\nbool\nwhether to allow adding a key when one has already been added\nFalse\n\n\n\nExamples:\nnetworks = ss.ndict(ss.MFNet(), ss.MaternalNet())\nnetworks = ss.ndict([ss.MFNet(), ss.MaternalNet()])\nnetworks = ss.ndict({'mf':ss.MFNet(), 'maternal':ss.MaternalNet()})\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nShallow copy\n\n\nextend\nAdd new items to the ndict, by item, list, or dict\n\n\nmerge\nMerge another dictionary with this one\n\n\n\n\n\nutils.ndict.copy()\nShallow copy\n\n\n\nutils.ndict.extend(*args, **kwargs)\nAdd new items to the ndict, by item, list, or dict\n\n\n\nutils.ndict.merge(other)\nMerge another dictionary with this one\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfind_contacts\nVariation on Network.find_contacts() that avoids sorting.\n\n\nload\nAlias to Sciris sc.loadany()\n\n\nparse_age_range\nParse an age range string into lower and upper bounds\n\n\nplot_args\nProcess known plotting kwargs.\n\n\nreturn_fig\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead; not for the user\n\n\nsave\nAlias to Sciris sc.save()\n\n\nshow\nShortcut for matplotlib.pyplot.show()\n\n\nstandardize_data\nStandardize formats of input data\n\n\nstandardize_netkey\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\nvalidate_sim_data\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\nwarn\nHelper function to handle warnings – shortcut to warnings.warn\n\n\n\n\n\nutils.find_contacts(p1, p2, inds)\nVariation on Network.find_contacts() that avoids sorting.\nA set is returned here rather than a sorted array so that custom tracing interventions can efficiently add extra people. For a version with sorting by default, see Network.find_contacts(). Indices must be an int64 array since this is what’s returned by true() etc. functions by default.\n\n\n\nutils.load(filename, **kwargs)\nAlias to Sciris sc.loadany()\nSince Starsim uses Sciris for saving objects, they can be loaded back using this function. This can also be used to load other objects of known type (e.g. JSON), although this usage is discouraged.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to load\nrequired\n\n\nkwargs\ndict\npassed to sc.loadany()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe loaded object\n\n\n\n\n\n\n\nutils.parse_age_range(age_string)\nParse an age range string into lower and upper bounds\nExample usage:\n&gt;&gt;&gt; ss.parse_age_range(\"5-9\")\n(5.0,9.0)\nSupported formats are - ‘5-9’ - ‘5 to 9’ - ‘&lt;5’ - which returns (0.0, 5.0) - ‘95+’ - which returns (95.0, np.inf) - ‘&gt;95’ - which returns (95.0, np.inf)\n:param age_string: A string specifying an age range (e.g., ‘5-9’, ‘5 to 9’, ‘95+’) :return: A tuple with (lower, upper) bound values.\n\n\n\nutils.plot_args(kwargs=None, _debug=False, **defaults)\nProcess known plotting kwargs.\nThis function handles arguments to sim.plot() and other plotting functions by splitting known kwargs among all the different aspects of the plot.\nNote: the kwargs supplied to the parent function should be supplied as the first argument of this function; keyword arguments to this function are treated as default values that will be overwritten by user-supplied values in kwargs. The argument “_debug” is used internally to print debugging output, but is not typically set by the user.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfig_kw\ndict\npassed to sc.getrowscols(), then plt.subplots() and plt.figure()\nrequired\n\n\nplot_kw\ndict\npassed to plt.plot()\nrequired\n\n\ndata_kw\ndict\npassed to plt.scatter(), for plotting the data\nrequired\n\n\nstyle_kw\ndict\npassed to sc.options.with_style(), for controlling the detailed plotting style\nrequired\n\n\n**kwargs\ndict\nparsed among the above dictionaries\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA dict-of-dicts with plotting arguments, for use with subsequent plotting commands\n\n\n\nValid kwarg arguments are:\n- fig: 'figsize', 'nrows', 'ncols', 'ratio', 'num', 'dpi', 'facecolor'\n- plot: 'alpha', 'c', 'lw', 'linewidth', 'marker', 'markersize', 'ms'\n- data: 'data_alpha', 'data_color', 'data_size'\n- style: 'font', 'fontsize', 'interactive'\n- return_fig: 'do_show', 'is_jupyter', 'is_reticulate'\nExamples:\nkw = ss.plot_args(kwargs, fig_kw=dict(figsize=(10,10)) # Explicit way to set figure size, passed to `plt.figure()` eventually\nkw = ss.plot_args(kwargs, figsize=(10,10)) # Shortcut since known keyword\n\n\n\n\nutils.return_fig(fig, **kwargs)\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead; not for the user\n\n\n\nutils.save(filename, obj, **kwargs)\nAlias to Sciris sc.save()\nWhile some Starsim objects have their own save methods, this function can be used to save any arbitrary object. It can then be loaded with ss.load().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to save\nrequired\n\n\nobj\nany\nthe object to save\nrequired\n\n\nkwargs\ndict\npassed to sc.save()\n{}\n\n\n\n\n\n\n\nutils.show(**kwargs)\nShortcut for matplotlib.pyplot.show()\n\n\n\nutils.standardize_data(\n    data=None,\n    metadata=None,\n    min_year=1800,\n    out_of_range=0,\n    default_age=0,\n    default_year=2024,\n)\nStandardize formats of input data\nInput data can arrive in many different forms. This function accepts a variety of data structures, and converts them into a Pandas Series containing one variable, based on specified metadata, or an ss.Dist if the data is already an ss.Dist object.\nThe metadata is a dictionary that defines columns of the dataframe or keys of the dictionary to use as indices in the output Series. It should contain:\n\nmetadata['data_cols']['value'] specifying the name of the column/key to draw values from\nmetadata['data_cols']['year'] optionally specifying the column containing year values; otherwise the default year will be used\nmetadata['data_cols']['age'] optionally specifying the column containing age values; otherwise the default age will be used\nmetadata['data_cols'][&lt;arbitrary&gt;] optionally specifying any other columns to use as indices. These will form part of the multi-index for the standardized Series output.\n\nIf a sex column is part of the index, the metadata can also optionally specify a string mapping to convert the sex labels in the input data into the ‘m’/‘f’ labels used by Starsim. In that case, the metadata can contain an additional key like metadata['sex_keys'] = {'Female':'f','Male':'m'} which in this case would map the strings ‘Female’ and ‘Male’ in the original data into ‘m’/‘f’ for Starsim.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(pandas.DataFrame, pandas.Series, dict, int, float)\nAn associative array or a number, with the input data to be standardized.\nNone\n\n\nmetadata\ndict\nDictionary specifiying index columns, the value column, and optionally mapping for sex labels\nNone\n\n\nmin_year\nfloat\nOptionally specify a minimum year allowed in the data. Default is 1800.\n1800\n\n\nout_of_range\nfloat\nValue to use for negative ages - typically 0 is a reasonable choice but other values (e.g., np.inf or np.nan) may be useful depending on the calculation. This will automatically be added to the dataframe with an age of -np.inf\n0\n\n\n\nReturns:\n- A `pd.Series` for all supported formats of `data` *except* an `ss.Dist`. This series will contain index columns for 'year'\n  and 'age' (in that order) and then subsequent index columns for any other variables specified in the metadata, in the order\n  they appeared in the metadata (except for year and age appearing first).\n- An `ss.Dist` instance - if the `data` input is an `ss.Dist`, that same object will be returned by this function\n\n\n\n\nutils.standardize_netkey(key)\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\n\nutils.validate_sim_data(data=None, die=None)\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndf / dict\na dataframe (or dict) of data, with a column “time” plus data columns of the form “module.result”, e.g. “hiv.new_infections”\nNone\n\n\ndie\nbool\nwhether to raise an exception if the data cannot be converted (default: die if data is not None but cannot be converted)\nNone\n\n\n\n\n\n\n\nutils.warn(msg, category=None, verbose=None, die=None)\nHelper function to handle warnings – shortcut to warnings.warn",
    "crumbs": [
      "**Utilities**",
      "utils"
    ]
  },
  {
    "objectID": "api/utils.html#classes",
    "href": "api/utils.html#classes",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nndict\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nutils.ndict(\n    *args,\n    nameattr='name',\n    type=None,\n    strict=True,\n    overwrite=False,\n    **kwargs,\n)\nA dictionary-like class that provides additional functionalities for handling named items.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnameattr\nstr\nThe attribute of the item to use as the dict key (i.e., all items should have this attribute defined)\n'name'\n\n\ntype\ntype\nThe expected type of items.\nNone\n\n\nstrict\nbool\nIf True, only items with the specified attribute will be accepted.\nTrue\n\n\noverwrite\nbool\nwhether to allow adding a key when one has already been added\nFalse\n\n\n\nExamples:\nnetworks = ss.ndict(ss.MFNet(), ss.MaternalNet())\nnetworks = ss.ndict([ss.MFNet(), ss.MaternalNet()])\nnetworks = ss.ndict({'mf':ss.MFNet(), 'maternal':ss.MaternalNet()})\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncopy\nShallow copy\n\n\nextend\nAdd new items to the ndict, by item, list, or dict\n\n\nmerge\nMerge another dictionary with this one\n\n\n\n\n\nutils.ndict.copy()\nShallow copy\n\n\n\nutils.ndict.extend(*args, **kwargs)\nAdd new items to the ndict, by item, list, or dict\n\n\n\nutils.ndict.merge(other)\nMerge another dictionary with this one",
    "crumbs": [
      "**Utilities**",
      "utils"
    ]
  },
  {
    "objectID": "api/utils.html#functions",
    "href": "api/utils.html#functions",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfind_contacts\nVariation on Network.find_contacts() that avoids sorting.\n\n\nload\nAlias to Sciris sc.loadany()\n\n\nparse_age_range\nParse an age range string into lower and upper bounds\n\n\nplot_args\nProcess known plotting kwargs.\n\n\nreturn_fig\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead; not for the user\n\n\nsave\nAlias to Sciris sc.save()\n\n\nshow\nShortcut for matplotlib.pyplot.show()\n\n\nstandardize_data\nStandardize formats of input data\n\n\nstandardize_netkey\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\nvalidate_sim_data\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\nwarn\nHelper function to handle warnings – shortcut to warnings.warn\n\n\n\n\n\nutils.find_contacts(p1, p2, inds)\nVariation on Network.find_contacts() that avoids sorting.\nA set is returned here rather than a sorted array so that custom tracing interventions can efficiently add extra people. For a version with sorting by default, see Network.find_contacts(). Indices must be an int64 array since this is what’s returned by true() etc. functions by default.\n\n\n\nutils.load(filename, **kwargs)\nAlias to Sciris sc.loadany()\nSince Starsim uses Sciris for saving objects, they can be loaded back using this function. This can also be used to load other objects of known type (e.g. JSON), although this usage is discouraged.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to load\nrequired\n\n\nkwargs\ndict\npassed to sc.loadany()\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nThe loaded object\n\n\n\n\n\n\n\nutils.parse_age_range(age_string)\nParse an age range string into lower and upper bounds\nExample usage:\n&gt;&gt;&gt; ss.parse_age_range(\"5-9\")\n(5.0,9.0)\nSupported formats are - ‘5-9’ - ‘5 to 9’ - ‘&lt;5’ - which returns (0.0, 5.0) - ‘95+’ - which returns (95.0, np.inf) - ‘&gt;95’ - which returns (95.0, np.inf)\n:param age_string: A string specifying an age range (e.g., ‘5-9’, ‘5 to 9’, ‘95+’) :return: A tuple with (lower, upper) bound values.\n\n\n\nutils.plot_args(kwargs=None, _debug=False, **defaults)\nProcess known plotting kwargs.\nThis function handles arguments to sim.plot() and other plotting functions by splitting known kwargs among all the different aspects of the plot.\nNote: the kwargs supplied to the parent function should be supplied as the first argument of this function; keyword arguments to this function are treated as default values that will be overwritten by user-supplied values in kwargs. The argument “_debug” is used internally to print debugging output, but is not typically set by the user.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfig_kw\ndict\npassed to sc.getrowscols(), then plt.subplots() and plt.figure()\nrequired\n\n\nplot_kw\ndict\npassed to plt.plot()\nrequired\n\n\ndata_kw\ndict\npassed to plt.scatter(), for plotting the data\nrequired\n\n\nstyle_kw\ndict\npassed to sc.options.with_style(), for controlling the detailed plotting style\nrequired\n\n\n**kwargs\ndict\nparsed among the above dictionaries\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n\nA dict-of-dicts with plotting arguments, for use with subsequent plotting commands\n\n\n\nValid kwarg arguments are:\n- fig: 'figsize', 'nrows', 'ncols', 'ratio', 'num', 'dpi', 'facecolor'\n- plot: 'alpha', 'c', 'lw', 'linewidth', 'marker', 'markersize', 'ms'\n- data: 'data_alpha', 'data_color', 'data_size'\n- style: 'font', 'fontsize', 'interactive'\n- return_fig: 'do_show', 'is_jupyter', 'is_reticulate'\nExamples:\nkw = ss.plot_args(kwargs, fig_kw=dict(figsize=(10,10)) # Explicit way to set figure size, passed to `plt.figure()` eventually\nkw = ss.plot_args(kwargs, figsize=(10,10)) # Shortcut since known keyword\n\n\n\n\nutils.return_fig(fig, **kwargs)\nDo postprocessing on the figure: by default, don’t return if in Jupyter, but show instead; not for the user\n\n\n\nutils.save(filename, obj, **kwargs)\nAlias to Sciris sc.save()\nWhile some Starsim objects have their own save methods, this function can be used to save any arbitrary object. It can then be loaded with ss.load().\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr / path\nthe name of the file to save\nrequired\n\n\nobj\nany\nthe object to save\nrequired\n\n\nkwargs\ndict\npassed to sc.save()\n{}\n\n\n\n\n\n\n\nutils.show(**kwargs)\nShortcut for matplotlib.pyplot.show()\n\n\n\nutils.standardize_data(\n    data=None,\n    metadata=None,\n    min_year=1800,\n    out_of_range=0,\n    default_age=0,\n    default_year=2024,\n)\nStandardize formats of input data\nInput data can arrive in many different forms. This function accepts a variety of data structures, and converts them into a Pandas Series containing one variable, based on specified metadata, or an ss.Dist if the data is already an ss.Dist object.\nThe metadata is a dictionary that defines columns of the dataframe or keys of the dictionary to use as indices in the output Series. It should contain:\n\nmetadata['data_cols']['value'] specifying the name of the column/key to draw values from\nmetadata['data_cols']['year'] optionally specifying the column containing year values; otherwise the default year will be used\nmetadata['data_cols']['age'] optionally specifying the column containing age values; otherwise the default age will be used\nmetadata['data_cols'][&lt;arbitrary&gt;] optionally specifying any other columns to use as indices. These will form part of the multi-index for the standardized Series output.\n\nIf a sex column is part of the index, the metadata can also optionally specify a string mapping to convert the sex labels in the input data into the ‘m’/‘f’ labels used by Starsim. In that case, the metadata can contain an additional key like metadata['sex_keys'] = {'Female':'f','Male':'m'} which in this case would map the strings ‘Female’ and ‘Male’ in the original data into ‘m’/‘f’ for Starsim.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(pandas.DataFrame, pandas.Series, dict, int, float)\nAn associative array or a number, with the input data to be standardized.\nNone\n\n\nmetadata\ndict\nDictionary specifiying index columns, the value column, and optionally mapping for sex labels\nNone\n\n\nmin_year\nfloat\nOptionally specify a minimum year allowed in the data. Default is 1800.\n1800\n\n\nout_of_range\nfloat\nValue to use for negative ages - typically 0 is a reasonable choice but other values (e.g., np.inf or np.nan) may be useful depending on the calculation. This will automatically be added to the dataframe with an age of -np.inf\n0\n\n\n\nReturns:\n- A `pd.Series` for all supported formats of `data` *except* an `ss.Dist`. This series will contain index columns for 'year'\n  and 'age' (in that order) and then subsequent index columns for any other variables specified in the metadata, in the order\n  they appeared in the metadata (except for year and age appearing first).\n- An `ss.Dist` instance - if the `data` input is an `ss.Dist`, that same object will be returned by this function\n\n\n\n\nutils.standardize_netkey(key)\nNetworks can be upper or lowercase, and have a suffix ‘net’ or not; this function standardizes them\n\n\n\nutils.validate_sim_data(data=None, die=None)\nValidate data intended to be compared to the sim outputs, e.g. for calibration\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndf / dict\na dataframe (or dict) of data, with a column “time” plus data columns of the form “module.result”, e.g. “hiv.new_infections”\nNone\n\n\ndie\nbool\nwhether to raise an exception if the data cannot be converted (default: die if data is not None but cannot be converted)\nNone\n\n\n\n\n\n\n\nutils.warn(msg, category=None, verbose=None, die=None)\nHelper function to handle warnings – shortcut to warnings.warn",
    "crumbs": [
      "**Utilities**",
      "utils"
    ]
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nThese tutorials will guide you through the main features of Starsim. Each tutorial is interactive and includes executable code examples.\n\n\nT1 - Introduction to Starsim\nA quick introduction to the Starsim framework.\n\n\nT2 - Building a simulation\nHow to build your first simulation.\n\n\nT3 - Demographics\nImplementing demographics: births, deaths, and population structure.\n\n\nT4 - Diseases\nHow to implement disease dynamics.\n\n\nT5 - Networks\nHow diseases spread between agents: networks and mixing pools.\n\n\nT6 - Interventions\nIt’s not all doom and gloom: implementing interventions to save lives.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can download these tutorials as Jupyter notebooks to run them locally. Look for the download button at the top of each tutorial.\n\n\n\n\n\n\n\n\nRunning tutorials locally\n\n\n\nTo run these tutorials locally:\n\nClone the Starsim repository\nInstall Starsim and its dependencies\nNavigate to the docs/tutorials directory\nLaunch Jupyter: jupyter notebook"
  }
]